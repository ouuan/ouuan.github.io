[{"categories":["技术"],"contents":"该博客的前身是自 2018 年 12 月搭建的 hexo 博客，于 2020 年 2 月搬迁至 hugo。\nMotivation 这次搬迁最直接的原因，是我把 hexo 博客从 Windows 搬到 Linux 失败了..\n之前魔改太多，主题里各种文件都改过，甚至 node_modules 里面都被我改过很多地方，之前因此都放弃升级 hexo 和 NexT 主题，而最近开始主用 Manjaro，于是博客必须得搬到 Linux 上，但无论是简单复制过来还是重新使用 npm 安装包都未能如愿。\n其实说不定还有很多解决方法，但我之前就听说过 hugo，于是就决定干脆搬过来好了。\n但为什么是搬到 hugo，而不是升级 hexo 呢？\n从 hugo 本身来说，它最显著的优点，就是快：\n 安装快。这在本地安装时倒影响不大，而且如果你要修改主题还得用 yarn 安装包，得装上几分钟（只在某些主题需要，如果无需压缩/使用 hugo 而非 node 进行压缩就不需要）。最主要的是，安装快使得 CI 快，使用 CI 发布 hugo 博客就会非常容易且快捷。 构建快。hugo 比起 hexo 的构建速度不是快了一点点，hexo 需要几十秒才能构建完的博客，hugo 只需不到一秒。这点更加重要，它不仅加速了 CI，而且本地构建几乎没有延时，加上 server 预览使用 websocket，直接分屏当预览写博客体验良好。  但弊端也同样明显：没有插件，导致很多功能得自己写，或者复制别人的代码。只不过对于 hexo 都能改到 node_modules 里面的魔改玩家来说，这都不算什么（\n只不过我一直用的是 2018 年 12 月那时的 hexo 和 NexT，这一年来 hexo 可能也有很多改进，所以我的比较不一定准确。\nProcess hugo 的配置步骤就不说了，网上很多教程，而且这个博客是 开源 的，可以自己看。\n本博客使用 GitHub Actions 进行自动发布，详见 配置文件。PERSONAL_TOKEN 需要在 repo 的 settings 里设置，但如果源码和博客在同一个 repo 里就可以直接用 GITHUB_TOKEN 了。\n从 hexo 搬到 hugo 可以参考这篇博客：Hugo 与 Hexo 的异同 | reuixiy 。\n我自己使用的脚本（fork 然后稍微改了一点）：ouuan/hexo2hugo 。\nhugo 还支持 aliases，所以链接改动可以轻松处理。\n如果对我博客的配置感兴趣，还可以参考 config.toml 和 even 主题 的历史记录。\n几个值得提醒的地方：（大约是我认为“已经完全搞好了！”之后遇到的问题，也就是你按网上的教程搞完之后仍然容易遇到的问题）\n站内搜索 可以参考 1d0901f，如果主题不是 even 的话我这个应该就不太能直接用了，得改一下 layout/_default/search.html 还有 static/js/search.js 中的 render 函数。\n代码高亮 推荐使用 highlight.js 而不是 chroma。even 主题把 highlight.js 的 CSS 放到了自己的 _code.scss 里，所以光是加上一个 highlight.js 的 CSS 是不够的，还得在 _code.scss 里把 hljs 相关的删掉，如果是 dark theme 还得修改背景颜色。\n代码复制按钮 可以参考 8347acf。全靠搜索引擎学来的 CSS 果然不够..就这么点东西我搞了四个小时，主要是滚动条、字体大小、行高、padding 之类杂七杂八的问题。\nGitInfo with Unicode 如果路径有中文，想用 GitInfo 的话就得 git config --global core.quotePath false，参见 gohugoio/hugo#3071 。\nTable Of Content with h1 默认情况下右侧目录是从 \u0026lt;h2\u0026gt; 开始的，如果你的文章中含有 \u0026lt;h1\u0026gt;（也就是 Markdown 中的单个 #），目录就会挂掉。在文章中使用 \u0026lt;h1\u0026gt; 是 不被推荐 的，但我自己一年前写的一些博客里有 \u0026lt;h1\u0026gt;，虽然批量修改也不难，但还有一种解决方案：在 config.toml 中加入：\n[markup.tableOfContents] startLevel = 1 endLevel = 4  这样从 \u0026lt;h1\u0026gt; 到 \u0026lt;h4\u0026gt; 都会在目录中显示。\nHTML in links 例如：[~~qwq~~](/post/from-hexo-to-hugo), [![favicon](/favicon.ico)](/favicon.ico)。\n默认情况下会渲染成这样：\n\u0026lt;del\u0026gt;qwq\u0026lt;/del\u0026gt;\n\u0026lt;img src=\u0026rdquo;/favicon.ico\u0026rdquo; alt=\u0026quot;favicon\u0026rdquo;\u0026gt;\n可以将 /layouts/_default/_markup/render-link.html 设成这样：（这个板子还包含了外链打开新标签页，不被渲染成 HTML 源码的关键在于 safeHTML）\n\u0026lt;a href=\u0026quot;{{ .Destination | safeURL }}\u0026quot;{{ with .Title}} title=\u0026quot;{{ . }}\u0026quot;{{ end }}{{ if strings.HasPrefix .Destination \u0026quot;http\u0026quot; }} target=\u0026quot;_blank\u0026quot;{{ end }}\u0026gt;{{ safeHTML .Text }}\u0026lt;/a\u0026gt;  然后就好了：\nqwq\n\nBaidu push 大家知道，百度收录个人博客是很慢的。\n于是我用了 黑魔法 GitHub Actions 每天自动推送，详见 配置文件。（需要先在 百度搜索资源平台 上进行一些设置，TOKEN 可以在“链接提交”页面找到。）\nComments loading spinner 见 commit。\nIssues 因为是用脚本批量改的，改完之后也没有一篇篇去检查，难免会有改错的地方以及一些死链，可以直接在评论区指出，多谢大家了。\n如果有原博客链接没有 redirect 而是 404 了，也请务必告诉我。\n如果需要原 hexo 博客的，可以看 ouuan.github.io/hexo-archive 。\n","date":"2020-02-06T23:07:17+08:00","permalink":"https://ouuan.github.io/post/from-hexo-to-hugo/","tags":["博客"],"title":"从 Hexo 到 Hugo"},{"categories":["其它"],"contents":" —— 简单题不 sb 是什么水平？\n—— 国家队水平。\n sb 错误   开 long long 时记得快读也要开 long long。\n  记得删调试信息，尤其是 cerr。\n  多测时要小心使用 memset。\n  operator 前面记得加返回值类型名。（dev c++ 不报错不警告）\n  跑的很快可能是因为被优化了，因此不要用空循环测运行用时。\n  （用于在线比赛）RE 可能是爆栈了。\n  不要假根号分治（可能大于 / 小于根号的同样可以处理小于 / 大于根号的）。\n  对常数有要求时应尽可能地避免复杂度瓶颈上的 push_back/emplace_back，解决方法有：在 push_back 前 reserve、使用 resize、使用传统数组等。\n  for (auto element : container) 需要在原处修改时使用 auto \u0026amp; 而非 auto。\n  不要同时 vector\u0026lt;...\u0026gt; a(...) 和 a.push_back(...) 而导致数组长度翻倍且前一半是空的。\n  q=0 不一定是不输出，例如题目要求输出答案的异或和时，就要输出 0。\n  OI 赛制记得自己测极限数据（最大 \u0026amp; 最小）。\n  不要把动态开点线段树写成可持久化线段树（常数会大）。\n  无符号整型（如 container.size()）减去一个正数时需要留意，若不能保证结果非负，则需要将无符号整型显式转换为有符号整型再进行运算。\n  虽然不是很懂为什么，但用 vector 写矩阵貌似非常慢。可能是计算过程中要频繁地创建新 vector 吧。\n  sb 想不到   计数 → 什么是重复的，什么是相同的。要做到不重不漏\n  最优化 → 什么是不优的，什么是不劣的。\n  要是怎么样就好了 → 能不能转化成这样。\n  存在反例 → 反例能否特殊处理。\n  只用管大小而不关心具体值 → 从小到大、从大到小考虑 / 二分答案转成 01。\n  构造最小值 → 找到一个较紧的下界，构造出下界（或者构造出一个方案，证明它是下界）。\n  分很多种奇奇怪怪的情况讨论时，可以想一想这些情况的补集。\n  有多次修改的题，可以考虑没有修改怎么算以及如何处理修改，而不一定要把初始状态当作若干次修改。\n  多次二分时想一想能不能用双指针。\n  成双成对的元素，在一起怎么样，不在一起怎么样，经常可以用随机数异或来处理。\n  把整个序列分成若干段，每段求一个值再加起来求最值，暴力是 DP，经常可以用决策单调性优化。\n  图论相关问题（包括树上问题）可以考虑点和边互相转化。\n  能够卷积时想一想能不能直接背包。\n  求生成函数然后带值进去求答案，可以过程中直接算点值。\n  无法继续优化往往是因为求了不必要的东西。\n  路径加单点求值可以树上差分 + 树状数组，不需要树剖/LCT。\n  不要使用动态开点线段树来求不带修的区间和，在对常数有要求时也不要使用 map，而应使用 vector + 二分 + 前缀和。\n  多次求矩阵快速幂乘一个向量时，可以预处理矩阵的幂（一次，二次，四次，八次\u0026hellip;），然后每次都用矩阵乘向量（从右向左依次算），这样预处理复杂度是 $O(n^3\\log k)$，单次询问复杂度是 $O(n^2\\log k)$。更一般地，求多个矩阵（每个矩阵都是已知的）的积乘上一个向量时，可以利用结合律每次都用矩阵乘向量。\n ","date":"2019-08-19T00:22:36+08:00","permalink":"https://ouuan.github.io/post/%E4%B8%80%E4%BA%9B%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/","tags":["注意事项"],"title":"一些注意事项"},{"categories":["技术"],"contents":" 说实话我觉得竞赛题目挺坑爹的……木有啥意思。人类为何要出题刁难人类。\n我更喜欢做的事情是写点工程啥的 \u0026gt;_\u0026lt;\u0026hellip; 做做小游戏挺好玩的。\n—— vfk 《四色的 NOI》\n （这算哪门子引用啊）\nCP Editor 这个是我和其他人一起写的。\n是一个为 OI 而设计的 IDE，有很多为 OI 设计的 feature。\n长期欢迎 contributors！\nCPTH 一些板子，有文档和测试。\n（其实我平常也就用一用线段树和树剖，其它基本上还是手写x）\nAwesome Competitive Programming Projects GitHub 上和算法竞赛相关的一些项目的列表以及统计数据。\nUOJ Data Converter 将数据转换为 UOJ 的格式。\nBZOJ-Local-Judge 我自己现在做 BZOJ 上有的题（5000 之前）全都用这个了。真的非常方便。\n我以前自己做 BZOJ 上有的题（5000 之前）全都用这个。\nHinata Online Judge 是 UOJ 的魔改，有 挺多 feature 的。\nDespised 除了选项单一，我觉得这是我用过体验最好的被鄙视小程序了。感觉加一些错误选项比较好，不然背着背着就变成背错误选项了。希望明年不要咕。\nTree-Generator 造树挺方便的。（顺便 求 up）。\nAnti-YiGeDingLia Demo\n大家知道 QQ 的接龙红包吗？我写这个东西的时候接龙红包特别火，然而大家都很喜欢“一个顶俩” qaq。有了这个项目，当你看到 yi 结尾时就能及时意气高昂啦！\nLuoguPaintBoard 顾名思义，是画洛谷冬日绘板用的。我明年一定画个ひなた！\nCode-Disturber 并没有什么用，实际作用是用 emoji 美化代码。\nSwapArrayDimension 或许是个实用的东西。\n","date":"2019-08-10T19:22:23+08:00","permalink":"https://ouuan.github.io/post/%E4%B8%80%E4%BA%9B%E6%9C%89%E8%B6%A3%E7%9A%84%E5%B0%8F%E5%B7%A5%E7%A8%8B/","tags":["工程"],"title":"一些有趣的小工程"},{"categories":["随笔"],"contents":"一些不能单独成篇的随笔。\n 当我在空间里看到大家都还在打 CF 时，我才真正感受到，自己退役了。\n  OI 对高考，LOJ 对洛谷，Linux 对 Windows，自由软件对专有软件，编程语言对自然语言，文档对教程，数学对语文，写在 IDE 中的 Lean 对写在答题卡上的证明，一部分人的题解对另一些人的题解，逻辑对经验，法制对人治，清晰对模糊，命由我对命由天。\n  什么是太平盛世？当像 ひなた、白灵 这样的女子，我们只见其可爱而不见其刚强时，那便是太平盛世了。\n  学 OI 时我最讨厌计数；学高中数学时我最喜欢计数。\n  我可以赞同你的每一句话，每一个观点，但我决不会坚决地拥护你。\n  学 OI，停课，最让我感到遗憾的，不是落下的文化课，而是圣诞晚会，课本剧表演，以及上给理科班的历史课。\n  能量守恒，质量守恒，所以无所谓「创造」，只有「分配」，人也就只能是自私的，只是“私”各不相同：有以自己的欲望为“私”的，有以自己的成就为“私”的，有以自己身边的人为“私”的，有以自己所在的一个团体为“私”的，有以自己所属的国家、民族为“私”的，有以自己这个物种——人类为“私”的，有以自己所属的生物界——动物为“私”的，有以一切生命为“私”的。“私”的范围究竟多大才是正确的呢？会有一个大小是正确的吗？\n","date":"2020-11-22T09:28:28+08:00","permalink":"https://ouuan.github.io/post/sentences/","tags":null,"title":"随笔合集"},{"categories":["随笔"],"contents":"中午，在食堂，我目睹了一场“革命”。\n食堂中原有一条长队，从领盒饭的窗口径直排到食堂门口。且不说领到盒饭的用时，在其中穿行就极为不便。一跨进食堂，根本望不到队尾，也不知究竟有一条队还是两条队。\n“到这儿来直接拿！”随着一位食堂大叔的这句话，两个满载着盒饭的箱子被打开。\n一霎间，原本井井有条的食堂变得混乱不堪——大家不去排队领取由食堂工作人员拿出来在窗口摆放齐整的盒饭，而是围成一团自己从箱子里把盒饭掏出来；原本在队伍里的人听到消息立刻从队伍中抽出身来挤向这两个箱子：这个小小的变革，将原有的秩序完全打乱了。\n然而，令人“意外”的是，这场混乱只持续了半分钟许。食堂重新平静了下来，只是那条长队已经看不见了。\n 第二天，食堂里又排起了长队……\n","date":"2020-10-24T21:15:26+08:00","permalink":"https://ouuan.github.io/post/a-revolution-in-the-canteen/","tags":null,"title":"记一场“革命”"},{"categories":["经历"],"contents":"我刚听说 \u0026ldquo;AFO\u0026rdquo; 这个词是就以为它是 \u0026ldquo;AFter OI\u0026rdquo; 的缩写。我到现在也不喜欢 \u0026ldquo;Away From OI\u0026rdquo; 这个说法。\n还记得那天，我妈问我，要不要去试一试信息学竞赛。NOIP，是我一年多前听学校电脑社的社长 wqs 说过的名字，如今，它摆在了我的眼前。\n这个梦就是这么开始的。听说学 OI 升学能有优惠，但我只是觉得这是个还不错的附赠品 —— 我只是想试一试在这条路上，我能走多远；想要证明自己，可以走得很远。\n还记得刚了解了赛制的我，去 NOI 官网上搜索历届 NOI 的排名，看到有初三选手拿到金牌。那时的我已经是初二升初三了，于是我在心里暗想，一定要在高一进入国集。\n听到教练推荐一本通和算法竞赛入门经典后，我不假思索地选择了后者，想着快点看完的话是不是就能变得很强了。由于自学过《C++ Primer Plus》，我跳过了语言部分，花了一个月阅读了前九章。事后回想起来当时很多例题都没看懂，很多知识点都没学会，但我就这么看了下来，没有一丝畏惧。\n后来听说了洛谷，我飞快地刷着试炼场，享受着 AC 的乐趣。\n那年 NOIP 的初赛，是我做的最认真的一次。在我们省，初赛可以轻松通过。那次我什么都没有准备，其他人做到一半都走了，我一直坚持到了最后，获得了三十多分。\n普及组 230 分一等奖，提高组 160 分二等奖，这是我当年的成绩。\n寒假，我去了 qbxt。当时几乎啥也没有听懂，只是在两场模拟赛中都拿到了 rk1。\n省选，一双木棋，只是在 qbxt 听说过“状压 DP”这个名称，一次都没有写过的我，当场想出了正解，在 Day1 得到 rk2。\n暑假校内集训，讲知识点时我并没有听，只是自己去网上简单学一下，然后就开始和其他人比拼完成洛谷团队作业的速度。\n当时的我就是这样，在一个狭小的圈子里始终名列前茅，就如同小学和初中时一样。水平有限，可心中却有着对未来的希望，学习 OI 的热情，前进的动力，甚至从未想过自己未来会无法进入国集。\nNOIP2018，489 分，HB rk1。虽然知道自己是凭借 D2T2 的打表取得的这个成绩，但还算是一份不小的惊喜。\n以此作为终点，我实质上还是一名 OIer 的生涯就几乎结束了。\n NOIP 成绩出来后不久，我去了广二集训。到达广州的第一天，广二的教练告诉了我们一些事实：\n 我们很菜，啥都不会。 政策不好，趁早放弃。  在这之后，我在一场场的模拟赛中见识到了，“遇强则强”是有极限的。如果你一步步地向上，你总是能从离顶端不远处爬回顶端；而如果将你一下扔到底端，就很难再爬上来了。\n与此同时，我 开始准备一场 CF，也逐渐开始沉迷于 making contribution。相关的很多事，我都在 2019，以及毕业之前 中说过了，在此也不再赘述。只是在之后的集训和练习中，原来那份热情再也找不回来了。\n就在 CSP-S2019 后，我 立下远离 contribution 的 flag，却又遇上了 CP Editor。我几乎停止了在 OI Wiki 开 PR，却免不了在群里与大家商讨问题。以 海子姐的手书 为始，vtb 走进了我的日常。立下的 flag 彻底倒下，再加上疫情的影响，只是变本加厉地将更少的时间用在了 OI 的练习上。\n想要调整自己的状态，这话我对自己说了一年半。直到 NOI2020，我没带着多少希望来到赛场，本以为已经离自己非常遥远的目标，意外地又回到自己的视线当中，而又以挂了整整 100 分这个事实再次从我身边远去。\n 在我 OI 历程的后半段中，或多或少地有着遗憾，但是，如果没有接触 OI，一切会变成什么样，我不敢想象。\n一定不是降了多少分，不会是学到了哪些算法，也不是学会了 git 的使用；OI 的这段经历，又有多少人能够体验呢。认识了天南海北各式各样的人；经历了各种大风大浪；在圈子中努力地留下了曾经来过的痕迹。\n或许当时不去广二会更好？当然会这么想过。但坐井观天总是不长久的，晚一些、慢一些认识到自己的弱小，真的就能做好应对一切挑战的准备吗？\n一路走来，经历了许多，给我留下印象最深的，还是刚学 OI 时的那份热情。即将步入文化课的学习，一切似乎都是未知的。我不想说什么“在文化课打败文化课选手们”这种话，我只希望，OI 这段经历，对梦想纯粹而朴素的追求，能够永远留在我的心中，after OI，但永不 away from OI。\n この道行きの最後が 天国か そこらじゃあないとしても\n这条路的尽头会是天国吗 就算不是也没有关系\nただの君と笑って立っていたいよ\n单纯地想和你相视而笑并肩而立\n誇らしさとか 願いとか 希望とか\n我的骄傲 愿望 希望\nもっと ずっと 持ち合わせとくよ\n愿能永久地伴我同行\n——《YUKI - さよならバイスタンダー》\n","date":"2020-08-19T22:04:16+08:00","permalink":"https://ouuan.github.io/post/afteroi/","tags":null,"title":"～AFTER OI～"},{"categories":["游记"],"contents":"为什么周围都是热点，而我却只有 2G（x\nAPIO Day 0 今年 APIO 是在自己学校打，而且 NOI 官网上的规则写了可以访问网络资源，只是不能用别人的代码。\n看到之后就问了教练，然后一开始还说要用机房电脑，后来就同意让我们带笔记本用自己的板子了。\n然而这个规则和 CF 之类的不一样，虽然可以用板子，但必须是自己写的..想了想我的板子里 debug 那些东西是从 tourist 板子里抄的，而且更重要的是，有一堆 define，又是 grader 题，感觉可能出问题，还有就是 IOI 赛制对板子需求也不是很大。所以最后就没用板子。\n但是自己的笔记本还是比机房电脑舒服多了。\nDay 1 首先面临的第一个问题就是 CP Editor 怎么测 grader 题..\n最后的方法是用 #ifdef OUUAN 把 grader 粘进代码里，其它都好说，就只有 Language Server 不太好搞，直接 include 头文件会报错。\n先看 T1，看了一会儿感觉不太会。\n然后看 T2，第一眼以为能够 swap 是要双连通，看到树的部分分才发现不对劲。然后又想了几种情况，以为自己会树了，先写了个环，然后去看 T3。\nT3，交互题（虽然另外两题也是），几乎是二叉树，询问两点距离，很自然地想到了 Nauuo and Binary Tree，但一看数据范围发现并没有什么用。能不能给一档 n≤5000 的分，我会！ 写了个每次暴力询问直径就跑路了。\n然后去看 T2，想到了一个假做法。写了 2h+，过了样例，提交 WA 了。写了个 $O(nm\\log)$ 的二分答案，T 了，然后换成了并查集，过了那个 subtask。然后对拍，发现自己漏了两种情况，然后发现自己不会处理这两种情况，就去看 T1 了。\n发现 T1 比我第一眼看到的貌似简单一些，先写了 subtask1，然后写了个 $O(nm)$，然后看着 $\\sum f(i)^2 \\le 4\\cdot 10^5$ 的限制一直以为复杂度里带一个 $\\sum f(i)^2$，就没想到正解。然后去把 T2 的菊花图写了。\n最后 30min 在想 T3 的完全二叉树 subtask，写了个假做法，考试结束了。\n出考场后听说 $\\sum f(i)^2$ 的限制是用来限制 $f(i) \\le \\sqrt{4\\cdot 10^5}$，自己想了下就会做了。\n听说 T2 我考虑的那一堆情况合并起来就是 $x$ 和 $y$ 所在连通块不是一条链，自己想了下也会做了。\n下午去 给 CP Editor 加了一些适用于 grader 题的 feature。\nNOI 前篇：NIO9102 落雨大。\nDay -1 早上坐一小时高铁到了长沙。\n可能是因为到的比较早，一路都有摄影跟着 🌚\n可能也是因为到的比较早，并且签完名会被拍照，签名墙上只有大家的姓名和 ID，没有任何奇奇怪怪的话（\n去年 WC 的时候还能开玩笑地写下 \u0026lt;font color=\u0026quot;gray\u0026quot;\u0026gt;ouuan\u0026lt;/font\u0026gt;，今年已经没心情写这种东西了。不想写姓名，ID 也不像 vfleaking 那么炫酷，就没签。\n寝室虽然环境比广二好，可是：\n 没有广二那个超适合坐在上面的梯子（ 不仅没有桌子也没有梯子，床的边上还有一圈凸出来的，空床完全没法坐边上，只能坐在用来睡的床上（有床垫，和凸出来的那一圈差不多高）。 信号和广二一样差。  最赞的一点，大概是插座不像广二那样藏在床底。（但据群友们说，有的寝室只有一个插座。我的寝室是每个床一个插座。）\n到寝室之后以及下午写了写游记。\n听说有自习室，就去了，然而很困 💤，几乎啥也没干。稍微面基了一些人，然而并没有面基到（指见到且知道对方 ID）以前没面基过的人。\n晚上见到了 @AprilGrimoiore 和 @ruogu，然后就开始了关于 Arch Linux 的交流，以及我教 @AprilGrimoiore 用 git。\n最后走的时候 @AprilGrimoiore 把胸牌落在了自习室，让我第二天给他。\nDay 0 早上吃完饭先去了自习室。\n想把胸牌给 @AprilGrimoiore 的时候听说他发烧去医院了 /jk 希望胸牌没事希望人没事 🙏\n不知道为什么，我在开阔的操场上以及开幕式的会场都没有信号 /yun\n开幕式先放了在 WC 看过好多次的 3M 原则宣传片，然后放了一年前就在广二看过的长沙一中宣传片。\n今年不用喊口号。感觉认识的人比去年少 /fad 同省都有一堆不认识的。倒也和 2020 年没有出去集训过有关。\ndzd 演讲依然非常精彩，得到的掌声也依然是其他人的好几倍。当场公布了新规：有剩饭会扣 1 分。\n今年也有花式开幕，是一个 扫描线 发光的电扇一样的东西，可以显示动画。\n开幕式结束后去自习室把 APIO 的 T2 写了。\n下午听说发烧了有隔离考场 /fad 把胸牌由工作人员转交给了 @AprilGrimoiore。\n这次的赛场和广二一样是由一个像是体育馆/报告厅一样的地方改造的。不知道再之前几届怎么样，我感觉这种赛场比机房舒服多了。\n今年笔试有好几道题库里没有的题，包括：（题面和答案都是印象中的大意）\n  程序在某个测试点运行时使用的内存超过了内存限制会怎么样？\n不能正常运行，该测试点获得 0 分。\n  机试时忘记了用户名和密码，找工作人员求助，扣几分？\n5分\n  哪些行为是禁止的？\n（多选，选项之一）在监考人员宣布 NOI 机试开始之前，禁止触摸键盘鼠标等外设。\n  只不过还是顺利 AC 了。\n看练习赛题目，发现有 C++11。王宏宣布考试时编译选项和练习赛一样时，全场掌声雷动（\n练习赛题目是去年的 D1T2, D1T3, D2T3，暗示 今年没有简单题 今年有交互。\n并没有写题，和 lk 还有 @rushcheyo 闲聊了一会儿就去自习室了。\nDay 1 半夜醒了 1h 还流了鼻血，只不过睡得比较早所以问题不大。\n看到 T1 后大概几分钟就会做了。\n看到 T2 后大概几分钟就会 40 分了。又想了一会儿，发现除了 40 分啥都不会。\n看到 T3 后大概几分钟就发现区间逆序对是部分分（A），后面还有一个特殊性质（C）可做，暴力应该也没问题。\n然后开始写 T1，写了 1h 过了样例。测了个极限数据发现要 2s，然后把矩乘的 for 循环顺序换了一下就 1.5s 了，感觉很神奇。\n然后开始写 T2 40 分，写了 1h 过了样例。感觉瓶颈上没有任何可以卡常的地方，就没测极限数据。\n然后开始写 T3 暴力，想了两分钟 $O(n^2\\log)$ 怎么做，发现自己是 sb，直接二维前缀和就可以 $O(n^2+nm)$。然后想了下另外一档特殊性质（B），感觉好像不太可做。写了 2h，三档分都过了样例。A 的样例不是极限数据，但只跑了 0.3s，感觉应该没问题。C 测了下极限数据，感觉没问题。C 没有合适的样例，就手造了组数据，发现暴力 T 了，然后发现暴力不小心写成了 $O(n^2m)$，赶紧改过来。\n这个时候只剩 0.5h 了，感觉没啥可做的了，就去写 T1 对拍。然后对拍挂了好多次，每次都发现数据不合法。最后不到 10min 的时候在看起来好像合法的数据上拍出来了，但是没时间了，非常自闭地考试结束了。\n今年可以多人同时上厕所。要不是这样的话不知道要排多久的队。\n看成绩，矩阵乘向量的 i 和 j 写反了，192 -\u0026gt; 112。（仔细分析后意识到，本质上是，我根据边建出来的那个矩阵适用于横向量乘矩阵，而我矩阵乘向量的时候写的是矩阵乘竖向量。由于题目求的是一个环，这样写可以通过 $k=0$ 的数据。）（其实只要写矩阵乘向量的时候想着“$A_{u, v}$ 表示从 $u$ 到 $v$ 的边”就不会有事，但我当时愣是去套普通的矩阵乘法，结果就写反了。）\n听讲题，T1 没啥意外自己写的就是标算，T2 听说正解和容斥几乎无关之后就没仔细听了，T3 很神仙，听完只记得用梯度下降法造数据卡莫队。\n看到成绩分布时，发现就算没挂分也很不会太靠前，有种输得心服口服的感觉。毕竟也没抱太大的进队的希望，但如果是因为挂分而退役还是挺难受的。这么想很蠢吧，知道自己排名不前反而放下心来。\nDay 2 虽然 T2 这个题面很长，对话的形式读起来还是很舒服的，非常巧妙地把形式化定义和易于理解的说明结合在了一起。（另外 X1, X2 和 X3 是 OI Diary 的角色，之前我只看过 「萌新的随想文坑」OI Diary Beta，还不知道 X1 和 X3，后来才知道。）\n依次读完三题，发现一题都不会，暴力也不太会。\n不如来写贪心吧！于是写了个 T1 的贪心：每次把最小和最大的合并。发现没过样例。换成了每次把最小的和最小的可以合并的合并，发现过了大多数样例，只有几个没过。之前看到数据范围时我就有注意到 $m\\ge n-1$ 有很多分，再一看，我没过的都是 $m=n-2$ 的。于是大胆猜想这个东西在 $m\\ge n-1$ 时是对的。写了个暴力简单拍了一下，发现 $m\\ge n-1$ 确实拍不出来。手玩了一些拍出来的 $m=n-2$，又想了几个贪心，全假了。这个时候已经 2h 多了，把几个贪心和暴力拼在一起就没管了。\n然后再去看了下 T2，突然感觉自己会做，写了之后没过样例，再仔细一看，只有叶子能长东西，我看成了每个点都能长东西..然后尝试着写了下特殊性质 4，发现并没有合适的样例（也可能是一个样例里有若干组满足特殊性质 4 的，反正我看开头不满足就没看了\u0026hellip;），于是手捏了一个样例过掉了。并不会写暴力，于是很难受，只能当它是对的（\n然后再看 T3，暴力完全没思路，只好看特殊性质。大力猜想一波性质 A 可以去掉割边跑最短路，过了大样例，然后把判割边去掉，发现也过了大样例\u0026hellip;但我也不会暴力，只能当它是对的（\n再看 T3 的性质 B，一开始想了个 DP，写完之后才发现完全不对..再仔细想了一下，发现看起来貌似是没有隔 2 边的间隔把整条链分成了若干段，每一段貌似选一条隔 2 边就行，又貌似必须在交接处选 /yun 不是很懂，但有大样例，于是写了一下，发现答案很接近每一段的最小值之和，然后又加加减减凑了一会儿，最后在 12:57 的时候把样例凑出来了。\n看成绩 \u0026amp; 复评咕了。等的时候又想了下 T3 的性质 B，发现 $n=3$ 就能 hack 掉我。然后再仔细回想了一下：我最后凑出来的答案是每一段的最小值加上 $n-1$ 减去段数，在调试过程中，我有试过最后一段是不是不计入答案，发现把最后一段去掉后答案几乎没有影响；当时我也没有多想，因为已经 12:50+ 了，当时我离答案还差好几万，都没注意到个位数的差别；在调试过程中，我有输出过一个值，这个值我见过它有两次相差了 $3$；而在 12:57 时，我把输出凑到了比答案小 2，然后我就直接加了 2。综上考虑，再在几个小的例子上测了一下，我几乎确信了把加二改成加上最后一段的最小值再减一是正解。在边权范围是 $1$ 到 $10^9$ 的情况下，样例中竟然有边权为 $3$ 的边，还恰好位于最后一段 /yun\n16:40 左右终于不咕了，$45+40+25=110$。T1 没有意外（然而貌似好多人都意外获得了很多分），T2 莫名过了 15 和 16 两个没有特殊性质的点，T3 的性质 B 过了一个点。把 T3 按上一段说的改过来，果然过了性质 B。\n听讲题，发现 T1 很可做。\nT3：《丢失密码条，puts(\u0026quot;-1\u0026quot;) 就好了》。听说性质 A 直接判最短路是否合法就行 /fad 只不过判是否合法貌似也不比把割边找出来简单多少（\n听说 C++11 是为了 T2 的 unordered_set 开的。（多谢出题人）（不会明年就没了吧）\n出榜了，在银牌线到队线减 100（意思就是没挂分也进不了队）之间。\nDay 3 听论文答辩，感觉 zrf 非常稳，jmr 有点悬。然而不知道是不是分差比较大，排名也是 3 和 5，并没有像去年那样影响到最终的结果。\n闭幕式就如往年那样进行，只是我不会再看第二次余姚中学的宣传片，无法明年再会了。\n我双色 NOI 的第二色，是银白色的。\n","date":"2020-08-16T11:44:09+08:00","permalink":"https://ouuan.github.io/post/apio-noi-2020/","tags":["CCF系列赛事"],"title":"APIO/NOI 2020 断网记"},{"categories":["题解"],"contents":"题目链接\n题目描述\n有一棵 $n$ 个点的树，由如下方式生成：\n对于每个点 $i$ ($i\\ge 2$)，在 $1$ 到 $i-1$ 中等概率选择一个点作为点 $i$ 的父亲。\n求每个点的度数的平方和的期望，要求绝对误差不超过 $10^{-6}$，$n\\le 10^6$。\n 状态设计与转移 令 $f_{i, j}$ 表示 $i$ 个点的树中度数为 $j$ 的点的个数的期望。\n那么：$f_{i, j} = f_{i - 1, j} - \\frac{f_{i - 1, j}}{i - 1} + \\frac{f_{i - 1, j - 1}}{i - 1} + [j=1]$\n其中 $\\frac{f_{i - 1, j}}{i - 1}$ 表示点 $i$ 的父亲在只有前 $i-1$ 个点时度数为 $j$ 的概率，$[j=1]$ 表示 j == 1 ? 1 : 0。\n然而，直接 DP 复杂度是 $O(n^2)$，无法通过此题。有多种处理方式，见下文。\n求答案的近似值 可以猜测 $j$ 比较大时 $f_{i, j}$ 非常小，可以忽略不计。实际上 $f_{10^6, 50}$ 只有大约 $10^{-14}$，所以只用计算 $j\\le 50$ 的 $f_{i, j}$。\n用生成函数和矩阵求答案的精确值 虽然上面这种求近似值的方法可以通过本题，但本题实际上是可以线性地求答案的精确值的。\n首先，每个 $f_{i, 1..i}$ 可以视为一个生成函数，记作 $F_i$，也就是说 $F_i$ 的 $x^j$ 项的系数表示 $f_{i, j}$。\n那么，转移方程可以表示为：\n$$ \\begin{aligned} F_i \u0026amp;= F_{i - 1} - \\frac{F_{i - 1}}{i - 1} + x\\frac{F_{i - 1}}{i - 1}+x\\\\\n\u0026amp;= \\frac{i-2+x}{i-1}F_{i - 1} + x \\end{aligned} $$\n然而，这样算出 $F_n$ 的每一项的系数依然是 $O(n^2)$ 的。\n但是，我们要求的并不是 $F_n$ 的每一项的系数，而是每一项的系数乘上次数的平方的和。\n注意到 $\\{1^2, 2^2, 3^2, \\ldots\\}$ 这个数列可以用下面这个矩阵的幂计算：\n$$ A= \\begin{bmatrix} 1\u0026amp;0\u0026amp;0\\\\\n1\u0026amp;1\u0026amp;0\\\\\n1\u0026amp;2\u0026amp;1 \\end{bmatrix} $$\n$$ A \\begin{bmatrix} 1\\\\\ni\\\\\ni^2 \\end{bmatrix}= \\begin{bmatrix} 1\\\\\n(i+1)\\\\\n(i+1)^2 \\end{bmatrix} $$\n所以，把 $A$ 作为 $x$ 带入生成函数中计算即可得到答案。\n参考代码 // Problem: Expected Tree Degrees // Contest: CS Academy // URL: https://csacademy.com/contest/archive/task/expected-tree-degrees/ // Memory Limit: 128 MB // Time Limit: 1000 ms // Powered by CP Editor (https://github.com/cpeditor/cpeditor) #ifndef OUUAN #pragma GCC optimize(\u0026quot;Ofast,no-stack-protector,unroll-loops,fast-math\u0026quot;) #endif #include\u0026lt;bits/stdc++.h\u0026gt; #define int ll // #define FAST_IOSTREAM 1 #define For(i,l,r)for(int i=(l),i##end=(r);i\u0026lt;=i##end;++i) #define FOR(i,r,l)for(int i=(r),i##end=(l);i\u0026gt;=i##end;--i) #define SON(i,u)for(int i=head[u];i;i=nxt[i]) #define BE(x)(x).begin(),(x).end() #define BE1(x)((x).begin()+1),(x).end() #define fi first #define se second #define pb push_back #define eb emplace_back #define pq priority_queue #define min minOfDifferentTypes #define max maxOfDifferentTypes #define y1 why_is_there_a_function_called_y1 using namespace std;typedef long long ll;typedef pair\u0026lt;int,int\u0026gt;pii;typedef vector\u0026lt;int\u0026gt;vi;typedef vector\u0026lt;vi\u0026gt;vvi;typedef vvi v2i;typedef vector\u0026lt;vvi\u0026gt;v3i;typedef vector\u0026lt;v3i\u0026gt;v4i;typedef vector\u0026lt;bool\u0026gt;vb;typedef vector\u0026lt;vb\u0026gt;vvb;typedef vvb v2b;typedef vector\u0026lt;vvb\u0026gt;v3b;typedef vector\u0026lt;v3b\u0026gt;v4b;typedef vector\u0026lt;pii\u0026gt;vpii;typedef vector\u0026lt;vpii\u0026gt;vvpii;typedef vvpii v2pii;typedef vector\u0026lt;vvpii\u0026gt;v3pii;typedef vector\u0026lt;v3pii\u0026gt;v4pii;typedef vector\u0026lt;double\u0026gt;vd;typedef vector\u0026lt;vd\u0026gt;vvd;typedef vvd v2d;typedef vector\u0026lt;v2d\u0026gt;v3d;typedef vector\u0026lt;v3d\u0026gt;v4d;const double inf=1e121;const double eps=1e-10;mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());int randint(int l,int r){int out=rng()%(r-l+1)+l;return out\u0026gt;=l?out:out+r-l+1;}template\u0026lt;typename A,typename B\u0026gt;string to_string(pair\u0026lt;A,B\u0026gt;p);template\u0026lt;typename A,typename B,typename C\u0026gt;string to_string(tuple\u0026lt;A,B,C\u0026gt;p);template\u0026lt;typename A,typename B,typename C,typename D\u0026gt;string to_string(tuple\u0026lt;A,B,C,D\u0026gt;p);string to_string(const string\u0026amp;s){return'\u0026quot;'+s+'\u0026quot;';}string to_string(const char*s){return to_string((string)s);}string to_string(bool b){return(b?\u0026quot;true\u0026quot;:\u0026quot;false\u0026quot;);}string to_string(vector\u0026lt;bool\u0026gt;v){bool first=true;string res=\u0026quot;{\u0026quot;;for(int i=0;i\u0026lt;static_cast\u0026lt;int\u0026gt;(v.size());i++){if(!first){res+=\u0026quot;, \u0026quot;;}first=false;res+=to_string(v[i]);}res+=\u0026quot;}\u0026quot;;return res;}template\u0026lt;size_t N\u0026gt;string to_string(bitset\u0026lt;N\u0026gt;v){string res=\u0026quot;\u0026quot;;for(size_t i=0;i\u0026lt;N;i++){res+=static_cast\u0026lt;char\u0026gt;('0'+v[i]);}return res;}template\u0026lt;typename A\u0026gt;string to_string(A v){bool first=true;string res=\u0026quot;{\u0026quot;;for(const auto\u0026amp;x:v){if(!first){res+=\u0026quot;, \u0026quot;;}first=false;res+=to_string(x);}res+=\u0026quot;}\u0026quot;;return res;}template\u0026lt;typename A,typename B\u0026gt;string to_string(pair\u0026lt;A,B\u0026gt;p){return\u0026quot;(\u0026quot;+to_string(p.first)+\u0026quot;, \u0026quot;+to_string(p.second)+\u0026quot;)\u0026quot;;}template\u0026lt;typename A,typename B,typename C\u0026gt;string to_string(tuple\u0026lt;A,B,C\u0026gt;p){return\u0026quot;(\u0026quot;+to_string(get\u0026lt;0\u0026gt;(p))+\u0026quot;, \u0026quot;+to_string(get\u0026lt;1\u0026gt;(p))+\u0026quot;, \u0026quot;+to_string(get\u0026lt;2\u0026gt;(p))+\u0026quot;)\u0026quot;;}template\u0026lt;typename A,typename B,typename C,typename D\u0026gt;string to_string(tuple\u0026lt;A,B,C,D\u0026gt;p){return\u0026quot;(\u0026quot;+to_string(get\u0026lt;0\u0026gt;(p))+\u0026quot;, \u0026quot;+to_string(get\u0026lt;1\u0026gt;(p))+\u0026quot;, \u0026quot;+to_string(get\u0026lt;2\u0026gt;(p))+\u0026quot;, \u0026quot;+to_string(get\u0026lt;3\u0026gt;(p))+\u0026quot;)\u0026quot;;}template\u0026lt;typename A,typename B,typename C,typename D,typename E\u0026gt;string to_string(tuple\u0026lt;A,B,C,D,E\u0026gt;p){return\u0026quot;(\u0026quot;+to_string(get\u0026lt;0\u0026gt;(p))+\u0026quot;, \u0026quot;+to_string(get\u0026lt;1\u0026gt;(p))+\u0026quot;, \u0026quot;+to_string(get\u0026lt;2\u0026gt;(p))+\u0026quot;, \u0026quot;+to_string(get\u0026lt;3\u0026gt;(p))+\u0026quot;,\u0026quot;+to_string(get\u0026lt;4\u0026gt;(p))+\u0026quot;)\u0026quot;;}void debug_out(){cerr\u0026lt;\u0026lt;endl;}template\u0026lt;typename Head,typename...Tail\u0026gt;void debug_out(Head H,Tail...T){cerr\u0026lt;\u0026lt;\u0026quot; \u0026quot;\u0026lt;\u0026lt;to_string(H);debug_out(T...);}template\u0026lt;typename T\u0026gt;struct is_pair{static const bool value=false;};template\u0026lt;typename T,typename U\u0026gt;struct is_pair\u0026lt;std::pair\u0026lt;T,U\u0026gt;\u0026gt;{static const bool value=true;}; #ifdef OUUAN #define debug(...)cerr\u0026lt;\u0026lt;\u0026quot;[\u0026quot;\u0026lt;\u0026lt;#__VA_ARGS__\u0026lt;\u0026lt;\u0026quot;]:\u0026quot;,debug_out(__VA_ARGS__) #else #define debug(...)42 #endif #ifdef int const int INF=0x3f3f3f3f3f3f3f3fll; #else const int INF=0x3f3f3f3f; #endif #ifdef FAST_IOSTREAM #define br cout\u0026lt;\u0026lt;'\\n' #define sp cout\u0026lt;\u0026lt;' ' #define fl cout.flush() ll read(){ll x;cin\u0026gt;\u0026gt;x;return x;}template\u0026lt;typename T\u0026gt;void read(T\u0026amp;x){cin\u0026gt;\u0026gt;x;}template\u0026lt;typename T\u0026gt;void write(const T\u0026amp;x){cout\u0026lt;\u0026lt;x;} #else #define br putchar('\\n') #define sp putchar(' ') #define fl fflush(stdout) template\u0026lt;typename T\u0026gt;typename enable_if\u0026lt;!is_integral\u0026lt;T\u0026gt;::value\u0026amp;\u0026amp;!is_pair\u0026lt;T\u0026gt;::value,void\u0026gt;::type read(T\u0026amp;x){cin\u0026gt;\u0026gt;x;}ll read(){char c;ll out=0,f=1;for(c=getchar();!isdigit(c)\u0026amp;\u0026amp;c!='-';c=getchar()){}if(c=='-'){f=-1;c=getchar();}for(;isdigit(c);c=getchar())out=(out\u0026lt;\u0026lt;3)+(out\u0026lt;\u0026lt;1)+c-'0';return out*f;}template\u0026lt;typename T\u0026gt;typename enable_if\u0026lt;is_integral\u0026lt;T\u0026gt;::value,T\u0026gt;::type read(T\u0026amp;x){char c;T f=1;x=0;for(c=getchar();!isdigit(c)\u0026amp;\u0026amp;c!='-';c=getchar()){}if(c=='-'){f=-1;c=getchar();}for(;isdigit(c);c=getchar())x=(x\u0026lt;\u0026lt;3)+(x\u0026lt;\u0026lt;1)+c-'0';return x*=f;}char read(char\u0026amp;x){for(x=getchar();isspace(x);x=getchar()){}return x;}double read(double\u0026amp;x){scanf(\u0026quot;%lf\u0026quot;,\u0026amp;x);return x;}template\u0026lt;typename T\u0026gt;typename enable_if\u0026lt;!is_integral\u0026lt;T\u0026gt;::value\u0026amp;\u0026amp;!is_pair\u0026lt;T\u0026gt;::value,void\u0026gt;::type write(const T\u0026amp;x){cout\u0026lt;\u0026lt;x;}template\u0026lt;typename T\u0026gt;typename enable_if\u0026lt;is_integral\u0026lt;T\u0026gt;::value,void\u0026gt;::type write(const T\u0026amp;x){if(x\u0026lt;0){putchar('-');write(-x);return;}if(x\u0026gt;9)write(x/10);putchar(x%10+'0');}void write(const char\u0026amp;x){putchar(x);}void write(const double\u0026amp;x){printf(\u0026quot;%.12lf\u0026quot;,x);} #endif template\u0026lt;typename T\u0026gt;typename enable_if\u0026lt;is_pair\u0026lt;T\u0026gt;::value,void\u0026gt;::type read(T\u0026amp;x){read(x.fi);read(x.se);}template\u0026lt;typename T\u0026gt;typename enable_if\u0026lt;is_pair\u0026lt;T\u0026gt;::value,void\u0026gt;::type write(const T\u0026amp;x){write(x.fi);sp;write(x.se);}template\u0026lt;typename T,typename...Args\u0026gt;void read(T\u0026amp;x,Args\u0026amp;...args){read(x);read(args...);}template\u0026lt;typename OutputIt,typename=typename enable_if\u0026lt;is_same\u0026lt;output_iterator_tag,typename iterator_traits\u0026lt;OutputIt\u0026gt;::iterator_category\u0026gt;::value||(is_base_of\u0026lt;forward_iterator_tag,typename iterator_traits\u0026lt;OutputIt\u0026gt;::iterator_category\u0026gt;::value\u0026amp;\u0026amp;!is_const\u0026lt;OutputIt\u0026gt;::value)\u0026gt;::type\u0026gt;void read(OutputIt __first,OutputIt __last){for(;__first!=__last;++__first)read(*__first);}template\u0026lt;typename InputIt,typename=typename enable_if\u0026lt;is_base_of\u0026lt;input_iterator_tag,typename iterator_traits\u0026lt;InputIt\u0026gt;::iterator_category\u0026gt;::value\u0026gt;::type\u0026gt;void wts(InputIt __first,InputIt __last){bool isFirst=true;for(;__first!=__last;++__first){if(isFirst)isFirst=false;else sp;write(*__first);}br;}template\u0026lt;typename InputIt,typename=typename enable_if\u0026lt;is_base_of\u0026lt;input_iterator_tag,typename iterator_traits\u0026lt;InputIt\u0026gt;::iterator_category\u0026gt;::value\u0026gt;::type\u0026gt;void wtb(InputIt __first,InputIt __last){for(;__first!=__last;++__first){write(*__first);br;}}template\u0026lt;typename T\u0026gt;void wts(const T\u0026amp;x){write(x);sp;}template\u0026lt;typename T\u0026gt;void wtb(const T\u0026amp;x){write(x);br;}template\u0026lt;typename T\u0026gt;void wte(const T\u0026amp;x){write(x);exit(0);}template\u0026lt;typename T,typename...Args\u0026gt;void wts(const T\u0026amp;x,Args...args){wts(x);wts(args...);}template\u0026lt;typename T,typename...Args\u0026gt;void wtb(const T\u0026amp;x,Args...args){wts(x);wtb(args...);}template\u0026lt;typename T,typename...Args\u0026gt;void wte(const T\u0026amp;x,Args...args){wts(x);wte(args...);}template\u0026lt;typename T1,typename T2\u0026gt;inline bool up(T1\u0026amp;x,const T2\u0026amp;y){return x\u0026lt;y?x=y,1:0;}template\u0026lt;typename T1,typename T2\u0026gt;inline bool dn(T1\u0026amp;x,const T2\u0026amp;y){return y\u0026lt;x?x=y,1:0;}template\u0026lt;typename T1,typename T2,typename T3\u0026gt;inline bool inRange(const T1\u0026amp;x,const T2\u0026amp;l,const T3\u0026amp;r){return!(x\u0026lt;l)\u0026amp;\u0026amp;!(r\u0026lt;x);}template\u0026lt;typename T1,typename T2\u0026gt;inline auto minOfDifferentTypes(const T1\u0026amp;x,const T2\u0026amp;y)-\u0026gt;decltype(x\u0026lt;y?x:y){return x\u0026lt;y?x:y;}template\u0026lt;typename T1,typename T2\u0026gt;inline auto maxOfDifferentTypes(const T1\u0026amp;x,const T2\u0026amp;y)-\u0026gt;decltype(x\u0026lt;y?y:x){return x\u0026lt;y?y:x;}template\u0026lt;typename T1,typename T2,typename T3\u0026gt;inline T1\u0026amp;madd(T1\u0026amp;x,const T2\u0026amp;y,const T3\u0026amp;modulo){return x=(ll)(x+y+modulo)%modulo;}template\u0026lt;typename T1,typename T2,typename T3\u0026gt;inline T1\u0026amp;mmul(T1\u0026amp;x,const T2\u0026amp;y,const T3\u0026amp;modulo){return x=(ll)x*y%modulo;}inline int modadd(int x,int y,int modulo){return(x+y)\u0026gt;=modulo?x+y-modulo:x+y;}inline int isinf(int x){return x\u0026lt;INF?x:-1;}inline void yesno(bool x){wtb(x?\u0026quot;Yes\u0026quot;:\u0026quot;No\u0026quot;);} /* ------------------------------------------------------------------------------------------------------------------- */ typedef long double ld; struct Matrix { ld a[3][3]; Matrix() { memset(a, 0, sizeof(a)); } ld *operator[](int x) { return a[x]; } const ld *operator[](int x) const { return a[x]; } Matrix operator*(const Matrix \u0026amp;b) const { Matrix res; For (i, 0, 2) { For (j, 0, 2) { For (k, 0, 2) { res[i][j] += a[i][k] * b[k][j]; } } } return res; } Matrix operator*(ld x) const { Matrix res; For (i, 0, 2) { For (j, 0, 2) { res[i][j] = a[i][j] * x; } } return res; } Matrix operator+(const Matrix \u0026amp;b) const { Matrix res; For (i, 0, 2) { For (j, 0, 2) { res[i][j] = a[i][j] + b[i][j]; } } return res; } }; signed main() { #ifdef FAST_IOSTREAM ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0); #endif int n = read(); Matrix sq; sq[0][0] = sq[1][0] = sq[1][1] = sq[2][0] = sq[2][2] = 1; sq[2][1] = 2; Matrix one; one[0][0] = one[1][1] = one[2][2] = 1; Matrix res = one; For (i, 2, n) res = res * (sq + one * (i - 2)) * (1.0l / (i - 1)) + sq; cout \u0026lt;\u0026lt; fixed \u0026lt;\u0026lt; setprecision(20) \u0026lt;\u0026lt; res[2][0]; return 0; }   推公式求答案的精确值 在 评论区 看到的：答案为 $6(n-1) - 4(1 + \\frac{1}{2} + \\frac{1}{3} + \\cdots + \\frac{1}{n - 1})$。\n使用转移方程证明公式 评论区除了这个公式啥都没有..我就自己试着把它推出来了..\n考虑增加一个点对答案的贡献，分为两部分：\n 新加的点度数为 $1$，贡献也为 $1$； 若父亲的度数为 $x$，则父亲的贡献增加 $2x+1$（因为 $(x+1)^2-x^2=2x+1$）。  所以，在一棵有 $i$ 个点的树上增加一个点的期望贡献为：（$f_{i, j}$ 为 上文中设计的状态）\n$$ 1 + \\sum\\limits_{j=0}^i (2j+1) \\frac{f_{i, j}}{i} $$\n为了方便，在下文中设 $g(i)=\\sum\\limits_{j=0}^i (2j+1) f_{i, j}$。\n这时再来观察一下转移方程：\n $f_{i-1, j}$，对 $g(i)$ 的贡献为 $g(i-1)$； $\\frac{f_{i - 1, j - 1}}{i - 1} - \\frac{f_{i - 1, j}}{i - 1}$，相当于把 $f_{i, j}$ 的 $\\frac{1}{i-1}$ “移动”到了 $f_{i, j+1}$，从而使 $g$ 中的系数从 $2j+1$ 变成了 $2j+3$，即每一项的系数加二，所以对 $g(i)$ 的贡献为 $\\frac{2}{i-1}\\sum_{j=0}^{i-1}f_{i-1,j}=2$； $[j=1]$，对 $g(i)$ 的贡献为 $2j+1=3$。  所以，$g(i)=g(i-1)+5$。又因为由定义计算可得 $g(1)=1$，所以 $g(i)=5i-4$。\n所以，在一棵有 $i$ 个点的树上增加一个点的期望贡献为 $1+\\frac{g(i)}{i}=6-\\frac{4}{i}$，累加一下就可以得到最上面那个公式了。\n枚举两条边证明公式 这个做法是 @AprilGrimoire 告诉我的。\n枚举两条边，对答案的贡献为这两条边期望相同的顶点个数（除了两条边是同一条边的情况，即两条边有公共顶点的概率）。\n那么，答案为：\n$$ 2(n-1) + 2\\sum\\limits_{i=3}^n\\sum\\limits_{j=2}^{i-1}\\frac{2}{i-1} $$\n其中，$2(n-1)$ 是枚举的两条边相同的贡献。\n后面则是枚举每两条不同的边：$i$ 到其父亲和 $j$ 到其父亲。有公共顶点的概率是编号小的点（$j$）的父亲随便选，而编号大的点（$i$）的父亲需要是 $j$ 或 $j$ 的父亲，概率为 $\\dfrac{2}{i-1}$。由于实际上需要枚举有序数对，再乘二。\n化简一下就可以得到公式。\n坑 不用 long double 可能会被卡精度..原因大概是题目要求的是 绝对 误差不超过 $10^{-6}$\u0026hellip; 怎么还有人出题要求绝对精度误差的 /fad\n只不过标算是求近似值，要是出题人会求精确值的做法就可以取模了 /fad\n","date":"2020-07-26T22:33:07+08:00","permalink":"https://ouuan.github.io/post/csacademy-expected-tree-degrees/","tags":["概率期望","计数dp","生成函数","矩阵"],"title":"CS Academy Round #10 - Expected Tree Degrees"},{"categories":["技术"],"contents":"你在使用浏览器时是否有这样的烦恼？\n 到底开多少个标签页？  开很多浏览器标签页 ⇒ 找不到标签页在哪，切换麻烦。 开很少浏览器标签页 ⇒ 需要频繁地打开、关闭标签页。   标签页之间层次混乱，不同类别的标签页混在一起。 从不同的地方点链接打开同一个网址，关了一个忘记关另一个。 ……  使用 Firefox 的 Tree Style Tab 和 Duplicate Tabs Closer 插件，就可以解决上述烦恼。\n（环境：Arch Linux, KDE Plasma, Dark Breeze）\n安装 Tree Style Tab  安装扩展：Tree Style Tab – 下载 🦊 Firefox 扩展 打开侧栏（默认快捷键为 F1）。 （可选）在 Firefox 的首选项中开启“恢复先前的浏览状态”。这能使长期打开很多标签页变得有意义。 （可选）隐藏传统标签栏：How to hide tab bar (tabstrip) in Firefox 57+ Quantum - Super User （可选）使用 Firefox 的“定制”功能，在地址栏左侧的按钮的左侧添加弹性空白，使侧栏与空白等宽。  安装 Duplicate Tabs Closer   安装扩展：Duplicate Tabs Closer – 下载 🦊 Firefox 扩展\n  点击扩展图标→设置按钮进行配置。\n我的配置：\n其中，“ホワイトリスト”是白名单，内容是正则表达式，表示哪些标签页会被排除在外（重复了也不会被关闭）（我感觉这个东西应该叫黑名单 🌚），而 ^(?!.*github.com).*$ 匹配的是所有不包含 github.com 的网址，也就是说只有网址包含 github.com 的重复标签页才会被自动关闭。我设置这个规则是因为 GitHub 上的很多页面是我一直打开着的，而我又经常会从邮箱里点进已打开的页面。\n  使用 Tree Style Tab 和 Duplicate Tabs Closer 随心所欲地新建标签页 开不开标签页？开！\n以后这个标签页还可能会用到，要留着吗？留！\nFirefox 67 的更新 使得开很多标签页不会占用过多的内存，Tree Style Tab 则使得开很多标签页不会变得杂乱无章，Duplicate Tabs Closer 使得你不会打开很多重复的标签页。所以，你在打开新标签页时基本上不需要担心打开的标签页过多（当然，如果真的太多（上百个），或者树的节点的度数太大，就另说了）。\n折叠，然后批量关闭 若一棵子树处于折叠状态，你可以一键关掉整棵子树。\n这在搜索解决方案时非常有用 \n ","date":"2020-07-09T13:00:46+08:00","permalink":"https://ouuan.github.io/post/firefox-tree-style-tab-and-duplicate-tabs-closer/","tags":["浏览器"],"title":"Firefox 的 Tree Style Tab 和 Duplicate Tabs Closer 插件"},{"categories":["技术"],"contents":"C++ NB $\\times$\nC++ UB $\\sqrt{}$\n这是一篇流水帐。\n学JS 前一天，我学习了 JavaScript 中的闭包。\n写题 当天，我在写一道需要使用 SAM 的题。\n想写闭包 我想到了昨天学的闭包，于是想“要是用 JS 就能写一个优美的迭代器用于访问 SAM 了”。\n（想象中的代码：）\nfunction\u0026lt;int(char)\u0026gt; makeIterator() { int cur = 0; return [this, \u0026amp;cur](char nxt) { return cur = t[cur].ch[nxt - 'a']; }; }  测试了一下，发现它 work 了！ （Arch Linux，g++ 10.1.0，-std=c++11 -O2）\nauto makeCounter = [] { int cnt = 0; return [\u0026amp;cnt] { return ++cnt; }; }; auto counter1 = makeCounter(); auto counter2 = makeCounter(); wtb(counter1()); wtb(counter1()); wtb(counter2()); wtb(counter1()); wtb(counter2()); wtb(counter2());  输出：\n1 2 1 3 2 3  发现函数返回时还是会调用析构函数 #include \u0026lt;iostream\u0026gt; #include \u0026lt;functional\u0026gt; using namespace std; class Test { public: Test(int id) : m_id(id), m_value(new int(0)) { cout \u0026lt;\u0026lt; \u0026quot;constructor: \u0026quot; \u0026lt;\u0026lt; m_id \u0026lt;\u0026lt; endl; } ~Test() { cout \u0026lt;\u0026lt; \u0026quot;destructor: \u0026quot; \u0026lt;\u0026lt; m_id \u0026lt;\u0026lt; endl; } void add(int delta) { *m_value += delta; } int value() const { return *m_value; } private: int m_id; int *m_value; }; int main() { auto makeCounter = [](int id) { Test cnt(id); return [\u0026amp;cnt] { cnt.add(1); return cnt.value(); }; }; auto counter1 = makeCounter(1); auto counter2 = makeCounter(2); cout \u0026lt;\u0026lt; counter1() \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; counter1() \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; counter2() \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; counter1() \u0026lt;\u0026lt; endl; return 0; }  输出：\nconstructor: 1 destructor: 1 constructor: 2 destructor: 2 1 2 1 3  甚至会轻而易举地 UB （其它代码不变）\nauto makeCounter = [](int id) { Test cnt(id); auto ret = [\u0026amp;cnt] { cnt.add(1); return cnt.value(); }; cnt.add(1); return ret; };  constructor: 1 destructor: 1 constructor: 2 destructor: 2 2 -72537979 -72537978 -72537977  甚至 最开始 那个版本，只要不开 O2 就会 输出：\n1 2 3 4 5 6  发现有博客讲这个 Modern C++中lambda表达式的陷阱_尘中远的程序开发记录\n得出结论 当你以为 C++ NB 的时候，实际上它可能在 UB。\nC++ 的局部变量确实是会在函数返回/语句块结束时销毁的，但销毁后由于 UB 可能还能用（\n总之不要在局部变量销毁后还能执行的 lambda 中以引用捕获局部变量。\n","date":"2020-07-08T14:08:38+08:00","permalink":"https://ouuan.github.io/post/lambda-capture-local-variable-by-reference/","tags":["cpp"],"title":"C++ lambda 使用引用捕获局部变量的陷阱"},{"categories":["游记"],"contents":"\u0026lt;area/\u0026gt; \u0026lt;base/\u0026gt; \u0026lt;br/\u0026gt; \u0026lt;col/\u0026gt; \u0026lt;command/\u0026gt; \u0026lt;embed/\u0026gt; \u0026lt;hr/\u0026gt; \u0026lt;img/\u0026gt; \u0026lt;input/\u0026gt; \u0026lt;keygen/\u0026gt; \u0026lt;link/\u0026gt; \u0026lt;menuitem/\u0026gt; \u0026lt;meta/\u0026gt; \u0026lt;param/\u0026gt; \u0026lt;source/\u0026gt; \u0026lt;track/\u0026gt; \u0026lt;wbr/\u0026gt;\n英文标题（链接末尾）叫 \u0026ldquo;HBSX2020\u0026rdquo; 是因为前两年文件夹名字都叫 \u0026ldquo;HBSX201X\u0026rdquo;，虽然今年是 \u0026ldquo;NOI省选\u0026rdquo;。\n子标题带“2020 省选”是因为听说这样更利于 SEO。\n2020 省选 Day 1 因为曾经遇到过：\n 模拟赛自己写的 $\\log^2$ 树状数组外面二分比别人写的 $\\log$ 线段树里面二分快； NOIP2018 D2T1 在所有 OJ 上不开 O2 都过不了，但在 8700k（全国统一评测机）上过了  这么两件事，于是不假思索地否掉了 T1 的线段树二分写了个树状数组外面二分甚至还花了半小时给这个做法卡常最后用时 8s 左右。\n做了上述这件事的我自闭了。\n 打开题面立刻看到编译选项有 O2，但下面又写了“评测时不开启任何优化选项”。\n 考场是 Windows 10 + NOI Linux 虚拟机。往虚拟机里拷贝文件的时候虚拟机卡了，然后在任务管理器里直接 kill 掉了，然后就打不开虚拟机了。\n后来对拍的时候不小心给暴力搞了个非常大的数据，然后 MLE 了，然后就死机了，然后就重启了，然后就可以进虚拟机了。\n2020 省选 Day 1.5 就一天没处理 CP Editor 相关的事，结果就遇上了 CP Editor 除了我开的 PR 的 PR 最多的一天，有两个 first-time contributor，处理 PR 就搞了一下午。有新 contributor 倒是好事 ，毕竟过不了多久我可能就要文化课了。\n晚上写了 AGC 的 A，然后看了眼 B 好像不太会，看了眼 C 会了但懒得写了。\n2020 省选 Day 2 打开题面立刻看到编译选项没有 O2，但下面貌似改成了（也可能是我 Day 1 看错了）“评测时除编译选项外不开启任何优化选项”。\n发现 T1 好像会，在草稿纸上写了下转移方程后就开始写，写完发现过不了大样例，然后发现假了，而且比较 naive 地改对会让复杂度变成 $O(n+2^mm^2)$。想了一会儿后发现一个空间复杂度 $O(2^mm)$ 的做法时间复杂度是 $O(n+2^mm)$，但貌似要 MLE，于是把 vector 都换成了数组，但还是爆了。然后发现一个性质：$n$ 只有 $10^5$，而那个非常大的数组每个值最大是 $\\frac12n$，于是不会爆 unsigned short，然后就卡到了 $470\\rm MiB$ 左右。\n然后感觉 T2 比较可做，于是先把 T3 的暴力写了。感觉 Matrix Tree 没有那么好写，于是先只写了 $30$ 分。\nT2 先打了个暴力，然后发现貌似可以 $O(n\\sqrt n+n\\log^2n)$，然后发现用 bitset 可以 $O(n\\sqrt\\frac nw+n\\log^2n)$ ($w$ 是字长, 一般为 $32$)，这时已经快 12 点了，T3 的 Matrix Tree 还没写，很方，但因为（当时以为）有 30/70 分（实际上是 30/90 分），就还是写了，然后很快就过了大样例，然后小数据过拍了，然后大数据没过拍，然后发现是 bitset 开小了，调了之后过了，然后在 Linux 上测了大样例，然后在 Windows 上测了链跑了 $4.3s$，感觉 8700k 肯定能过，但还是最好在 Linux 上测一下，然后在 Linux 上段错误了，然后调了一会儿数组大小，然后想起来可能是爆栈了，然后发现自己并不会在 Linux 上开栈，然后就自闭了，然后没时间了，Matrix Tree 写不了了，考试结束了。\n出考场听说 T2 是原题可以 $O(n\\log^2 n)$，听说 yls T2 写的和我是一个东西但没用 bitset，听说机房电脑很快所以不会比 8700k 慢太多，听说 Day 1 前两题很简单，听说 wcx 500+。\n","date":"2020-06-20T14:46:43+08:00","permalink":"https://ouuan.github.io/post/hbsx2020/","tags":["CCF系列赛事","省选"],"title":"2020省选自闭记"},{"categories":["知识点"],"contents":"“动态 DP”通过树链剖分将带修改的树上 DP 问题拆分为规模更小的序列上的半群合并问题和树上 DP 问题，从而可以快速地支持修改。\n（这一篇中我会尝试将形式化的问题通式和具体的例题一并进行讲解。）\n需解决的问题 概述 一个树上 DP 问题，需要支持单点修改，单点询问 DP 值。\n形式化描述 给你一棵有根树，树上的每个点有 权值 与 DP 值 两个属性，其中 权值 是题目给定的，DP 值 是你需要计算的。\n令点 $u$ 的权值为 $a_u$，DP 值为 $d_u$。题目给定了树的形态，每个点的初始权值，以及 DP 值的计算方法：$d_u=f(a_u, d_{v_1}, d_{v_2}, \\ldots)$，其中 $v_i$ 是 $u$ 的儿子节点，$f$ 是一个接受一个权值和多个 DP 值，返回一个 DP 值的函数，每个 $d_{v_i}$ 对 $f$ 的贡献都是独立的，且可以快速地计算加入/删除一个 $d_{v_i}$ 后的 $f$.\n现在，你需要执行若干次操作，每次操作为以下之一：\n 给定一个点和一个权值，将这个点的权值修改为给定的权值。 给定一个点，求此时这个点的 DP 值。  额外地，如果将计算 $f(a_1, f(a_2, f(a_3, \\ldots)))$ 视作一连串二元运算的话，应当可以将权值和 DP 值映射到一个半群来进行这样的运算，也就是说这样的运算满足结合律。并且，这样的运算应当能够快速进行。\n例题 洛谷 P4719\n给你一棵由 $n$ 个点构成的，点带权的树。$m$ 次修改单点权值，每次修改后你需要求出整棵树的最大权独立集的权值和。\n“独立集”是给定的树点集的一个子集，其中任意两点在树上不相邻。\n$1\\le n, m\\le 10^5$。\n 在链上解决问题 如果树是一条链，那么我们要做的其实就是求一个后缀的权值合并起来的结果，支持单点修改。\n在序列上，这样的问题往往可以通过线段树来解决。使用线段树来动态维护后缀和，我们需要能够将两段相邻区间的信息进行合并，这一点是由题目性质所保证的。\n以例题为例：我们可以维护一段区间开头选/不选，结尾选/不选共四种情况各自的最大权独立集权值和，那么，在合并后，两端是否选择保持不变，中间只有两段都不选或其中一段选才能合并。也就是说：\n用 $l_{i, j}$ ($i, j\\in\\{0, 1\\}$) 表示左半段开头是否选择为 $i$，结尾是否选择为 $j$ 时的最大权独立集权值和，右半段用 $r_{i, j}$，合并后用 $c_{i, j}$ 类似地表示，那么：\n$$ c_{i, j} = \\max(l_{i, 0} + r_{0, j}, l_{i, 0} + r_{1, j}, l_{i, 1} + r_{0, j}) $$\n这样的话，使用线段树来维护信息并，用这个公式来合并相邻两段，我们就在树是一条链时解决了带修改的树上 DP 问题。实际上，我们可以快速地求出并更新链上任何一个区间的信息并。\n解决原问题 当链上问题可以解决时，我们往往可以使用树链剖分来将问题推广到树上。\n注意，这里的“树链剖分”指任意的一种剖分，不一定是“重链剖分”。但为了叙述方便，依然使用“重链”“轻链”“重儿子”“轻儿子”等术语。\n当我们将树剖分成若干条链后，我们可以快速获得任意一条重链的一个区间的信息并。我们需要做的，其实就是将轻儿子所在重链的信息合并上来。\n我们在进行链与链的信息合并时，要求两条链是首尾相接的，所以直接使用链与链的信息合并来把轻儿子所在重链的信息合并上来是行不通的。但不要忘了原本的题目：树形 DP。我们除了可以将首尾相接的两条链合并，还能将一个点与它的若干子树合并。于是，我们可以将一个点的轻儿子所在重链的信息合并到这个点上，计算出这个点与其所有轻子树的并，等效为一个点。\n还是以例题为例：用 $a_u$ 代指 $u$ 的权值，$c_{v_i, 0/1, 0/1}$ 代指 $v_i$（$u$ 的一个轻儿子）所属的整条重链的信息并，那么：\n在计算 $u$ 所属的重链的信息并时，令 $[u, u]$ 这一段的信息并为 $c_{u, 0/1, 0/1}$，那么：\n $c_{u, 0, 1} = c_{u, 1, 0} = -\\infty$（一个足够小的数） $c_{u, 1, 1} = a_u + \\sum \\max(c_{v_i, 0, 0}, c_{v_i, 0, 1})$ $c_{u, 0, 0} = \\sum \\max(c_{v_i, 0, 0}, c_{v_i, 0, 1}, c_{v_i, 1, 0}, c_{v_i, 1, 1})$  这样的话，我们就可以将轻链的信息合并到重链上。并且，轻子树的贡献是独立的，所以可以快速地更新一个轻子树的信息。此时，一个点到其所在重链的底端的信息并就是这个点的 DP 值，也就是说，这样的一段链实际上是整个子树的信息并。\n为了快速地进行这样的计算，可以：（时间复杂度是在信息合并复杂度为 $O(1)$ 的情况下）\n 使用重链剖分，每次单点修改时不断向上将当前所在重链合并到当前所在重链顶端的父亲。（$O(n\\log n+m\\log^2n)$） 使用 LCT 来维护实链剖分，用类似维护子树信息的方式来维护轻儿子的信息。（$O((n + m)\\log n))$，常数略大） 使用全局平衡二叉树。（$O((n + m)\\log n))$，常数较小）  例题参考代码 树链剖分 （使用了 CPTH）\n（常数有点大，被迫在 Val 里使用数组而非 vector）\n#ifndef CPTH_SEGMENTTREE #define CPTH_SEGMENTTREE #include\u0026lt;cassert\u0026gt; #include\u0026lt;climits\u0026gt; #include\u0026lt;functional\u0026gt; #include\u0026lt;vector\u0026gt; namespace CPTH{template\u0026lt;typename valueType,typename modType\u0026gt;struct SegmentTreeNode{std::size_t id;long long left,right;valueType val;modType mod;};template\u0026lt;typename valueType,typename modType,bool elementModificationOnly=false\u0026gt;class SegmentTree{public:SegmentTree()=default;SegmentTree(const std::vector\u0026lt;valueType\u0026gt;\u0026amp;_initValue,std::function\u0026lt;valueType(const valueType\u0026amp;,const valueType\u0026amp;)\u0026gt;_merge,std::function\u0026lt;void(SegmentTreeNode\u0026lt;valueType,modType\u0026gt;\u0026amp;,const modType\u0026amp;)\u0026gt;_update,long long _startPoint=1,const valueType\u0026amp;_valueZero=valueType(),const modType\u0026amp;_modZero=modType());void init(const std::vector\u0026lt;valueType\u0026gt;\u0026amp;_initValue,std::function\u0026lt;valueType(const valueType\u0026amp;,const valueType\u0026amp;)\u0026gt;_merge,std::function\u0026lt;void(SegmentTreeNode\u0026lt;valueType,modType\u0026gt;\u0026amp;,const modType\u0026amp;)\u0026gt;_update,long long _startPoint=1,const valueType\u0026amp;_valueZero=valueType(),const modType\u0026amp;_modZero=modType());void modify(long long l,long long r,const modType\u0026amp;mod);void modify(long long p,const modType\u0026amp;mod);valueType query(long long l,long long r);valueType query(long long p);private:void pushup(std::size_t cur);void pushdown(std::size_t cur);void build(std::size_t cur,long long l,long long r,const std::vector\u0026lt;valueType\u0026gt;\u0026amp;initValue);void m_init(const std::vector\u0026lt;valueType\u0026gt;\u0026amp;_initValue,std::function\u0026lt;valueType(const valueType\u0026amp;,const valueType\u0026amp;)\u0026gt;_merge,std::function\u0026lt;void(SegmentTreeNode\u0026lt;valueType,modType\u0026gt;\u0026amp;,const modType\u0026amp;)\u0026gt;_update,const valueType\u0026amp;_valueZero,const modType\u0026amp;_modZero);void modify(std::size_t cur,long long l,long long r,long long L,long long R,const modType\u0026amp;mod);valueType query(std::size_t cur,long long l,long long r,long long L,long long R);std::function\u0026lt;valueType(const valueType\u0026amp;,const valueType\u0026amp;)\u0026gt;merge;std::function\u0026lt;void(SegmentTreeNode\u0026lt;valueType,modType\u0026gt;\u0026amp;,const modType\u0026amp;)\u0026gt;update;std::vector\u0026lt;SegmentTreeNode\u0026lt;valueType,modType\u0026gt;\u0026gt;nodes;long long leftRange=0,rightRange=0;valueType valueZero;modType modZero;};template\u0026lt;typename valueType,typename modType,bool elementModificationOnly\u0026gt;SegmentTree\u0026lt;valueType,modType,elementModificationOnly\u0026gt;::SegmentTree(const std::vector\u0026lt;valueType\u0026gt;\u0026amp;_initValue,std::function\u0026lt;valueType(const valueType\u0026amp;,const valueType\u0026amp;)\u0026gt;_merge,std::function\u0026lt;void(SegmentTreeNode\u0026lt;valueType,modType\u0026gt;\u0026amp;,const modType\u0026amp;)\u0026gt;_update,long long _startPoint,const valueType\u0026amp;_valueZero,const modType\u0026amp;_modZero){init(_initValue,_merge,_update,_startPoint,_valueZero,_modZero);}template\u0026lt;typename valueType,typename modType,bool elementModificationOnly\u0026gt;void SegmentTree\u0026lt;valueType,modType,elementModificationOnly\u0026gt;::init(const std::vector\u0026lt;valueType\u0026gt;\u0026amp;_initValue,std::function\u0026lt;valueType(const valueType\u0026amp;,const valueType\u0026amp;)\u0026gt;_merge,std::function\u0026lt;void(SegmentTreeNode\u0026lt;valueType,modType\u0026gt;\u0026amp;,const modType\u0026amp;)\u0026gt;_update,long long _startPoint,const valueType\u0026amp;_valueZero,const modType\u0026amp;_modZero){assert(_startPoint\u0026gt;=LLONG_MIN/2);assert(_startPoint\u0026lt;=LLONG_MAX/2-(long long)_initValue.size());leftRange=_startPoint;rightRange=_startPoint+_initValue.size();m_init(_initValue,_merge,_update,_valueZero,_modZero);}template\u0026lt;typename valueType,typename modType,bool elementModificationOnly\u0026gt;void SegmentTree\u0026lt;valueType,modType,elementModificationOnly\u0026gt;::modify(long long l,long long r,const modType\u0026amp;mod){assert(!elementModificationOnly);modify(1,leftRange,rightRange,l,r,mod);}template\u0026lt;typename valueType,typename modType,bool elementModificationOnly\u0026gt;void SegmentTree\u0026lt;valueType,modType,elementModificationOnly\u0026gt;::modify(long long p,const modType\u0026amp;mod){assert(p\u0026lt;LLONG_MAX);modify(1,leftRange,rightRange,p,p+1,mod);}template\u0026lt;typename valueType,typename modType,bool elementModificationOnly\u0026gt;valueType SegmentTree\u0026lt;valueType,modType,elementModificationOnly\u0026gt;::query(long long l,long long r){return query(1,leftRange,rightRange,l,r);}template\u0026lt;typename valueType,typename modType,bool elementModificationOnly\u0026gt;valueType SegmentTree\u0026lt;valueType,modType,elementModificationOnly\u0026gt;::query(long long p){return query(p,p+1);}template\u0026lt;typename valueType,typename modType,bool elementModificationOnly\u0026gt;void SegmentTree\u0026lt;valueType,modType,elementModificationOnly\u0026gt;::pushup(std::size_t cur){nodes[cur].val=merge(nodes[cur\u0026lt;\u0026lt;1].val,nodes[cur\u0026lt;\u0026lt;1|1].val);}template\u0026lt;typename valueType,typename modType,bool elementModificationOnly\u0026gt;void SegmentTree\u0026lt;valueType,modType,elementModificationOnly\u0026gt;::pushdown(std::size_t cur){update(nodes[cur\u0026lt;\u0026lt;1],nodes[cur].mod);update(nodes[cur\u0026lt;\u0026lt;1|1],nodes[cur].mod);nodes[cur].mod=modZero;}template\u0026lt;typename valueType,typename modType,bool elementModificationOnly\u0026gt;void SegmentTree\u0026lt;valueType,modType,elementModificationOnly\u0026gt;::build(std::size_t cur,long long l,long long r,const std::vector\u0026lt;valueType\u0026gt;\u0026amp;initValue){nodes[cur].id=cur;nodes[cur].left=l;nodes[cur].right=r;nodes[cur].mod=modZero;if(l==r-1)nodes[cur].val=initValue[l-leftRange];else{build(cur\u0026lt;\u0026lt;1,l,(l+r)\u0026gt;\u0026gt;1,initValue);build(cur\u0026lt;\u0026lt;1|1,(l+r)\u0026gt;\u0026gt;1,r,initValue);pushup(cur);}}template\u0026lt;typename valueType,typename modType,bool elementModificationOnly\u0026gt;void SegmentTree\u0026lt;valueType,modType,elementModificationOnly\u0026gt;::m_init(const std::vector\u0026lt;valueType\u0026gt;\u0026amp;_initValue,std::function\u0026lt;valueType(const valueType\u0026amp;,const valueType\u0026amp;)\u0026gt;_merge,std::function\u0026lt;void(SegmentTreeNode\u0026lt;valueType,modType\u0026gt;\u0026amp;,const modType\u0026amp;)\u0026gt;_update,const valueType\u0026amp;_valueZero,const modType\u0026amp;_modZero){merge=_merge;update=_update;valueZero=_valueZero;modZero=_modZero;nodes.resize((rightRange-leftRange)\u0026lt;\u0026lt;2);build(1,leftRange,rightRange,_initValue);}template\u0026lt;typename valueType,typename modType,bool elementModificationOnly\u0026gt;void SegmentTree\u0026lt;valueType,modType,elementModificationOnly\u0026gt;::modify(std::size_t cur,long long l,long long r,long long L,long long R,const modType\u0026amp;mod){if(l\u0026gt;=R||r\u0026lt;=L)return;if(L\u0026lt;=l\u0026amp;\u0026amp;r\u0026lt;=R)update(nodes[cur],mod);else{if(!elementModificationOnly)pushdown(cur);modify(cur\u0026lt;\u0026lt;1,l,(l+r)\u0026gt;\u0026gt;1,L,R,mod);modify(cur\u0026lt;\u0026lt;1|1,(l+r)\u0026gt;\u0026gt;1,r,L,R,mod);pushup(cur);}}template\u0026lt;typename valueType,typename modType,bool elementModificationOnly\u0026gt;valueType SegmentTree\u0026lt;valueType,modType,elementModificationOnly\u0026gt;::query(std::size_t cur,long long l,long long r,long long L,long long R){if(l\u0026gt;=R||r\u0026lt;=L)return valueZero;if(L\u0026lt;=l\u0026amp;\u0026amp;r\u0026lt;=R)return nodes[cur].val;if(!elementModificationOnly)pushdown(cur);return merge(query(cur\u0026lt;\u0026lt;1,l,(l+r)\u0026gt;\u0026gt;1,L,R),query(cur\u0026lt;\u0026lt;1|1,(l+r)\u0026gt;\u0026gt;1,r,L,R));}} #endif #ifndef CPTH_HLD #define CPTH_HLD #include\u0026lt;algorithm\u0026gt; #include\u0026lt;cassert\u0026gt; #include\u0026lt;vector\u0026gt; namespace CPTH{class HLD{public:HLD(std::size_t size=0);void reset(std::size_t size);void addEdge(std::size_t u,std::size_t v);void build(std::size_t root=1);std::size_t lca(std::size_t u,std::size_t v)const;std::size_t id(std::size_t u)const;std::size_t atId(std::size_t x)const;std::size_t top(std::size_t u)const;std::size_t bottom(std::size_t u)const;std::size_t parent(std::size_t u)const;std::vector\u0026lt;std::size_t\u0026gt;children(std::size_t u)const;std::pair\u0026lt;std::size_t,std::size_t\u0026gt;subtree(std::size_t u)const;std::vector\u0026lt;std::pair\u0026lt;std::size_t,std::size_t\u0026gt;\u0026gt;path(std::size_t u,std::size_t v)const;private:void dfs1(std::size_t u);void dfs2(std::size_t u);void validate(std::size_t u)const;private:bool built;std::size_t n,dfntot;std::vector\u0026lt;std::vector\u0026lt;std::size_t\u0026gt;\u0026gt;g;std::vector\u0026lt;std::size_t\u0026gt;pa,heavy,dep,siz,tp,bt,dfn,rdfn,exi;};HLD::HLD(std::size_t size){reset(size);}void HLD::reset(std::size_t size){assert(size\u0026lt;g.max_size());assert(size\u0026lt;pa.max_size());built=false;n=size;dfntot=0;g.clear();g.resize(n+1);pa.assign(n+1,0);heavy=dep=siz=tp=bt=dfn=rdfn=exi=pa;}void HLD::addEdge(std::size_t u,std::size_t v){validate(u);validate(v);g[u].push_back(v);g[v].push_back(u);}void HLD::build(std::size_t root){if(built)return;assert(n\u0026gt;=1);validate(root);dfs1(root);tp[root]=root;dfs2(root);assert(dfntot==n);built=true;}std::size_t HLD::lca(std::size_t u,std::size_t v)const{assert(built);validate(u);validate(v);while(tp[u]!=tp[v]){if(dep[tp[u]]\u0026gt;dep[tp[v]])u=pa[tp[u]];else v=pa[tp[v]];}return dep[u]\u0026lt;dep[v]?u:v;}std::size_t HLD::id(std::size_t u)const{assert(built);validate(u);return dfn[u];}std::size_t HLD::atId(std::size_t x)const{assert(built);validate(x);return rdfn[x];}std::size_t HLD::top(std::size_t u)const{assert(built);validate(u);return tp[u];}std::size_t HLD::bottom(std::size_t u)const{assert(built);validate(u);return bt[tp[u]];}std::size_t HLD::parent(std::size_t u)const{assert(built);validate(u);return pa[u];}std::vector\u0026lt;std::size_t\u0026gt;HLD::children(std::size_t u)const{auto ret=g[u];if(pa[u])ret.erase(std::find(ret.begin(),ret.end(),pa[u]));return ret;}std::pair\u0026lt;std::size_t,std::size_t\u0026gt;HLD::subtree(std::size_t u)const{assert(built);validate(u);return{dfn[u],exi[u]};}std::vector\u0026lt;std::pair\u0026lt;std::size_t,std::size_t\u0026gt;\u0026gt;HLD::path(std::size_t u,std::size_t v)const{assert(built);validate(u);validate(v);std::vector\u0026lt;std::pair\u0026lt;std::size_t,std::size_t\u0026gt;\u0026gt;res;while(tp[u]!=tp[v]){if(dep[tp[u]]\u0026gt;dep[tp[v]]){res.emplace_back(dfn[tp[u]],dfn[u]);u=pa[tp[u]];}else{res.emplace_back(dfn[tp[v]],dfn[v]);v=pa[tp[v]];}}if(dep[u]\u0026gt;dep[v])std::swap(u,v);res.emplace_back(dfn[u],dfn[v]);return res;}void HLD::dfs1(std::size_t u){assert(siz[u]==0);siz[u]=1;for(auto v:g[u]){if(v==pa[u])continue;dep[v]=dep[u]+1;pa[v]=u;dfs1(v);siz[u]+=siz[v];if(siz[v]\u0026gt;siz[heavy[u]])heavy[u]=v;}}void HLD::dfs2(std::size_t u){bt[tp[u]]=u;dfn[u]=++dfntot;rdfn[dfn[u]]=u;if(heavy[u]){tp[heavy[u]]=tp[u];dfs2(heavy[u]);for(auto v:g[u]){if(v==pa[u]||v==heavy[u])continue;tp[v]=v;dfs2(v);}}exi[u]=dfntot;}void HLD::validate(std::size_t u)const{assert(u\u0026gt;=1);assert(u\u0026lt;=n);}} #endif #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;cctype\u0026gt; #include \u0026lt;set\u0026gt; #include \u0026lt;map\u0026gt; int read() { int out = 0, f = 1; char c = getchar(); while (!isdigit(c) \u0026amp;\u0026amp; c != '-') c = getchar(); if (c == '-') { f = -1; c = getchar(); } for (; isdigit(c); c = getchar()) out = out * 10 + c - '0'; return out * f; } using namespace CPTH; using namespace std; typedef vector\u0026lt;int\u0026gt; vi; typedef vector\u0026lt;vi\u0026gt; vvi; const int INF = 1e9; struct Val { int a[2][2]; Val() { a[0][0] = a[1][1] = -INF; a[0][1] = a[1][0] = 0; } int *operator[](int x) { return a[x]; } const int *operator[](int x) const { return a[x]; } Val operator+(const Val \u0026amp;b) const { Val ret; for (int i = 0; i \u0026lt; 2; ++i) { for (int j = 0; j \u0026lt; 2; ++j) { ret[i][j] = max({a[i][0] + b[0][j], a[i][0] + b[1][j], a[i][1] + b[0][j]}); } } return ret; } int ans() { return max({a[0][0], a[0][1], a[1][0], a[1][1]}); } }; struct SingleVal : public Val // 自行搜索：C++ 类继承 { int self, ch0, ch1; explicit SingleVal(int x = 0) : Val(), self(x), ch0(0), ch1(0) { update(); } void update() { a[0][0] = ch1; a[1][1] = self + ch0; a[0][1] = a[1][0] = -INF; } void modify(int x) { self = x; update(); } void add(const Val \u0026amp;x) { ch0 += max(x[0][0], x[0][1]); ch1 += max({x[0][0], x[0][1], x[1][0], x[1][1]}); update(); } void del(const Val \u0026amp;x) { ch0 -= max(x[0][0], x[0][1]); ch1 -= max({x[0][0], x[0][1], x[1][0], x[1][1]}); update(); } }; int main() { int n = read(); int m = read(); vector\u0026lt;SingleVal\u0026gt; a(n + 1); vector\u0026lt;Val\u0026gt; init(n), b(n + 1); for (int i = 1; i \u0026lt;= n; ++i) a[i] = SingleVal(read()); HLD hld(n); for (int i = 1; i \u0026lt; n; ++i) hld.addEdge(read(), read()); hld.build(); for (int i = 1; i \u0026lt;= n; ++i) init[i - 1] = a[hld.atId(i)]; SegmentTree\u0026lt;Val, bool, true\u0026gt; seg( init, plus\u0026lt;Val\u0026gt;(), [\u0026amp;](SegmentTreeNode\u0026lt;Val, bool\u0026gt; \u0026amp;u, bool x) { if (x) u.val = a[hld.atId(u.left)]; } ); for (int i = n; i \u0026gt;= 2; --i) { int u = hld.atId(i); if (u == (int)hld.top(u)) { b[u] = seg.query(i, hld.id(hld.bottom(u)) + 1); a[hld.parent(u)].add(b[u]); seg.modify(hld.id(hld.parent(u)), true); } } while (m--) { int x = read(); int y = read(); a[x].modify(y); seg.modify(hld.id(x), true); while (1) { x = hld.top(x); y = hld.parent(x); if (!y) break; a[y].del(b[x]); b[x] = seg.query(hld.id(x), hld.id(hld.bottom(x)) + 1); a[y].add(b[x]); seg.modify(hld.id(y), true); x = y; } printf(\u0026quot;%d\\n\u0026quot;, seg.query(1, hld.id(hld.bottom(1)) + 1).ans()); } return 0; }   LCT #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;cctype\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;functional\u0026gt; using namespace std; int read() { int out = 0, f = 1; char c = getchar(); while (!isdigit(c) \u0026amp;\u0026amp; c != '-') c = getchar(); if (c == '-') { f = -1; c = getchar(); } for (; isdigit(c); c = getchar()) out = out * 10 + c - '0'; return out * f; } const int INF = 1e9; typedef vector\u0026lt;int\u0026gt; vi; struct Val { int a[2][2]; Val() { a[0][0] = a[1][1] = -INF; a[0][1] = a[1][0] = 0; } int *operator[](int x) { return a[x]; } const int *operator[](int x) const { return a[x]; } Val operator+(const Val \u0026amp;b) const { Val ret; for (int i = 0; i \u0026lt; 2; ++i) { for (int j = 0; j \u0026lt; 2; ++j) { ret[i][j] = max({a[i][0] + b[0][j], a[i][0] + b[1][j], a[i][1] + b[0][j]}); } } return ret; } int ans() { return max({a[0][0], a[0][1], a[1][0], a[1][1]}); } }; struct SingleVal : public Val // 自行搜索：C++ 类继承 { int self, ch0, ch1; explicit SingleVal(int x = 0) : Val(), self(x), ch0(0), ch1(0) { update(); } void update() { a[0][0] = ch1; a[1][1] = self + ch0; a[0][1] = a[1][0] = -INF; } void modify(int x) { self = x; update(); } void add(const Val \u0026amp;x) { ch0 += max(x[0][0], x[0][1]); ch1 += max({x[0][0], x[0][1], x[1][0], x[1][1]}); update(); } void del(const Val \u0026amp;x) { ch0 -= max(x[0][0], x[0][1]); ch1 -= max({x[0][0], x[0][1], x[1][0], x[1][1]}); update(); } }; struct LCT { struct Node { vi ch; int pa; Val sum; SingleVal self; Node() : ch(2), pa(0), sum(), self() {} }; vector\u0026lt;Node\u0026gt; t; LCT(int n) : t(n + 1) {} bool nroot(int x) { return x == t[t[x].pa].ch[0] || x == t[t[x].pa].ch[1]; } void pushup(int x) { t[x].sum = t[t[x].ch[0]].sum + t[x].self + t[t[x].ch[1]].sum; } void rotate(int x) { int y = t[x].pa; int z = t[y].pa; int k = x == t[y].ch[1]; if (nroot(y)) t[z].ch[y == t[z].ch[1]] = x; t[x].pa = z; t[y].ch[k] = t[x].ch[k ^ 1]; t[t[x].ch[k ^ 1]].pa = y; t[x].ch[k ^ 1] = y; t[y].pa = x; pushup(y); pushup(x); } void Splay(int x) { while (nroot(x)) { int y = t[x].pa; int z = t[y].pa; if (nroot(y)) rotate((x == t[y].ch[1]) ^ (y == t[z].ch[1]) ? x : y); rotate(x); } } void access(int x) { for (int y = 0; x; x = t[y = x].pa) { Splay(x); if (y) t[x].self.del(t[y].sum); if (t[x].ch[1]) t[x].self.add(t[t[x].ch[1]].sum); t[x].ch[1] = y; pushup(x); } } void link(int u, int pa) { // 为了只用从轻儿子向上更新一次，link 时两段都要 access, Splay access(u); Splay(u); access(pa); Splay(pa); t[u].pa = pa; t[pa].self.add(t[u].sum); pushup(pa); } void modify(int u, int x) { access(u); Splay(u); t[u].self.modify(x); pushup(u); } int query() { Splay(1); return max({t[1].sum[0][0], t[1].sum[0][1], t[1].sum[1][0], t[1].sum[1][1]}); } }; int main() { int n = read(); int m = read(); LCT lct(n); for (int i = 1; i \u0026lt;= n; ++i) lct.modify(i, read()); vector\u0026lt;vi\u0026gt; g(n + 1); for (int i = 1; i \u0026lt; n; ++i) { int u = read(); int v = read(); g[u].push_back(v); g[v].push_back(u); } function\u0026lt;void(int, int)\u0026gt; dfs = [\u0026amp;](int u, int pa) { for (auto v : g[u]) { if (v == pa) continue; lct.link(v, u); dfs(v, u); } }; dfs(1, 0); while (m--) { int u = read(); int x = read(); lct.modify(u, x); printf(\u0026quot;%d\\n\u0026quot;, lct.query()); } return 0; }   其它题目 BZOJ5210 最大连通子块和，感觉能用线段树维护最大子段和那一套（根本不需要什么“广义矩阵”，会序列问题就能做的啊..），写了下过了样例，但只在 BZOJ 找到了这道题，一不小心 用了 C++11，懒得改成 C++98 了，就没交。感觉挺对的，就算挂了也应该是写挂了..\n说句闲话 为啥其他人的博客讲动态 DP 上来就一个矩阵啊..凭啥想到可以用矩阵转移啊..根本就不需要矩阵的..随便来个半群就好了..精髓根本不在矩阵吧..能转化成矩阵的形式而已..\n","date":"2020-05-07T20:58:54+08:00","permalink":"https://ouuan.github.io/post/tree-dp-with-modification/","tags":["动态DP","树形DP","线段树","LCT","数据结构"],"title":"带修改的树上 DP 问题（动态 DP）"},{"categories":["题解"],"contents":"题目链接\n题目描述\n给你一个数列 $a_{1..n}$，进行 $m$ 次询问，每次询问给出一个区间 $[l, r]$ 及参数 $w$，询问 $\\max_{i = l}^{r-w+1}\\{\\min_{j=i}^{i+w-1}\\{a_j\\}\\}$。\n数列长度和询问次数 $10^5$。\n 简要做法 O((n+m)log^2n) 做法 二分答案，记当前二分的值为 $x$，定义 $b_i=\\begin{cases}1\u0026amp;a_i\\ge x\\\\-n\u0026amp;a_i\u0026lt;x\\end{cases}$，那么答案不小于 $x$ 当且仅当 $b_{l..r}$ 的最大子段和不小于 $w$。\n最大子段和可以用线段树维护，记录每个区间的最大子段和，最大前缀，最大后缀，以及总和即可。\n然后用主席树或 整体二分 就能在 $O((n+m)\\log^2n)$ 的时间复杂度内解决这道题。\n（其实我自己没写主席树做法，听说别人都写的主席树，口胡了一下，感觉应该和整体二分做法差不多..）\nO((n+m)(logn+logm)) 做法 首先用单调栈求出每个点作为最小值最远能向左延伸到 $p_i$，向右延伸到 $q_i$。\n那么，我们将每个 $[p_i, q_i]$ 看作一条权值为 $a_i$ 的线段，每次询问就是求与 $[l, r]$ 的交不小于 $w$ 的线段里最大的权值。\n$[p_i, q_i]$ 和 $[l, r]$ 相交有两种情况：\n  $p_i\u0026lt;l$\n此时若 $[p_i, q_i]$ 和 $[l, r]$ 的交不小于 $w$，则 $[l, l+w-1]$ 必然是一个合法的交。而在这种情况下，$\\min_{j=l}^{l+w-1}\\{a_j\\}$ 必然不小于 $a_i$（因为 $a_i$ 是 $[p_i, q_i]$ 内的最小值，而 $[p_i, q_i]$ 包含 $[l, l+w-1]$），所以只需考虑 $[l, l+w-1]$ 便不劣于这种情况下的任一线段。\n  $p_i\\ge l$\n这种情况下，$[p_i, q_i]$ 和 $[l, r]$ 的交不小于 $w$ 等价于 $l\\le p_i\\le r-w+1$ 且 $q_i-p_i+1\\ge w$。只要对线段和询问分别按长度和 $w$ 从大到小排序，双指针枚举就可以满足 $q_i-p_i+1\\ge w$，而 $\\max_{l\\le p_i\\le r-w+1}a_i$ 可以用线段树维护（枚举到线段时在 $p_i$ 处对 $a_i$ 取 max，枚举到询问时在 $[l, r-w+1]$ 这个区间上求 max）。\n  然后把这两种情况的答案取 max，就做完了。\n参考代码 代码中的线段树用了 板子。整体二分这份代码还用了 CF 板子。\n整体二分 O((n\u0026#43;m)log^2n) #ifndef OUUAN #pragma GCC optimize(\u0026quot;Ofast,no-stack-protector,unroll-loops,fast-math\u0026quot;) #endif #include\u0026lt;bits/stdc++.h\u0026gt; template\u0026lt;typename valueType,typename modType\u0026gt;struct SegmentTreeNode{public:std::size_t id;long long left,right;valueType val;modType mod;};template\u0026lt;typename valueType,typename modType,bool elementModificationOnly=false\u0026gt;class SegmentTree{public:SegmentTree()=default;SegmentTree(const std::vector\u0026lt;valueType\u0026gt;\u0026amp;_initValue,std::function\u0026lt;valueType(const valueType\u0026amp;,const valueType\u0026amp;)\u0026gt;_merge,std::function\u0026lt;void(SegmentTreeNode\u0026lt;valueType,modType\u0026gt;\u0026amp;,const modType\u0026amp;)\u0026gt;_update,long long _startPoint=1,const valueType\u0026amp;_valueZero=valueType(),const modType\u0026amp;_modZero=modType()){init(_initValue,_merge,_update,_startPoint,_valueZero,_modZero);}void init(const std::vector\u0026lt;valueType\u0026gt;\u0026amp;_initValue,std::function\u0026lt;valueType(const valueType\u0026amp;,const valueType\u0026amp;)\u0026gt;_merge,std::function\u0026lt;void(SegmentTreeNode\u0026lt;valueType,modType\u0026gt;\u0026amp;,const modType\u0026amp;)\u0026gt;_update,long long _startPoint=1,const valueType\u0026amp;_valueZero=valueType(),const modType\u0026amp;_modZero=modType()){assert(_startPoint\u0026gt;=LLONG_MIN/2);assert(_startPoint\u0026lt;=LLONG_MAX/2-(long long)_initValue.size());leftRange=_startPoint;rightRange=_startPoint+_initValue.size();m_init(_initValue,_merge,_update,_valueZero,_modZero);}void modify(long long l,long long r,const modType\u0026amp;mod){assert(!elementModificationOnly);modify(1,leftRange,rightRange,l,r,mod);}void modify(long long p,const modType\u0026amp;mod){assert(p\u0026lt;LLONG_MAX);modify(1,leftRange,rightRange,p,p+1,mod);}valueType query(long long l,long long r){return query(1,leftRange,rightRange,l,r);}valueType query(long long p){return query(p,p+1);}private:void pushup(std::size_t cur){nodes[cur].val=merge(nodes[cur\u0026lt;\u0026lt;1].val,nodes[cur\u0026lt;\u0026lt;1|1].val);}void pushdown(std::size_t cur){update(nodes[cur\u0026lt;\u0026lt;1],nodes[cur].mod);update(nodes[cur\u0026lt;\u0026lt;1|1],nodes[cur].mod);nodes[cur].mod=modZero;}void build(std::size_t cur,long long l,long long r,const std::vector\u0026lt;valueType\u0026gt;\u0026amp;initValue){nodes[cur].id=cur;nodes[cur].left=l;nodes[cur].right=r;nodes[cur].mod=modZero;if(l==r-1)nodes[cur].val=initValue[l-leftRange];else{build(cur\u0026lt;\u0026lt;1,l,(l+r)\u0026gt;\u0026gt;1,initValue);build(cur\u0026lt;\u0026lt;1|1,(l+r)\u0026gt;\u0026gt;1,r,initValue);pushup(cur);}}void m_init(const std::vector\u0026lt;valueType\u0026gt;\u0026amp;_initValue,std::function\u0026lt;valueType(const valueType\u0026amp;,const valueType\u0026amp;)\u0026gt;_merge,std::function\u0026lt;void(SegmentTreeNode\u0026lt;valueType,modType\u0026gt;\u0026amp;,const modType\u0026amp;)\u0026gt;_update,const valueType\u0026amp;_valueZero,const modType\u0026amp;_modZero){merge=_merge;update=_update;valueZero=_valueZero;modZero=_modZero;nodes.resize((rightRange-leftRange)\u0026lt;\u0026lt;2);build(1,leftRange,rightRange,_initValue);}void modify(std::size_t cur,long long l,long long r,long long L,long long R,const modType\u0026amp;mod){if(l\u0026gt;=R||r\u0026lt;=L)return;if(L\u0026lt;=l\u0026amp;\u0026amp;r\u0026lt;=R)update(nodes[cur],mod);else{if(!elementModificationOnly)pushdown(cur);modify(cur\u0026lt;\u0026lt;1,l,(l+r)\u0026gt;\u0026gt;1,L,R,mod);modify(cur\u0026lt;\u0026lt;1|1,(l+r)\u0026gt;\u0026gt;1,r,L,R,mod);pushup(cur);}}valueType query(std::size_t cur,long long l,long long r,long long L,long long R){if(l\u0026gt;=R||r\u0026lt;=L)return valueZero;if(L\u0026lt;=l\u0026amp;\u0026amp;r\u0026lt;=R)return nodes[cur].val;if(!elementModificationOnly)pushdown(cur);return merge(query(cur\u0026lt;\u0026lt;1,l,(l+r)\u0026gt;\u0026gt;1,L,R),query(cur\u0026lt;\u0026lt;1|1,(l+r)\u0026gt;\u0026gt;1,r,L,R));}std::function\u0026lt;valueType(const valueType\u0026amp;,const valueType\u0026amp;)\u0026gt;merge;std::function\u0026lt;void(SegmentTreeNode\u0026lt;valueType,modType\u0026gt;\u0026amp;,const modType\u0026amp;)\u0026gt;update;std::vector\u0026lt;SegmentTreeNode\u0026lt;valueType,modType\u0026gt;\u0026gt;nodes;long long leftRange=0,rightRange=0;valueType valueZero;modType modZero;}; // #define int ll // #define FAST_IOSTREAM 1 #define For(i,l,r)for(int i=(l),i##end=(r);i\u0026lt;=i##end;++i) #define FOR(i,r,l)for(int i=(r),i##end=(l);i\u0026gt;=i##end;--i) #define SON(i,u)for(int i=head[u];i;i=nxt[i]) #define BE(x)(x).begin(),(x).end() #define fi first #define se second #define pb push_back #define eb emplace_back #define pq priority_queue #define min minOfDifferentTypes #define max maxOfDifferentTypes #define y1 why_is_there_a_function_called_y1 using namespace std;typedef long long ll;typedef pair\u0026lt;int,int\u0026gt;pii;typedef vector\u0026lt;int\u0026gt;vi;typedef vector\u0026lt;vi\u0026gt; vvi;typedef vvi v2i;typedef vector\u0026lt;vvi\u0026gt;v3i;typedef vector\u0026lt;v3i\u0026gt;v4i;typedef vector\u0026lt;bool\u0026gt;vb;typedef vector\u0026lt;vb\u0026gt;vvb;typedef vvb v2b;typedef vector\u0026lt;vvb\u0026gt;v3b;typedef vector\u0026lt;v3b\u0026gt;v4b;typedef vector\u0026lt;pii\u0026gt;vpii;typedef vector\u0026lt;vpii\u0026gt;vvpii;typedef vvpii v2pii;typedef vector\u0026lt;vvpii\u0026gt;v3pii;typedef vector\u0026lt;v3pii\u0026gt;v4pii;typedef long double ld;typedef vector\u0026lt;ld\u0026gt;vd;typedef vector\u0026lt;vd\u0026gt;vvd;typedef vvd v2d;typedef vector\u0026lt;v2d\u0026gt;v3d;typedef vector\u0026lt;v3d\u0026gt;v4d;const ld inf=1e121;const ld eps=1e-10;mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());int randint(int l,int r){int out=rng()%(r-l+1)+l;return out\u0026gt;=l?out:out+r-l+1;}template\u0026lt;typename A,typename B\u0026gt;string to_string(pair\u0026lt;A,B\u0026gt;p);template\u0026lt;typename A,typename B,typename C\u0026gt;string to_string(tuple\u0026lt;A,B,C\u0026gt;p);template\u0026lt;typename A,typename B,typename C,typename D\u0026gt;string to_string(tuple\u0026lt;A,B,C,D\u0026gt;p);string to_string(const string\u0026amp;s){return '\u0026quot;'+s+'\u0026quot;';}string to_string(const char*s){return to_string((string)s);}string to_string(bool b){return(b?\u0026quot;true\u0026quot;:\u0026quot;false\u0026quot;);}string to_string(vector\u0026lt;bool\u0026gt;v){bool first=true;string res=\u0026quot;{\u0026quot;;for(int i=0;i\u0026lt;static_cast\u0026lt;int\u0026gt;(v.size());i++){if(!first){res+=\u0026quot;,\u0026quot;;}first=false;res+=to_string(v[i]);}res+=\u0026quot;}\u0026quot;;return res;}template\u0026lt;size_t N\u0026gt;string to_string(bitset\u0026lt;N\u0026gt;v){string res=\u0026quot;\u0026quot;;for(size_t i=0;i\u0026lt;N;i++){res+=static_cast\u0026lt;char\u0026gt;('0'+v[i]);}return res;}template\u0026lt;typename A\u0026gt;string to_string(A v){bool first=true;string res=\u0026quot;{\u0026quot;;for(const auto\u0026amp;x:v){if(!first){res+=\u0026quot;,\u0026quot;;}first=false;res+=to_string(x);}res+=\u0026quot;}\u0026quot;;return res;}template\u0026lt;typename A,typename B\u0026gt;string to_string(pair\u0026lt;A,B\u0026gt;p){return \u0026quot;(\u0026quot;+to_string(p.first)+\u0026quot;,\u0026quot;+to_string(p.second)+\u0026quot;)\u0026quot;;}template\u0026lt;typename A,typename B,typename C\u0026gt;string to_string(tuple\u0026lt;A,B,C\u0026gt;p){return \u0026quot;(\u0026quot;+to_string(get\u0026lt;0\u0026gt;(p))+\u0026quot;,\u0026quot;+to_string(get\u0026lt;1\u0026gt;(p))+\u0026quot;,\u0026quot;+to_string(get\u0026lt;2\u0026gt;(p))+\u0026quot;)\u0026quot;;}template\u0026lt;typename A,typename B,typename C,typename D\u0026gt;string to_string(tuple\u0026lt;A,B,C,D\u0026gt;p){return \u0026quot;(\u0026quot;+to_string(get\u0026lt;0\u0026gt;(p))+\u0026quot;,\u0026quot;+to_string(get\u0026lt;1\u0026gt;(p))+\u0026quot;,\u0026quot;+to_string(get\u0026lt;2\u0026gt;(p))+\u0026quot;,\u0026quot;+to_string(get\u0026lt;3\u0026gt;(p))+\u0026quot;)\u0026quot;;}template\u0026lt;typename A,typename B,typename C,typename D,typename E\u0026gt;string to_string(tuple\u0026lt;A,B,C,D,E\u0026gt;p){return \u0026quot;(\u0026quot;+to_string(get\u0026lt;0\u0026gt;(p))+\u0026quot;,\u0026quot;+to_string(get\u0026lt;1\u0026gt;(p))+\u0026quot;,\u0026quot;+to_string(get\u0026lt;2\u0026gt;(p))+\u0026quot;,\u0026quot;+to_string(get\u0026lt;3\u0026gt;(p))+\u0026quot;,\u0026quot;+to_string(get\u0026lt;4\u0026gt;(p))+\u0026quot;)\u0026quot;;}void debug_out(){cerr\u0026lt;\u0026lt;endl;}template\u0026lt;typename Head,typename...Tail\u0026gt;void debug_out(Head H,Tail...T){cerr\u0026lt;\u0026lt;\u0026quot; \u0026quot;\u0026lt;\u0026lt;to_string(H);debug_out(T...);}template\u0026lt;typename T\u0026gt;struct is_pair{static const bool value=false;};template\u0026lt;typename T,typename U\u0026gt;struct is_pair\u0026lt;std::pair\u0026lt;T,U\u0026gt;\u0026gt;{static const bool value=true;}; #ifdef OUUAN #define debug(...)cerr\u0026lt;\u0026lt;\u0026quot;[\u0026quot;\u0026lt;\u0026lt;#__VA_ARGS__\u0026lt;\u0026lt;\u0026quot;]:\u0026quot;,debug_out(__VA_ARGS__) #else #define debug(...)42 #endif #ifdef int const int INF=0x3f3f3f3f3f3f3f3fll; #else const int INF=0x3f3f3f3f; #endif #ifdef FAST_IOSTREAM #define br cout\u0026lt;\u0026lt;'\\n' #define sp cout\u0026lt;\u0026lt;' ' #define fl cout.flush() ll read(){ll x;cin\u0026gt;\u0026gt;x;return x;}template\u0026lt;typename T\u0026gt;void read(T\u0026amp;x){cin\u0026gt;\u0026gt;x;}template\u0026lt;typename T\u0026gt;void write(const T\u0026amp;x){cout\u0026lt;\u0026lt;x;} #else #define br putchar('\\n') #define sp putchar(' ') #define fl fflush(stdout) template\u0026lt;typename T\u0026gt;typename enable_if\u0026lt;!is_integral\u0026lt;T\u0026gt;::value\u0026amp;\u0026amp;!is_pair\u0026lt;T\u0026gt;::value,void\u0026gt;::type read(T\u0026amp;x){cin\u0026gt;\u0026gt;x;}ll read(){char c;ll out=0,f=1;for(c=getchar();!isdigit(c)\u0026amp;\u0026amp;c!='-';c=getchar());if(c=='-'){f=-1;c=getchar();}for(;isdigit(c);c=getchar())out=(out\u0026lt;\u0026lt;3)+(out\u0026lt;\u0026lt;1)+c-'0';return out*f;}template\u0026lt;typename T\u0026gt;typename enable_if\u0026lt;is_integral\u0026lt;T\u0026gt;::value,T\u0026gt;::type read(T\u0026amp;x){char c;T f=1;x=0;for(c=getchar();!isdigit(c)\u0026amp;\u0026amp;c!='-';c=getchar());if(c=='-'){f=-1;c=getchar();}for(;isdigit(c);c=getchar())x=(x\u0026lt;\u0026lt;3)+(x\u0026lt;\u0026lt;1)+c-'0';return x*=f;}char read(char\u0026amp;x){for(x=getchar();isspace(x);x=getchar());return x;}double read(double\u0026amp;x){scanf(\u0026quot;%lf\u0026quot;,\u0026amp;x);return x;}ld read(ld\u0026amp;x){scanf(\u0026quot;%Lf\u0026quot;,\u0026amp;x);return x;}template\u0026lt;typename T\u0026gt;typename enable_if\u0026lt;!is_integral\u0026lt;T\u0026gt;::value\u0026amp;\u0026amp;!is_pair\u0026lt;T\u0026gt;::value,void\u0026gt;::type write(const T\u0026amp;x){cout\u0026lt;\u0026lt;x;}template\u0026lt;typename T\u0026gt;typename enable_if\u0026lt;is_integral\u0026lt;T\u0026gt;::value,void\u0026gt;::type write(const T\u0026amp;x){if(x\u0026lt;0){putchar('-');write(-x);return;}if(x\u0026gt;9)write(x/10);putchar(x%10+'0');}void write(const char\u0026amp;x){putchar(x);}void write(const double\u0026amp;x){printf(\u0026quot;%.10lf\u0026quot;,x);}void write(const ld\u0026amp;x){printf(\u0026quot;%.10Lf\u0026quot;,x);} #endif template\u0026lt;typename T\u0026gt;typename enable_if\u0026lt;is_pair\u0026lt;T\u0026gt;::value,void\u0026gt;::type read(T\u0026amp;x){read(x.fi);read(x.se);}template\u0026lt;typename T\u0026gt;typename enable_if\u0026lt;is_pair\u0026lt;T\u0026gt;::value,void\u0026gt;::type write(const T\u0026amp;x){write(x.fi);sp;write(x.se);}template\u0026lt;typename T,typename...Args\u0026gt;void read(T\u0026amp;x,Args\u0026amp;...args){read(x);read(args...);}template\u0026lt;typename OutputIt,typename=typename enable_if\u0026lt;is_same\u0026lt;output_iterator_tag,typename iterator_traits\u0026lt;OutputIt\u0026gt;::iterator_category\u0026gt;::value||(is_base_of\u0026lt;forward_iterator_tag,typename iterator_traits\u0026lt;OutputIt\u0026gt;::iterator_category\u0026gt;::value\u0026amp;\u0026amp;!is_const\u0026lt;OutputIt\u0026gt;::value)\u0026gt;::type\u0026gt;void read(OutputIt __first,OutputIt __last){for(;__first!=__last;++__first)read(*__first);}template\u0026lt;typename InputIt,typename=typename enable_if\u0026lt;is_base_of\u0026lt;input_iterator_tag,typename iterator_traits\u0026lt;InputIt\u0026gt;::iterator_category\u0026gt;::value\u0026gt;::type\u0026gt;void wts(InputIt __first,InputIt __last){bool isFirst=true;for(;__first!=__last;++__first){if(isFirst)isFirst=false;else sp;write(*__first);}br;}template\u0026lt;typename InputIt,typename=typename enable_if\u0026lt;is_base_of\u0026lt;input_iterator_tag,typename iterator_traits\u0026lt;InputIt\u0026gt;::iterator_category\u0026gt;::value\u0026gt;::type\u0026gt;void wtb(InputIt __first,InputIt __last){for(;__first!=__last;++__first){write(*__first);br;}}template\u0026lt;typename T\u0026gt;void wts(const T\u0026amp;x){write(x);sp;}template\u0026lt;typename T\u0026gt;void wtb(const T\u0026amp;x){write(x);br;}template\u0026lt;typename T\u0026gt;void wte(const T\u0026amp;x){write(x);exit(0);}template\u0026lt;typename T,typename...Args\u0026gt;void wts(const T\u0026amp;x,Args...args){wts(x);wts(args...);}template\u0026lt;typename T,typename...Args\u0026gt;void wtb(const T\u0026amp;x,Args...args){wts(x);wtb(args...);}template\u0026lt;typename T,typename...Args\u0026gt;void wte(const T\u0026amp;x,Args...args){wts(x);wte(args...);}template\u0026lt;typename T1,typename T2\u0026gt;inline bool up(T1\u0026amp;x,const T2\u0026amp;y){return x\u0026lt;y?x=y,1:0;}template\u0026lt;typename T1,typename T2\u0026gt;inline bool dn(T1\u0026amp;x,const T2\u0026amp;y){return y\u0026lt;x?x=y,1:0;}template\u0026lt;typename T1,typename T2,typename T3\u0026gt;inline bool inRange(const T1\u0026amp;x,const T2\u0026amp;l,const T3\u0026amp;r){return!(x\u0026lt;l)\u0026amp;\u0026amp;!(r\u0026lt;x);}template\u0026lt;typename T1,typename T2\u0026gt;inline auto minOfDifferentTypes(const T1\u0026amp;x,const T2\u0026amp;y)-\u0026gt;decltype(x\u0026lt;y?x:y){return x\u0026lt;y?x:y;}template\u0026lt;typename T1,typename T2\u0026gt;inline auto maxOfDifferentTypes(const T1\u0026amp;x,const T2\u0026amp;y)-\u0026gt;decltype(x\u0026lt;y?y:x){return x\u0026lt;y?y:x;}template\u0026lt;typename T1,typename T2,typename T3\u0026gt;inline T1\u0026amp;madd(T1\u0026amp;x,const T2\u0026amp;y,const T3\u0026amp;modulo){return x=(ll)(x+y+modulo)%modulo;}template\u0026lt;typename T1,typename T2,typename T3\u0026gt;inline T1\u0026amp;mmul(T1\u0026amp;x,const T2\u0026amp;y,const T3\u0026amp;modulo){return x=(ll)x*y%modulo;}inline int modadd(int x,int y,int modulo){return(x+=y)\u0026gt;=modulo?x-modulo:x;}inline int isinf(int x){return x\u0026lt;INF?x:-1;}inline void yesno(bool x){wtb(x?\u0026quot;Yes\u0026quot;:\u0026quot;No\u0026quot;);} /* ------------------------------------------------------------------------------------------------------------------- */ struct Modify { int p, x; }; struct Query { int l, r, w, id; }; struct Val { int ans, pre, suf, sum; }; signed main() { #ifdef FAST_IOSTREAM ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0); #endif int n = read(); vector\u0026lt;Modify\u0026gt; modify; vi lsh; For (i, 1, n) { int x = read(); lsh.pb(x); modify.pb({i, x}); } sort(BE(lsh)); lsh.resize(unique(BE(lsh)) - lsh.begin()); for (auto \u0026amp;m : modify) m.x = lower_bound(BE(lsh), m.x) - lsh.begin(); int k = read(); vector\u0026lt;Query\u0026gt; query; For (i, 0, k - 1) { int l = read(); int r = read(); int w = read(); query.pb({l, r, w, i}); } SegmentTree\u0026lt;Val, int, true\u0026gt; seg ( vector\u0026lt;Val\u0026gt;(n, {0, 0, 0, -n}), [n](const Val \u0026amp;x, const Val \u0026amp;y) { Val res; res.ans = max(x.suf + y.pre, max(x.ans, y.ans)); res.pre = max(x.pre, x.sum + y.pre); res.suf = max(y.suf, x.suf + y.sum); res.sum = max(x.sum + y.sum, -n); return res; }, [](SegmentTreeNode\u0026lt;Val, int\u0026gt; \u0026amp;node, int x) { if (x == INF) return; node.val.ans = node.val.pre = node.val.suf = max(0, x); node.val.sum = x; }, 1, {0, 0, 0, 0}, INF ); vi ans(k); function\u0026lt;void(vector\u0026lt;Modify\u0026gt; \u0026amp;, vector\u0026lt;Query\u0026gt; \u0026amp;, int, int)\u0026gt; solve = [\u0026amp;](vector\u0026lt;Modify\u0026gt; \u0026amp;ms, vector\u0026lt;Query\u0026gt; \u0026amp;qs, int l, int r) { if (qs.empty()) return; if (l == r - 1) { for (auto q : qs) { ans[q.id] = lsh[l]; } return; } vector\u0026lt;Modify\u0026gt; lm, rm; int mid = (l + r) \u0026gt;\u0026gt; 1; for (auto m : ms) { if (m.x \u0026gt;= mid) { seg.modify(m.p, 1); rm.push_back(m); } else lm.push_back(m); } vector\u0026lt;Query\u0026gt; lq, rq; for (auto q : qs) { if (seg.query(q.l, q.r + 1).ans \u0026gt;= q.w) rq.push_back(q); else lq.push_back(q); } vector\u0026lt;Modify\u0026gt;().swap(ms); vector\u0026lt;Query\u0026gt;().swap(qs); solve(lm, lq, l, mid); for (auto m : rm) seg.modify(m.p, -n); solve(rm, rq, mid, r); }; solve(modify, query, 0, lsh.size()); for (auto x : ans) wtb(x); return 0; }   O((n\u0026#43;m)(logn\u0026#43;logm)) #include \u0026lt;bits/stdc++.h\u0026gt; template\u0026lt;typename valueType,typename modType\u0026gt;struct SegmentTreeNode{public:std::size_t id;long long left,right;valueType val;modType mod;};template\u0026lt;typename valueType,typename modType,bool elementModificationOnly=false\u0026gt;class SegmentTree{public:SegmentTree()=default;SegmentTree(const std::vector\u0026lt;valueType\u0026gt;\u0026amp;_initValue,std::function\u0026lt;valueType(const valueType\u0026amp;,const valueType\u0026amp;)\u0026gt;_merge,std::function\u0026lt;void(SegmentTreeNode\u0026lt;valueType,modType\u0026gt;\u0026amp;,const modType\u0026amp;)\u0026gt;_update,long long _startPoint=1,const valueType\u0026amp;_valueZero=valueType(),const modType\u0026amp;_modZero=modType()){init(_initValue,_merge,_update,_startPoint,_valueZero,_modZero);}void init(const std::vector\u0026lt;valueType\u0026gt;\u0026amp;_initValue,std::function\u0026lt;valueType(const valueType\u0026amp;,const valueType\u0026amp;)\u0026gt;_merge,std::function\u0026lt;void(SegmentTreeNode\u0026lt;valueType,modType\u0026gt;\u0026amp;,const modType\u0026amp;)\u0026gt;_update,long long _startPoint=1,const valueType\u0026amp;_valueZero=valueType(),const modType\u0026amp;_modZero=modType()){assert(_startPoint\u0026gt;=LLONG_MIN/2);assert(_startPoint\u0026lt;=LLONG_MAX/2-(long long)_initValue.size());leftRange=_startPoint;rightRange=_startPoint+_initValue.size();m_init(_initValue,_merge,_update,_valueZero,_modZero);}void modify(long long l,long long r,const modType\u0026amp;mod){assert(!elementModificationOnly);modify(1,leftRange,rightRange,l,r,mod);}void modify(long long p,const modType\u0026amp;mod){assert(p\u0026lt;LLONG_MAX);modify(1,leftRange,rightRange,p,p+1,mod);}valueType query(long long l,long long r){return query(1,leftRange,rightRange,l,r);}valueType query(long long p){return query(p,p+1);}private:void pushup(std::size_t cur){nodes[cur].val=merge(nodes[cur\u0026lt;\u0026lt;1].val,nodes[cur\u0026lt;\u0026lt;1|1].val);}void pushdown(std::size_t cur){update(nodes[cur\u0026lt;\u0026lt;1],nodes[cur].mod);update(nodes[cur\u0026lt;\u0026lt;1|1],nodes[cur].mod);nodes[cur].mod=modZero;}void build(std::size_t cur,long long l,long long r,const std::vector\u0026lt;valueType\u0026gt;\u0026amp;initValue){nodes[cur].id=cur;nodes[cur].left=l;nodes[cur].right=r;nodes[cur].mod=modZero;if(l==r-1)nodes[cur].val=initValue[l-leftRange];else{build(cur\u0026lt;\u0026lt;1,l,(l+r)\u0026gt;\u0026gt;1,initValue);build(cur\u0026lt;\u0026lt;1|1,(l+r)\u0026gt;\u0026gt;1,r,initValue);pushup(cur);}}void m_init(const std::vector\u0026lt;valueType\u0026gt;\u0026amp;_initValue,std::function\u0026lt;valueType(const valueType\u0026amp;,const valueType\u0026amp;)\u0026gt;_merge,std::function\u0026lt;void(SegmentTreeNode\u0026lt;valueType,modType\u0026gt;\u0026amp;,const modType\u0026amp;)\u0026gt;_update,const valueType\u0026amp;_valueZero,const modType\u0026amp;_modZero){merge=_merge;update=_update;valueZero=_valueZero;modZero=_modZero;nodes.resize((rightRange-leftRange)\u0026lt;\u0026lt;2);build(1,leftRange,rightRange,_initValue);}void modify(std::size_t cur,long long l,long long r,long long L,long long R,const modType\u0026amp;mod){if(l\u0026gt;=R||r\u0026lt;=L)return;if(L\u0026lt;=l\u0026amp;\u0026amp;r\u0026lt;=R)update(nodes[cur],mod);else{if(!elementModificationOnly)pushdown(cur);modify(cur\u0026lt;\u0026lt;1,l,(l+r)\u0026gt;\u0026gt;1,L,R,mod);modify(cur\u0026lt;\u0026lt;1|1,(l+r)\u0026gt;\u0026gt;1,r,L,R,mod);pushup(cur);}}valueType query(std::size_t cur,long long l,long long r,long long L,long long R){if(l\u0026gt;=R||r\u0026lt;=L)return valueZero;if(L\u0026lt;=l\u0026amp;\u0026amp;r\u0026lt;=R)return nodes[cur].val;if(!elementModificationOnly)pushdown(cur);return merge(query(cur\u0026lt;\u0026lt;1,l,(l+r)\u0026gt;\u0026gt;1,L,R),query(cur\u0026lt;\u0026lt;1|1,(l+r)\u0026gt;\u0026gt;1,r,L,R));}std::function\u0026lt;valueType(const valueType\u0026amp;,const valueType\u0026amp;)\u0026gt;merge;std::function\u0026lt;void(SegmentTreeNode\u0026lt;valueType,modType\u0026gt;\u0026amp;,const modType\u0026amp;)\u0026gt;update;std::vector\u0026lt;SegmentTreeNode\u0026lt;valueType,modType\u0026gt;\u0026gt;nodes;long long leftRange=0,rightRange=0;valueType valueZero;modType modZero;}; using namespace std; int read() { int out = 0; char c; while (!isdigit(c = getchar())); for (; isdigit(c); c = getchar()) out = out * 10 + c - '0'; return out; } typedef vector\u0026lt;int\u0026gt; vi; const int INF = 1e9; struct Query { int l, r, w, id; bool operator\u0026lt;(const Query \u0026amp;b) const { return w \u0026gt; b.w; } }; int main() { int n = read(); vi a(n); for (int i = 0; i \u0026lt; n; ++i) a[i] = read(); vi p(n), len(n); stack\u0026lt;int\u0026gt; stk; for (int i = 0; i \u0026lt; n; ++i) { while (stk.size() \u0026amp;\u0026amp; a[stk.top()] \u0026gt;= a[i]) stk.pop(); if (stk.empty()) p[i] = 0; else p[i] = stk.top() + 1; stk.push(i); } stack\u0026lt;int\u0026gt;().swap(stk); for (int i = n - 1; i \u0026gt;= 0; --i) { while (stk.size() \u0026amp;\u0026amp; a[stk.top()] \u0026gt;= a[i]) stk.pop(); int r; if (stk.empty()) r = n - 1; else r = stk.top() - 1; len[i] = r - p[i] + 1; stk.push(i); } vi id(n); for (int i = 0; i \u0026lt; n; ++i) id[i] = i; sort(id.begin(), id.end(), [\u0026amp;](int x, int y) { return len[x] \u0026gt; len[y]; }); SegmentTree\u0026lt;int, bool, true\u0026gt; mn ( a, [](int x, int y) { return min(x, y); }, [](SegmentTreeNode\u0026lt;int, bool\u0026gt; \u0026amp;, bool) {}, 1, INF ); int m = read(); vi ans(m); vector\u0026lt;Query\u0026gt; query; for (int i = 0; i \u0026lt; m; ++i) { int l = read(); int r = read(); int w = read(); query.push_back({l, r, w, i}); ans[i] = mn.query(l, l + w); } sort(query.begin(), query.end()); SegmentTree\u0026lt;int, int, true\u0026gt; mx ( vi(n), [](int x, int y) { return max(x, y); }, [](SegmentTreeNode\u0026lt;int, int\u0026gt; \u0026amp;node, int x) { node.val = max(node.val, x); node.mod = max(node.mod, x); } ); auto it = id.begin(); for (auto t : query) { while (it != id.end() \u0026amp;\u0026amp; len[*it] \u0026gt;= t.w) { mx.modify(p[*it] + 1, a[*it]); ++it; } ans[t.id] = max(ans[t.id], mx.query(t.l, t.r - t.w + 2)); } for (auto x : ans) printf(\u0026quot;%d\\n\u0026quot;, x); return 0; }  ","date":"2020-04-20T23:05:37+08:00","permalink":"https://ouuan.github.io/post/cf484e/","tags":["线段树","整体二分","主席树","数据结构"],"title":"CF484E Sign on Fence"},{"categories":["题解"],"contents":"LOJ\n题目描述\n给你一棵有根树，一开始每个点都有不同的颜色。有三种操作：\n 给定 $x$，将 $x$ 到根的路径修改为一种当前树上没有出现的颜色。 给定 $x$ 和 $y$，询问 $x$ 到 $y$ 的路径上不同颜色的数量。 给定 $x$，令一个点的权值为它到根路径上不同颜色的数量，求子树 $x$ 中的最大权值。  点数和操作数 $10^5$。\n 简要做法 大致方向肯定是维护每个点到根路径上不同颜色的数量，由于操作 3，用差分维护不太可行，于是锁定为使用线段树以 DFS 序为下标维护每个点到根的颜色数量。如果能够维护这个，操作 2, 3 就好办了：\n 操作 3 直接区间最大值即可。（子树的 DFS 序连续） 令 $x$ 到根的颜色数量为 $a_x$，那么 $x$ 到 $y$ 的颜色数量为 $a_x+a_y-2a_{lca(x, y)}+1$。这个可以用树上差分来理解。  现在的问题就是如何在进行操作 1 时在线段树上更新每个点到根的颜色数量。\n首先，定义“关键点”为根或与 parent 颜色不同的点，那么：\n 每个点到根的颜色数即为到根路径上的关键点个数。 在操作 1 中，有两类点（下文中也会用“两类点”来指代这两类点）的关键点属性会发生改变：  从 $x$ 到根的路径上，除根外全部变成非关键点。 每个被改变的颜色段，没被改变的那一部分的顶端变为关键点。    （P.S. 为啥要用画图（实际上是 KolourPaint 而非 mspaint）而不是 PPT 呢？因为 1. PPT 虽然好看，但手绘貌似更有灵魂 2. 一直用 PPT，想试着换个画风 3. 懒）\n在图中，$2$ 和 $4$ 从关键点变成了非关键点，而 $6$ 和 $8$ 从非关键点变成了关键点。\n关键点和非关键点的转换其实就是子树加一或减一，于是，问题的关键就在于如何快速找到这两类点。\n可以发现，操作 1 其实就和 LCT 的 access 操作是一样的，LCT 中的实链即为本题中颜色相同的段，而使用 LCT 的确能快速找到这两类点（前一类是实链的顶端，即 Splay 中的最小点；后一类是被修改的末端的实儿子，即被修改的末端在 Splay 上的右子树中的最小点），具体怎么找这两类点可以参考下面的代码。\n时间复杂度是 $O((n+m)\\log^2 n)$（说不定是 $\\Theta(n\\log n+m\\log^2 n)$ 或者 $\\Theta(n\\log^2 n+m\\log n)$，不会算 /kk）。\n参考代码 #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;cctype\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;functional\u0026gt; using namespace std; int read() { int out = 0; char c; while (!isdigit(c = getchar())); for (; isdigit(c); c = getchar()) out = out * 10 + c - '0'; return out; } typedef vector\u0026lt;int\u0026gt; vi; typedef pair\u0026lt;int, int\u0026gt; pii; struct SegmentTree { #define ls (cur \u0026lt;\u0026lt; 1) #define rs (cur \u0026lt;\u0026lt; 1 | 1) #define mid ((l + r) \u0026gt;\u0026gt; 1) vi mx, tag; SegmentTree(int n, const vi \u0026amp;init) : mx(n * 4), tag(n * 4) { build(1, 1, n + 1, init); } void pushup(int cur) { mx[cur] = max(mx[ls], mx[rs]); } void build(int cur, int l, int r, const vi \u0026amp;init) { if (l == r - 1) mx[cur] = init[l]; else { build(ls, l, mid, init); build(rs, mid, r, init); pushup(cur); } } void modify(int cur, int x) { mx[cur] += x; tag[cur] += x; } void pushdown(int cur) { modify(ls, tag[cur]); modify(rs, tag[cur]); tag[cur] = 0; } void modify(int cur, int l, int r, int L, int R, int x) { if (l \u0026gt;= R || r \u0026lt;= L) return; if (L \u0026lt;= l \u0026amp;\u0026amp; r \u0026lt;= R) modify(cur, x); else { pushdown(cur); modify(ls, l, mid, L, R, x); modify(rs, mid, r, L, R, x); pushup(cur); } } int query(int cur, int l, int r, int L, int R) { if (l \u0026gt;= R || r \u0026lt;= L) return 0; if (L \u0026lt;= l \u0026amp;\u0026amp; r \u0026lt;= R) return mx[cur]; pushdown(cur); return max(query(ls, l, mid, L, R), query(rs, mid, r, L, R)); } #undef ls #undef rs #undef mid }; struct LCT { struct Node { vi ch; int pa; Node() : ch(2), pa(0) {} }; vector\u0026lt;Node\u0026gt; t; LCT(int n) : t(n + 1) {} bool nroot(int x) { return x == t[t[x].pa].ch[0] || x == t[t[x].pa].ch[1]; } void rotate(int x) { int y = t[x].pa; int z = t[y].pa; int k = x == t[y].ch[1]; if (nroot(y)) t[z].ch[y == t[z].ch[1]] = x; t[x].pa = z; t[y].ch[k] = t[x].ch[k ^ 1]; t[t[x].ch[k ^ 1]].pa = y; t[x].ch[k ^ 1] = y; t[y].pa = x; } void Splay(int x) { while (nroot(x)) { int y = t[x].pa; int z = t[y].pa; if (nroot(y)) rotate((x == t[y].ch[1]) ^ (y == t[z].ch[1]) ? x : y); rotate(x); } } int gettop(int x) { while (t[x].ch[0]) x = t[x].ch[0]; return x; } vector\u0026lt;pii\u0026gt; access(int x) // 返回值为每一对“两类点” { vector\u0026lt;pii\u0026gt; res; for (int y = 0; x; x = t[y = x].pa) { Splay(x); res.emplace_back(gettop(x), gettop(t[x].ch[1])); t[x].ch[1] = y; } return res; } }; int main() { int n = read(); int m = read(); vector\u0026lt;vi\u0026gt; g(n + 1); for (int i = 1; i \u0026lt; n; ++i) { int u = read(); int v = read(); g[u].push_back(v); g[v].push_back(u); } LCT lct(n); int dfntot = 0; vi dfn(n + 1), exi(n + 1), pa(n + 1), son(n + 1), siz(n + 1), dep(n + 1), tp(n + 1); function\u0026lt;void(int)\u0026gt; dfs1 = [\u0026amp;](int u) { siz[u] = 1; dfn[u] = ++dfntot; for (auto v : g[u]) { if (v == pa[u]) continue; dep[v] = dep[u] + 1; lct.t[v].pa = u; pa[v] = u; dfs1(v); siz[u] += siz[v]; if (siz[v] \u0026gt; siz[son[u]]) son[u] = v; } exi[u] = dfntot; }; function\u0026lt;void(int)\u0026gt; dfs2 = [\u0026amp;](int u) { if (!son[u]) return; tp[son[u]] = tp[u]; dfs2(son[u]); for (auto v : g[u]) { if (v == pa[u] || v == son[u]) continue; tp[v] = v; dfs2(v); } }; auto lca = [\u0026amp;](int u, int v) { while (tp[u] != tp[v]) { if (dep[tp[u]] \u0026gt; dep[tp[v]]) u = pa[tp[u]]; else v = pa[tp[v]]; } return dep[u] \u0026gt; dep[v] ? v : u; }; dep[1] = tp[1] = 1; dfs1(1); dfs2(1); vi init(n + 1); for (int i = 1; i \u0026lt;= n; ++i) init[dfn[i]] = dep[i]; SegmentTree seg(n, init); while (m--) { switch(read()) { case 1: { int x = read(); lct.Splay(x); auto res = lct.access(x); for (auto p : res) { int u = p.first; int v = p.second; if (u != 1) seg.modify(1, 1, n + 1, dfn[u], exi[u] + 1, -1); if (v) seg.modify(1, 1, n + 1, dfn[v], exi[v] + 1, 1); } break; } case 2: { int x = read(); int y = read(); int u = lca(x, y); int ans = seg.query(1, 1, n + 1, dfn[x], dfn[x] + 1); ans += seg.query(1, 1, n + 1, dfn[y], dfn[y] + 1); ans -= 2 * seg.query(1, 1, n + 1, dfn[u], dfn[u] + 1); ans += 1; printf(\u0026quot;%d\\n\u0026quot;, ans); break; } case 3: { int x = read(); printf(\u0026quot;%d\\n\u0026quot;, seg.query(1, 1, n + 1, dfn[x], exi[x] + 1)); break; } } } return 0; }  （没有全局变量的代码是不是非常清爽）\n","date":"2020-04-17T12:38:34+08:00","permalink":"https://ouuan.github.io/post/sdoi2017-%E6%A0%91%E7%82%B9%E6%B6%82%E8%89%B2/","tags":["LCT","线段树","数据结构"],"title":"「SDOI2017」树点涂色"},{"categories":["技术"],"contents":"大家知道我整天在 GitHub 上根本几乎不做题，那为什么不利用 GitHub 来督促自己做题呢？\nGitHub 的 Projects 功能正好适合这么做。\n我的 Project\n创建 Project 在自己的 GitHub 个人信息页上的 Project 里创建就可以了。\n添加 column 和 notes 点右边的 Add column 和每一栏里的加号就可以了。\n使用 Copy as Markdown 插件 由于加题的时候经常要复制题目链接再改成 Markdown，可以使用 Copy as Markdown 插件 来更加便捷地完成这个操作。\n使用方法：\n 选中 Link 的一部分，右击，然后 \u0026ldquo;Copy [Link Content](URL)\u0026quot;，选中的部分会作为 \u0026ldquo;Link Content\u0026rdquo;。 点击扩展程序图标，可以复制当前 / 全部标签页。  结构 可以参考 我的 Project，分为 \u0026ldquo;Check contests\u0026rdquo;, \u0026ldquo;Topics\u0026rdquo;, \u0026ldquo;LOJ AC desc\u0026rdquo;（在 LOJ 中搜索 \u0026ldquo;OI\u0026rdquo; 并按 AC 人数降序排序）和 \u0026ldquo;NOI\u0026rdquo; 四个部分。每个 Topic 和每届 NOI 单独放一栏，里面放上题目和相应的博客。\u0026ldquo;Topics\u0026rdquo; 和 \u0026ldquo;NOI\u0026rdquo; 中放上对应栏的 Link（在每一栏的菜单里可以 \u0026ldquo;Copy column link\u0026rdquo;），这个 link 只保留类似于 \u0026ldquo;#column-8321611\u0026rdquo; 的部分就好了，否则点的时候可能会刷新页面。\n归档 当一个任务完成后在它的右上角菜单中点 \u0026ldquo;Archive\u0026rdquo; 就可以归档。归档后的 notes 可以在 Menu-\u0026gt;\u0026hellip;-\u0026gt;View Archive 查看。\n固定标签页 在 Chrome 中可以在标签页的右键菜单中固定标签页，把这个 Project 页面固定下来还是很不错的。\n关于我的 Project 这里面的题都是我没做过的，做过的都没加进来。\n建议不要完全照搬题目，可以参考一下结构，自己找题。\n最后希望自己有了这个不要再咕咕咕了..\n","date":"2020-03-14T13:14:15+08:00","permalink":"https://ouuan.github.io/post/use-github-project-to-create-a-to-do-list/","tags":["计划"],"title":"使用 GitHub Project 创建一份 To Do List"},{"categories":["题解"],"contents":"洛谷\nBZOJ\n题目描述\n给你一张边带权的无向连通图，多次修改，每次修改一条边的边权，每次修改完后求最小生成树的边权之和。\n点数 $2\\cdot 10^4$, 边数和修改数 $5\\cdot 10^4$，时限 3s。\n 简要做法 LCT 做法 把每条边按两次修改之间以及头尾分成若干段，然后按出现时间线段树分治，LCT 维护最小生成树。\n时间复杂度 $O(n+(m+q)\\log q\\log n)$ ，常数有点大，听说很难卡到满分，自己没写。\nKruskal 做法 还是线段树分治，但尝试用 Kruskal 算法求最小生成树。\n然而，Kruskal 算法要求边权从小到大加入，直接线段树分治无法满足这个要求。\n（注：为了严谨，你可以认为下文中在比较大小时给第 $i$ ($1\\le i\\le m$) 条边的边权加上了 $2^{-i}$，这样保证了 MST 是唯一的。当然，在代码中无需如此。）\n可以观察到，随着分治区间越来越小，修改的边也越来越少，图中大多数的边是不会被修改的。正因如此，可以猜想，大多数边在或不在 MST 中是固定的，而我们需要关注的，只有那些因会修改的边的边权变化而既可能在 MST 中又可能不在 MST 中的边。\n如果我们有一张图 $G=(V, E)$，其中 $E\u0026rsquo;\\subseteq E$ 是以后会被修改的边，那么，如何求出那些无论 $E'$ 中的边边权如何变化都一定在 MST 中/一定不在 MST 中的边呢？\n 将 $E'$ 中的边边权设为正无穷，求 MST，此时不在 $E'$ 中且不在 MST 中的边，无论 $E'$ 中的边边权如何变化，都不在 MST 中，下文中称这些边为“一类边”。 将 $E'$ 中的边边权设为 $0$，求 MST，此时不在 $E'$ 中且在 MST 中的边，无论 $E'$ 中的边边权如何变化，都在 MST 中，下文中称这些边为“二类边”。  那么，在继续分治下去的过程中，我们就只需关注 $E'$ 中的边以及是一类边而不是二类边的边。\n由于一类边最多有 $|V|-1$ 条，而二类边至少有 $|V|-1-|E'|$ 条，所以是一类边而不是二类边的边最多有 $|E'|$ 条，于是，向下分治时需要关注的边就不超过 $2|E'|$ 条。\n虽然只需关注这些边，但二类边依然要在分治过程中保留（计算 MST 时并查集中要保留，最后边权要计入答案）。边权计入答案很好办，而保留在并查集中可以通过可回退并查集来实现。\n一层分治中每个分治内会被修改的边加起来是 $O(m+q)$ 条，并查集要可回退，只能按秩合并。所以总时间复杂度是 $O(n+(m+q)\\log(m+q)+(m+q)\\log q\\log n)$ 。\n时间复杂度和 LCT 做法差不多（你愿意的话你可以说时间复杂度更大），但跑得飞快。\n有个实现上的小细节：将 $E'$ 中的边边权设为无穷大和 $0$ 时不需要真的修改再排序，最后加入（其实可以直接不加入）/最先加入即可，而其它边的排序可以在主函数中完成，而在分治过程中保持原序。这样时间复杂度的瓶颈上就只有并查集而没有排序了（当然我说的是 (m+q)logqlogn 这个瓶颈，不是 (m+q)log(m+q) 这个瓶颈）。\nKruskal 做法参考代码 #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;stack\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; typedef long long ll; struct Edge { int u, v, w, l, r; bool operator\u0026lt;(const Edge \u0026amp;b) const { return w \u0026lt; b.w; } bool change(int left, int right) { return (l \u0026gt; left \u0026amp;\u0026amp; l \u0026lt;= right) || (r \u0026gt;= left \u0026amp;\u0026amp; r \u0026lt; right); } }; struct UFS { vector\u0026lt;int\u0026gt; f, siz; struct Change { int x, y; }; stack\u0026lt;Change\u0026gt; c; void init(int n) { f.resize(n + 1); siz.resize(n + 1, 1); for (int i = 0; i \u0026lt;= n; ++i) f[i] = i; } int find(int x) { return x == f[x] ? x : find(f[x]); } bool merge(int x, int y) { x = find(x); y = find(y); if (x == y) return false; if (siz[x] \u0026lt; siz[y]) swap(x, y); c.push({x, y}); siz[x] += siz[y]; f[y] = x; return true; } void rollback(int x) { while ((int)c.size() \u0026gt; x) { f[c.top().y] = c.top().y; siz[c.top().x] -= siz[c.top().y]; c.pop(); } } int status() const { return c.size(); } } ufs; vector\u0026lt;ll\u0026gt; ans; void solve(int l, int r, vector\u0026lt;Edge\u0026gt; \u0026amp;e, ll delta = 0) { if (l == r) { ans[l] = delta; int ver = ufs.status(); for (int i = 0; i \u0026lt; (int)e.size(); ++i) if (ufs.merge(e[i].u, e[i].v)) ans[l] += e[i].w; ufs.rollback(ver); return; } vector\u0026lt;bool\u0026gt; ininf(e.size(), false), inzero(e.size(), false); int ver = ufs.status(); for (int i = 0; i \u0026lt; (int)e.size(); ++i) if (!e[i].change(l, r)) ininf[i] = ufs.merge(e[i].u, e[i].v); ufs.rollback(ver); for (int i = 0; i \u0026lt; (int)e.size(); ++i) if (e[i].change(l, r)) ufs.merge(e[i].u, e[i].v); for (int i = 0; i \u0026lt; (int)e.size(); ++i) { if (!e[i].change(l, r) \u0026amp;\u0026amp; ufs.merge(e[i].u, e[i].v)) { inzero[i] = true; delta += e[i].w; } } int mid = (l + r) \u0026gt;\u0026gt; 1; vector\u0026lt;Edge\u0026gt; le, re; for (int i = 0; i \u0026lt; (int)e.size(); ++i) { if (e[i].change(l, r) || (ininf[i] \u0026amp;\u0026amp; !inzero[i])) { if (e[i].l \u0026lt;= mid) le.push_back(e[i]); if (e[i].r \u0026gt; mid) re.push_back(e[i]); } } ufs.rollback(ver); for (int i = 0; i \u0026lt; (int)e.size(); ++i) if (inzero[i]) ufs.merge(e[i].u, e[i].v); solve(l, mid, le, delta); solve(mid + 1, r, re, delta); ufs.rollback(ver); } int main() { int n, m, q; scanf(\u0026quot;%d%d%d\u0026quot;, \u0026amp;n, \u0026amp;m, \u0026amp;q); vector\u0026lt;Edge\u0026gt; e; vector\u0026lt;int\u0026gt; u(m), v(m), w(m), last(m, 1); for (int i = 0; i \u0026lt; m; ++i) scanf(\u0026quot;%d%d%d\u0026quot;, \u0026amp;u[i], \u0026amp;v[i], \u0026amp;w[i]); for (int i = 1; i \u0026lt;= q; ++i) { int p, x; scanf(\u0026quot;%d%d\u0026quot;, \u0026amp;p, \u0026amp;x); --p; if (i \u0026gt; 1) e.push_back({u[p], v[p], w[p], last[p], i - 1}); last[p] = i; w[p] = x; } for (int i = 0; i \u0026lt; m; ++i) e.push_back({u[i], v[i], w[i], last[i], q}); sort(e.begin(), e.end()); ans.resize(q + 1); ufs.init(n); solve(1, q, e); for (int i = 1; i \u0026lt;= q; ++i) printf(\u0026quot;%lld\\n\u0026quot;, ans[i]); return 0; } ","date":"2020-02-26T23:12:33+08:00","permalink":"https://ouuan.github.io/post/hnoi2010-%E5%9F%8E%E5%B8%82%E5%BB%BA%E8%AE%BE/","tags":["线段树分治","分治","LCT","并查集","Kruskal"],"title":"「HNOI2010」城市建设（线段树分治，LCT/Kruskal）"},{"categories":["题解"],"contents":"题目链接\n题意简述\n给你一张边带权且边从 $1$ 到 $m$ 编号的无向图 $G$，称一张图 $H$ 是“好的”，当且仅当存在一个 $H$ 的生成子图 $F$ 使得 $F$ 中每个点的度数都是奇数。现在，你需要回答 $m$ 个问题，第 $i$ 个问题是：求最小的 $x$，使得仅保留 $G$ 中编号不超过 $i$ 且边权不超过 $x$ 的边时，得到的生成子图是“好的”，或者指出不存在这样的 $x$。\n$2\\le n\\le 10^5$, $1\\le m\\le 3\\cdot 10^5$, TL 4s。\n 简要做法 第一步转化 这道题题意就非常绕口，不转化一下很难下手。\n我们需要得到这样一个结论：\n$G$ 的一个生成子图是“好的”，当且仅当它的每一个连通块都包含偶数个点。\n结论的证明 必要性\n如果存在一个连通块有奇数个点，这张图的任何一个生成子图都必然包含一个包含奇数个点的连通块。由于无向图中所有点的度数之和为偶数，一个包含奇数个点的连通块中必然存在度数为偶数的点，从而不符合题意。\n充分性\n一句话说明：对每个包含偶数个点的连通块找一个生成树，每个点如果有奇数个儿子就断开与父亲的边，就构造出来了。\n下面是详细的证明。\n先是问题的转化：\n需证一张图是“好的”，只需证明它的每一个连通块都是“好的”。\n需证一张连通图是“好的”，只需证明它的任意一个生成树都是“好的”。\n需证任意一张每个连通块都包含偶数个点的图都是“好的”，只需证明任意一棵包含偶数个点的树都是“好的”。\n下面开始证明任意一棵包含偶数个点的树都是“好的”：\n首先，任选一个点作为树根。\n约定：一个单点的高度是 $1$，树根的所有儿子均是叶子的树高度为 $2$。\n接着，使用归纳法证明。\n归纳基础：高度为 $2$ 且有偶数个点的树显然是“好的”。高度为 $1$ 或 $2$ 且有奇数个点的树显然有且仅有根的度数为偶数。\n归纳假设：高度不超过 $i$ 且有偶数个点的树是“好的”，高度不超过 $i$ 且有奇数个点的树可以通过删边使得有且仅有根的度数为偶数。\n归纳证明：\n  高度为 $i+1$ 且有偶数个点的树是“好的”\n删去树根与包含偶数个点的子树之间的连边，由归纳假设得到这些子树都是“好的”，所以只需证明剩下没被删去的部分是“好的”。\n删去后，整棵树依然包含偶数个点，因此，根有奇数个儿子，也就是说根的度数为奇数。由归纳假设得到剩下的每棵子树都可以转化成有且仅有根的度数为偶数的树，加上与根相连的这条边，所有子树内的点的度数就都为奇数了。所以，高度为 $i+1$ 且有偶数个点的树是“好的”。\n  高度为 $i+1$ 且有奇数个点的树可以通过删边使得有且仅有根的度数为偶数。\n与上面类似，唯一不同的地方在于删去包含偶数个点的子树后根有偶数个儿子，此时有且仅有根的度数为偶数。\n  通过上述归纳可以得到，任意一棵包含偶数个点的树都是“好的”，从而充分性得证。\n 有了这个结论之后，问题就变成了：对于前 $i$ ($1\\le i\\le m$) 条边，至少要保留其中边权不大于多少的边，才能使得图中所有连通块都包含偶数个点（或者保留所有前 $i$ 条边依然无法满足）。\nLCT 做法 考虑按编号顺序加边，用堆/priority_queue 按边权大小维护边，每加一条边就按边权从大到小删边直至出现大小为奇数的连通块，最后删掉的那条边的边权就是答案。由于边权大的边总是先被删掉，可以用 LCT 维护最小生成森林而非整张图。\n复杂度 $O(n+m\\log n)$ 。\n分治做法 这题还有一个神奇的分治做法。\n首先，“编号”和“边权”可以看成是两维坐标，从而可以把每条边视作二维平面上的一个点，“编号不超过 $x$ 且边权不超过 $y$ 的边”就对应着 $(0, 0)$ 到 $(x, y)$ 这个矩形。\n在下文中，用 $(x_1, y_1, x_2, y_2)$ 表示编号在 $[x_1, x_2]$ 之内，边权在 $[y_1, y_2]$ 之内的所有边构成的集合。\n于是，原问题就转变成了，对于每个横坐标 $x$，求出最小的 $y$，使得原图仅保留 $(0, 0, x, y)$ 内的边时，所有连通块都包含偶数个点。\n为了方便，下文不考虑无解的情况，写代码时简单判一判就好了。\n分治的概述：\n 全局维护一个支持撤销的并查集。 solve(xl, xr, yl, yr) 会算出 $[xl, xr]$ 的答案，已知这些答案都在 $[yl, yr]$ 内。调用之前需要保证并查集内的边集为 $(0, 0, xl - 1, yl - 1)$。 令 $xmid = (xl + xr) / 2$，solve(xl, xr, yl, yr) 先计算出 $xmid$ 的答案为 $ans[xmid]$，然后递归计算 solve(xl, xmid - 1, ans[xmid], yr) 和 solve(xmid + 1, xr, yl, ans[xmid])。  这带来了两个问题：\n 递归下去时如何保证并查集内分别含有 $(0, 0, xl-1, ansmid-1)$ 和 $(0, 0, xmid, yl-1)$？ 总的时间复杂度是多少？  解决这两个问题前，我们先来看一下更加完整的流程：\nsolve(xl, xr, yl, yr): 如果 xl \u0026gt; xr: return 如果 yl = yr: [xl, xr] 的答案为 yl return 令此时的并查集状态为 ver1 = (0, 0, xl - 1, yl - 1) 加上 (xl, 0, xmid, yl - 1) 的边 令此时的并查集状态为 ver2 = (0, 0, xmid, yl - 1) 将 (0, yl, xmid, yr) 的边按纵坐标（边权）顺序从小到大加入，直至图中没有奇连通块 上一步中最后加入的边的边权即为 xmid 的答案 ans[xmid] 回退至 ver2 = (0, 0, xmid, yl - 1) solve(xmid + 1, xr, yl, ans[xmid]) 回退至 ver1 = (0, 0, xl - 1, yl - 1) 加上 (0, yl, xl - 1, ans[xmid] - 1) 的边，此时并查集内的边为 (0, 0, xl - 1, ansmid - 1) solve(xl, xmid - 1, ans[xmid], yr) 回退至 ver1 = (0, 0, xl - 1, yl - 1)  结合图来理解：\n 一开始并查集里是 ①。 加上 ②。 在 ③ + ④ 中按边权从小到大加边，直至只有偶连通块。真正加了的边是 ④，ans[xmid] 是 ④ 的顶端。 删掉 ④，递归解决红色部分。 删掉 ②，加上 ⑤，递归解决蓝色部分。  还有一个细节：为了快速获取一个矩形内的边，可以将 $(0, 0, xr, yr)\\setminus(0, 0, xl-1, yl-1)$ 这些边作为 solve 的参数。\n有了这个完整流程，第一个问题（正确性）解决了。\n接下来是第二个问题：时间复杂度是多少？\n我们来看每一层分治的 solve 函数的参数构成的的这些矩形，实际上是从左上到右下排列，而 solve 函数中添加/回退/作为参数的边是向左和向下的两条。可以看出：在每一层分治内，每条边最多在三个 solve 函数内带来了常数次操作。（并不会出现多个高度为 $1$ 的矩形排成一排的情况，因为高度为 $1$ 时直接得到答案终止递归了。）\n于是，每一层分治的时间复杂度是 $O(m\\log n)$，总时间复杂度就是 $O(n+m\\log^2 n+m\\log m)$。\n虽然两个 log，但它是分治和并查集，所以跑的比 LCT 快。\n我写的空间复杂度是 $O(n+m\\log n)$。貌似可以不在参数里放 $(0, 0, xr, yr)\\setminus(0, 0, xl-1, yl-1)$，然后可以线性空间复杂度，不是很懂..（如果追求理论复杂度的话 LCT 它不香吗；否则，只要能过，且体会到这个做法的精髓就好。）\nP.S. 我是在 一些常用的数据结构维护手法 - zzq 看到这题和这个做法的（其实是我一开始没看懂他的伪码在干嘛，后来自己想出来的..）。我个人觉得这个和整体二分差的挺大的，套不到 整体二分的框架 中。但我也不知道整体二分有没有一个官方而精确的定义，大家各自的定义或狭义或广义，读者可以自行判断是否要把这个做法视作一种整体二分。（把这个视作整体二分的人多半会认为决策单调性优化 DP 那个分治也是整体二分吧..）\n参考代码 LCT 做法 #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;queue\u0026gt; #include \u0026lt;stack\u0026gt; #include \u0026lt;cctype\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; const int INF = 2e9; int read() { int out = 0; char c; while (!isdigit(c = getchar())); for (; isdigit(c); c = getchar()) out = out * 10 + c - '0'; return out; } struct Edge { int u, v, w, id; bool operator\u0026lt;(const Edge \u0026amp;b) const { return w \u0026lt; b.w; } }; struct LCT { struct Node { vector\u0026lt;int\u0026gt; ch; int pa; bool node, odd, vir, rev; Edge e, mx; Node() : ch(2, 0), pa(0), node(true), odd(true), vir(false), rev(false), e({0, 0, 0, 0}), mx({0, 0, 0, 0}) {} Node(int u, int v, int w, int id) : ch(2, 0), pa(0), node(false), odd(false), vir(false), rev(false), e({u, v, w, id}), mx({u, v, w, id}) {} }; int odd; vector\u0026lt;Node\u0026gt; t; LCT(int n, int m) { t.resize(n + 1); t[0] = Node(0, 0, 0, 0); t.reserve(n + m + 1); odd = n; } bool nroot(int x) { return x == t[t[x].pa].ch[0] || x == t[t[x].pa].ch[1]; } void pushup(int x) { t[x].mx = max(t[x].e, max(t[t[x].ch[0]].mx, t[t[x].ch[1]].mx)); t[x].odd = t[t[x].ch[0]].odd ^ t[t[x].ch[1]].odd ^ t[x].vir ^ t[x].node; } void rotate(int x) { int y = t[x].pa; int z = t[y].pa; int k = x == t[y].ch[1]; if (nroot(y)) t[z].ch[y == t[z].ch[1]] = x; t[x].pa = z; t[y].ch[k] = t[x].ch[k ^ 1]; t[t[x].ch[k ^ 1]].pa = y; t[x].ch[k ^ 1] = y; t[y].pa = x; pushup(y); pushup(x); } void reverse(int x) { swap(t[x].ch[0], t[x].ch[1]); t[x].rev ^= 1; } void pushdown(int x) { if (t[x].rev) { reverse(t[x].ch[0]); reverse(t[x].ch[1]); t[x].rev = false; } } void Splay(int x) { static vector\u0026lt;int\u0026gt; stk; // 一件玄学的事是这里 vector 1.7s, stack 2.8s... int u = x; stk.push_back(x); while (nroot(u)) stk.push_back(u = t[u].pa); while (!stk.empty()) { pushdown(stk.back()); stk.pop_back(); } while (nroot(x)) { int y = t[x].pa; int z = t[y].pa; if (nroot(y)) (x == t[y].ch[1]) ^ (y == t[z].ch[1]) ? rotate(x) : rotate(y); rotate(x); } } void access(int x) { for (int y = 0; x; x = t[y = x].pa) { Splay(x); t[x].vir ^= t[y].odd ^ t[t[x].ch[1]].odd; t[x].ch[1] = y; pushup(x); } } void makeroot(int x) { access(x); Splay(x); reverse(x); } int findroot(int x) { access(x); Splay(x); while (t[x].ch[0]) { pushdown(x); x = t[x].ch[0]; } Splay(x); return x; } void link(int x, int y, int w, int id) { int e = t.size(); t.emplace_back(x, y, w, id); makeroot(x); makeroot(y); odd -= t[x].odd + t[y].odd; t[x].pa = t[y].pa = e; t[e].vir = t[x].odd ^ t[y].odd; pushup(e); odd += t[e].odd; } void cut(int x, int y, int id) { makeroot(x); if (findroot(y) == x) { if (t[t[x].ch[1]].e.id == id || t[t[t[x].ch[1]].ch[0]].e.id == id) { odd -= t[x].odd; t[x].ch[1] = t[y].pa = t[y].ch[0] = 0; pushup(x); pushup(y); odd += t[x].odd + t[y].odd; } } } }; int main() { int n = read(); int m = read(); LCT t(n, m); priority_queue\u0026lt;Edge\u0026gt; q; int ans = INF; for (int i = 1; i \u0026lt;= m; ++i) { int u = read(); int v = read(); int w = read(); q.push({u, v, w, i}); t.makeroot(u); if (t.findroot(v) == u) { Edge e = t.t[u].mx; if (e.w \u0026gt; w) { t.cut(e.u, e.v, e.id); t.link(u, v, w, i); } else if (!t.odd) ans = min(ans, w); } else t.link(u, v, w, i); while (!t.odd) { Edge e = q.top(); q.pop(); ans = min(ans, e.w); t.cut(e.u, e.v, e.id); } printf(\u0026quot;%d\\n\u0026quot;, ans == INF ? -1 : ans); } return 0; }   分治做法 #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;cctype\u0026gt; #include \u0026lt;stack\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; int read() { int out = 0; char c; while (!isdigit(c = getchar())); for (; isdigit(c); c = getchar()) out = out * 10 + c - '0'; return out; } const int INF = 1e9 + 1; struct UFS { int odd; vector\u0026lt;int\u0026gt; f, s; struct Change { int x, y, s; }; stack\u0026lt;Change\u0026gt; c; void init(int n) { f.resize(n + 1, 0); s.resize(n + 1, 1); for (int i = 1; i \u0026lt;= n; ++i) f[i] = i; odd = n; } int find(int x) { return x == f[x] ? x : find(f[x]); } void merge(int x, int y) { x = find(x); y = find(y); if (x == y) return; if (s[x] \u0026lt; s[y]) swap(x, y); c.push({x, y, s[x]}); if ((s[x] \u0026amp; 1) \u0026amp;\u0026amp; (s[y] \u0026amp; 1)) odd -= 2; s[x] += s[y]; f[y] = x; } void rollback(int x) { while ((int)c.size() \u0026gt; x) { Change t = c.top(); c.pop(); if ((t.s \u0026amp; 1) \u0026amp;\u0026amp; (s[t.y] \u0026amp; 1)) odd += 2; s[t.x] = t.s; f[t.y] = t.y; } } int status() const { return c.size(); } } ufs; struct Edge { int u, v, w, id; bool operator\u0026lt;(const Edge \u0026amp;b) const { return w \u0026lt; b.w; } bool in(int x1, int y1, int x2, int y2) const { return id \u0026gt;= x1 \u0026amp;\u0026amp; id \u0026lt;= x2 \u0026amp;\u0026amp; w \u0026gt;= y1 \u0026amp;\u0026amp; w \u0026lt;= y2; } }; vector\u0026lt;int\u0026gt; ans; void solve(int xl, int xr, int yl, int yr, vector\u0026lt;Edge\u0026gt;\u0026amp; e) { if (xl \u0026gt; xr) return; if (yl == yr) { for (int i = xl; i \u0026lt;= xr; ++i) ans[i] = yl; return; } int ver1 = ufs.status(); int xmid = (xl + xr) \u0026gt;\u0026gt; 1; int p; for (p = 0; p \u0026lt; (int)e.size() \u0026amp;\u0026amp; e[p].w \u0026lt; yl; ++p) if (e[p].in(xl, 0, xmid, yl - 1)) ufs.merge(e[p].u, e[p].v); int ver2 = ufs.status(); for (int i = p; i \u0026lt; (int)e.size(); ++i) { if (e[i].in(0, yl, xmid, yr)) { ufs.merge(e[i].u, e[i].v); if (!ufs.odd) { ans[xmid] = e[i].w; break; } } } vector\u0026lt;Edge\u0026gt; le, re; for (auto x : e) if (x.in(0, 0, xr, ans[xmid]) \u0026amp;\u0026amp; !x.in(0, 0, xmid, yl - 1)) re.push_back(x); for (auto x : e) if (x.in(0, 0, xmid - 1, yr) \u0026amp;\u0026amp; !x.in(0, 0, xl - 1, ans[xmid] - 1)) le.push_back(x); ufs.rollback(ver2); solve(xmid + 1, xr, yl, ans[xmid], re); if (ans[xmid] \u0026lt; INF) { ufs.rollback(ver1); for (int i = p; i \u0026lt; (int)e.size(); ++i) if (e[i].in(0, yl, xl - 1, ans[xmid] - 1)) ufs.merge(e[i].u, e[i].v); solve(xl, xmid - 1, ans[xmid], yr, le); } ufs.rollback(ver1); } int main() { int n = read(); int m = read(); vector\u0026lt;Edge\u0026gt; e; for (int i = 0; i \u0026lt; m; ++i) { int u = read(); int v = read(); int w = read(); e.push_back({u, v, w, i}); } sort(e.begin(), e.end()); ans.resize(m, INF); ufs.init(n); solve(0, m - 1, 1, INF, e); for (auto x : ans) printf(\u0026quot;%d\\n\u0026quot;, x == INF ? -1 : x); return 0; }  ","date":"2020-02-18T11:45:02+08:00","permalink":"https://ouuan.github.io/post/cf603e/","tags":["结论","图论","LCT","分治","并查集"],"title":"CF603E Pastoral Oddities（结论，LCT/分治+并查集）"},{"categories":["知识点"],"contents":"整体二分是一种离线算法，可以将一个修改同时作用于多个询问，从而减少不必要的开销，将二分答案从单次询问扩展到多次询问。\n在一些题目中，相比与其它解法，整体二分可以避免复杂的数据结构，降低代码难度与空间复杂度。\n解决的问题 概述 给你多组修改与询问，其中每个修改有一个可二分的指标，每个询问有一个目标，你需要对每个询问回答：应用了指标不超过多少的所有修改后，这个询问的目标可以达到，或者应用了所有修改后该目标依然无法达到。并且，你可以在得知所有修改和询问后开始回答，即允许离线。\n形式化描述 指标集合 与 指标比较 构成了一个有限 全序集 。其中指标集合用 $\\mathbf{INDEX}$ 表示，指标比较用 $\\le$ 表示。\n贡献集合 和 贡献累加 构成了一个 交换幺半群 。其中贡献集合用 $\\mathbf{CONTRIBUTION}$ 表示，贡献累加用 $+$ 表示，也可用 $\\Sigma$ 表示多个贡献累加。\n一个 修改 $m$ 具有 指标 $m.index$ 和 贡献 $m.contribution$ 两个属性，其中指标属于指标集合，贡献属于贡献集合。\n一个 询问 $q$ 包含一个 目标函数 $q.f:\\mathbf{CONTRIBUTION}\\to\\{0, 1\\}$（输入是一个贡献，输出是 $0$ 或 $1$），满足 $\\forall x, y\\in\\mathbf{CONTRIBUTION}, q.f(x)=1\\implies q.f(x+y)=1$（这条性质保证了可二分性）。\n那么，一个可以被整体二分解决的问题可以表述如下：\n题目描述\n 给定修改集合 $M$ 和询问集合 $Q$， 对于每个 $q\\in Q$，求出最小的 $x\\in\\mathbf{INDEX}$ 使得 $q.f(\\sum_{m\\in M}[m.index\\le x]m.contribution)=1$，或指出这样的 $x$ 不存在。（其中 $[m.index\\le x]$ 是 艾弗森括号 。）   对传统二分的分析 如果询问只有一个，使用 二分答案 即可求解。\n如果对每次询问单独使用二分答案，效率将十分低下，究其原因，在于“计算修改对询问的贡献”这一步有大量重复的操作，冗余的计算没有得到有效的合并。\n因此，整体二分的优化重点就在于“将多个操作同时作用于多个询问”。\n算法框架 概述  递归地处理指标/答案在一个区间内的修改和询问。 每次计算出左半的修改对所有询问的贡献。 依次判断每个询问在加上来自左半修改的贡献后是否满足了要求。 按修改的指标，询问是否在加上来自左半修改的贡献后满足了要求，将修改和询问划分成两半，继续递归下去。 递归在指标区间大小为 $1$ 时终止。  伪代码 1 这份伪代码中对每个询问维护一个 $q.current$ 属性，表示这个询问已经加上了多少贡献（在实际代码实现中 $q.current$ 往往不必和“贡献”是同一类型的，如“贡献”可能用一个数据结构维护，而“满足了多少”可以简单地用一个数表示）。\n$$ \\begin{array}{rl} 1\u0026amp;\\textbf{function}\\text{ PARALLEL_BINARY_SEARCH}(l, r, M, Q)\\\\\n2\u0026amp;\\qquad\\textbf{if }Q=\\varnothing\\\\\n3\u0026amp;\\qquad\\qquad\\textbf{return}\\\\\n4\u0026amp;\\qquad \\textbf{if }l=r\\\\\n5\u0026amp;\\qquad\\qquad \\text{The answer of all queries in }Q\\text{ is }l\\\\\n6\u0026amp;\\qquad\\qquad \\textbf{return}\\\\\n7\u0026amp;\\qquad mid\\gets \\text{middle of }l\\text{ and }r\\\\\n8\u0026amp;\\qquad \\mathrm{LM}\\gets\\varnothing\\\\\n9\u0026amp;\\qquad \\mathrm{RM}\\gets\\varnothing\\\\\n10\u0026amp;\\qquad sum\\gets(\\mathbf{CONTRIBUTION}, +)\\text{ 的单位元}\\\\\n11\u0026amp;\\qquad \\textbf{for each }m\\in M\\\\\n12\u0026amp;\\qquad\\qquad \\textbf{if }m.index\\le mid\\\\\n13\u0026amp;\\qquad\\qquad\\qquad sum\\gets sum+m.contribution\\\\\n14\u0026amp;\\qquad\\qquad\\qquad \\mathrm{LM}\\gets \\mathrm{LM}\\bigcup\\{m\\}\\\\\n15\u0026amp;\\qquad\\qquad \\textbf{else}\\\\\n16\u0026amp;\\qquad\\qquad\\qquad \\mathrm{RM}\\gets \\mathrm{RM}\\bigcup\\{m\\}\\\\\n17\u0026amp;\\qquad \\mathrm{LQ}\\gets\\varnothing\\\\\n18\u0026amp;\\qquad \\mathrm{RQ}\\gets\\varnothing\\\\\n19\u0026amp;\\qquad \\textbf{for each }q\\in Q\\\\\n20\u0026amp;\\qquad\\qquad \\textbf{if }q.f(q.current+sum)=1\\\\\n21\u0026amp;\\qquad\\qquad\\qquad \\mathrm{LQ}\\gets \\mathrm{LQ}\\bigcup \\{q\\}\\\\\n22\u0026amp;\\qquad\\qquad \\textbf{else}\\\\\n23\u0026amp;\\qquad\\qquad\\qquad q.current\\gets q.current+sum\\\\\n24\u0026amp;\\qquad\\qquad\\qquad \\mathrm{RQ}\\gets \\mathrm{RQ}\\bigcup \\{q\\}\\\\\n25\u0026amp;\\qquad \\text{PARALLEL_BINARY_SEARCH}(l, mid, \\mathrm{LM}, \\mathrm{LQ})\\\\\n26\u0026amp;\\qquad \\text{PARALLEL_BINARY_SEARCH}(mid\\text{ 的后继}, r, \\mathrm{RM}, \\mathrm{RQ})\\\\\n27\u0026amp;\\\\\n28\u0026amp;\\textbf{function}\\text{ SOLVE(M, Q)}\\\\\n29\u0026amp;\\qquad \\textbf{for each }q\\in Q\\\\\n30\u0026amp;\\qquad\\qquad q.current\\gets(\\mathbf{CONTRIBUTION}, +)\\text{ 的单位元}\\\\\n31\u0026amp;\\qquad \\text{PARALLEL_BINARY_SEARCH}(\\min\\{\\mathbf{INDEX}\\}, \\max\\{\\mathbf{INDEX}\\}, M, Q) \\end{array} $$\n伪代码 2 这份伪代码维护了一个全局的贡献，每次加上左半修改的贡献后，先递归解决右半部分，然后将这些修改回退，再去解决左半部分。\n$$ \\begin{array}{rl} 1\u0026amp;current\\gets(\\mathbf{CONTRIBUTION}, +)\\text{ 的单位元}\\\\\n2\u0026amp;\\\\\n3\u0026amp;\\textbf{function}\\text{ PARALLEL_BINARY_SEARCH}(l, r, M, Q)\\\\\n4\u0026amp;\\qquad\\textbf{if }Q=\\varnothing\\\\\n5\u0026amp;\\qquad\\qquad\\textbf{return}\\\\\n6\u0026amp;\\qquad \\textbf{if }l=r\\\\\n7\u0026amp;\\qquad\\qquad \\text{The answer of all queries in }Q\\text{ is }l\\\\\n8\u0026amp;\\qquad\\qquad \\textbf{return}\\\\\n9\u0026amp;\\qquad mid\\gets \\text{middle of }l\\text{ and }r\\\\\n10\u0026amp;\\qquad \\mathrm{LM}\\gets\\varnothing\\\\\n11\u0026amp;\\qquad \\mathrm{RM}\\gets\\varnothing\\\\\n12\u0026amp;\\qquad old\\gets current\\\\\n13\u0026amp;\\qquad \\textbf{for each }m\\in M\\\\\n14\u0026amp;\\qquad\\qquad \\textbf{if }m.index\\le mid\\\\\n15\u0026amp;\\qquad\\qquad\\qquad current\\gets current+m.contribution\\\\\n16\u0026amp;\\qquad\\qquad\\qquad \\mathrm{LM}\\gets \\mathrm{LM}\\bigcup\\{m\\}\\\\\n17\u0026amp;\\qquad\\qquad \\textbf{else}\\\\\n18\u0026amp;\\qquad\\qquad\\qquad \\mathrm{RM}\\gets \\mathrm{RM}\\bigcup\\{m\\}\\\\\n19\u0026amp;\\qquad \\mathrm{LQ}\\gets\\varnothing\\\\\n20\u0026amp;\\qquad \\mathrm{RQ}\\gets\\varnothing\\\\\n21\u0026amp;\\qquad \\textbf{for each }q\\in Q\\\\\n22\u0026amp;\\qquad\\qquad \\textbf{if }q.f(current)=1\\\\\n23\u0026amp;\\qquad\\qquad\\qquad \\mathrm{LQ}\\gets \\mathrm{LQ}\\bigcup \\{q\\}\\\\\n24\u0026amp;\\qquad\\qquad \\textbf{else}\\\\\n25\u0026amp;\\qquad\\qquad\\qquad \\mathrm{RQ}\\gets \\mathrm{RQ}\\bigcup \\{q\\}\\\\\n26\u0026amp;\\qquad \\text{PARALLEL_BINARY_SEARCH}(mid\\text{ 的后继}, r, \\mathrm{RM}, \\mathrm{RQ})\\\\\n27\u0026amp;\\qquad current\\gets old\\\\\n28\u0026amp;\\qquad \\text{PARALLEL_BINARY_SEARCH}(l, mid, \\mathrm{LM}, \\mathrm{LQ})\\\\\n29\u0026amp;\\\\\n30\u0026amp;\\textbf{function}\\text{ SOLVE(M, Q)}\\\\\n31\u0026amp;\\qquad \\text{PARALLEL_BINARY_SEARCH}(\\min\\{\\mathbf{INDEX}\\}, \\max\\{\\mathbf{INDEX}\\}, M, Q) \\end{array} $$\n算法分析 整体二分算法的核心在于：\n 整体地计算多个修改对多个询问的贡献。 伪代码 1 的 23 行处 / 伪代码 2 的先处理右半部分再回退左半修改，将左半修改对右半询问的贡献应用到整个处理右半部分的过程中，之后不再重复计算。  令计算两个贡献之和的时间复杂度为 $O(f(\\cdots))$，判定一个贡献是否达到一个询问的目标的时间复杂度为 $O(g(\\cdots))$，那么总的时间复杂度为:（\u0026ldquo;$\\cdots$\u0026rdquo; 表示会对复杂度造成影响的各种因素）\n$$O(((|M|+|Q|)\\cdot f(\\cdots)+|Q|\\cdot g(\\cdots))\\cdot\\log|\\mathbf{INDEX}|)$$\n为什么两侧操作个数分布不均而复杂度依然正确？ 虽然操作划分到两侧后可能一侧操作多另一侧操作少，但指标的分布是均匀的，从而保证了分治的层数是 $O(\\log|\\mathbf{INDEX}|)$，而每一层的操作总数是固定的，总的复杂度就是正确的。\n warning\n这里的时间复杂度没有计算预处理的时间复杂度，也就是说，一般情况下，在整体二分的函数中，除继续递归下去的部分，复杂度应该是当前的修改数加上操作数，可能再乘上若干个 log。而复杂度与总操作个数/值域大小多项式相关的步骤（如，初始化数据结构）应该在主函数中完成，在二分过程中，如果需要清空数据结构，应该使用一些快速的清空方法，如将之前的操作回退、使用时间戳清空等。\n 例题 上面给出的是算法抽象的框架，实际代码中，不需要真的将“贡献”对象化，而应该采用高效的方式（数据结构）去计算修改对询问的贡献。\n（注：下面的例题往往可以通过可持久化数据结构、数据结构嵌套来在线地处理，这里只介绍整体二分的解法。）\n静态区间第 k 小 题目描述\n给你一个长为 $n$ 的数列 $a_1, a_2, \\ldots, a_n$ 以及 $m$ 组询问，每次询问一个区间 $[l, r]$，求 ${a_l, a_{l+1}, \\ldots, a_r}$ 中第 $k$ 小的数。\n 在这个问题中，套用上面的形式化定义，我们可以这样看待：\n 贡献：一个长为 $n$ 的数组，每个位置上的数为 $1$ 表示这个位置“符合要求”（小于等于某个数），否则表示这个位置“不符合要求”。 指标：一个数的值。 修改：一个修改代表着数组上一个位置的值，如，$a_2=7$ 对应着这样的一个修改：贡献是将下标 $2$ 加一，指标是 $7$。 询问的目标：贡献的 $[l, r]$ 之和不小于 $k$ 。  通过整体二分，我们可以将问题转化成：单点加、区间求和，所有单点加都在区间求和之前，允许离线，要求复杂度与当前操作数相关而非与总操作数 $n$, $m$ 相关。\n一个容易想到的做法是使用树状数组来维护，使用时间戳清空。\n怎样使用时间戳清空数组？ 维护一个时间戳 tim 以及一个数组 vis，清空时 ++tim，访问数组的下标 i 前检查 vis[i] 是否等于 tim，若否就将 vis[i] 设为 tim 并清空 vis[i] 。\n 其实，这里还有一个额外的性质：所有修改均在询问前。这样的话，就可以通过计算前缀和来求解。但先计算前缀和再查询复杂度会和 $n$ 相关，先离散化再计算前缀和复杂度会多一个 log。其实还有一种处理方法：如果修改和询问的位置有序，可以在扫一遍的过程中维护前缀和并查询。如果每次都排序的话复杂度会多一个 log，但我们可以只在主函数中进行一遍排序，在整体二分的过程中保持相对顺序不变，这样的话总复杂度就是 $O((n+m)\\log n)$（如果值域大可以离散化）。\n参考代码 #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; struct Operation { int x, id, type; Operation(int _x, int _id = -1, int _type = 0) : x(_x), id(_id), type(_type) {} }; vector\u0026lt;int\u0026gt; ans, cur, tmp; #define mid ((l + r) \u0026gt;\u0026gt; 1) void solve(int l, int r, vector\u0026lt;Operation\u0026gt; \u0026amp;ops) // 这里 l 和 r 表示左闭右开区间 [l, r) { if (l == r - 1) { for (auto op : ops) { if (op.type) ans[op.id] = l; } return; } int sum = 0; for (auto op : ops) { if (op.type) tmp[op.id] += sum * op.type; // 使用 tmp 记录一个询问受到的贡献总和 else if (op.x \u0026lt; mid) ++sum; } vector\u0026lt;Operation\u0026gt; lop, rop; for (auto op : ops) { if (op.type) { if (cur[op.id] + tmp[op.id] \u0026gt;= op.x) lop.push_back(op); else { if (op.type == 1) cur[op.id] += tmp[op.id]; // 在被拆成两个的询问中的后一个处更新 current rop.push_back(op); } if (op.type == 1) tmp[op.id] = 0; // 在被拆成两个的询问中的后一个处清空 tmp } else // 由于这里操作之间的顺序是重要的，修改和询问要按原序划分到左右两边，而不能先划分修改再划分询问 { if (op.x \u0026lt; mid) lop.push_back(op); else rop.push_back(op); } } vector\u0026lt;Operation\u0026gt;().swap(ops); // 释放空间，否则空间复杂度带 log solve(l, mid, lop); solve(mid, r, rop); } int main() { int n, m; scanf(\u0026quot;%d%d\u0026quot;, \u0026amp;n, \u0026amp;m); vector\u0026lt;int\u0026gt; a(n), lsh(n); for (int i = 0; i \u0026lt; n; ++i) { scanf(\u0026quot;%d\u0026quot;, \u0026amp;a[i]); lsh[i] = a[i]; } sort(lsh.begin(), lsh.end()); lsh.resize(unique(lsh.begin(), lsh.end()) - lsh.begin()); // 离散化 vector\u0026lt;vector\u0026lt;Operation\u0026gt; \u0026gt; bucket(n); // 桶排序 for (int i = 0; i \u0026lt; n; ++i) bucket[i].emplace_back(lower_bound(lsh.begin(), lsh.end(), a[i]) - lsh.begin()); for (int i = 0; i \u0026lt; m; ++i) { int l, r, x; scanf(\u0026quot;%d%d%d\u0026quot;, \u0026amp;l, \u0026amp;r, \u0026amp;x); if (l \u0026gt; 1) bucket[l - 2].emplace_back(x, i, -1); bucket[r - 1].emplace_back(x, i, 1); } vector\u0026lt;Operation\u0026gt; ops; for (auto i : bucket) { for (auto j : i) { ops.push_back(j); } } ans.resize(m, 0); cur = tmp = ans; solve(0, lsh.size(), ops); for (auto x : ans) printf(\u0026quot;%d\\n\u0026quot;, lsh[x]); return 0; }   「ZJOI2013」K大数查询 题目描述\n给你一个由 $n$ 个初始为空的可重集构成的序列，需要支持两种操作：\n 向一段区间 $[l, r]$ 内的每一个可重集内加入一个数 $c$ 。 查询一段区间 $[l, r]$ 内的所有可重集并起来（不去重）后第 $c$ 大的数。   经过整体二分后问题转化为：区间加，区间求和，要求复杂度与当前操作数相关。\n这次没有修改在询问之前的性质，所以没什么可优化的地方，复杂度与当前操作数相关有很多种方式：\n 动态开点线段树。 离散化+线段树。 树状数组+时间戳清空。  参考代码 #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; typedef long long ll; struct Operation { int l, r, id; ll target, current, tmp; Operation(int _l, int _r, int _id, ll _target) : l(_l), r(_r), id(_id), target(_target), current(0) {} }; struct BIT { int tim; vector\u0026lt;ll\u0026gt; a; vector\u0026lt;int\u0026gt; vis; BIT() : tim(0) {} void resize(int size) { a.resize(size + 1, 0); vis.resize(size + 1, 0); } void modify(int p, int x) { for (; p \u0026lt; (int)a.size(); p += (p \u0026amp; -p)) { if (vis[p] != tim) { vis[p] = tim; a[p] = 0; } a[p] += x; } } ll query(int p) { ll out = 0; for (; p; p -= (p \u0026amp; -p)) { if (vis[p] == tim) out += a[p]; } return out; } void clear() { ++tim; } } bitk, bitb; void modify(int p, int x) { bitk.modify(p, x); bitb.modify(p, (1 - p) * x); } ll query(int p) { return bitk.query(p) * p + bitb.query(p); } void clear() { bitk.clear(); bitb.clear(); } vector\u0026lt;int\u0026gt; ans; #define mid ((l + r) \u0026gt;\u0026gt; 1) void solve(int l, int r, vector\u0026lt;Operation\u0026gt; \u0026amp;ops) { if (l == r - 1) { for (auto op : ops) { if (~op.id) ans[op.id] = l; } return; } clear(); for (auto \u0026amp;op : ops) { if (~op.id) op.tmp = query(op.r) - query(op.l - 1); else if (op.target \u0026lt; mid) { modify(op.l, 1); modify(op.r + 1, -1); } } vector\u0026lt;Operation\u0026gt; lop, rop; for (auto op : ops) { if (op.id == -1) { if (op.target \u0026lt; mid) lop.push_back(op); else rop.push_back(op); } else { if (op.current + op.tmp \u0026gt;= op.target) lop.push_back(op); else { op.current += op.tmp; rop.push_back(op); } } } vector\u0026lt;Operation\u0026gt;().swap(ops); solve(l, mid, lop); solve(mid, r, rop); } int main() { int n, m; scanf(\u0026quot;%d%d\u0026quot;, \u0026amp;n, \u0026amp;m); int qid = 0; vector\u0026lt;Operation\u0026gt; ops; for (int i = 0; i \u0026lt; m; ++i) { int op, l, r; ll x; scanf(\u0026quot;%d%d%d%lld\u0026quot;, \u0026amp;op, \u0026amp;l, \u0026amp;r, \u0026amp;x); if (op == 1) ops.emplace_back(l, r, -1, -x); // 取负将第 k 大转化为第 k 小 else ops.emplace_back(l, r, qid++, x); } ans.resize(qid); bitk.resize(n); bitb.resize(n); solve(-n, n + 1, ops); for (auto x : ans) printf(\u0026quot;%d\\n\u0026quot;, -x); return 0; }   练习  「POI2011」Meteors 矩阵乘法 「HNOI2016」网络 ","date":"2020-02-14T14:50:32+08:00","permalink":"https://ouuan.github.io/post/parallel-binary-search/","tags":["整体二分","离线算法","分治"],"title":"整体二分学习笔记"},{"categories":null,"contents":"","date":"2020-02-07T17:43:21+08:00","permalink":"https://ouuan.github.io/search/","tags":null,"title":"搜索"},{"categories":null,"contents":"友情链接  EternalAlexander ustze xht37 PinkRabbit lk Sooke wxw memset0 AprilGrimoire zbw StudyingFather  一些网站  图床 几何 图论 函数 数列 在线汇编编译器 C++ LaTeX 公式大全 LaTeX 公式奆全 .tex 教程 OI Wiki Wolfram Alpha OIerDb OI 中转站 线稿上色 手绘线条  ","date":"2020-02-06T22:53:11+08:00","permalink":"https://ouuan.github.io/links/","tags":null,"title":"链接"},{"categories":["题解"],"contents":"题目链接 LOJ\n洛谷\n题意简述 给你一张带边权的无向图，边权都形如 $2^a3^b$ ，若干询问，每次问是否存在 $u$ 到 $v$ 且边权的最小公倍数为 $2^a3^b$ 的途径（可以不是简单路径）。\n点数 $5\\cdot 10^4$，边数 $10^5$，询问数 $5\\cdot 10^4$ 。\n简要做法 首先转化问题：仅保留图中 $2$ 的指数不超过 $a$ 且 $3$ 的指数不超过 $b$ 的边，是否满足“$u$ 和 $v$ 连通，且连通块内 $2$ 的最高指数为 $a$，$3$ 的最高指数为 $b$”？\n发现 $a$ 和 $b$ 在增大/减小时会导致边加入图中/从图中删去，这和莫队的左右指针很像。事实上这题的确可以看作一种长得比较奇怪的莫队。\n具体来说，维护 $a$ 指针和 $b$ 指针，由于每条边要么先被 $a$ 指针扫到，要么先被 $b$ 指针扫到，增大其中一个指针时判一下是否满足另一个指针的要求，若满足则加入图中即可。\n由于删边不好维护，可以使用类似 回滚莫队 的方法处理，但由于本题的特殊性，不存在“左右端点在同一块的暴力计算”这种情况。\n具体实现可以参考代码（\n坑 形如 u u 0 0 的询问若不存在 $(u, v)$ 的边权为 $1$ 则答案为 No，所以连通块内 $2$ 和 $3$ 指数的初值要赋为 $-1$ 。\n个人觉得 u u 0 0 答案不为 Yes 很蠢..\n参考代码 #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;cmath\u0026gt; #include \u0026lt;stack\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; int B; struct Edge { int u, v, a, b; Edge(int _a = 0, int _b = 0): a(_a), b(_b) {} }; vector\u0026lt;Edge\u0026gt; a, b; struct Query { int u, v, a, b, ra, rb, id; Query(int _u, int _v, int _a, int _b, int _ra, int _rb, int _id): u(_u), v(_v), a(_a), b(_b), ra(_ra), rb(_rb), id(_id) {} bool operator\u0026lt;(const Query\u0026amp; y) const { return b \u0026lt; y.b; } }; vector\u0026lt;vector\u0026lt;Query\u0026gt; \u0026gt; q; int n, m, k, qa, qb; vector\u0026lt;bool\u0026gt; ans; struct UnionFindSet { int tim; vector\u0026lt;int\u0026gt; f, siz, two, three; struct Change { int x, y, x2, x3; Change(int _x, int _y, int _x2, int _x3): x(_x), y(_y), x2(_x2), x3(_x3) {} }; stack\u0026lt;Change\u0026gt; c; int find(int x) { return x == f[x] ? x : find(f[x]); } void merge(int x, int y, int tw, int th) { x = find(x); y = find(y); if (x == y) { c.emplace(x, -1, two[x], three[x]); two[x] = max(two[x], tw); three[x] = max(three[x], th); return; } if (siz[x] \u0026lt; siz[y]) swap(x, y); c.emplace(x, y, two[x], three[x]); siz[x] += siz[y]; f[y] = x; two[x] = max(tw, max(two[x], two[y])); three[x] = max(th, max(three[x], three[y])); } void record() { tim = c.size(); } void rollback() { while (c.size() \u0026gt; tim) { auto t = c.top(); c.pop(); if (~t.y) { f[t.y] = t.y; siz[t.x] -= siz[t.y]; two[t.x] = t.x2; three[t.x] = t.x3; } else { two[t.x] = t.x2; three[t.x] = t.x3; } } } void reset() { f.resize(n + 1); siz.assign(n + 1, 1); two.assign(n + 1, -1); three = two; for (int i = 1; i \u0026lt;= n; ++i) f[i] = i; tim = 0; while (!c.empty()) c.pop(); } void check(Query t) { int u = find(t.u); int v = find(t.v); ans[t.id] = u == v \u0026amp;\u0026amp; two[u] == t.ra \u0026amp;\u0026amp; three[u] == t.rb; } } ufs; bool cmpa(const Edge\u0026amp; x, const Edge\u0026amp; y) { return x.a \u0026lt; y.a; } bool cmpb(const Edge\u0026amp; x, const Edge\u0026amp; y) { return x.b \u0026lt; y.b; } void adda(int x) { if (~qb \u0026amp;\u0026amp; a[x].b \u0026lt;= b[qb].b) { ufs.merge(a[x].u, a[x].v, a[x].a, a[x].b); } } void addb(int x) { if (~qa \u0026amp;\u0026amp; b[x].a \u0026lt;= a[qa].a) { ufs.merge(b[x].u, b[x].v, b[x].a, b[x].b); } } int main() { scanf(\u0026quot;%d%d\u0026quot;, \u0026amp;n, \u0026amp;m); a.resize(m); for (int i = 0; i \u0026lt; m; ++i) scanf(\u0026quot;%d%d%d%d\u0026quot;, \u0026amp;a[i].u, \u0026amp;a[i].v, \u0026amp;a[i].a, \u0026amp;a[i].b); b = a; sort(a.begin(), a.end(), cmpa); sort(b.begin(), b.end(), cmpb); scanf(\u0026quot;%d\u0026quot;, \u0026amp;k); B = m / sqrt(k) + 1; q.resize(m / B + 1); ans.resize(k); for (int i = 0; i \u0026lt; k; ++i) { int u, v, ra, rb; scanf(\u0026quot;%d%d%d%d\u0026quot;, \u0026amp;u, \u0026amp;v, \u0026amp;ra, \u0026amp;rb); int aa = upper_bound(a.begin(), a.end(), Edge(ra, rb), cmpa) - a.begin() - 1; int bb = upper_bound(b.begin(), b.end(), Edge(ra, rb), cmpb) - b.begin() - 1; if (~aa \u0026amp;\u0026amp; ~bb) q[aa / B].emplace_back(u, v, aa, bb, ra, rb, i); else ans[i] = false; } for (int i = 0; i \u0026lt; q.size(); ++i) { sort(q[i].begin(), q[i].end()); ufs.reset(); qb = -1; qa = i * B; for (auto t : q[i]) { while (qb \u0026lt; t.b) addb(++qb); ufs.record(); while (qa \u0026lt; t.a) adda(++qa); ufs.check(t); ufs.rollback(); qa = i * B; } } for (auto x : ans) puts(x ? \u0026quot;Yes\u0026quot; : \u0026quot;No\u0026quot;); return 0; } ","date":"2020-01-08T14:49:06+08:00","permalink":"https://ouuan.github.io/post/hnoi2016%E6%9C%80%E5%B0%8F%E5%85%AC%E5%80%8D%E6%95%B0%E5%9B%9E%E6%BB%9A%E8%8E%AB%E9%98%9F%E5%B9%B6%E6%9F%A5%E9%9B%86/","tags":["莫队","并查集"],"title":"「HNOI2016」最小公倍数（回滚莫队，并查集）"},{"categories":["题解"],"contents":"题目链接 UOJ\nLOJ\n洛谷\n题意简述 给你一个字符串 $S$，有 $q$ 次询问，每次给你询问串 $T$ 以及左右端点 $l$, $r$，询问 $T$ 有多少个 本质不同 的子串 不是 $S[l..r]$ 的子串。\n$|S|\\le 5\\cdot 10^5$, $\\sum|T|\\le 10^6$, $q\\le 10^5$ 。\n简要做法 不需要本质不同、l=1、r=|S| 枚举 $T$ 的前缀，找到这个前缀的最长后缀使其是 $S$ 的子串，就可以求出答案了。\n换句话说，对于每个 $i$，求出最小的 $j$ ($1\\le j\\le i+1$) 使得 $T[j..i]$ 是 $S$ 的子串，那么 $\\sum j-1$ 就是答案。\n可以对 $S$ 建 SAM，维护一个指针指向 $T[j..i]$ 在 SAM 上对应的顶点，如果拓展一个字符后不是 $S$ 的子串就把 $j$ 加一，如果低于当前 SAM 上节点的长度限制就跳 parent 边，也就是 从首部删去字符 。\n需要本质不同、l=1、r=|S| 由本质不同可以想到用 SAM 去重。具体来说，对 $T$ 建 SAM，对每个 $T[j..i]$ 在 SAM 上打个标记，表示 $T[j..i]$ 及其所有后缀（即对应顶点及其在 parent 树上的祖先）都是 $S$ 的子串，最后 DFS 一遍即可求出答案。\n原问题 如果询问的不是整个 $S$ 而是其一个子串，关键在于如何判断 $T[j..i]$ 是不是 $S[l..r]$ 的子串。\n可以使用线段树合并维护 $S$ 的 SAM 上的每个点的 right 集合，$T[j..i]$ 是 $S[l..r]$ 的子串等价于 $T[j..i]$ 在 $S$ 中的 right 集合含有某个区间内的元素，区间求和即可查询。\n还有一个细节，在 $T$ 的 SAM 上打标记时，可能出现 SAM 上的一个节点对应的较短的那些串是 $S[l..r]$ 的子串，但较长的串不是。所以标记还需要记录不是 $S[l..r]$ 子串所需的长度。\n参考代码 #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; typedef long long ll; struct SAM { struct Node { int len, pa, tag; vector\u0026lt;int\u0026gt; ch; Node(int _len = 0, int _pa = -1, vector\u0026lt;int\u0026gt; _ch = vector\u0026lt;int\u0026gt;(26, 0)): len(_len), pa(_pa), tag(0), ch(_ch) {} }; vector\u0026lt;Node\u0026gt; t; int p; vector\u0026lt;int\u0026gt; endp; vector\u0026lt;vector\u0026lt;int\u0026gt; \u0026gt; g; void extend(int x) { int np = t.size(); t.emplace_back(t[p].len + 1); while (~p \u0026amp;\u0026amp; !t[p].ch[x]) { t[p].ch[x] = np; p = t[p].pa; } if (p == -1) t[np].pa = 0; else { int q = t[p].ch[x]; if (t[q].len == t[p].len + 1) t[np].pa = q; else { int nq = t.size(); t.emplace_back(t[p].len + 1, t[q].pa, t[q].ch); t[q].pa = t[np].pa = nq; while (~p \u0026amp;\u0026amp; t[p].ch[x] == q) { t[p].ch[x] = nq; p = t[p].pa; } } } p = np; } SAM(const string\u0026amp; s): t(1), p(0) { t.reserve(s.size() * 2); endp.resize(s.size()); for (int i = 0; i \u0026lt; s.size(); ++i) { extend(s[i] - 'a'); endp[i] = p; } g.resize(t.size()); for (int i = 1; i \u0026lt; t.size(); ++i) g[t[i].pa].push_back(i); } ll dfs(int u = 0) { ll out = 0; for (auto v : g[u]) { if (!v) continue; out += dfs(v); t[u].tag = max(t[u].tag, t[v].tag); } if (u) out += max(0, t[u].len - max(t[u].tag, t[t[u].pa].len)); return out; } }; struct SegmentTree { #define mid ((l + r) \u0026gt;\u0026gt; 1) struct Node { int sum, ls, rs; Node(int _sum = 0, int _ls = 0, int _rs = 0): sum(_sum), ls(_ls), rs(_rs) {} }; vector\u0026lt;Node\u0026gt; t; int add(int x, int p, int l, int r) { int cur = t.size(); t.push_back(t[x]); ++t[cur].sum; if (l == r - 1) return cur; if (p \u0026lt; mid) t[cur].ls = add(t[x].ls, p, l, mid); else t[cur].rs = add(t[x].rs, p, mid, r); return cur; } int merge(int x, int y) { if (!x || !y) return x | y; t.emplace_back(t[x].sum + t[y].sum, merge(t[x].ls, t[y].ls), merge(t[x].rs, t[y].rs)); return t.size() - 1; } int query(int x, int L, int R, int l, int r) { if (L \u0026gt;= r || R \u0026lt;= l) return 0; if (L \u0026lt;= l \u0026amp;\u0026amp; r \u0026lt;= R) return t[x].sum; return query(t[x].ls, L, R, l, mid) + query(t[x].rs, L, R, mid, r); } #undef mid } seg; vector\u0026lt;int\u0026gt; rt; void dfs(const vector\u0026lt;vector\u0026lt;int\u0026gt; \u0026gt;\u0026amp; g, int u = 0) { for (auto v : g[u]) { dfs(g, v); rt[u] = seg.merge(rt[u], rt[v]); } } int main() { ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0); string s; cin \u0026gt;\u0026gt; s; SAM sams(s); seg.t.resize(1); seg.t.reserve(s.size() \u0026lt;\u0026lt; 5); rt.resize(sams.t.size(), 0); for (int i = 0; i \u0026lt; s.size(); ++i) rt[sams.endp[i]] = seg.add(rt[sams.endp[i]], i, 0, s.size()); dfs(sams.g); int q; cin \u0026gt;\u0026gt; q; while (q--) { int l, r; string t; cin \u0026gt;\u0026gt; t \u0026gt;\u0026gt; l \u0026gt;\u0026gt; r; SAM samt(t); for (int i = 0, u = 0, v = 0, p = 0; i \u0026lt; t.size(); ++i) { while (p \u0026lt; i \u0026amp;\u0026amp; !sams.t[u].ch[t[i] - 'a']) { ++p; if (u \u0026amp;\u0026amp; i - p \u0026lt;= sams.t[sams.t[u].pa].len) u = sams.t[u].pa; if (v \u0026amp;\u0026amp; i - p \u0026lt;= samt.t[samt.t[v].pa].len) v = samt.t[v].pa; } if (!sams.t[u].ch[t[i] - 'a']) { p = i + 1; u = v = 0; continue; } u = sams.t[u].ch[t[i] - 'a']; v = samt.t[v].ch[t[i] - 'a']; while (p \u0026lt;= i \u0026amp;\u0026amp; seg.query(rt[u], l + i - p - 1, r, 0, s.size()) == 0) { ++p; if (u \u0026amp;\u0026amp; i - p + 1 \u0026lt;= sams.t[sams.t[u].pa].len) u = sams.t[u].pa; if (v \u0026amp;\u0026amp; i - p + 1 \u0026lt;= samt.t[samt.t[v].pa].len) v = samt.t[v].pa; } samt.t[v].tag = max(samt.t[v].tag, i - p + 1); } cout \u0026lt;\u0026lt; samt.dfs() \u0026lt;\u0026lt; '\\n'; } return 0; } ","date":"2020-01-07T18:33:42+08:00","permalink":"https://ouuan.github.io/post/noi2018%E4%BD%A0%E7%9A%84%E5%90%8D%E5%AD%97sam%E7%BA%BF%E6%AE%B5%E6%A0%91%E5%90%88%E5%B9%B6/","tags":["SAM","线段树合并","字符串","数据结构"],"title":"「NOI2018」你的名字（SAM，线段树合并）"},{"categories":["游记"],"contents":"非常荣幸能够参加这场跨度 300+ 天的比赛。\n上接 2019THUWC/WC冬眠记 。\nDay 333 收到通知比赛环境的邮件。\n今年环境怎么啥额外软件都没有（没有 GIMP 也没有 WireShark 什么的）。也没看到题型/赛制说明什么的..没法押 Day2+ 了 T_T\n上午把前一天晚上（其实是当天凌晨）海子姐（@七海Nana7mi）的相簿分享会补了（幸好没顶着强行看直播，不然人没了.png）。\n下午和晚上把远古巨坑填了：chen_zhe的号哭 。\n全部做好之后渲染，2min 后电脑卡了..重启之后重新渲染，这个时候海子姐已经开播了（\n因为电脑在渲染，所以就只能一边用手机看直播一边渲染（\n最后在显示还剩 2min 渲染完毕的时候又卡住了..正当我长按关机键还不到 10s 时，电脑突然活过来了..赶紧松开关机键，差点人没了。\n然后就一边看直播一边传视频，成功掉进海子姐发 8 给 9 投票的陷阱..还第一次被海子姐读弹幕了（在大家投票时发了一句“第一步下角第二步必须下 5”，然后大家投的 9，最后还平了..）。\n总结：因为 SC 考了 WireShark，所以来看鲨鱼直播准备 Day2+。\nDay 334 一天大部分时间（？其实算一算并没有）都在高铁上。\n大概是 BEASTARS + 海子姐录播 + 三狮漫画。\n高铁还是一如既往的吵，一直戴着耳机，到了北京之后人都晕了。\n然后晚上不是去宾馆，而是住一个亲戚家。\n由于亲戚家孩子刚开始时在旁边看着，于是就佯装看自己博客里的题解。之后就顺势看下去了..赛前看看自己写的题解或许的确不错..\n说起来，不到 18 点的时候路过天津，20:39 收到天津文旅局短信是什么操作（\nDay 335 赛前 自然醒好评（\n试机 10 点多才去，T1 照例 A+B，T2 是之前看游记见到过的 THUWC2018 签到题，然而一开始想了个假做法，半个多小时才过掉..过掉的时候大家都跑路了，所以我也没去看剩下两题，但记得题目名，回来一查果然是 THUWC2018 的另外两题。\n开营式比 SC 短了接近 1h，所以比赛没咕，好评（\n简要题意 T1 给你 $n$ 个在长为 $k$ 的数列 $a_1,a_2,\\ldots,a_n$ 上进行的操作，第 $i$ 个操作形如 “$p(i)$, $b(i)_1, b(i)_2, \\ldots, b(i)_k$”，表示“若 $a_{p_i}\u0026lt; b(i)_{p_i}$，则将 $a$ 修改为 $b(i)$”。再给你 $m$ 个初始序列 $a$，求依次进行这 $n$ 个操作后会得到什么数列。\n$1\\le n, m\\le 10^5$ , $1\\le k\\le 20$ ，时限 $\\mathtt{3s}$。\nT2 给你一张带非负边权的有向图，你需要在上面移动棋子。棋子的移动规则：选择 权值 非零的出边中 编号 最小的一条移动，然后将这条边的 权值 减一。每次操作会给你棋子的初始位置以及移动步数上限，棋子会在无法移动或移动步数达到上限时停止移动，你需要求出每次操作的棋子停下来的位置。前面的操作会对后面的操作产生影响。\n点数、询问数 $10^5$ ，边数 $1.5\\cdot 10^5$ ，时限 $\\mathtt{8s}$ 。\nT3 给你一张所有边长度都为 $1$ 的树 $G=(V, E)$ 以及常量 $k$ ，记 $G$ 中两点 $u$ 和 $v$ 之间的距离为 $dis(u, v)$ ，构造无向图 $H=(V, \\{(u, v)|dis(u, v)\\le k\\})$ ，$q$ 次询问，每次给出 $l$ 和 $r$ ，求 $H$ 在 $[l, r]$ 上的导出子图（即仅保留 $[l, r]$ 内的点以及它们之间的所有连边得到的子图）的连通块数量。\n点数 $3\\cdot 10^5$ ，边数 $6\\cdot 10^5$ ，时限 $\\mathtt{6s}$ 。\n比赛 登录用户名竟然是 \u0026ldquo;THUWC2020\u0026rdquo; 开头，明明是 2019 年的比赛（\nT1 看了一小会儿就会了，写完之后把编译错误改完就 pp 了。\n过了之后去把 lower_bound 改成了 upper_bound ，然后 并不愉快地 又 pp 了..说好的实质 IOI 赛制呢 QAQ。于是跑去写了个对拍，upper_bound 很快拍出错了，一开始的版本几万组没出错，极限数据不开 O2 过不了，开 O2 $\\mathtt{1.5s}$ 。于是 T1 就搞了 1h+\u0026hellip;\n一开始的题面还没写值域，结果提问发出去的 20s 前发了个公告补充了值域，然后就得到了“请仔细阅读公告”的回复\u0026hellip;\n看了眼 T2 和 T3，发现都不太会做。\nT3 不知道为什么，第一眼我就把它转化成了“求每个点编号左右编号最靠近它的距离不超过 $k$ 的点，然后莫队”，对着这个想了好久，然后发现这是个明显的假转化，然后发现自己连 $k=1$ 的数普通连通块都不会做了，然后发现链并不保证编号是顺着来的所以链也不会了，就滚去看 T2 了..\nT2 的“数据随机”那档部分分给的很迷，说什么“每条边出现概率为 $\\dfrac{1}{n^2}$”，听起来像是期望只有一条边的感觉，然后我交上去测了一下，发现不止 $10$ 条边，怀疑是笔误..只不过这档大概是给暴力的吧，我暴力也过了这档，就没提问了..\n然而问题在于，暴力甚至可以过环套树加上不超过 $50$ 条额外边的那档..（过不了环套树那档。）\n然后去写不需要考虑删边那档，一开始我去写了个拓扑排序找环，快写完的时候突然发现自己没有处理步数上限既没到链的末尾也没到环上的情况，立刻想到可以用倍增处理，紧接着想到这档除了倍增啥都不用写，然后就把写了半天的拓扑排序全删了..\n然后去写树的部分分，一开始一个地方想错写自闭了，然后去写 T3 的 $8$ 分，写完回来发现自己 sb 了，然后写完了树的部分分，结果调了 1h..然后就考试结束了。\n感觉少想一会儿正解，部分分打快点，环套树就可以写出来了..\nPT 是 $165$ 分，但环套树加上不超过 $50$ 条额外边显然过不了，所以大概是 $100+49+8=157$ 分。看起来就很大众分的样子，然而持续两天的比赛第一天结束当然是不能去看别人多少分的。\nDay 336 简要题意 T1 给你一个数以及 $n$ 个对一个数进行的操作，其中第 $i$ 个操作是将 $x$ 变成 $a_i|x|+b_ix+c_i$ ，你可以改变操作进行的顺序，求最后得到的数的最大值。\n$1\\le n\\le 15$ ，$-15\\le a_i, b_i, c_i\\le 15$ ，时限 $\\mathtt{1s}$ 。\nT2 给你一张有向无环图 $G$ ，令 $G$ 的 DFS 树为 $T$（以 $1$ 为根，优先访问编号小的点），多组询问，每次给出 $a$ 和 $b$ ，保证 $a$ 在 $T$ 上是 $b$ 的祖先，询问“在 $G$ 中删去 $T$ 上 $a$ 到 $b$ 的简单路径上的边之后，$T$ 中以 $b$ 为根的子树内的点有多少个在 $G$ 中是从 $1$ 出发不可达的”。\n点数、询问数 $10^5$ ，边数 $1.5\\cdot 10^5$ ，时限 $\\mathtt{1s}$ 。\nT3 给你一棵点权是一个排列的树，多组询问，每次给出两个点和一个非负整数 $k$ ，求这两点间路径上的点权构成的序列可以由多少个不同的序列由恰好 $k$ 轮 冒泡排序得到。\n点数、询问数 $5\\cdot 10^5$ ，时限 $\\mathtt{4s}$ 。\n比赛 今天 T1 怎么不会做..今天 T2 和 T3 依然不会做..\n把 T1 暴力打了。\n把 T2 暴力打了。\n把 T3 暴力打了。怎么 T 掉了..\nT3 打个表，啥规律都没有。\n把 T1 部分分打全了。\n我好像会 T2 所有部分分？\n写完 subtask2，假了。\n写完 subtask4，假了。\n写完 subtask3，还剩不到 1h 了。\n卡了下 T3 暴力常数，暴力过了。\n我自闭了。\n今天 pt 好像更弱（？），好像 T1 随便写都能过若干 subtask，subtask1 没过剩下都过、subtask2 没过剩下都过之类的。反正我的部分分都对拍了，应该没啥问题..\n好像是比大众分低但是并不知道的 $55+31+8=94$ 。\n下午 下午好短啊..我怎么写个游记就快要吃饭了 QAQ\n本来还想学一下 Python 二进制文件读写的..\nDay 336+ 这次不用二进制文件读写了，任务是模拟 Cache。\n开场前一直在想：“APIO 上到底讲了啥\u0026hellip;”\n开场先读了 10min 学习手册，发现不对劲，回想一下自己平时写工程时的流程（需要什么 → 搜什么 → 发现哪看不懂 → DFS 前置知识）以及前两次工程题的教训，于是就先去看了看题，直接去找学习手册中对应的部分，然后发现题目名称和学习手册标题顺序是相反的（\n5min 后发现 T1 需要用到的只有倒数第二页的一张表格..然后非常愉快地 OOP 实现了一发，然后因为语文问题没过样例，过样例之后交上去只过了 subtask1，仔细阅读之后发现还是语文问题，改了之后就过了。此时 1:20 左右。\nT2 好像差不多就是 APIO 上讲的那个东西，写着写着就只剩半小时了..\n然后把 T3 的 subtask1 写完就只剩不到 10min 了..\nT3 剩下的 subtask 差不多就是把 T2 封装一下用上去，感觉 20min 就可以写完..\n最后是大众分 $40+56+16=112$ 。\nDay 337 面试 听说 0 点半的时候教练收到了面试通知..\n依然是按字典序排序，又等到了接近 12 点，但这次没有要求关手机，于是可以愉快地水群。\n面试的时候说了一下之前颓 OI Wiki 时学的时间复杂性理论，还有 capacity scaling 什么的，然后果然被问了“什么是 NP 问题？什么是 NPC 问题？”。\n英语阅读是一篇图论基础概念（点和边的定义之类的），之前写 OI Wiki 的时候也查过很多图论相关的 en Wikipedia，所以感觉很稳，然后读完之后，用英语问了我“你知道图论在生活中有哪些运用吗？”，突然不按剧本，然后就随便说了个导航，然后阅读部分竟然就结束了..这和图论基础概念到底有什么关系啊..\n然后是“还有一分钟，要不问你个数学题吧”。上次没问数学题，但看很多人游记都有提到，而且据说很简单。问的是“一支铅笔折三次，组成三角形的概率是多大”。题面非常迷惑，我向考官确认了一下，意思就是“将一条线段均匀随机地分成三段，这三段能够组成三角形的概率是多大”。然而我从小不擅长当面回答问题，当时半分钟脑子一片空白，考官问我有什么思路，我说了个“最长那段要小于二分之一”，被回了个“显然”，然后时间就到了。\n出考场后瞬间会做，感觉自己没救了。\n宣讲 感觉这次宣讲是今年 WC 第一轮（指 2019 年 1 月那次）和今年 SC 的结合，总体效果感觉和 WC 第一轮差不多，没有 SC 那么无聊（\n然而这次完全没有讲题，连 Day336+ T6（期待你的声音）的分享都没有（\n发奖 今年没进面试都有奖（\n为啥线这么低啊..\n我好像压线 1= 了。\n","date":"2019-12-20T20:37:57+08:00","permalink":"https://ouuan.github.io/post/thuwc2019-%E7%AC%AC%E4%BA%8C%E8%BD%AE%E5%86%AC%E7%9C%A0/","tags":["清华营"],"title":"THUWC2019 第二轮冬眠"},{"categories":["题解"],"contents":"题目链接 CF\n题意简述 给你一个长为 $n$ 的数列，对于 $1\\le k\\le n$ 的所有整数 $k$，求出这个问题的答案：将数列划分成若干连续段，每段内最多有 $k$ 个 不同 的数，至少要划分成几段？\n$n\\le 10^5$ 。\n简要做法 首先是一个显而易见的贪心：分段时在一段内放更多的数一定不劣。这个结论在下面两个做法都会用到。\n根号分治 根据上面的那个结论，可以得到一个 $k$ 固定时复杂度为 $O(n)$ 的做法。需要使用时间戳清空访问数组。\n然后就可以进行根号分治：\n取一个合适的值 $B$ 。\n对于 $1\\le k\\le B$ ，直接做，时间复杂度为 $O(nB)$ 。\n对于 $B+1\\le k\\le n$ ，答案不超过 $n/B$ ，可以对于每个答案二分求出 $k$ 的最小值和最大值，时间复杂度为 $O(n^2\\log n/B)$ 。\n取 $B=\\sqrt{n\\log n}$，总时间复杂度为 $O(n\\sqrt{n\\log n})$，可以通过本题。\n主席树 每个 $k$ 的答案不超过 $n/k$，根据调和级数，可以得到总答案的级别为 $O(n\\log n)$ ，所以只要能够快速求出一次分段的右端点，就能够快速求出总答案了。\n这题依然可以沿用 「SDOI2009」HH 的项链 的树状数组做法，但由于要不断地求分段的右端点，需要使用主席树，再加上线段树二分，就可以 $O(\\log n)$ 求出一段的右端点，总时间复杂度即为 $O(n\\log^2n)$ 。\n具体来说，$f_{l, i}\\in\\{0, 1\\}$ ，$f_{l, i}=1$ 当且仅当 $i$ 是 $l$ 及其右侧第一个为 $a_i$ 的数，即 $i\\ge l$ 且不存在 $j$ 使得 $l\\le j\\le i-1, a_j=a_i$ 。那么，$[l, r]$ 的颜色数就是 $\\sum_{i=l}^rf_{l, i}$ 。使用 $n$ 棵主席树分别维护 $f_{1..n, i}$ 即可。\n参考代码 根号分治 #ifndef OUUAN #pragma GCC optimize(\u0026quot;Ofast,no-stack-protector,unroll-loops,fast-math\u0026quot;) #endif #include\u0026lt;bits/stdc++.h\u0026gt; //#define int LoveLive //#define FAST_IOSTREAM 1 #define For(i,l,r)for(int i=(l),i##end=(r);i\u0026lt;=i##end;++i) #define FOR(i,r,l)for(int i=(r),i##end=(l);i\u0026gt;=i##end;--i) #define SON(i,u)for(int i=head[u];i;i=nxt[i]) #define ms(a,x)memset(a,x,sizeof(a)) #define fi first #define se second #define pb emplace_back #define pq priority_queue #define isinf(x)(x\u0026gt;=INF?-1:x) #define y1 why_is_there_a_function_called_y1 using namespace std;typedef long long LoveLive;typedef pair\u0026lt;int,int\u0026gt;pii;typedef vector\u0026lt;int\u0026gt;vi;typedef long double ld;const double inf=1e121;const double eps=1e-10;mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());int randint(int l,int r){int out=rng()%(r-l+1)+l;return out\u0026gt;=l?out:out+r-l+1;}template\u0026lt;typename A,typename B\u0026gt;string to_string(pair\u0026lt;A,B\u0026gt;p);template\u0026lt;typename A,typename B,typename C\u0026gt;string to_string(tuple\u0026lt;A,B,C\u0026gt;p);template\u0026lt;typename A,typename B,typename C,typename D\u0026gt;string to_string(tuple\u0026lt;A,B,C,D\u0026gt;p);string to_string(const string\u0026amp;s){return '\u0026quot;'+s+'\u0026quot;';}string to_string(const char*s){return to_string((string)s);}string to_string(bool b){return(b?\u0026quot;true\u0026quot;:\u0026quot;false\u0026quot;);}string to_string(vector\u0026lt;bool\u0026gt;v){bool first=true;string res=\u0026quot;{\u0026quot;;for(int i=0;i\u0026lt;static_cast\u0026lt;int\u0026gt;(v.size());i++){if(!first){res+=\u0026quot;,\u0026quot;;}first=false;res+=to_string(v[i]);}res+=\u0026quot;}\u0026quot;;return res;}template\u0026lt;size_t N\u0026gt;string to_string(bitset\u0026lt;N\u0026gt;v){string res=\u0026quot;\u0026quot;;for(size_t i=0;i\u0026lt;N;i++){res+=static_cast\u0026lt;char\u0026gt;('0'+v[i]);}return res;}template\u0026lt;typename A\u0026gt;string to_string(A v){bool first=true;string res=\u0026quot;{\u0026quot;;for(const auto\u0026amp;x:v){if(!first){res+=\u0026quot;,\u0026quot;;}first=false;res+=to_string(x);}res+=\u0026quot;}\u0026quot;;return res;}template\u0026lt;typename A,typename B\u0026gt;string to_string(pair\u0026lt;A,B\u0026gt;p){return \u0026quot;(\u0026quot;+to_string(p.first)+\u0026quot;,\u0026quot;+to_string(p.second)+\u0026quot;)\u0026quot;;}template\u0026lt;typename A,typename B,typename C\u0026gt;string to_string(tuple\u0026lt;A,B,C\u0026gt;p){return \u0026quot;(\u0026quot;+to_string(get\u0026lt;0\u0026gt;(p))+\u0026quot;,\u0026quot;+to_string(get\u0026lt;1\u0026gt;(p))+\u0026quot;,\u0026quot;+to_string(get\u0026lt;2\u0026gt;(p))+\u0026quot;)\u0026quot;;}template\u0026lt;typename A,typename B,typename C,typename D\u0026gt;string to_string(tuple\u0026lt;A,B,C,D\u0026gt;p){return \u0026quot;(\u0026quot;+to_string(get\u0026lt;0\u0026gt;(p))+\u0026quot;,\u0026quot;+to_string(get\u0026lt;1\u0026gt;(p))+\u0026quot;,\u0026quot;+to_string(get\u0026lt;2\u0026gt;(p))+\u0026quot;,\u0026quot;+to_string(get\u0026lt;3\u0026gt;(p))+\u0026quot;)\u0026quot;;}template\u0026lt;typename A,typename B,typename C,typename D,typename E\u0026gt;string to_string(tuple\u0026lt;A,B,C,D,E\u0026gt;p){return \u0026quot;(\u0026quot;+to_string(get\u0026lt;0\u0026gt;(p))+\u0026quot;,\u0026quot;+to_string(get\u0026lt;1\u0026gt;(p))+\u0026quot;,\u0026quot;+to_string(get\u0026lt;2\u0026gt;(p))+\u0026quot;,\u0026quot;+to_string(get\u0026lt;3\u0026gt;(p))+\u0026quot;,\u0026quot;+to_string(get\u0026lt;4\u0026gt;(p))+\u0026quot;)\u0026quot;;}void debug_out(){cerr\u0026lt;\u0026lt;endl;}template\u0026lt;typename Head,typename...Tail\u0026gt;void debug_out(Head H,Tail...T){cerr\u0026lt;\u0026lt;\u0026quot; \u0026quot;\u0026lt;\u0026lt;to_string(H);debug_out(T...);} #ifdef OUUAN #define debug(...)cerr\u0026lt;\u0026lt;\u0026quot;[\u0026quot;\u0026lt;\u0026lt;#__VA_ARGS__\u0026lt;\u0026lt;\u0026quot;]:\u0026quot;,debug_out(__VA_ARGS__) #else #define debug(...)42 #endif #ifdef int const int INF=0x3f3f3f3f3f3f3f3fll; #else const int INF=0x3f3f3f3f;typedef long long ll; #endif #ifdef FAST_IOSTREAM #define br cout\u0026lt;\u0026lt;'\\n' #define sp cout\u0026lt;\u0026lt;' ' long long read(){long long x;cin\u0026gt;\u0026gt;x;return x;}template\u0026lt;typename T\u0026gt;void read(T\u0026amp;x){cin\u0026gt;\u0026gt;x;}template\u0026lt;typename T\u0026gt;void write(const T\u0026amp;x){cout\u0026lt;\u0026lt;x;} #else #define br putchar('\\n') #define sp putchar(' ') template\u0026lt;typename T\u0026gt;typename enable_if\u0026lt;!is_integral\u0026lt;T\u0026gt;::value,void\u0026gt;::type read(T\u0026amp;x){cin\u0026gt;\u0026gt;x;}long long read(){char c;long long out=0,f=1;for(c=getchar();!isdigit(c)\u0026amp;\u0026amp;c!='-';c=getchar());if(c=='-'){f=-1;c=getchar();}for(;isdigit(c);c=getchar())out=(out\u0026lt;\u0026lt;3)+(out\u0026lt;\u0026lt;1)+c-'0';return out*f;}template\u0026lt;typename T\u0026gt;typename enable_if\u0026lt;is_integral\u0026lt;T\u0026gt;::value,T\u0026gt;::type read(T\u0026amp;x){char c;T f=1;x=0;for(c=getchar();!isdigit(c)\u0026amp;\u0026amp;c!='-';c=getchar());if(c=='-'){f=-1;c=getchar();}for(;isdigit(c);c=getchar())x=(x\u0026lt;\u0026lt;3)+(x\u0026lt;\u0026lt;1)+c-'0';return x*=f;}char read(char\u0026amp;x){for(x=getchar();isspace(x);x=getchar());return x;}double read(double\u0026amp;x){scanf(\u0026quot;%lf\u0026quot;,\u0026amp;x);return x;}ld read(ld\u0026amp;x){scanf(\u0026quot;%Lf\u0026quot;,\u0026amp;x);return x;}template\u0026lt;typename T\u0026gt;typename enable_if\u0026lt;!is_integral\u0026lt;T\u0026gt;::value,void\u0026gt;::type write(const T\u0026amp;x){cout\u0026lt;\u0026lt;x;}template\u0026lt;typename T\u0026gt;typename enable_if\u0026lt;is_integral\u0026lt;T\u0026gt;::value,void\u0026gt;::type write(const T\u0026amp;x){if(x\u0026lt;0){putchar('-');write(-x);return;}if(x\u0026gt;9)write(x/10);putchar(x%10+'0');}void write(const char\u0026amp;x){putchar(x);}void write(const double\u0026amp;x){printf(\u0026quot;%.10lf\u0026quot;,x);}void write(const ld\u0026amp;x){printf(\u0026quot;%.10Lf\u0026quot;,x);} #endif template\u0026lt;typename T,typename...Args\u0026gt;void read(T\u0026amp;x,Args\u0026amp;...args){read(x);read(args...);}template\u0026lt;typename OutputIt,typename=typename enable_if\u0026lt;is_same\u0026lt;output_iterator_tag,typename iterator_traits\u0026lt;OutputIt\u0026gt;::iterator_category\u0026gt;::value||(is_base_of\u0026lt;forward_iterator_tag,typename iterator_traits\u0026lt;OutputIt\u0026gt;::iterator_category\u0026gt;::value\u0026amp;\u0026amp;!is_const\u0026lt;OutputIt\u0026gt;::value)\u0026gt;::type\u0026gt;void read(OutputIt __first,OutputIt __last){for(;__first!=__last;++__first)read(*__first);}template\u0026lt;typename InputIt,typename=typename enable_if\u0026lt;is_base_of\u0026lt;input_iterator_tag,typename iterator_traits\u0026lt;InputIt\u0026gt;::iterator_category\u0026gt;::value\u0026gt;::type\u0026gt;void wts(InputIt __first,InputIt __last){bool isFirst=true;for(;__first!=__last;++__first){if(isFirst)isFirst=false;else sp;write(*__first);}br;}template\u0026lt;typename InputIt,typename=typename enable_if\u0026lt;is_base_of\u0026lt;input_iterator_tag,typename iterator_traits\u0026lt;InputIt\u0026gt;::iterator_category\u0026gt;::value\u0026gt;::type\u0026gt;void wtb(InputIt __first,InputIt __last){for(;__first!=__last;++__first){write(*__first);br;}}template\u0026lt;typename T\u0026gt;void wts(const T\u0026amp;x){write(x);sp;}template\u0026lt;typename T\u0026gt;void wtb(const T\u0026amp;x){write(x);br;}template\u0026lt;typename T\u0026gt;void wte(const T\u0026amp;x){write(x);exit(0);}template\u0026lt;typename T,typename...Args\u0026gt;void wts(const T\u0026amp;x,Args...args){wts(x);wts(args...);}template\u0026lt;typename T,typename...Args\u0026gt;void wtb(const T\u0026amp;x,Args...args){wts(x);wtb(args...);}template\u0026lt;typename T,typename...Args\u0026gt;void wte(const T\u0026amp;x,Args...args){wts(x);wte(args...);}template\u0026lt;typename T\u0026gt;inline bool up(T\u0026amp;x,const T\u0026amp;y){return x\u0026lt;y?x=y,1:0;}template\u0026lt;typename T\u0026gt;inline bool dn(T\u0026amp;x,const T\u0026amp;y){return y\u0026lt;x?x=y,1:0;}template\u0026lt;typename T\u0026gt;inline bool inRange(const T\u0026amp;x,const T\u0026amp;l,const T\u0026amp;r){return!(x\u0026lt;l)\u0026amp;\u0026amp;!(r\u0026lt;x);}template\u0026lt;typename valueType,typename tagType\u0026gt;class segmentTreeNode{public:int id,left,right;valueType val;tagType tag;};template\u0026lt;typename valueType, typename tagType, valueType(*merge)(valueType,valueType), void(*update)(segmentTreeNode\u0026lt;valueType,tagType\u0026gt;\u0026amp;,tagType)\u0026gt;class segmentTree{private:std::vector\u0026lt;segmentTreeNode\u0026lt;valueType,tagType\u0026gt;\u0026gt;nodes;int leftRange,rightRange;valueType valueZero;tagType tagZero;void pushup(int cur){nodes[cur].val=merge(nodes[cur\u0026lt;\u0026lt;1].val,nodes[cur\u0026lt;\u0026lt;1|1].val);}void pushdown(int cur){update(nodes[cur\u0026lt;\u0026lt;1],nodes[cur].tag);update(nodes[cur\u0026lt;\u0026lt;1|1],nodes[cur].tag);nodes[cur].tag=tagZero;}void build(int cur,int l,int r,const std::vector\u0026lt;valueType\u0026gt;\u0026amp;initValue){nodes[cur].id=cur;nodes[cur].left=l;nodes[cur].right=r;nodes[cur].tag=tagZero;if(l==r-1)nodes[cur].val=initValue[l-leftRange];else{build(cur\u0026lt;\u0026lt;1,l,(l+r)\u0026gt;\u0026gt;1,initValue);build(cur\u0026lt;\u0026lt;1|1,(l+r)\u0026gt;\u0026gt;1,r,initValue);pushup(cur);}}void init(const std::vector\u0026lt;valueType\u0026gt;\u0026amp;_initValue,const valueType\u0026amp;_valueZero,const tagType\u0026amp;_tagZero){valueZero=_valueZero;tagZero=_tagZero;nodes.resize((rightRange-leftRange)\u0026lt;\u0026lt;2);build(1,leftRange,rightRange,_initValue);}void modify(int cur,int l,int r,int L,int R,const tagType\u0026amp;tag){if(l\u0026gt;=R||r\u0026lt;=L)return;if(L\u0026lt;=l\u0026amp;\u0026amp;r\u0026lt;=R)update(nodes[cur],tag);else{pushdown(cur);modify(cur\u0026lt;\u0026lt;1,l,(l+r)\u0026gt;\u0026gt;1,L,R,tag);modify(cur\u0026lt;\u0026lt;1|1,(l+r)\u0026gt;\u0026gt;1,r,L,R,tag);pushup(cur);}}valueType query(int cur,int l,int r,int L,int R){if(l\u0026gt;=R||r\u0026lt;=L)return valueZero;if(L\u0026lt;=l\u0026amp;\u0026amp;r\u0026lt;=R)return nodes[cur].val;pushdown(cur);return merge(query(cur\u0026lt;\u0026lt;1,l,(l+r)\u0026gt;\u0026gt;1,L,R), query(cur\u0026lt;\u0026lt;1|1,(l+r)\u0026gt;\u0026gt;1,r,L,R));}public:segmentTree(){}segmentTree(int _leftRange,int _rightRange,const std::vector\u0026lt;valueType\u0026gt;\u0026amp;_initValue,const valueType\u0026amp;_valueZero,const tagType\u0026amp;_tagZero){leftRange=_leftRange;rightRange=_rightRange;init(_initValue,_valueZero,_tagZero);}segmentTree(int size,const std::vector\u0026lt;valueType\u0026gt;\u0026amp;_initValue,const valueType\u0026amp;_valueZero,const tagType\u0026amp;_tagZero){leftRange=1;rightRange=size+1;init(_initValue,_valueZero,_tagZero);}void modify(int l,int r,const tagType\u0026amp;tag){modify(1,leftRange,rightRange,l,r,tag);}void modify(int p,const tagType\u0026amp;tag){modify(p,p+1,tag);}valueType query(int l,int r){return query(1,leftRange,rightRange,l,r);}valueType query(int p){return query(p,p+1);}};class maxFlow{private:typedef long long ll;std::queue\u0026lt;int\u0026gt;q;std::vector\u0026lt;int\u0026gt;head,cur,nxt,to,dep;std::vector\u0026lt;ll\u0026gt;cap;public:maxFlow(int _n=0){init(_n);}void init(int _n){head.clear();head.resize(_n+1,0);nxt.resize(2);to.resize(2);cap.resize(2);}void init(){init(head.size()-1);}void add(int u,int v,ll w){nxt.push_back(head[u]);head[u]=to.size();to.push_back(v);cap.push_back(w);}void Add(int u,int v,ll w){add(u,v,w);add(v,u,0);}void del(int x){cap[x\u0026lt;\u0026lt;1]=cap[x\u0026lt;\u0026lt;1|1]=0;}bool bfs(int s,int t){dep.clear();dep.resize(head.size(),-1);dep[s]=0;q.push(s);while(!q.empty()){int u=q.front();q.pop();for(int i=head[u];i;i=nxt[i]){int v=to[i];ll w=cap[i];if(w\u0026gt;0\u0026amp;\u0026amp;dep[v]==-1){dep[v]=dep[u]+1;q.push(v);}}}return ~dep[t];}ll dfs(int u,ll flow,int t){if(dep[u]==dep[t])return u==t?flow:0;ll out=0;for(int\u0026amp;i=cur[u];i;i=nxt[i]){int v=to[i];ll w=cap[i];if(w\u0026gt;0\u0026amp;\u0026amp;dep[v]==dep[u]+1){ll f=dfs(v,std::min(w,flow-out),t);cap[i]-=f;cap[i ^ 1]+=f;out+=f;if(out==flow)return out;}}return out;}ll maxflow(int s,int t){ll out=0;while(bfs(s,t)){cur=head;out+=dfs(s,0x7fffffffffffffffll,t);}return out;}ll getflow(int x)const{return cap[x\u0026lt;\u0026lt;1|1];}};struct customHash{static uint64_t splitmix64(uint64_t x){x+=0x9e3779b97f4a7c15;x=(x ^(x\u0026gt;\u0026gt;30))*0xbf58476d1ce4e5b9;x=(x ^(x\u0026gt;\u0026gt;27))*0x94d049bb133111eb;return x ^(x\u0026gt;\u0026gt;31);}size_t operator()(uint64_t x)const{static const uint64_t FIXED_RANDOM=rng();return splitmix64(x+FIXED_RANDOM);}}; const int B = 1400; int n, tim; vi a, vis; int solve(int k) { int out = 0, p = 0; do { int cnt = 0; ++tim; ++out; while (p \u0026lt; n) { if (vis[a[p]] != tim) { if (++cnt \u0026gt; k) break; vis[a[p]] = tim; } ++p; } } while (p \u0026lt; n); return out; } signed main() { #ifdef FAST_IOSTREAM cin.sync_with_stdio(false); cin.tie(0); #endif read(n); a.resize(n); vis.resize(n + 1, 0); read(a.begin(), a.end()); For (i, 1, min(B, n)) wts(solve(i)); int p = min(B, n) + 1; FOR (i, n / B + 1, 1) { int l = p - 1; int r = n; while (l \u0026lt; r) { int mid = (l + r + 1) \u0026gt;\u0026gt; 1; if (solve(mid) \u0026lt; i) r = mid - 1; else l = mid; } for (; p \u0026lt;= l; ++p) wts(i); } return 0; }   主席树 #ifndef OUUAN #pragma GCC optimize(\u0026quot;Ofast,no-stack-protector,unroll-loops,fast-math\u0026quot;) #endif #include\u0026lt;bits/stdc++.h\u0026gt; //#define int LoveLive //#define FAST_IOSTREAM 1 #define For(i,l,r)for(int i=(l),i##end=(r);i\u0026lt;=i##end;++i) #define FOR(i,r,l)for(int i=(r),i##end=(l);i\u0026gt;=i##end;--i) #define SON(i,u)for(int i=head[u];i;i=nxt[i]) #define ms(a,x)memset(a,x,sizeof(a)) #define fi first #define se second #define pb emplace_back #define pq priority_queue #define isinf(x)(x\u0026gt;=INF?-1:x) #define y1 why_is_there_a_function_called_y1 using namespace std;typedef long long LoveLive;typedef pair\u0026lt;int,int\u0026gt;pii;typedef vector\u0026lt;int\u0026gt;vi;typedef long double ld;const double inf=1e121;const double eps=1e-10;mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());int randint(int l,int r){int out=rng()%(r-l+1)+l;return out\u0026gt;=l?out:out+r-l+1;}template\u0026lt;typename A,typename B\u0026gt;string to_string(pair\u0026lt;A,B\u0026gt;p);template\u0026lt;typename A,typename B,typename C\u0026gt;string to_string(tuple\u0026lt;A,B,C\u0026gt;p);template\u0026lt;typename A,typename B,typename C,typename D\u0026gt;string to_string(tuple\u0026lt;A,B,C,D\u0026gt;p);string to_string(const string\u0026amp;s){return '\u0026quot;'+s+'\u0026quot;';}string to_string(const char*s){return to_string((string)s);}string to_string(bool b){return(b?\u0026quot;true\u0026quot;:\u0026quot;false\u0026quot;);}string to_string(vector\u0026lt;bool\u0026gt;v){bool first=true;string res=\u0026quot;{\u0026quot;;for(int i=0;i\u0026lt;static_cast\u0026lt;int\u0026gt;(v.size());i++){if(!first){res+=\u0026quot;,\u0026quot;;}first=false;res+=to_string(v[i]);}res+=\u0026quot;}\u0026quot;;return res;}template\u0026lt;size_t N\u0026gt;string to_string(bitset\u0026lt;N\u0026gt;v){string res=\u0026quot;\u0026quot;;for(size_t i=0;i\u0026lt;N;i++){res+=static_cast\u0026lt;char\u0026gt;('0'+v[i]);}return res;}template\u0026lt;typename A\u0026gt;string to_string(A v){bool first=true;string res=\u0026quot;{\u0026quot;;for(const auto\u0026amp;x:v){if(!first){res+=\u0026quot;,\u0026quot;;}first=false;res+=to_string(x);}res+=\u0026quot;}\u0026quot;;return res;}template\u0026lt;typename A,typename B\u0026gt;string to_string(pair\u0026lt;A,B\u0026gt;p){return \u0026quot;(\u0026quot;+to_string(p.first)+\u0026quot;,\u0026quot;+to_string(p.second)+\u0026quot;)\u0026quot;;}template\u0026lt;typename A,typename B,typename C\u0026gt;string to_string(tuple\u0026lt;A,B,C\u0026gt;p){return \u0026quot;(\u0026quot;+to_string(get\u0026lt;0\u0026gt;(p))+\u0026quot;,\u0026quot;+to_string(get\u0026lt;1\u0026gt;(p))+\u0026quot;,\u0026quot;+to_string(get\u0026lt;2\u0026gt;(p))+\u0026quot;)\u0026quot;;}template\u0026lt;typename A,typename B,typename C,typename D\u0026gt;string to_string(tuple\u0026lt;A,B,C,D\u0026gt;p){return \u0026quot;(\u0026quot;+to_string(get\u0026lt;0\u0026gt;(p))+\u0026quot;,\u0026quot;+to_string(get\u0026lt;1\u0026gt;(p))+\u0026quot;,\u0026quot;+to_string(get\u0026lt;2\u0026gt;(p))+\u0026quot;,\u0026quot;+to_string(get\u0026lt;3\u0026gt;(p))+\u0026quot;)\u0026quot;;}template\u0026lt;typename A,typename B,typename C,typename D,typename E\u0026gt;string to_string(tuple\u0026lt;A,B,C,D,E\u0026gt;p){return \u0026quot;(\u0026quot;+to_string(get\u0026lt;0\u0026gt;(p))+\u0026quot;,\u0026quot;+to_string(get\u0026lt;1\u0026gt;(p))+\u0026quot;,\u0026quot;+to_string(get\u0026lt;2\u0026gt;(p))+\u0026quot;,\u0026quot;+to_string(get\u0026lt;3\u0026gt;(p))+\u0026quot;,\u0026quot;+to_string(get\u0026lt;4\u0026gt;(p))+\u0026quot;)\u0026quot;;}void debug_out(){cerr\u0026lt;\u0026lt;endl;}template\u0026lt;typename Head,typename...Tail\u0026gt;void debug_out(Head H,Tail...T){cerr\u0026lt;\u0026lt;\u0026quot; \u0026quot;\u0026lt;\u0026lt;to_string(H);debug_out(T...);} #ifdef OUUAN #define debug(...)cerr\u0026lt;\u0026lt;\u0026quot;[\u0026quot;\u0026lt;\u0026lt;#__VA_ARGS__\u0026lt;\u0026lt;\u0026quot;]:\u0026quot;,debug_out(__VA_ARGS__) #else #define debug(...)42 #endif #ifdef int const int INF=0x3f3f3f3f3f3f3f3fll; #else const int INF=0x3f3f3f3f;typedef long long ll; #endif #ifdef FAST_IOSTREAM #define br cout\u0026lt;\u0026lt;'\\n' #define sp cout\u0026lt;\u0026lt;' ' long long read(){long long x;cin\u0026gt;\u0026gt;x;return x;}template\u0026lt;typename T\u0026gt;void read(T\u0026amp;x){cin\u0026gt;\u0026gt;x;}template\u0026lt;typename T\u0026gt;void write(const T\u0026amp;x){cout\u0026lt;\u0026lt;x;} #else #define br putchar('\\n') #define sp putchar(' ') template\u0026lt;typename T\u0026gt;typename enable_if\u0026lt;!is_integral\u0026lt;T\u0026gt;::value,void\u0026gt;::type read(T\u0026amp;x){cin\u0026gt;\u0026gt;x;}long long read(){char c;long long out=0,f=1;for(c=getchar();!isdigit(c)\u0026amp;\u0026amp;c!='-';c=getchar());if(c=='-'){f=-1;c=getchar();}for(;isdigit(c);c=getchar())out=(out\u0026lt;\u0026lt;3)+(out\u0026lt;\u0026lt;1)+c-'0';return out*f;}template\u0026lt;typename T\u0026gt;typename enable_if\u0026lt;is_integral\u0026lt;T\u0026gt;::value,T\u0026gt;::type read(T\u0026amp;x){char c;T f=1;x=0;for(c=getchar();!isdigit(c)\u0026amp;\u0026amp;c!='-';c=getchar());if(c=='-'){f=-1;c=getchar();}for(;isdigit(c);c=getchar())x=(x\u0026lt;\u0026lt;3)+(x\u0026lt;\u0026lt;1)+c-'0';return x*=f;}char read(char\u0026amp;x){for(x=getchar();isspace(x);x=getchar());return x;}double read(double\u0026amp;x){scanf(\u0026quot;%lf\u0026quot;,\u0026amp;x);return x;}ld read(ld\u0026amp;x){scanf(\u0026quot;%Lf\u0026quot;,\u0026amp;x);return x;}template\u0026lt;typename T\u0026gt;typename enable_if\u0026lt;!is_integral\u0026lt;T\u0026gt;::value,void\u0026gt;::type write(const T\u0026amp;x){cout\u0026lt;\u0026lt;x;}template\u0026lt;typename T\u0026gt;typename enable_if\u0026lt;is_integral\u0026lt;T\u0026gt;::value,void\u0026gt;::type write(const T\u0026amp;x){if(x\u0026lt;0){putchar('-');write(-x);return;}if(x\u0026gt;9)write(x/10);putchar(x%10+'0');}void write(const char\u0026amp;x){putchar(x);}void write(const double\u0026amp;x){printf(\u0026quot;%.10lf\u0026quot;,x);}void write(const ld\u0026amp;x){printf(\u0026quot;%.10Lf\u0026quot;,x);} #endif template\u0026lt;typename T,typename...Args\u0026gt;void read(T\u0026amp;x,Args\u0026amp;...args){read(x);read(args...);}template\u0026lt;typename OutputIt,typename=typename enable_if\u0026lt;is_same\u0026lt;output_iterator_tag,typename iterator_traits\u0026lt;OutputIt\u0026gt;::iterator_category\u0026gt;::value||(is_base_of\u0026lt;forward_iterator_tag,typename iterator_traits\u0026lt;OutputIt\u0026gt;::iterator_category\u0026gt;::value\u0026amp;\u0026amp;!is_const\u0026lt;OutputIt\u0026gt;::value)\u0026gt;::type\u0026gt;void read(OutputIt __first,OutputIt __last){for(;__first!=__last;++__first)read(*__first);}template\u0026lt;typename InputIt,typename=typename enable_if\u0026lt;is_base_of\u0026lt;input_iterator_tag,typename iterator_traits\u0026lt;InputIt\u0026gt;::iterator_category\u0026gt;::value\u0026gt;::type\u0026gt;void wts(InputIt __first,InputIt __last){bool isFirst=true;for(;__first!=__last;++__first){if(isFirst)isFirst=false;else sp;write(*__first);}br;}template\u0026lt;typename InputIt,typename=typename enable_if\u0026lt;is_base_of\u0026lt;input_iterator_tag,typename iterator_traits\u0026lt;InputIt\u0026gt;::iterator_category\u0026gt;::value\u0026gt;::type\u0026gt;void wtb(InputIt __first,InputIt __last){for(;__first!=__last;++__first){write(*__first);br;}}template\u0026lt;typename T\u0026gt;void wts(const T\u0026amp;x){write(x);sp;}template\u0026lt;typename T\u0026gt;void wtb(const T\u0026amp;x){write(x);br;}template\u0026lt;typename T\u0026gt;void wte(const T\u0026amp;x){write(x);exit(0);}template\u0026lt;typename T,typename...Args\u0026gt;void wts(const T\u0026amp;x,Args...args){wts(x);wts(args...);}template\u0026lt;typename T,typename...Args\u0026gt;void wtb(const T\u0026amp;x,Args...args){wts(x);wtb(args...);}template\u0026lt;typename T,typename...Args\u0026gt;void wte(const T\u0026amp;x,Args...args){wts(x);wte(args...);}template\u0026lt;typename T\u0026gt;inline bool up(T\u0026amp;x,const T\u0026amp;y){return x\u0026lt;y?x=y,1:0;}template\u0026lt;typename T\u0026gt;inline bool dn(T\u0026amp;x,const T\u0026amp;y){return y\u0026lt;x?x=y,1:0;}template\u0026lt;typename T\u0026gt;inline bool inRange(const T\u0026amp;x,const T\u0026amp;l,const T\u0026amp;r){return!(x\u0026lt;l)\u0026amp;\u0026amp;!(r\u0026lt;x);}template\u0026lt;typename valueType,typename tagType\u0026gt;class segmentTreeNode{public:int id,left,right;valueType val;tagType tag;};template\u0026lt;typename valueType, typename tagType, valueType(*merge)(valueType,valueType), void(*update)(segmentTreeNode\u0026lt;valueType,tagType\u0026gt;\u0026amp;,tagType)\u0026gt;class segmentTree{private:std::vector\u0026lt;segmentTreeNode\u0026lt;valueType,tagType\u0026gt;\u0026gt;nodes;int leftRange,rightRange;valueType valueZero;tagType tagZero;void pushup(int cur){nodes[cur].val=merge(nodes[cur\u0026lt;\u0026lt;1].val,nodes[cur\u0026lt;\u0026lt;1|1].val);}void pushdown(int cur){update(nodes[cur\u0026lt;\u0026lt;1],nodes[cur].tag);update(nodes[cur\u0026lt;\u0026lt;1|1],nodes[cur].tag);nodes[cur].tag=tagZero;}void build(int cur,int l,int r,const std::vector\u0026lt;valueType\u0026gt;\u0026amp;initValue){nodes[cur].id=cur;nodes[cur].left=l;nodes[cur].right=r;nodes[cur].tag=tagZero;if(l==r-1)nodes[cur].val=initValue[l-leftRange];else{build(cur\u0026lt;\u0026lt;1,l,(l+r)\u0026gt;\u0026gt;1,initValue);build(cur\u0026lt;\u0026lt;1|1,(l+r)\u0026gt;\u0026gt;1,r,initValue);pushup(cur);}}void init(const std::vector\u0026lt;valueType\u0026gt;\u0026amp;_initValue,const valueType\u0026amp;_valueZero,const tagType\u0026amp;_tagZero){valueZero=_valueZero;tagZero=_tagZero;nodes.resize((rightRange-leftRange)\u0026lt;\u0026lt;2);build(1,leftRange,rightRange,_initValue);}void modify(int cur,int l,int r,int L,int R,const tagType\u0026amp;tag){if(l\u0026gt;=R||r\u0026lt;=L)return;if(L\u0026lt;=l\u0026amp;\u0026amp;r\u0026lt;=R)update(nodes[cur],tag);else{pushdown(cur);modify(cur\u0026lt;\u0026lt;1,l,(l+r)\u0026gt;\u0026gt;1,L,R,tag);modify(cur\u0026lt;\u0026lt;1|1,(l+r)\u0026gt;\u0026gt;1,r,L,R,tag);pushup(cur);}}valueType query(int cur,int l,int r,int L,int R){if(l\u0026gt;=R||r\u0026lt;=L)return valueZero;if(L\u0026lt;=l\u0026amp;\u0026amp;r\u0026lt;=R)return nodes[cur].val;pushdown(cur);return merge(query(cur\u0026lt;\u0026lt;1,l,(l+r)\u0026gt;\u0026gt;1,L,R), query(cur\u0026lt;\u0026lt;1|1,(l+r)\u0026gt;\u0026gt;1,r,L,R));}public:segmentTree(){}segmentTree(int _leftRange,int _rightRange,const std::vector\u0026lt;valueType\u0026gt;\u0026amp;_initValue,const valueType\u0026amp;_valueZero,const tagType\u0026amp;_tagZero){leftRange=_leftRange;rightRange=_rightRange;init(_initValue,_valueZero,_tagZero);}segmentTree(int size,const std::vector\u0026lt;valueType\u0026gt;\u0026amp;_initValue,const valueType\u0026amp;_valueZero,const tagType\u0026amp;_tagZero){leftRange=1;rightRange=size+1;init(_initValue,_valueZero,_tagZero);}void modify(int l,int r,const tagType\u0026amp;tag){modify(1,leftRange,rightRange,l,r,tag);}void modify(int p,const tagType\u0026amp;tag){modify(p,p+1,tag);}valueType query(int l,int r){return query(1,leftRange,rightRange,l,r);}valueType query(int p){return query(p,p+1);}};class maxFlow{private:typedef long long ll;std::queue\u0026lt;int\u0026gt;q;std::vector\u0026lt;int\u0026gt;head,cur,nxt,to,dep;std::vector\u0026lt;ll\u0026gt;cap;public:maxFlow(int _n=0){init(_n);}void init(int _n){head.clear();head.resize(_n+1,0);nxt.resize(2);to.resize(2);cap.resize(2);}void init(){init(head.size()-1);}void add(int u,int v,ll w){nxt.push_back(head[u]);head[u]=to.size();to.push_back(v);cap.push_back(w);}void Add(int u,int v,ll w){add(u,v,w);add(v,u,0);}void del(int x){cap[x\u0026lt;\u0026lt;1]=cap[x\u0026lt;\u0026lt;1|1]=0;}bool bfs(int s,int t){dep.clear();dep.resize(head.size(),-1);dep[s]=0;q.push(s);while(!q.empty()){int u=q.front();q.pop();for(int i=head[u];i;i=nxt[i]){int v=to[i];ll w=cap[i];if(w\u0026gt;0\u0026amp;\u0026amp;dep[v]==-1){dep[v]=dep[u]+1;q.push(v);}}}return ~dep[t];}ll dfs(int u,ll flow,int t){if(dep[u]==dep[t])return u==t?flow:0;ll out=0;for(int\u0026amp;i=cur[u];i;i=nxt[i]){int v=to[i];ll w=cap[i];if(w\u0026gt;0\u0026amp;\u0026amp;dep[v]==dep[u]+1){ll f=dfs(v,std::min(w,flow-out),t);cap[i]-=f;cap[i ^ 1]+=f;out+=f;if(out==flow)return out;}}return out;}ll maxflow(int s,int t){ll out=0;while(bfs(s,t)){cur=head;out+=dfs(s,0x7fffffffffffffffll,t);}return out;}ll getflow(int x)const{return cap[x\u0026lt;\u0026lt;1|1];}};struct customHash{static uint64_t splitmix64(uint64_t x){x+=0x9e3779b97f4a7c15;x=(x ^(x\u0026gt;\u0026gt;30))*0xbf58476d1ce4e5b9;x=(x ^(x\u0026gt;\u0026gt;27))*0x94d049bb133111eb;return x ^(x\u0026gt;\u0026gt;31);}size_t operator()(uint64_t x)const{static const uint64_t FIXED_RANDOM=rng();return splitmix64(x+FIXED_RANDOM);}}; #define mid ((l + r) \u0026gt;\u0026gt; 1) struct Node { int val, ls, rs; bool l1; Node() { val = ls = rs = 0; l1 = false; } }; vector\u0026lt;Node\u0026gt; t; int modify(int u, int l, int r, int p, int x) { int cur = t.size(); t.push_back(t[u]); t[cur].val += x; if (p == l) t[cur].l1 = x == 1; if (l == r - 1) return cur; if (p \u0026lt; mid) { int ls = modify(t[u].ls, l, mid, p, x); t[cur].ls = ls; } else { int rs = modify(t[u].rs, mid, r, p, x); t[cur].rs = rs; } return cur; } int query(int u, int l, int r, int k) { if (l == r - 1) return l; if (t[t[u].ls].val \u0026lt; k || (t[t[u].ls].val == k \u0026amp;\u0026amp; !t[t[u].rs].l1)) return query(t[u].rs, mid, r, k - t[t[u].ls].val); else return query(t[u].ls, l, mid, k); } int n; vi a, rt, pre; int solve(int k) { int p = 0, out = 0; while (p \u0026lt; n) { ++out; p = query(rt[p], 0, n, k) + 1; } return out; } signed main() { #ifdef FAST_IOSTREAM cin.sync_with_stdio(false); cin.tie(0); #endif read(n); a.resize(n); rt.resize(n + 1, 0); pre.resize(n + 1, -1); read(a.begin(), a.end()); t.resize(1); FOR (i, n - 1, 0) { rt[i] = modify(rt[i + 1], 0, n, i, 1); if (~pre[a[i]]) rt[i] = modify(rt[i], 0, n, pre[a[i]], -1); pre[a[i]] = i; } For (i, 1, n) wts(solve(i)); return 0; }  ","date":"2019-12-06T19:24:14+08:00","permalink":"https://ouuan.github.io/post/cf786c-till-i-collapse%E6%A0%B9%E5%8F%B7%E5%88%86%E6%B2%BB%E4%BA%8C%E5%88%86%E7%AD%94%E6%A1%88-%E4%B8%BB%E5%B8%AD%E6%A0%91%E8%B0%83%E5%92%8C%E7%BA%A7%E6%95%B0/","tags":["根号分治","二分答案","主席树","数颜色","调和级数","数据结构","贪心"],"title":"CF786C Till I Collapse（根号分治，二分答案 / 主席树，调和级数）"},{"categories":["题解"],"contents":"题目链接 CF\n题意简述 给你一个正整数序列，多次询问给定区间内每个数之积的欧拉函数 ($\\varphi$)，对 $10^9+7$ 取模。\n数列长度、询问个数不超过 $2\\cdot 10^5$，数的大小不超过 $10^6$ 。\n简要做法 其实这题和 「SDOI2009」HH 的项链 本质是一样的。\n由计算欧拉函数的公式得：\n$$ \\varphi\\left(\\prod\\limits_{i=l}^ra_i\\right)=\\left(\\prod\\limits_{i=l}^ra_i\\right)\\cdot\\left(\\prod\\limits_{p\\text{ is a prime factor of }a_{l..r}}\\frac{p-1}p\\right) $$\n即，区间积乘上每个在这个区间中出现了的质因数减一除以本身。\n区间积可以通过计算前缀积线性解决，关键在于求出分母。\n如果每个质因数的贡献不是 $(p-1)/p$ 而是 $1$，并且贡献不是相乘而是相加，这就是一个区间数颜色问题了。事实上，区间数颜色问题的解法的确可以套用过来。\n（下文中复杂度里的 $w$ 均指值域，$\\omega(w)$ 指值域内一个数不可重质因子个数的最大值，即 A111972 ，$m$ 指模数，即 $10^9+7$ 。）\n莫队做法 感觉 $O(w+w\\log m/\\log w+n\\sqrt q\\log w+q\\log q)$ 做法没啥好讲的，会莫队就会了吧..但这个复杂度我写的过不了。\n数论相关的莫队题经常可以根号分治去掉一个 log 。\n具体来说，大小超过 $\\sqrt w$ 的质因数在一个数中最多出现一次，所以可以把这些“大质数”用莫队处理，其它“小质数”用前缀和预处理，然后时间复杂度就是 $O(w+w\\log m/\\log w+n\\sqrt q+q\\log q)$ 了（$O(w\\log m/\\log w)$ 是计算 $(p-1)/p$ 以及 $p/(p-1)$ 的复杂度，当然，可以通过线性求逆元去掉这个 $\\log m$）（空间复杂度为 $O(w+n\\sqrt w + m)$）。\n这样优化之后可以通过本题。\n还有另外一种方式：不枚举重复的质因数，可以优化到 $O(w+w\\log m/\\log w+n\\sqrt q\\omega(w)+q\\log q)$，也可以通过本题。\n树状数组做法 这也是区间数颜色的经典做法。\n记 $pre(p, r)$ 表示质因数 $p$ 在 $[1, r]$ 中最后一次出现的位置，即：\n$$ pre(p, r)=\\max\\left(\\{x|x\\in\\mathbb{N}, x\\in[1, r], p|a_x\\}\\bigcup\\{0\\}\\right) $$\n那么，$ans(l, r)=\\left(\\prod_{pre(p, r)\\ge l}(p-1)/p\\right)\\cdot\\left(\\prod_{i=l}^ra_i\\right)$ 。\n将询问离线下来，按右端点排序，从左往右遍历每个点作为 $r$，使用数据结构（如树状数组）维护 $pre(1..r, r)$ 并查询答案，就好了。\n如果不枚举重复的质因数，复杂度为 $O(w+w\\log p/\\log w+n\\omega(w)\\log n+q(\\log n+\\log m))$ 。\n参考代码 瓶颈不带 log 的莫队做法 #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;cctype\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; typedef long long ll; int read() { int out = 0; char c; while (!isdigit(c = getchar())); for (; isdigit(c); c = getchar()) out = out * 10 + c - '0'; return out; } const int B = 168; const int W = 1e6; const int BLOCK = 500; const int mod = 1e9 + 7; int qpow(int x, int y) { int out = 1; while (y) { if (y \u0026amp; 1) out = (ll) out * x % mod; x = (ll) x * x % mod; y \u0026gt;\u0026gt;= 1; } return out; } vector\u0026lt;bool\u0026gt; np; int n, m, ans = 1; vector\u0026lt;vector\u0026lt;int\u0026gt; \u0026gt; tot; vector\u0026lt;int\u0026gt; a, p, k, invk, maxp, mul, cnt, out; struct Query { int l, r, id; Query(int _l, int _r, int _id) { l = _l; r = _r; id = _id; } bool operator\u0026lt;(const Query\u0026amp; y) const { return l / BLOCK == y.l / BLOCK ? ((l / BLOCK) \u0026amp; 1 ? r \u0026gt; y.r : r \u0026lt; y.r) : l \u0026lt; y.l; } }; vector\u0026lt;Query\u0026gt; q; void add(int x) { if (maxp[x] \u0026gt;= B) { if (++cnt[maxp[x]] == 1) { ans = (ll) ans * k[maxp[x]] % mod; } } } void del(int x) { if (maxp[x] \u0026gt;= B) { if (--cnt[maxp[x]] == 0) { ans = (ll) ans * invk[maxp[x]] % mod; } } } int main() { n = read(); np.resize(W + 1, false); maxp.resize(W + 1); for (int i = 2; i \u0026lt;= W; ++i) { if (!np[i]) { maxp[i] = p.size(); p.push_back(i); k.push_back((ll) (i - 1) * qpow(i, mod - 2) % mod); invk.push_back(qpow(k.back(), mod - 2)); } for (int j = 0; j \u0026lt; p.size() \u0026amp;\u0026amp; i * p[j] \u0026lt;= W; ++j) { int x = i * p[j]; np[x] = true; maxp[x] = max(j, maxp[i]); if (i % p[j] == 0) break; } } a.resize(n + 1); mul.resize(n + 1, 1); cnt.resize(p.size(), 0); tot.resize(B, vector\u0026lt;int\u0026gt;(n + 1, 0)); for (int i = 1; i \u0026lt;= n; ++i) { a[i] = read(); mul[i] = (ll) mul[i - 1] * a[i] % mod; for (int j = 0; j \u0026lt; B; ++j) tot[j][i] = tot[j][i - 1]; for (int x = a[i]; x \u0026gt; 1; x /= p[maxp[x]]) if (maxp[x] \u0026lt; B) ++tot[maxp[x]][i]; } m = read(); out.resize(m); int l, r; for (int i = 0; i \u0026lt; m; ++i) { l = read(); r = read(); q.push_back(Query(l, r, i)); } sort(q.begin(), q.end()); l = 1, r = 0; for (int i = 0; i \u0026lt; m; ++i) { while (l \u0026gt; q[i].l) add(a[--l]); while (r \u0026lt; q[i].r) add(a[++r]); while (l \u0026lt; q[i].l) del(a[l++]); while (r \u0026gt; q[i].r) del(a[r--]); int tmp = (ll) ans * mul[q[i].r] % mod * qpow(mul[q[i].l - 1], mod - 2) % mod; for (int j = 0; j \u0026lt; B; ++j) if (tot[j][q[i].r] - tot[j][q[i].l - 1]) tmp = (ll) tmp * k[j] % mod; out[q[i].id] = tmp; } for (int i = 0; i \u0026lt; m; ++i) printf(\u0026quot;%d\\n\u0026quot;, out[i]); return 0; }   树状数组做法 #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;cctype\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; int read() { int out = 0; char c; while (!isdigit(c = getchar())); for (; isdigit(c); c = getchar()) out = out * 10 + c - '0'; return out; } const int mod = 1e9 + 7; const int W = 1e6; int qpow(int x, int y) { int out = 1; while (y) { if (y \u0026amp; 1) out = (ll) out * x % mod; x = (ll) x * x % mod; y \u0026gt;\u0026gt;= 1; } return out; } struct BIT { vector\u0026lt;int\u0026gt; A; void resize(int size) { A.resize(size + 1, 1); } void add(int p, int x) { for (; p \u0026lt; A.size(); p += (p \u0026amp; -p)) { A[p] = (ll) A[p] * x % mod; } } int query(int p) { int out = 1; for (; p; p -= (p \u0026amp; -p)) out = (ll) out * A[p] % mod; return out; } } bit; vector\u0026lt;vector\u0026lt;pii\u0026gt; \u0026gt; q; int n, m; vector\u0026lt;bool\u0026gt; np; vector\u0026lt;int\u0026gt; a, mul, p, minp, nxt, k, invk, pre, out; int main() { np.resize(W + 1); nxt.resize(W + 1); minp.resize(W + 1); for (int i = 2; i \u0026lt;= W; ++i) { if (!np[i]) { nxt[i] = 1; minp[i] = p.size(); p.push_back(i); k.push_back((ll) (i - 1) * qpow(i, mod - 2) % mod); invk.push_back(qpow(k.back(), mod - 2)); } for (int j = 0; j \u0026lt; p.size() \u0026amp;\u0026amp; i * p[j] \u0026lt;= W; ++j) { int x = i * p[j]; np[x] = true; minp[x] = j; if (i % p[j]) nxt[x] = i; else { nxt[x] = nxt[i]; break; } } } n = read(); a.resize(n + 1); mul.resize(n + 1, 1); for (int i = 1; i \u0026lt;= n; ++i) { a[i] = read(); mul[i] = (ll) mul[i - 1] * a[i] % mod; } m = read(); q.resize(n + 1); for (int i = 0; i \u0026lt; m; ++i) { int l = read(); int r = read(); q[r].push_back(pii(l, i)); } pre.resize(p.size(), 0); out.resize(m); bit.resize(n); for (int i = 1; i \u0026lt;= n; ++i) { for (int x = a[i]; x \u0026gt; 1; x = nxt[x]) { if (pre[minp[x]]) bit.add(pre[minp[x]], invk[minp[x]]); bit.add(pre[minp[x]] = i, k[minp[x]]); } int tmp = (ll) bit.query(i) * mul[i] % mod; for (auto x : q[i]) out[x.second] = (ll) tmp * qpow((ll) bit.query(x.first - 1) * mul[x.first - 1] % mod, mod - 2) % mod; } for (int i = 0; i \u0026lt; m; ++i) printf(\u0026quot;%d\\n\u0026quot;, out[i]); return 0; }  ","date":"2019-12-05T16:41:23+08:00","permalink":"https://ouuan.github.io/post/cf594d-req%E6%95%B0%E9%A2%9C%E8%89%B2%E8%8E%AB%E9%98%9F%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%E6%95%B0%E8%AE%BA/","tags":["数颜色","莫队","树状数组","数论","数据结构"],"title":"CF594D REQ（数颜色，莫队，树状数组，数论）"},{"categories":["题解"],"contents":"题目链接 CF\n题意简述 给你一个序列，在线地支持两个操作：\n  将一个区间循环移位。\n  查询一个区间中某个数出现的次数。\n  序列长度、查询个数都不超过 $10^5$，时限 $\\texttt{4s}$ 。\nO((n+m)sqrtn) 做法 大致思路：分成若干块，每块维护块内每个数的出现次数（这导致空间复杂度是 $O(n\\sqrt n)$），以及这一块对应的序列（相当于块状链表）。\n具体来说，有至少四种大同小异的做法：\n  算法：\n  每次循环移位时只将给定区间的末尾移至给定区间的开头，这样的话每块的大小会经常改变，每根号次循环移位需要重构一次。\n  每次循环移位时除了将给定区间的末尾移至给定区间的开头，还将区间内每一块的末尾移至下一块的开头，这样的话每块的大小总是不变的。\n    数据结构：\n  使用链表维护每一块，找到需要插入、删除的位置可以做到 $O(\\sqrt n)$，插入、删除可以做到 $O(1)$ ，换块（末尾删除、头部插入）可以做到 $O(1)$ 。\n  使用双端队列维护每一块，找到需要插入、删除的位置可以做到 $O(1)$，插入、删除可以做到 $O(\\sqrt n)$ ，换块（末尾删除、头部插入）可以做到 $O(1)$ 。\n    选择一个算法和一个数据结构组合在一起，就可以得到四种做法。\nO(n+mlog^2n) 做法 使用一棵平衡树维护整个序列，再使用 $n$ 棵平衡树分别维护值为 $i$ 的数之间的相对位置。\n即，$t_0$ 中的元素是序列中的每个数，$t_i$ ($1\\le i\\le n$) 中的元素是所有大小为 $i$ 的数，用于比较的键值是这个数在序列中的位置。\n$t_0$ 的维护是经典问题，而维护 $t_i$ 时需要查找位置不超过/不小于给定值的最靠右/最靠左元素，找这个的时候需要利用 $t_0$ 来查询一个数在序列中的位置，具体实现时需要记录 $t_i$ 的每个节点在 $t_0$ 中对应的节点。\n由于在 $t_i$ 中调用了 $t_0$，复杂度就是 $O(n+m\\log^2 n)$ 。\n有点难写，我写了 5KB，调了一年..CF 上有 2.3KB 的提交（没仔细看，但应该是一样的做法..）。\n然后这题还成功劝退结构体数组选手，让我改用指针了..最后内存占用比分块还大。\n参考代码 nsqrtn 做法（链表，每次换块） #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;list\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; const int N = 1e5 + 5; const int B = 1000; int n, m, a[N], bl[N], bll[N], blr[N], cnt[N / B + 5][N]; list\u0026lt;int\u0026gt; lst[N / B + 5]; int main() { scanf(\u0026quot;%d\u0026quot;, \u0026amp;n); for (int i = 1; i \u0026lt;= n; ++i) scanf(\u0026quot;%d\u0026quot;, a + i); for (int i = 1, l = 1, r; l \u0026lt;= n; l = r + 1, ++i) { r = min(n, l + B - 1); bll[i] = l; blr[i] = r; for (int j = l; j \u0026lt;= r; ++j) { bl[j] = i; ++cnt[i][a[j]]; lst[i].push_back(a[j]); } } scanf(\u0026quot;%d\u0026quot;, \u0026amp;m); int ans = 0; while (m--) { int type, l, r; scanf(\u0026quot;%d%d%d\u0026quot;, \u0026amp;type, \u0026amp;l, \u0026amp;r); l = (l + ans - 1) % n + 1; r = (r + ans - 1) % n + 1; if (l \u0026gt; r) swap(l, r); if (type == 1) { auto it = lst[bl[r]].begin(); for (int i = bll[bl[r]]; i \u0026lt; r; ++i) ++it; int tmp = *it; --cnt[bl[r]][tmp]; ++cnt[bl[l]][tmp]; lst[bl[r]].erase(it); it = lst[bl[l]].begin(); for (int i = bll[bl[l]]; i \u0026lt; l; ++i) ++it; lst[bl[l]].insert(it, tmp); for (int i = bl[l]; i \u0026lt; bl[r]; ++i) { int t = lst[i].back(); lst[i].pop_back(); lst[i + 1].push_front(t); --cnt[i][t]; ++cnt[i + 1][t]; } } else { int k; scanf(\u0026quot;%d\u0026quot;, \u0026amp;k); k = (k + ans - 1) % n + 1; ans = 0; if (bl[l] == bl[r]) { auto it = lst[bl[l]].begin(); for (int i = bll[bl[l]]; i \u0026lt;= r; ++i) { if (i \u0026gt;= l) ans += *it == k; ++it; } } else { auto it = lst[bl[l]].begin(); for (int i = bll[bl[l]]; i \u0026lt;= blr[bl[l]]; ++i) { if (i \u0026gt;= l) ans += *it == k; ++it; } it = lst[bl[r]].begin(); for (int i = bll[bl[r]]; i \u0026lt;= r; ++i) { ans += *it == k; ++it; } for (int i = bl[l] + 1; i \u0026lt; bl[r]; ++i) ans += cnt[i][k]; } printf(\u0026quot;%d\\n\u0026quot;, ans); } } return 0; }   nlog^2n 做法（Splay） #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;queue\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; struct Node; int n, m; vector\u0026lt;int\u0026gt; a; vector\u0026lt;Node *\u0026gt; rt; vector\u0026lt;queue\u0026lt;Node *\u0026gt; \u0026gt; q; // q[i] 存的是值为 i 的数在 t_0 中对应的节点 Node *empty, *lsen, *rsen; struct Node { int val, siz; Node *pa, *mir; // mir 是在 t_0 中对应的节点 vector\u0026lt;Node *\u0026gt; ch; Node(Node *_pa = empty, int _val = 0, Node *_mir = empty) { siz = 1; pa = _pa; mir = _mir; val = _val; ch.resize(2, empty); } }; void pushup(Node *x) { x-\u0026gt;siz = x-\u0026gt;ch[0]-\u0026gt;siz + x-\u0026gt;ch[1]-\u0026gt;siz + 1; } void rotate(Node *x) { Node *y = x-\u0026gt;pa; Node *z = y-\u0026gt;pa; int k = x == y-\u0026gt;ch[1]; z-\u0026gt;ch[y == z-\u0026gt;ch[1]] = x; x-\u0026gt;pa = z; y-\u0026gt;ch[k] = x-\u0026gt;ch[k ^ 1]; x-\u0026gt;ch[k ^ 1]-\u0026gt;pa = y; x-\u0026gt;ch[k ^ 1] = y; y-\u0026gt;pa = x; pushup(y); pushup(x); } void Splay(Node *x, Node *goal) { while (x-\u0026gt;pa != goal) { Node *y = x-\u0026gt;pa; Node *z = y-\u0026gt;pa; if (z != goal) rotate((x == y-\u0026gt;ch[1]) ^ (y == z-\u0026gt;ch[1]) ? x : y); rotate(x); } } void makeroot(Node *\u0026amp; root, Node *x) { Splay(x, empty); root = x; } Node* kth(Node *root, int x) { Node *u = root; while (1) { if (u-\u0026gt;ch[0]-\u0026gt;siz \u0026gt;= x) u = u-\u0026gt;ch[0]; else if (u-\u0026gt;ch[0]-\u0026gt;siz + 1 == x) return u; else { x -= u-\u0026gt;ch[0]-\u0026gt;siz + 1; u = u-\u0026gt;ch[1]; } } } int rk(Node *\u0026amp; root, Node *x) { makeroot(root, x); return x-\u0026gt;ch[0]-\u0026gt;siz + 1; } void link(Node *\u0026amp; root, Node *x, Node *y, int type = 0) { makeroot(root, y); if (root-\u0026gt;ch[type] != empty) { Node *u = kth(y-\u0026gt;ch[0], y-\u0026gt;ch[0]-\u0026gt;siz); makeroot(root, u); } y-\u0026gt;ch[type] = x; x-\u0026gt;pa = y; pushup(y); if (y-\u0026gt;pa != empty) pushup(y-\u0026gt;pa); } void cut(Node *\u0026amp; root, Node *x) { makeroot(root, x); Node *u = kth(x-\u0026gt;ch[0], x-\u0026gt;ch[0]-\u0026gt;siz); makeroot(root, u); u-\u0026gt;ch[1] = x-\u0026gt;ch[1]; x-\u0026gt;ch[1]-\u0026gt;pa = u; x-\u0026gt;ch[0] = x-\u0026gt;ch[1] = x-\u0026gt;pa = empty; x-\u0026gt;siz = 1; pushup(u); } Node* rkle(Node *root, int x) { Node *u = root; while (1) { if (u-\u0026gt;ch[1] != empty \u0026amp;\u0026amp; rk(rt[0], kth(u-\u0026gt;ch[1], 1)-\u0026gt;mir) \u0026lt;= x) u = u-\u0026gt;ch[1]; else if (rk(rt[0], u-\u0026gt;mir) \u0026lt;= x) return u; else u = u-\u0026gt;ch[0]; } } Node* rkge(Node *root, int x) { Node *u = root; while (1) { if (u-\u0026gt;ch[0] != empty \u0026amp;\u0026amp; rk(rt[0], kth(u-\u0026gt;ch[0], u-\u0026gt;ch[0]-\u0026gt;siz)-\u0026gt;mir) \u0026gt;= x) u = u-\u0026gt;ch[0]; else if (rk(rt[0], u-\u0026gt;mir) \u0026gt;= x) return u; else u = u-\u0026gt;ch[1]; } } Node* split(Node *\u0026amp; root, int l, int r) { Node *x = kth(root, l); Node *y = kth(root, r + 2); makeroot(root, x); Splay(y, x); return y-\u0026gt;ch[0]; } Node* get(Node *\u0026amp; root, int p) { Node *x = rkle(root, p); Node *y = rkge(root, p + 2); makeroot(root, x); Splay(y, x); return y-\u0026gt;ch[0]; } Node* build1(vector\u0026lt;int\u0026gt;::iterator l, vector\u0026lt;int\u0026gt;::iterator r, Node *pa) { if (l == r) return empty; auto mid = l + (r - l) / 2; Node *cur = new Node(pa, *mid); cur-\u0026gt;ch[0] = build1(l, mid, cur); q[*mid].push(cur); cur-\u0026gt;ch[1] = build1(mid + 1, r, cur); pushup(cur); return cur; } void build1(Node *\u0026amp; root, vector\u0026lt;int\u0026gt;\u0026amp; a) { root = build1(a.begin(), a.end(), empty); lsen = new Node(); link(root, lsen, kth(root, 1)); rsen = new Node(); link(root, rsen, kth(root, root-\u0026gt;siz), 1); } Node* build2(int l, int r, int val, Node *pa) { if (l == r) return empty; int mid = (l + r) \u0026gt;\u0026gt; 1; Node *cur = new Node(pa, val); cur-\u0026gt;ch[0] = build2(l, mid, val, cur); cur-\u0026gt;mir = q[val].front(); q[val].pop(); cur-\u0026gt;ch[1] = build2(mid + 1, r, val, cur); pushup(cur); return cur; } void build2(Node *\u0026amp; root, int size, int val) { if (size == 0) return; root = build2(0, size, val, empty); Node *lsentry = new Node(empty, 0, lsen); link(root, lsentry, kth(root, 1)); Node *rsentry = new Node(empty, 0, rsen); link(root, rsentry, kth(root, root-\u0026gt;siz), 1); } int main() { empty = new Node(); empty-\u0026gt;siz = 0; empty-\u0026gt;ch[0] = empty-\u0026gt;ch[1] = empty-\u0026gt;pa = empty-\u0026gt;mir = empty; scanf(\u0026quot;%d\u0026quot;, \u0026amp;n); a.resize(n, 0); for (int i = 0; i \u0026lt; n; ++i) scanf(\u0026quot;%d\u0026quot;, \u0026amp;a[i]); rt.resize(n + 1); q.resize(n + 1); build1(rt[0], a); for (int i = 1; i \u0026lt;= n; ++i) build2(rt[i], q[i].size(), i); scanf(\u0026quot;%d\u0026quot;, \u0026amp;m); int ans = 0; while (m--) { int type, l, r; scanf(\u0026quot;%d%d%d\u0026quot;, \u0026amp;type, \u0026amp;l, \u0026amp;r); l = (l + ans - 1) % n + 1; r = (r + ans - 1) % n + 1; if (l \u0026gt; r) swap(l, r); if (type == 1) { if (l == r) continue; Node *x = split(rt[0], l, r); Node *y = kth(x, 1); Node *z = kth(x, x-\u0026gt;siz); int k = z-\u0026gt;val; x = get(rt[k], r); cut(rt[k], x); Node *qaq = rkle(rt[k], l); Node *qwq = rkge(rt[k], l + 1); makeroot(rt[k], qaq); Splay(qwq, qaq); link(rt[k], x, qwq); cut(rt[0], z); link(rt[0], z, y); } else { int k; scanf(\u0026quot;%d\u0026quot;, \u0026amp;k); k = (k + ans - 1) % n + 1; if (rt[k] == 0) { ans = 0; puts(\u0026quot;0\u0026quot;); continue; } Node *x = rkle(rt[k], l); Node *y = rkge(rt[k], r + 2); makeroot(rt[k], x); Splay(y, x); ans = y-\u0026gt;ch[0]-\u0026gt;siz; printf(\u0026quot;%d\\n\u0026quot;, ans); } } return 0; }  ","date":"2019-12-04T15:20:52+08:00","permalink":"https://ouuan.github.io/post/cf455d-serega-and-fun%E5%88%86%E5%9D%97-%E5%B9%B3%E8%A1%A1%E6%A0%91/","tags":["分块","平衡树","数据结构"],"title":"CF455D Serega and Fun（分块 / 平衡树）"},{"categories":["题解"],"contents":"题目链接 CF\n题意简述 定义一个“偶环”为边数为偶数的回路（回路又被称作“边简单环”，即不经过重复边且首尾点相同的途径）。\n给你一张不含“偶环”的无向图。称一个区间是“好的”，当且仅当编号在这个区间中的点的导出子图是一张二分图。\n多组询问，每次询问一个给定区间有多少个子区间是“好的”。\n点数、边数、询问数均不超过 $3\\cdot 10^5$ 。\n简要做法 由于图中没有偶环，容易想到一个子图是二分图等价于没有环（因为二分图等价于没有奇环）。\n但“没有偶环”的用处远不止此：没有偶环还意味着每个点最多处于一个环内（否则取两个包含同一个点的奇环，把重复的边去掉，就可以得到一个偶环）。\n那么，找出图中的每个环的最小节点编号和最大节点编号，以最小值和最大值作为左右端点，就可以得到若干条线段。而一个区间合法就等价于其不包含这些线段中的任意一条。\n现在问题已经转化成了：给你 $k$ 条线段 $\\{[c_i, d_i]\\}_{i=1}^k$，$q$ 次询问，第 $i$ 次询问给你一个区间 $[l_i, r_i]$，求 $[l_i, r_i]$ 有多少个子区间不包含这 $k$ 条线段中的任意一条。\n首先，可以观察到，若有一条线段被另一条线段完全包含，包含它的这条线段就可以被无视了。\n去除掉上述无用线段后，剩下的线段两两互不包含，那么将它们按左端点排序，会满足：$\\forall 1\\le i\u0026lt; k, c_i\u0026lt; c_{i+1}, d_i\u0026lt; d_{i+1}$ （不取等号是因为 $1\\sim n$ 中的每个数在 $c_{1..n}$ 和 $d_{1..n}$ 中最多只出现一次，而这是因为在原题意中每个点最多处于一个环内）。\n如果不管 $r_i$ 的限制，对于每个左端点求答案，画个图手玩一下可以发现，以 $p$ 为左端点时，合法区间的右端点最多到 $\\min\\left(\\{d_j-1|c_j\\ge p\\}\\bigcup\\{n\\}\\right)$ ，即 $p$ “右边”的第一条线段的右端点减一（不存在则为 $n$）。每个左端点无视右端点限制的合法区间数可以求个前缀和，而 $p$ “右边”的第一条线段可以二分求得，也可以线性预处理后 $O(1)$ 求得。那么，我们就会做 $r_i=n$ 的情况了。\n然后考虑如何处理 $r_i$ 的限制。对称地（指这个式子和上面那个式子几乎是对称的），令 $t=\\max\\left(\\{c_j|d_j\\le r_i\\}\\bigcup\\{0\\}\\right)$，即 $r_i$ “左边”的第一条线段的左端点（不存在则为 $0$），那么对于不小于 $t$ 的左端点，$r_i$ 这个限制是无用的，而对于大于 $t$ 的左端点，右端点最多可以取到 $r_i$ 。 $t$ 同样可以二分求得或者线性预处理后 $O(1)$ 求得，将左端点分成 $[l_i, t]$ 和 $[t+1, r_i]$ 两部分，前半部分用前缀和计算，后半部分即为 $[t+1, r_i]$ 的子区间数，然后就做完了。实现时注意特判 $t\u0026lt; l_i$ 的情况。\n参考代码 #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; vector\u0026lt;int\u0026gt; pa, dfn, rt, uncut; vector\u0026lt;vector\u0026lt;int\u0026gt; \u0026gt; g; int n, m, q, dfntot; vector\u0026lt;ll\u0026gt; pre; vector\u0026lt;pii\u0026gt; s; void dfs(int u) { dfn[u] = ++dfntot; for (auto v : g[u]) { if (v == pa[u]) continue; if (!dfn[v]) { pa[v] = u; dfs(v); } else if (dfn[v] \u0026lt; dfn[u]) { int mn = u, mx = u, x = u; while (x != v) { x = pa[x]; mn = min(mn, x); mx = max(mx, x); } rt[mn] = mx; } } } int main() { scanf(\u0026quot;%d%d\u0026quot;, \u0026amp;n, \u0026amp;m); g.resize(n + 1); pa.resize(n + 1, 0); pre.resize(n + 1, 0); dfn.resize(n + 1, 0); uncut.resize(n + 1, 0); rt.resize(n + 1, n + 1); for (int i = 1; i \u0026lt;= m; ++i) { int u, v; scanf(\u0026quot;%d%d\u0026quot;, \u0026amp;u, \u0026amp;v); g[u].push_back(v); g[v].push_back(u); } for (int i = 1; i \u0026lt;= n; ++i) if (!dfn[i]) dfs(i); int mn = n; for (int i = n; i \u0026gt;= 1; --i) { mn = min(mn, rt[i]); if (rt[i] \u0026lt;= mn) s.push_back(pii(i, rt[i])); } reverse(s.begin(), s.end()); s.push_back(pii(n + 1, n + 1)); int p = 0, ban = s[0].second; for (int i = 1; i \u0026lt;= n; ++i) { if (i \u0026gt; s[p].first) ban = s[++p].second; pre[i] = pre[i - 1] + ban - i; uncut[i] = uncut[i - 1] + (i == s[uncut[i - 1]].second); } scanf(\u0026quot;%d\u0026quot;, \u0026amp;q); while (q--) { int l, r; scanf(\u0026quot;%d%d\u0026quot;, \u0026amp;l, \u0026amp;r); int k = uncut[r]; if (k == 0 || s[k - 1].first \u0026lt; l) printf(\u0026quot;%I64d\\n\u0026quot;, (ll) (r - l + 1) * (r - l + 2) / 2); else printf(\u0026quot;%I64d\\n\u0026quot;, pre[s[k - 1].first] - pre[l - 1] + (ll) (r - s[k - 1].first) * (r - s[k - 1].first + 1) / 2); } return 0; } ","date":"2019-11-29T20:54:11+08:00","permalink":"https://ouuan.github.io/post/cf901c-bipartite-segments%E4%BA%8C%E5%88%86%E5%9B%BE/","tags":["二分图"],"title":"CF901C Bipartite Segments（二分图）"},{"categories":["题解"],"contents":"题目链接 CF\n题意简述 给你一棵树，每个点的颜色为一个区间内的整数，一种染色方案的权值是所有同色无序点对的距离之和，求所有不同染色方案的权值之和。\n点数、颜色数均不超过 $10^5$ 。\n简要做法 首先是 $O(n^2)$ 做法：把计算总和转化为计算期望，然后就可以枚举点对，计算同色概率，乘上距离，最后把期望乘上方案数就是答案。进行 $n$ 次 DFS 而不是每次求 LCA 就可以做到 $O(n^2)$ 。\n然后是 $O(n\\log n\\log c)$（$c$ 为颜色数）做法：点分治，令 $f(u, v)=\\max(0, \\min(r_u, r_v)-\\max(l_u, l_v)+1)$, 点 $u$ 的贡献是 $\\sum_{v}f(u, v)(dep_u+dep_v)(r_u-l_u+1)^{-1}(r_v-l_v+1)^{-1}$，即 $\\left(dep_u\\cdot(r_u-l_u+1)^{-1}\\right)\\cdot\\left(\\sum_{v}f(u, v)(r_v-l_v+1)^{-1}\\right)+(r_u-l_u+1)^{-1}\\cdot\\left(\\sum_{v}f(u, v)dep_v(r_v-l_v+1)^{-1}\\right)$ ，用以颜色为下标、支持区间加/查询区间和的线段树维护 $\\sum_{v}(r_v-l_v+1)^{-1}$ 以及 $\\sum_{v}dep_v(r_v-l_v+1)^{-1}$ 即可。\n如果你写的是其它 $O(n\\log n\\log c)$ 做法，如链分治（dsu on tree），或者你的常数比较小（比如使用树状数组而不是线段树），你可能就过了。\n否则，你可能 TLE on 6 或者 TLE on 14 之类的。\n但是，大常数选手并不是没有活路的，因为这题有 $O(n\\log n)$ 做法。\n其中一种，是使用差分代替上述做法中的线段树。但如果在点分治内进行比较排序，复杂度是 $O(n\\log^2 n)$（尽管瓶颈部分的常数很小），解决方法是在点分治的外部进行一次排序，然后在内部就可以线性地将每棵子树的修改与询问划分开来。\n“划分”本质上是一个双关键字排序，第一关键字为所在子树的编号，第二关键字为修改/询问原本的排序方式，利用基数排序的思想，由于第二关键字已经有序，对第一关键字进行稳定排序即可。使用计数排序可以做到线性复杂度，总复杂度就是 $O(n\\log n)$ 。\n参考代码 nlognlogc #ifndef OUUAN #pragma GCC optimize(\u0026quot;Ofast,no-stack-protector,unroll-loops,fast-math\u0026quot;) #endif #include\u0026lt;bits/stdc++.h\u0026gt; //#define int LoveLive //#define FAST_IOSTREAM 1 #define For(i,l,r)for(int i=(l),i##end=(r);i\u0026lt;=i##end;++i) #define FOR(i,r,l)for(int i=(r),i##end=(l);i\u0026gt;=i##end;--i) #define SON(i,u)for(int i=head[u];i;i=nxt[i]) #define ms(a,x)memset(a,x,sizeof(a)) #define fi first #define se second #define pb emplace_back #define pq priority_queue #define isinf(x)(x\u0026gt;=INF?-1:x) #define y1 why_is_there_a_function_called_y1 #define DEBUG(x)cerr\u0026lt;\u0026lt;(#x)\u0026lt;\u0026lt;\u0026quot;:\u0026quot;\u0026lt;\u0026lt;x\u0026lt;\u0026lt;endl using namespace std;typedef long long LoveLive;typedef pair\u0026lt;int,int\u0026gt;pii;typedef vector\u0026lt;int\u0026gt;vi;typedef long double ld;const double inf=1e121;const double eps=1e-10;mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());int randint(int l,int r){int out=rng()%(r-l+1)+l;return out\u0026gt;=l?out:out+r-l+1;} #ifdef int const int INF=0x3f3f3f3f3f3f3f3fll; #else const int INF=0x3f3f3f3f;typedef long long ll; #endif #ifdef FAST_IOSTREAM #define br cout\u0026lt;\u0026lt;'\\n' #define sp cout\u0026lt;\u0026lt;' ' long long read(){long long x;cin\u0026gt;\u0026gt;x;return x;}template\u0026lt;typename T\u0026gt;void read(T\u0026amp;x){cin\u0026gt;\u0026gt;x;}template\u0026lt;typename T\u0026gt;void write(const T\u0026amp;x){cout\u0026lt;\u0026lt;x;} #else #define br putchar('\\n') #define sp putchar(' ') template\u0026lt;typename T\u0026gt;typename enable_if\u0026lt;!is_integral\u0026lt;T\u0026gt;::value,void\u0026gt;::type read(T\u0026amp;x){cin\u0026gt;\u0026gt;x;}long long read(){char c;long long out=0,f=1;for(c=getchar();!isdigit(c)\u0026amp;\u0026amp;c!='-';c=getchar());if(c=='-'){f=-1;c=getchar();}for(;isdigit(c);c=getchar())out=(out\u0026lt;\u0026lt;3)+(out\u0026lt;\u0026lt;1)+c-'0';return out*f;}template\u0026lt;typename T\u0026gt;typename enable_if\u0026lt;is_integral\u0026lt;T\u0026gt;::value,T\u0026gt;::type read(T\u0026amp;x){char c;T f=1;x=0;for(c=getchar();!isdigit(c)\u0026amp;\u0026amp;c!='-';c=getchar());if(c=='-'){f=-1;c=getchar();}for(;isdigit(c);c=getchar())x=(x\u0026lt;\u0026lt;3)+(x\u0026lt;\u0026lt;1)+c-'0';return x*=f;}char read(char\u0026amp;x){for(x=getchar();isspace(x);x=getchar());return x;}double read(double\u0026amp;x){scanf(\u0026quot;%lf\u0026quot;,\u0026amp;x);return x;}ld read(ld\u0026amp;x){scanf(\u0026quot;%Lf\u0026quot;,\u0026amp;x);return x;}template\u0026lt;typename T\u0026gt;typename enable_if\u0026lt;!is_integral\u0026lt;T\u0026gt;::value,void\u0026gt;::type write(const T\u0026amp;x){cout\u0026lt;\u0026lt;x;}template\u0026lt;typename T\u0026gt;typename enable_if\u0026lt;is_integral\u0026lt;T\u0026gt;::value,void\u0026gt;::type write(const T\u0026amp;x){if(x\u0026lt;0){putchar('-');write(-x);return;}if(x\u0026gt;9)write(x/10);putchar(x%10+'0');}void write(const char\u0026amp;x){putchar(x);}void write(const double\u0026amp;x){printf(\u0026quot;%.10lf\u0026quot;,x);}void write(const ld\u0026amp;x){printf(\u0026quot;%.10Lf\u0026quot;,x);} #endif template\u0026lt;typename T,typename...Args\u0026gt;void read(T\u0026amp;x,Args\u0026amp;...args){read(x);read(args...);}template\u0026lt;typename OutputIt,typename=typename enable_if\u0026lt;is_same\u0026lt;output_iterator_tag,typename iterator_traits\u0026lt;OutputIt\u0026gt;::iterator_category\u0026gt;::value||(is_base_of\u0026lt;forward_iterator_tag,typename iterator_traits\u0026lt;OutputIt\u0026gt;::iterator_category\u0026gt;::value\u0026amp;\u0026amp;!is_const\u0026lt;OutputIt\u0026gt;::value)\u0026gt;::type\u0026gt;void read(OutputIt __first,OutputIt __last){for(;__first!=__last;++__first)read(*__first);}template\u0026lt;typename InputIt,typename=typename enable_if\u0026lt;is_base_of\u0026lt;input_iterator_tag,typename iterator_traits\u0026lt;InputIt\u0026gt;::iterator_category\u0026gt;::value\u0026gt;::type\u0026gt;void wts(InputIt __first,InputIt __last){bool isFirst=true;for(;__first!=__last;++__first){if(isFirst)isFirst=false;else sp;write(*__first);}br;}template\u0026lt;typename InputIt,typename=typename enable_if\u0026lt;is_base_of\u0026lt;input_iterator_tag,typename iterator_traits\u0026lt;InputIt\u0026gt;::iterator_category\u0026gt;::value\u0026gt;::type\u0026gt;void wtb(InputIt __first,InputIt __last){for(;__first!=__last;++__first){write(*__first);br;}}template\u0026lt;typename T\u0026gt;void wts(const T\u0026amp;x){write(x);sp;}template\u0026lt;typename T\u0026gt;void wtb(const T\u0026amp;x){write(x);br;}template\u0026lt;typename T\u0026gt;void wte(const T\u0026amp;x){write(x);exit(0);}template\u0026lt;typename T,typename...Args\u0026gt;void wts(const T\u0026amp;x,Args...args){wts(x);wts(args...);}template\u0026lt;typename T,typename...Args\u0026gt;void wtb(const T\u0026amp;x,Args...args){wts(x);wtb(args...);}template\u0026lt;typename T,typename...Args\u0026gt;void wte(const T\u0026amp;x,Args...args){wts(x);wte(args...);}template\u0026lt;typename T\u0026gt;inline bool up(T\u0026amp;x,const T\u0026amp;y){return x\u0026lt;y?x=y,1:0;}template\u0026lt;typename T\u0026gt;inline bool dn(T\u0026amp;x,const T\u0026amp;y){return y\u0026lt;x?x=y,1:0;}template\u0026lt;typename T\u0026gt;inline bool inRange(const T\u0026amp;x,const T\u0026amp;l,const T\u0026amp;r){return!(x\u0026lt;l)\u0026amp;\u0026amp;!(r\u0026lt;x);}template\u0026lt;typename valueType,typename tagType\u0026gt;class segmentTreeNode{public:int id,left,right;valueType val;tagType tag;};template\u0026lt;typename valueType, typename tagType, valueType(*merge)(valueType,valueType), void(*update)(segmentTreeNode\u0026lt;valueType,tagType\u0026gt;\u0026amp;,tagType)\u0026gt;class segmentTree{private:std::vector\u0026lt;segmentTreeNode\u0026lt;valueType,tagType\u0026gt;\u0026gt;nodes;int leftRange,rightRange;valueType valueZero;tagType tagZero;void pushup(int cur){nodes[cur].val=merge(nodes[cur\u0026lt;\u0026lt;1].val,nodes[cur\u0026lt;\u0026lt;1|1].val);}void pushdown(int cur){update(nodes[cur\u0026lt;\u0026lt;1],nodes[cur].tag);update(nodes[cur\u0026lt;\u0026lt;1|1],nodes[cur].tag);nodes[cur].tag=tagZero;}void build(int cur,int l,int r,const std::vector\u0026lt;valueType\u0026gt;\u0026amp;initValue){nodes[cur].id=cur;nodes[cur].left=l;nodes[cur].right=r;nodes[cur].tag=tagZero;if(l==r-1)nodes[cur].val=initValue[l-leftRange];else{build(cur\u0026lt;\u0026lt;1,l,(l+r)\u0026gt;\u0026gt;1,initValue);build(cur\u0026lt;\u0026lt;1|1,(l+r)\u0026gt;\u0026gt;1,r,initValue);pushup(cur);}}void init(const std::vector\u0026lt;valueType\u0026gt;\u0026amp;_initValue,const valueType\u0026amp;_valueZero,const tagType\u0026amp;_tagZero){valueZero=_valueZero;tagZero=_tagZero;nodes.resize((rightRange-leftRange)\u0026lt;\u0026lt;2);build(1,leftRange,rightRange,_initValue);}void modify(int cur,int l,int r,int L,int R,const tagType\u0026amp;tag){if(l\u0026gt;=R||r\u0026lt;=L)return;if(L\u0026lt;=l\u0026amp;\u0026amp;r\u0026lt;=R)update(nodes[cur],tag);else{pushdown(cur);modify(cur\u0026lt;\u0026lt;1,l,(l+r)\u0026gt;\u0026gt;1,L,R,tag);modify(cur\u0026lt;\u0026lt;1|1,(l+r)\u0026gt;\u0026gt;1,r,L,R,tag);pushup(cur);}}valueType query(int cur,int l,int r,int L,int R){if(l\u0026gt;=R||r\u0026lt;=L)return valueZero;if(L\u0026lt;=l\u0026amp;\u0026amp;r\u0026lt;=R)return nodes[cur].val;pushdown(cur);return merge(query(cur\u0026lt;\u0026lt;1,l,(l+r)\u0026gt;\u0026gt;1,L,R), query(cur\u0026lt;\u0026lt;1|1,(l+r)\u0026gt;\u0026gt;1,r,L,R));}public:segmentTree(){}segmentTree(int _leftRange,int _rightRange,const std::vector\u0026lt;valueType\u0026gt;\u0026amp;_initValue,const valueType\u0026amp;_valueZero,const tagType\u0026amp;_tagZero){leftRange=_leftRange;rightRange=_rightRange;init(_initValue,_valueZero,_tagZero);}segmentTree(int size,const std::vector\u0026lt;valueType\u0026gt;\u0026amp;_initValue,const valueType\u0026amp;_valueZero,const tagType\u0026amp;_tagZero){leftRange=1;rightRange=size+1;init(_initValue,_valueZero,_tagZero);}void modify(int l,int r,const tagType\u0026amp;tag){modify(1,leftRange,rightRange,l,r,tag);}void modify(int p,const tagType\u0026amp;tag){modify(p,p+1,tag);}valueType query(int l,int r){return query(1,leftRange,rightRange,l,r);}valueType query(int p){return query(p,p+1);}};class maxFlow{private:typedef long long ll;std::queue\u0026lt;int\u0026gt;q;std::vector\u0026lt;int\u0026gt;head,cur,nxt,to,dep;std::vector\u0026lt;ll\u0026gt;cap;public:maxFlow(int _n=0){init(_n);}void init(int _n){head.clear();head.resize(_n+1,0);nxt.resize(2);to.resize(2);cap.resize(2);}void init(){init(head.size()-1);}void add(int u,int v,ll w){nxt.push_back(head[u]);head[u]=to.size();to.push_back(v);cap.push_back(w);}void Add(int u,int v,ll w){add(u,v,w);add(v,u,0);}void del(int x){cap[x\u0026lt;\u0026lt;1]=cap[x\u0026lt;\u0026lt;1|1]=0;}bool bfs(int s,int t){dep.clear();dep.resize(head.size(),-1);dep[s]=0;q.push(s);while(!q.empty()){int u=q.front();q.pop();for(int i=head[u];i;i=nxt[i]){int v=to[i];ll w=cap[i];if(w\u0026gt;0\u0026amp;\u0026amp;dep[v]==-1){dep[v]=dep[u]+1;q.push(v);}}}return ~dep[t];}ll dfs(int u,ll flow,int t){if(dep[u]==dep[t])return u==t?flow:0;ll out=0;for(int\u0026amp;i=cur[u];i;i=nxt[i]){int v=to[i];ll w=cap[i];if(w\u0026gt;0\u0026amp;\u0026amp;dep[v]==dep[u]+1){ll f=dfs(v,std::min(w,flow-out),t);cap[i]-=f;cap[i ^ 1]+=f;out+=f;if(out==flow)return out;}}return out;}ll maxflow(int s,int t){ll out=0;while(bfs(s,t)){cur=head;out+=dfs(s,0x7fffffffffffffffll,t);}return out;}ll getflow(int x)const{return cap[x\u0026lt;\u0026lt;1|1];}};struct customHash{static uint64_t splitmix64(uint64_t x){x+=0x9e3779b97f4a7c15;x=(x ^(x\u0026gt;\u0026gt;30))*0xbf58476d1ce4e5b9;x=(x ^(x\u0026gt;\u0026gt;27))*0x94d049bb133111eb;return x ^(x\u0026gt;\u0026gt;31);}size_t operator()(uint64_t x)const{static const uint64_t FIXED_RANDOM=rng();return splitmix64(x+FIXED_RANDOM);}}; typedef pair\u0026lt;bool, pii\u0026gt; pbii; const int W = 100000; const int mod = (1e9 + 7//, 998244353 ); vector\u0026lt;vi\u0026gt; g; vector\u0026lt;bool\u0026gt; vis; int n, tsiz, rt, ans; vi l, r, siz, wt, inv; int qpow(int x, int y) { int out = 1; while (y) { if (y \u0026amp; 1) out = (ll) out * x % mod; x = (ll) x * x % mod; y \u0026gt;\u0026gt;= 1; } return out; } int modadd(int x, int y) { return (x += y) \u0026gt;= mod ? x - mod : x; } pii merge(pii x, pii y) { return pii(modadd(x.fi, y.fi), modadd(x.se, y.se)); } void update(segmentTreeNode\u0026lt;pii, pbii\u0026gt;\u0026amp; u, pbii x) { if (x.first) { u.tag = pbii(true, pii(0, 0)); u.val = pii(0, 0); } else if (x.se == pii(0, 0)) return; u.tag.se = merge(u.tag.se, x.se); u.val.fi = (u.val.fi + (ll) x.se.fi * (u.right - u.left)) % mod; u.val.se = (u.val.se + (ll) x.se.se * (u.right - u.left)) % mod; } segmentTree\u0026lt;pii, pbii, merge, update\u0026gt; t(W, vector\u0026lt;pii\u0026gt;(W, pii(0, 0)), pii(0, 0), pbii(false, pii(0, 0))); void getroot(int u, int pa) { siz[u] = wt[u] = 1; for (auto v : g[u]) { if (v == pa || vis[v]) continue; getroot(v, u); siz[u] += siz[v]; up(wt[u], siz[v]); } up(wt[u], tsiz - siz[u]); if (!rt || wt[u] \u0026lt; wt[rt]) rt = u; } void calc(int u, int pa, int dep) { auto res = t.query(l[u], r[u] + 1); ans = (ans + (ll) inv[u] * dep % mod * res.fi + (ll) inv[u] * res.se) % mod; for (auto v : g[u]) { if (v == pa || vis[v]) continue; calc(v, u, dep + 1); } } void insert(int u, int pa, int dep) { t.modify(l[u], r[u] + 1, pbii(false, pii(inv[u], (ll) inv[u] * dep % mod))); for (auto v : g[u]) { if (v == pa || vis[v]) continue; insert(v, u, dep + 1); } } void solve(int u) { vis[u] = true; t.modify(1, W + 1, pbii(true, pii(0, 0))); t.modify(l[u], r[u] + 1, pbii(false, pii(inv[u], 0))); for (auto v : g[u]) { if (vis[v]) continue; calc(v, u, 1); insert(v, u, 1); } for (auto v : g[u]) { if (vis[v]) continue; rt = 0; tsiz = siz[v]; getroot(v, u); solve(rt); } } signed main() { #ifdef FAST_IOSTREAM cin.sync_with_stdio(false); cin.tie(0); #endif read(n); l.resize(n + 1); g.resize(n + 1); vis.resize(n + 1, false); r = wt = siz = inv = l; For (i, 1, n) { read(l[i], r[i]); inv[i] = qpow(r[i] - l[i] + 1, mod - 2); } For (i, 2, n) { int u, v; read(u, v); g[u].pb(v); g[v].pb(u); } tsiz = n; getroot(1, 0); solve(rt); for (int i = 1; i \u0026lt;= n; ++i) ans = (ll) ans * (r[i] - l[i] + 1) % mod; cout \u0026lt;\u0026lt; ans; return 0; }   nlogn#1 #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; typedef long long ll; const int mod = 1e9 + 7; int qpow(int x, int y) { int out = 1; while (y) { if (y \u0026amp; 1) out = (ll) out * x % mod; x = (ll) x * x % mod; y \u0026gt;\u0026gt;= 1; } return out; } vector\u0026lt;bool\u0026gt; vis; int n, tsiz, rt, ans; vector\u0026lt;vector\u0026lt;int\u0026gt; \u0026gt; g; vector\u0026lt;int\u0026gt; siz, wt, bel, dep, inv; struct Modification { int id, p, inv, l; Modification(int _id, int _p, int _inv, int _l): id(_id), p(_p), inv(_inv), l(_l) {} bool operator\u0026lt;(const Modification\u0026amp; b) const { return p \u0026lt; b.p; } int k1() const { return inv; } int b1() const { return p == l ? (ll) (1 - l + mod) * k1() % mod : (ll) (mod - p + 1) * k1() % mod; } int k2() const { return (ll) inv * dep[id] % mod; } int b2() const { return p == l ? (ll) (1 - l + mod) * k2() % mod : (ll) (mod - p + 1) * k2() % mod; } }; struct Query { int id, p, inv; Query(int _id, int _p, int _inv): id(_id), p(_p), inv(_inv) {} bool operator\u0026lt;(const Query\u0026amp; b) const { return p \u0026lt; b.p; } void calc(int x1, int x2, int type) const { ans = (ans + (ll) type * inv * ((ll) dep[id] * x1 % mod + x2) % mod + mod) % mod; } }; void getroot(int u, int pa) { siz[u] = wt[u] = 1; for (auto v : g[u]) { if (v == pa || vis[v]) continue; getroot(v, u); siz[u] += siz[v]; wt[u] = max(wt[u], siz[v]); } wt[u] = max(wt[u], tsiz - siz[u]); if (!rt || wt[u] \u0026lt; wt[rt]) rt = u; } void calc(const vector\u0026lt;Modification\u0026gt;\u0026amp; ms, const vector\u0026lt;Query\u0026gt;\u0026amp; qs, int type) { int k1 = 0, b1 = 0, k2 = 0, b2 = 0, i = 0; for (auto q : qs) { while (i \u0026lt; ms.size() \u0026amp;\u0026amp; ms[i].p \u0026lt;= q.p) { k1 = (k1 + ms[i].k1()) % mod; b1 = (b1 + ms[i].b1()) % mod; k2 = (k2 + ms[i].k2()) % mod; b2 = (b2 + ms[i].b2()) % mod; ++i; } q.calc(((ll) k1 * q.p + b1) % mod, ((ll) k2 * q.p + b2) % mod, type); } } void dfs(int u, int pa) { for (auto v : g[u]) { if (v == pa || vis[v]) continue; dep[v] = dep[u] + 1; bel[v] = bel[u]; dfs(v, u); } } void solve(int u, vector\u0026lt;Modification\u0026gt;\u0026amp; ms, vector\u0026lt;Query\u0026gt;\u0026amp; qs) { vis[u] = true; vector\u0026lt;vector\u0026lt;Query\u0026gt; \u0026gt; qson(1, vector\u0026lt;Query\u0026gt;()); vector\u0026lt;vector\u0026lt;Modification\u0026gt; \u0026gt; mson(1, vector\u0026lt;Modification\u0026gt;()); for (auto v : g[u]) { if (vis[v]) continue; mson.push_back(vector\u0026lt;Modification\u0026gt;()); qson.push_back(vector\u0026lt;Query\u0026gt;()); bel[v] = mson.size() - 1; dep[v] = 1; dfs(v, u); } bel[u] = dep[u] = 0; calc(ms, qs, 1); for (auto m : ms) mson[bel[m.id]].push_back(m); for (auto q : qs) qson[bel[q.id]].push_back(q); vector\u0026lt;Modification\u0026gt;().swap(ms); // free memory, the memory complexity is O(n) instead of O(nlogn) because of these two lines vector\u0026lt;Query\u0026gt;().swap(qs); for (auto v : g[u]) { if (vis[v]) continue; calc(mson[bel[v]], qson[bel[v]], -1); tsiz = siz[v]; rt = 0; getroot(v, u); solve(rt, mson[bel[v]], qson[bel[v]]); } } int main() { scanf(\u0026quot;%d\u0026quot;, \u0026amp;n); g.resize(n + 1); siz.resize(n + 1, 0); vis.resize(n + 1, false); wt = bel = dep = inv = siz; vector\u0026lt;Modification\u0026gt; ms; vector\u0026lt;Query\u0026gt; qs; int mul = (mod + 1) / 2; for (int i = 1; i \u0026lt;= n; ++i) { int l, r; scanf(\u0026quot;%d%d\u0026quot;, \u0026amp;l, \u0026amp;r); mul = (ll) mul * (r - l + 1) % mod; inv[i] = qpow(r - l + 1, mod - 2); ms.push_back(Modification(i, l, inv[i], l)); ms.push_back(Modification(i, r + 1, mod - inv[i], l)); qs.push_back(Query(i, l - 1, mod - inv[i])); qs.push_back(Query(i, r, inv[i])); } for (int i = 1; i \u0026lt; n; ++i) { int u, v; scanf(\u0026quot;%d%d\u0026quot;, \u0026amp;u, \u0026amp;v); g[u].push_back(v); g[v].push_back(u); } sort(ms.begin(), ms.end()); sort(qs.begin(), qs.end()); tsiz = n; getroot(1, 0); solve(rt, ms, qs); cout \u0026lt;\u0026lt; (ll) ans * mul % mod; return 0; }   nlogn#2 #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; typedef long long ll; const int mod = 1e9 + 7; static unsigned fast_mod(uint64_t x) { #if !defined(_WIN32) || defined(_WIN64) return x % mod; #endif // Optimized mod for Codeforces 32-bit machines. // x must be less than 2^32 * m for this to work, so that x / m fits in a 32-bit integer. unsigned x_high = x \u0026gt;\u0026gt; 32, x_low = (unsigned) x; unsigned quot, rem; asm(\u0026quot;divl %4\\n\u0026quot; : \u0026quot;=a\u0026quot; (quot), \u0026quot;=d\u0026quot; (rem) : \u0026quot;d\u0026quot; (x_high), \u0026quot;a\u0026quot; (x_low), \u0026quot;r\u0026quot; (mod)); return rem; } int modadd(int x, int y) { return (x += y) \u0026gt;= mod ? x - mod : x; } int qpow(int x, int y) { int out = 1; while (y) { if (y \u0026amp; 1) out = fast_mod((ll) out * x); x = fast_mod((ll) x * x); y \u0026gt;\u0026gt;= 1; } return out; } vector\u0026lt;bool\u0026gt; vis; int n, tsiz, rt, ans; vector\u0026lt;vector\u0026lt;int\u0026gt; \u0026gt; g; vector\u0026lt;int\u0026gt; siz, wt, bel, dep, inv, cnt, ma, mb, qa, qb; struct Modification { int id, p, inv, l; Modification(int _id, int _p, int _inv, int _l): id(_id), p(_p), inv(_inv), l(_l) {} bool operator\u0026lt;(const Modification\u0026amp; b) const { return p \u0026lt; b.p; } int k1() const { return inv; } int b1() const { return p == l ? fast_mod((ll) (1 - l + mod) * k1()) : fast_mod((ll) (mod - p + 1) * k1()); } int k2() const { return (ll) inv * dep[id] % mod; } int b2() const { return p == l ? fast_mod((ll) (1 - l + mod) * k2()) : fast_mod((ll) (mod - p + 1) * k2()); } }; vector\u0026lt;Modification\u0026gt; ms; struct Query { int id, p, inv; Query(int _id, int _p, int _inv): id(_id), p(_p), inv(_inv) {} bool operator\u0026lt;(const Query\u0026amp; b) const { return p \u0026lt; b.p; } void calc(int x1, int x2, int type) const { ans = fast_mod(ans + type * fast_mod((ll) inv * (fast_mod((ll) dep[id] * x1 + x2))) + mod); } }; vector\u0026lt;Query\u0026gt; qs; void getroot(int u, int pa) { siz[u] = wt[u] = 1; for (auto v : g[u]) { if (v == pa || vis[v]) continue; getroot(v, u); siz[u] += siz[v]; wt[u] = max(wt[u], siz[v]); } wt[u] = max(wt[u], tsiz - siz[u]); if (!rt || wt[u] \u0026lt; wt[rt]) rt = u; } void calc(int l, int r, int type) { int k1 = 0, b1 = 0, k2 = 0, b2 = 0, i = l; for (int j = l; j \u0026lt;= r; ++j) { Query\u0026amp; q = qs[qa[j]]; while (i \u0026lt;= r) { Modification\u0026amp; m = ms[ma[i]]; if (m.p \u0026gt; q.p) break; k1 = modadd(k1, m.k1()); b1 = modadd(b1, m.b1()); k2 = modadd(k2, m.k2()); b2 = modadd(b2, m.b2()); ++i; } q.calc(fast_mod((ll) k1 * q.p + b1), fast_mod((ll) k2 * q.p + b2), type); } } void dfs(int u, int pa) { cnt[bel[u]] += 2; for (auto v : g[u]) { if (v == pa || vis[v]) continue; dep[v] = dep[u] + 1; bel[v] = bel[u]; dfs(v, u); } } void solve(int u, int l, int r) { vis[u] = true; int soncnt = bel[u] = dep[u] = 0; cnt[0] = l + 1; for (auto v : g[u]) { if (vis[v]) continue; bel[v] = ++soncnt; cnt[bel[v]] = cnt[bel[v] - 1]; dep[v] = 1; dfs(v, u); } calc(l, r, 1); vector\u0026lt;int\u0026gt; cnt2(cnt.begin(), cnt.begin() + soncnt + 1); for (int i = r; i \u0026gt;= l; --i) mb[cnt2[bel[ms[ma[i]].id]]--] = ma[i]; for (int i = l; i \u0026lt;= r; ++i) ma[i] = mb[i]; for (int i = 0; i \u0026lt;= soncnt; ++i) cnt2[i] = cnt[i]; for (int i = r; i \u0026gt;= l; --i) qb[cnt2[bel[qs[qa[i]].id]]--] = qa[i]; for (int i = l; i \u0026lt;= r; ++i) qa[i] = qb[i]; for (int i = 0; i \u0026lt;= soncnt; ++i) cnt2[i] = cnt[i]; for (auto v : g[u]) { if (vis[v]) continue; calc(cnt2[bel[v] - 1] + 1, cnt2[bel[v]], -1); tsiz = siz[v]; rt = 0; getroot(v, u); solve(rt, cnt2[bel[v] - 1] + 1, cnt2[bel[v]]); } } int main() { scanf(\u0026quot;%d\u0026quot;, \u0026amp;n); g.resize(n + 1); siz.resize(n + 1, 0); vis.resize(n + 1, false); wt = bel = dep = inv = cnt = siz; int mul = (mod + 1) / 2; for (int i = 1; i \u0026lt;= n; ++i) { int l, r; scanf(\u0026quot;%d%d\u0026quot;, \u0026amp;l, \u0026amp;r); mul = fast_mod((ll) mul * (r - l + 1)); inv[i] = qpow(r - l + 1, mod - 2); ms.push_back(Modification(i, l, inv[i], l)); ms.push_back(Modification(i, r + 1, mod - inv[i], l)); qs.push_back(Query(i, l - 1, mod - inv[i])); qs.push_back(Query(i, r, inv[i])); } for (int i = 1; i \u0026lt; n; ++i) { int u, v; scanf(\u0026quot;%d%d\u0026quot;, \u0026amp;u, \u0026amp;v); g[u].push_back(v); g[v].push_back(u); } ma.resize(n * 2); mb = qa = qb = ma; for (int i = 0; i \u0026lt; n * 2; ++i) ma[i] = qa[i] = i; sort(ma.begin(), ma.end(), [](int x, int y) { return ms[x] \u0026lt; ms[y]; }); sort(qa.begin(), qa.end(), [](int x, int y) { return qs[x] \u0026lt; qs[y]; }); tsiz = n; getroot(1, 0); solve(rt, 0, 2 * n - 1); cout \u0026lt;\u0026lt; fast_mod((ll) ans * mul); return 0; }  ","date":"2019-11-29T14:00:53+08:00","permalink":"https://ouuan.github.io/post/cf1260f-colored-tree%E7%82%B9%E5%88%86%E6%B2%BB%E5%B7%AE%E5%88%86%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F/","tags":["点分治","差分","基数排序","数据结构","概率期望","分治"],"title":"CF1260F Colored Tree（点分治，差分，基数排序）"},{"categories":["技术"],"contents":"本文讲的是自己搭建的 UOJ 如何解决无限 waiting，而不是 https://uoj.ac 如何解决无限 waiting（后者大概要联系 vfk..反正我是没遇到过）。\n这个问题困扰了我很久..\n然后在若干次数据回滚后，我发现每次都是使用 git 后出现无限 waiting。进而发现是在 git reset --hard 后发生这种情况。\n最后，我发现了问题的真正原因：git 把某些文件的权限改了，导致 docker 启动时无法运行 judger。\n解决方法：\ndocker exec -it uoj chmod +x /opt/uoj/judger/judge_client docker exec -it uoj chown local_main_judger: /opt/uoj/judger/log/judger.log docker restart uoj  （当然，如果你改了 docker 容器名 / judger 用户名，甚至网页和 judger 不是同一个 docker，就不能照搬上面的命令了。）\n","date":"2019-11-28T20:10:41+08:00","permalink":"https://ouuan.github.io/post/uoj-%E6%97%A0%E9%99%90-waiting-%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/","tags":["OJ"],"title":"UOJ 无限 waiting 的解决方法"},{"categories":["题解"],"contents":"题目链接 UOJ\n洛谷\n题意简述 给你一棵树，$i$ 号点有 $p_i$、$q_i$ 和 $l_i$ 三个属性，每条边有给定的长度。\n从一个点出发可以到达其祖先中与其距离不超过 $l_i$ 的点，费用为 $p_i\\cdot dis+q_i$，求每个点到根的最小费用。\n点数不超过 $2\\cdot 10^5$ 。\n简要做法 用 $dis[i]$ 表示$i$ 到根的距离，$f_i$ 表示点 $i$ 的答案，那么： $$ f_i=\\min\\limits_{\\begin{array}{cc}j\\text{ is an ancestor of }i\\\\dis[j]\\ge dis[i]-l_i\\end{array}}\\{f_j-p_i dis[j]+p_i dis[i]+q[i]\\} $$ 这个东西可以用斜率优化，然而有三个不太友好的地方：\n 这是棵树； 有 $dis[j]\\ge dis[i]-l_i$ 这个限制； $p_i$ 不是单调的。  类似于 「NOI2007」货币兑换 ，可以用类似于 CDQ 分治的点分治来解决上述三个问题。（然而我不仅没做过货币兑换，而且想到这个做法的时候都没意识到它是 CDQ 分治，只是在 四色的 NOI 中听说了这题可以点分治然后就 yy 出来了..）\n具体来说，每个转移都可以看成一条路径，但只有竖直向上的路径是合法的，所以“向上”的那个子树需要特殊处理。类似于 CDQ 分治先处理左半部分再计算左半部分对右半部分的贡献，这题每次分治时先处理“向上”的那个子树，然后用分治中心到根的链除了分治中心本身外在当前分治树上的部分来更新分治中心的 DP 值，再用分治中心到根的链在当前分治树上的部分来更新除了“向上”的那个外的其它子树的 DP 值，最后再分治下去处理除了“向上”的那个外的其它子树。\n更新除了“向上”的那个外的其它子树的 DP 值时，需要把这些子树里的点按 $dis[i]-l_i$ 排序，然后从下往上把分治中心到根的链在当前分治树上的部分在可行时加入凸包。\n由于 $p_i$ 不是单调的，并不是用单调队列/单调栈维护凸包，而是保留整个凸包，查询的时候二分。\n用叉积判斜率会爆 long long，可以用 __int128 / double 解决。\n总复杂度 $O(n\\log^2 n)$ 。\n参考代码 #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; typedef long long ll; const ll INF = 1e18; vector\u0026lt;bool\u0026gt; vis; int n, type, tsiz, rt; vector\u0026lt;vector\u0026lt;int\u0026gt; \u0026gt; g; vector\u0026lt;ll\u0026gt; dis, p, q, k, f; vector\u0026lt;int\u0026gt; siz, wt, dep, pa; void getroot(int u, int fa) { siz[u] = wt[u] = 1; for (int i = 0; i \u0026lt; g[u].size(); ++i) { int v = g[u][i]; if (v == fa || vis[v]) continue; getroot(v, u); siz[u] += siz[v]; wt[u] = max(wt[u], siz[v]); } wt[u] = max(wt[u], tsiz - siz[u]); if (!rt || wt[u] \u0026lt; wt[rt]) rt = u; } void getchildren(int u, vector\u0026lt;int\u0026gt;\u0026amp; children) { for (int i = 0; i \u0026lt; g[u].size(); ++i) { int v = g[u][i]; if (v == pa[u] || vis[v]) continue; children.push_back(v); getchildren(v, children); } } bool cmp(int x, int y) { return dis[x] - k[x] \u0026gt; dis[y] - k[y]; } bool check(int x, int y, int z) { return 1.0 * (f[x] - f[y]) / (dis[x] - dis[y]) \u0026lt; 1.0 * (f[y] - f[z]) / (dis[y] - dis[z]); } ll calc(int i, int j) { return f[j] + p[i] * (dis[i] - dis[j]) + q[i]; } void solve(int u) { vis[u] = true; vector\u0026lt;int\u0026gt; anc(1, u); while (pa[anc.back()] \u0026amp;\u0026amp; !vis[pa[anc.back()]]) anc.push_back(pa[anc.back()]); if (anc.size() \u0026gt; 1) { rt = 0; tsiz = siz[pa[u]]; getroot(pa[u], u); solve(rt); for (int i = 1; i \u0026lt; anc.size() \u0026amp;\u0026amp; dis[anc[i]] \u0026gt;= dis[u] - k[u]; ++i) f[u] = min(f[u], calc(u, anc[i])); } vector\u0026lt;int\u0026gt; children; getchildren(u, children); sort(children.begin(), children.end(), cmp); vector\u0026lt;int\u0026gt; convex; int t = 0; for (int i = 0; i \u0026lt; children.size(); ++i) { int v = children[i]; while (t \u0026lt; anc.size() \u0026amp;\u0026amp; dis[anc[t]] \u0026gt;= dis[v] - k[v]) { while (convex.size() \u0026gt;= 2 \u0026amp;\u0026amp; check(convex[convex.size() - 2], convex.back(), anc[t])) convex.pop_back(); convex.push_back(anc[t++]); } if (convex.empty()) continue; int l = 0, r = convex.size() - 1; while (l \u0026lt; r) { int mid = (l + r + 1) \u0026gt;\u0026gt; 1; if (mid \u0026amp;\u0026amp; calc(v, convex[mid - 1]) \u0026lt; calc(v, convex[mid])) r = mid - 1; else l = mid; } f[v] = min(f[v], calc(v, convex[l])); } for (int i = 0; i \u0026lt; children.size(); ++i) { int v = children[i]; if (v == pa[u] || vis[v]) continue; rt = 0; tsiz = siz[v]; getroot(v, u); solve(v); } } int main() { scanf(\u0026quot;%d%d\u0026quot;, \u0026amp;n, \u0026amp;type); vis.resize(n + 1, false); f.resize(n + 1, INF); dis.resize(n + 1, 0); dep.resize(n + 1, 0); siz.resize(n + 1, 0); wt.resize(n + 1, 0); pa.resize(n + 1, 0); g.resize(n + 1); p.resize(n + 1); q.resize(n + 1); k.resize(n + 1); for (int i = 2; i \u0026lt;= n; ++i) { scanf(\u0026quot;%d%lld%lld%lld%lld\u0026quot;, \u0026amp;pa[i], \u0026amp;dis[i], \u0026amp;p[i], \u0026amp;q[i], \u0026amp;k[i]); g[pa[i]].push_back(i); g[i].push_back(pa[i]); dis[i] += dis[pa[i]]; } f[1] = 0; tsiz = n; getroot(1, 0); solve(rt); for (int i = 2; i \u0026lt;= n; ++i) printf(\u0026quot;%lld\\n\u0026quot;, f[i]); return 0; } ","date":"2019-11-25T16:07:04+08:00","permalink":"https://ouuan.github.io/post/noi2014%E8%B4%AD%E7%A5%A8%E6%96%9C%E7%8E%87%E4%BC%98%E5%8C%96%E7%82%B9%E5%88%86%E6%B2%BB/","tags":["斜率优化","点分治","cdq分治","分治"],"title":"「NOI2014」购票（斜率优化，点分治）"},{"categories":["经历"],"contents":"怀着伤感的心情写下这段文字，然后开始一段新的征程。\nStarting point 看到左边那几排灰色的方格了吗。\n第一个绿色的方格是 2018 年 12 月 4 日。\n那是什么日子呢？\n要说的话，那是我开始使用 hexo 博客的日子。\n那还是我得知自己在 NOIP2018 中夺得 HB rk1 后不久。\n在那之后没过几天，我坐上高铁，第一次长期（大于一周）在外参加集训。\n也就是那时，我谋生了办一场 CF 的想法。\n使用 hexo 博客，也让我从一个 Github 的旁观者，变成了使用者。\n究竟是其中的哪一个，改变了故事的主人公，我们不得而知。\n但那天，就这样成了故事的起点。\nProblem Setting 故事的第一站，叫做 Problem Setting 。\n这一站很长，可以说从故事开始前——2018 年 8 月——就开始了。那是两场洛谷公开赛，非酋yyf的sif之旅 与 蒟蒻们的补番之旅 。它们并不完善，所以这两场旅途并没有被纳入本文所讲的这个故事之中。\n这一站的故事我也曾经讲述过，题目叫做 「bad round 与出题人的坚守」 。\n这其中的过程其实并不重要，但就像 后记 中所说的，这一站改变了故事的主人公。\n他会对有漏洞的题面感到愤怒——无论是自己过去出的题，还是在哪看到的题目。\nCodeforces Round #564，在 CF 上留下的只是八道题目与若干 rating 的变化，但它让故事的主人公对事物的看法有了变化：\n 我讨厌不用心的出题人，讨厌不严谨甚至误导人的博客，因为，我认为出题给别人做、写博客给别人看是应当对别人负责的。如果没有精力、不想负责的话，出题给自己做，博客保存在本地就好了，发出来干什么？即使是能力不够，也得有认真负责的态度才行。如果没有，别人骂你，只当骂醒好了。如果骂不醒，那着实该骂。\n当我指出其他人题目里的种种不足，当我抛开他人博客中不严谨的话语而豁然开朗大叫原文之漏洞满篇时，有没有想过他人付出的心血呢？当然有，只是我认为尊重不是基于付出，而是基于负责的态度，基于真正做了什么的。就好比你追一个女孩子，辛辛苦苦付出了那么多，如果不提升自己，如果不付出真心，别人凭什么喜欢你？\n说到底，对写给别人的东西负责，是我自己的一种坚守，我自己并不是总能做到，也不是生来就能做到。但我会努力去做，无论在怎样的大环境下，我想尽我所能创造一片小小的净土。\n 很快，他将发现，他不止学会了出题。\nGithub Github 是什么？\n它不只是一个 “代码托管平台”，更是一个 “开源社区”。\n在这里，你可以参与他人的项目，也可以让自己的项目被更多人发现，让他人也能够参与其中。\n在这个故事中，我们的主人公也写过一些小东西，虽然都不是什么大工程，但也列在这了，有兴趣的读者不妨翻一翻，看看有没有什么能够用得上的：一些有趣的小工程 。\n这一站只是故事的一个小插曲，让我们接着往下。\nOI Wiki OI Wiki 又是什么呢？\n它也是托管在 Github 上的一个开源项目，可它和上面刚刚说过的那些小东西不同，OI Wiki 是一个有着 3.5k stars 和 700+ forks (截至 2019.11.23) 的大项目。\n那是一个崇尚知识自由的 OI 学习资源整合站点，可它，很不完善。\n信步在 OI Wiki 中的主人公，发现了满眼的空白与漏洞。\n他意识到这是怎样的一个平台——它不像出题，只是昙花一现，若题目不够优美，还不知是否有人从中有所收获；它不像写博客，在这个平台上，会有人和你一起协作，也有更多的目光，聚焦在你敲打出的文字之上。\n这一站究竟发生了什么？时至今日，我也说不清楚，留下的只有数字：59 pull requests，182 commits，7966 additions ，4675 delections ，100 pull requests reviewed。\n伴随着这些数字的，还有一个谜一样的 OIer，他从不在机房打游戏，但他的提交记录却总是寥寥无几。\nValue 这个故事，好像不是很长，那我们来讲一讲故事之外的一些内容，有关一个看似失败的 OIer 背后的故事。\n一切得追溯到一本叫做 从零开始学理财 的书，书中的内容我都不太记得了，故事的主人公现在也对经济不是很感兴趣，那是他小学一二年级时看的，现在只记得其中的一个片段：\n 有次李嘉诚结束酒会，出酒店刚要上车，一枚一元硬币掉落，滚向下水道，李嘉诚便紧走几步要赶上去捡取。\n旁边酒店门童眼疾手快，从地上捡起硬币，交给李嘉诚。李嘉诚很高兴，当即给了门童 100 元小费。\n据说李嘉诚是这样说的：“如果我不捡，这一元就从市面消失，毫无价值，而门童捡起来给了我，我的一元没有丢失；门童为我保住一元，值得奖励，100 元他花出去可以吃好的，可以给家人买东西，很有意义，谁都没有损失。”\n 这个故事的真假暂且不论，丢失一元硬币在经济学意义上究竟带来了什么也不重要，但这个故事给他展示了一个新的视角，一个从全局看问题的视角。\n在小学四年级的奥数课上，他又学习了“统筹与规划”，知道了人们排队打水时应当如何安排顺序。\n在听说了囚徒困境，并在生活中找到了无数个实例后，他发现，合作博弈的平衡点与非合作博弈截然不同。\nvfk 所写的 美在这里 点醒了他，让他看到了 「美就在人与人的相互帮助，相互信任中」，明白了 UOJ 精神之源流究竟在何处。\n在 OI 的学习中，一个又一个的最优化问题，让他明白了，看问题不能片面。\n在 CF contribution 机制的激励下，他登上了中国 contribution 榜的顶峰。\n经过上面那个故事，contribute 已经成了他生活的一部分。\n三月のライオン 中 ひなた 喊出的 「後悔なんてしないっっ しちゃダメだっ だって 私のした事は ぜったい まちがってなんか ない！」，让他坚定了自己的决心。\n他给自己的价值观下了定义：以最大化社会全体成员的利益总和为目标。\n这不是利他主义：自己是社会全体的一部分，他人的利益不比自己的利益重要，但多数人的利益往往更加重要。\n这一价值观也不会让他帮助恶人，因为这会间接地使他人利益受损。这也使他明白，惩治恶人的目的不是报复，而是使其改过自新，不再作恶。\n这一价值观还让他相信，竞争是以共同进步为目的的，正如他在博客的「关于」一栏中所写，「我不想和他人争抢保送的名额，但我现阶段的梦想，是提高国家集训队第 50 名的水平」，他相信竞争的受益者不会是少数人，而是全体。\n他不能做到像雷锋一样总是帮助身边的人，他不懂如何安慰他人，如何鼓励他人，如何在恰当的时候给身边的人以帮助，他也不愿花费比受益人所受之益更大的代价来帮助他人。所以，他选择了 contribute ，选择了在排队时等在最后，选择了在车厢上有空位时若没有其他人站着便坐下。\nFuture 但他在 contribute 这条路上渐行渐远，回头望去时，他发现，自己无法像 ひなた 一样，坚信自己所做是没有错的。\n 感觉 NOIP 时期自己还是有点智商的，从去广二集训起智商严重下滑。\n自从搭了 hexo 博客经常沉迷开发、写工程。然而到现在 Python、JS 什么的还严重依赖搜索引擎。\n自从在 CF 出了题，经常沉迷喷出题人、帮出题人改题面、写出题规范，甚至不切实际地希望洛谷公开赛能有所改善。\nCF contribution 还挺高的，但 rating 已经大半年停滞不前了。\n总之最近一年学了别人一个月就能学完的知识点，但智商下滑，导致水平没有提高。倒是学习了各种各样 contribute 的姿势。感觉要退役。\n 他意识到，自己的视角虽然够广，但还不够长远。\n他想起了自己的梦想，想起了曾经立下的誓言。\n是时候把手头的事情放下了，变得更像一名 OIer。\n直到 2021 年的夏日，无论是一路在 OI 之路上前行，还是走上高考这条道路。\n他在心里暗暗发誓，到那时，他还要回归 contribute 这条不归路，继续走下去。\n一句话题意 我直到高中毕业大概都不会再参与出题 / 写 OI Wiki 等 contribute 性质的活动了。\n","date":"2019-11-23T19:28:56+08:00","permalink":"https://ouuan.github.io/post/2019%E4%BB%A5%E5%8F%8A%E6%AF%95%E4%B8%9A%E4%B9%8B%E5%89%8D/","tags":["contribute"],"title":"2019，以及毕业之前"},{"categories":["游记"],"contents":"标题来自 三月のライオン Chapter.64 銀の羽根 ：\n 答案只在漆黑的水底。\n越是前进，下一个答案就只能在更深的地方找到。\n以前越是潜入，就能获得答案。\n比起恐怖，欲望更胜一筹。\n但是成为职业棋手 6 年后，如今变得完全不能前进。\n即便带着要撕碎全身的想法去潜入，但是却空手而回，已经是很常见的事了。\n比起 「也许能找到」，「反正又不一定能找到」这个念头胜利的时候，就只能进行有限的努力了。\n但是，桐山和二海堂无视了那样的我。\n理所当然一样无论多少次都跳入其中。根本就不正常。\n他们即便屡次空手而归，也会制定对策继续挑战。\n丝毫不介意痛苦，无论多少次都投身其中。\n只留下，被恐惧压倒的我。\n Day 1 像往常一样，听了 YUKI 的两首三狮 OP 和 IOI2018 主题曲，抽签进考场。\n由于自己还算小有名气，这次也不是 NOI 或是什么比赛，只是 CSP，于是避开了人群，也并没有人过来搭话。大概不露出准考证上的名字的话，其他人要么不认识我，要么已经退役了，要么知道我实际上有多菜吧。\nT1 当然是看完题就会做了。$n\\le 64$ 真毒瘤，只不过给个 $95%$ 的 $k\\le 2^{63}-1$ 提示太明显了（然而后 $50%$ 的数据 $n$ 还是可以到 $64$\u0026hellip;不知道有没有这样的数据）。\nT2 一开始想了个神秘的树套树做法，感觉非常蠢，于是去看 T3，发现并不会做，就把 T2 的 $O(n^3)$ 和 T3 的暴力写了。\n写完之后想到了若干 T2 的假做法，然后想到了一个略麻烦的线性做法，只不过写起来也没花太多时间。拍上的时候已经 10:30 了，好像比大众 AC 时间 9:00 晚了不少。\n之后开始自闭。大概 11:20 的时候去上了个厕所，想到了个感觉挺对的做法：把删边视作给边编号，每个点出发先走编号最小的出边，然后走来到当前点的边在当前点出边中编号的后继。于是可以关于每个点用链表维护一个出边的顺序，再枚举每个数字，DFS 求出它的终点可以在哪些位置，选择其中最小的一个。感觉挺难写的，11:54 的时候算是写完了，但由于赶时间几乎是乱写的，测样例 RE 了，于是就注释掉了，换成了暴力。\n我是从学 OI 一个月起就 using namespace std; 的选手，但这次就突然想不 using 来防止 CE，而且每题都在 NOI Linux 虚拟机下编译了，但 11:58 的时候突然发现自己 T3 暴力的 next_permutation 没有加 std，不是很清楚为什么不会 CE，当时的代码也没有了，可能是我哪看错了，总之我最后是把 using namespace std; 加上了..\n所以说不要试图在考场上改代码习惯。\n考场须知的签名是在监考说考试结束之后写的，写的时候手都在抖..所以说最后 10min 都别写代码了，5min 根本不够。\n考完立刻出了考场，无视掉身边所有人，假装世界上只有自己一个人考了 CSP（\n然后由于最后搞得有点紧张，还有神秘的 std::next_permutation 事件，一直担心文件错误 / CE 。于是就下了一下午（酒馆战）棋，试图忘掉 Day 1。\n可是屏蔽 QQ 并不能妨碍我妈晚餐时告诉我人均 210，myh AK 之类的。\nDay 2 今天是一次崭新的比赛（自我洗脑成功）。\n依然是 YUKI 的两首三狮 OP 和 IOI2018 主题曲，然而因为估错时间，为了避免听车载广播，多听了一遍 Euphoria 。\n今天不用校内集合，然而考场在 8 楼，于是要坐电梯。只不过还是没人过来搭话。\nT1，怎么是计数啊（\n看了几分钟感觉不太会做，人要懵了，这是 D2T1 吗（\n冷静了一下，想到一个假的 $O(n^2m)$ 做法。\n然后去看 T2，怎么办我只会 $O(n^3)$..但 $O(n^2)$ 好像很可做的样子。\n然后去看 T3，怎么办我只会 $O(n^2)$..但链和菊花好像很可做的样子。\n写 T1 写到一半，发现自己假了。冷静了一下，想到一个 $O(n^3m)$ 做法。8700k 应该啥都能过吧.png\n写完一测，4.8s，人没了。\n卡了卡常，3.6s，人没了。\n开 O2，1.2s。但要是手开 O2 我就真没了。怎么手写取模优化啊.png\n然后去写 T2，还没开始写就发现可以 $O(n^2\\log n)$。写完一测，5s，我又没了。发现多次二分可以用双指针（在 一些注意事项 中有），于是就 $O(n^2)$ 了，跑的挺快。\n然后去写 T3。$O(n^2)$ 挺好写的。链好像很简单。完美二叉树是啥..手画一下，发现剩下来较大的那部分的重心只能是根或根的儿子或根和根的儿子，于是也很好写。\n此时 11:00 了。\n为什么我不会做 D2T1 啊..于是选择去看 T1。这个背包可以 NTT 优化吗..在脑内思考了 5s NTT 是否应当出现在 CSP 中后，我成功算错了复杂度，以为它是 $O(n^2m\\log)$ 的，然后写了个极限数据跑 80s 的 $O(n^2m\\log^2)$\u0026hellip;\n最后也没有获得更多分数了。只不过这天提前 10min 就开始检查文件相关问题了。而且全部都 using namespace std; 了，也在 NOI Linux 下编译了。感觉挺放心的。\n这次出来没有直接跑掉，然后就听说闫老师 A 了 T1，T2 88。还听说华一前几天校内讲了 T2..\n在回家的路上被告知下午要去学校上 whk..然后书包都没拿（实际上书包里也没有任何 whk 相关的东西），吃完饭就去了，还迟到了 5min。\n听说是与前段时间内容无关的物理课，然后还真是与前面的电学无关的动量，给人的感觉几乎是接着我停课前往后讲，于是还算顺畅。\n选修 3-5 后面的几章还稍微有一点点涉及电学内容，量子力学什么的也没有完全看懂，计算什么的都跳过了，然而我晚自习就顺着把书看完了（感觉看完后啥都没学会）。\nDay 3 上午是快乐的 whk 生活。语文课讲期中考试卷子，我就拿别人的卷子看了下上面的几篇阅读。数学课讲求导，于是就写了下物理作业（没毛病）。化学课完全自闭了，于是就写完了物理作业（另一种意义上的没毛病）。\n下午好像啥都没干，看着闫老师和肖老师拿民间数据测全省，然后发现 jxl 可能 535\u0026hellip;\n晚上写游记。\n然后发现 D1T3 wqy 的题解好像和我的思路差不多，就试图拿我的考场代码调，发现调不出来，就重写了一遍，调过小样例之后获得了链的 25 分..\nDay 4 今天上了一整天 whk，上午还是化学自闭，其它课还好，下午是体检 \u0026amp; 地理 \u0026amp; 政治（马上学考了）。\n晚上过来给 UOJ #487 加了个负自环的样例，稍微修了下题面。第一次用 svn。（并不知道 UOJ 社区版把 svn 阉割掉之后怎么远程下载数据，只不过 Hinata Online Judge 是资瓷的。）\n然后继续调 D1T3，一开始用 $n=10$ 的数据调自闭了，对拍出 $n=4$ 的数据之后 5min 就调出来了..\n感觉要是头脑清醒而且像兔那样 30min AC T1T2，还是能在考场上写出来的..\n题解 D1T1 依题意模拟，记得开 unsigned long long 。\n考场代码 #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstdio\u0026gt; typedef unsigned long long ull; void solve(int n, ull k) { if (n == 0) return; if (k \u0026lt; (1ull \u0026lt;\u0026lt; (n - 1))) { std::cout \u0026lt;\u0026lt; 0; solve(n - 1, k); } else { std::cout \u0026lt;\u0026lt; 1; solve(n - 1, (1ull \u0026lt;\u0026lt; (n - 1)) - 1 - (k \u0026amp; ((1ull \u0026lt;\u0026lt; (n - 1)) - 1))); } } int main() { int n; ull k; std::cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; k; solve(n, k); puts(\u0026quot;\u0026quot;); return 0; }   D1T2 我的考场做法好像比较麻烦..\n大致思路是定义一个点的权值是它到根的路径上左括号个数减去右括号个数，并且维护每个点向上多少个点满足右括号个数之和不少于左括号个数之和，后面这个东西维护的时候要分几种情况讨论。\n维护了这两个信息，每个点新增的合法括号串就是一段区间里权值为某个数的点的个数，离线下来就可以 $O(n)$ 且无需高级数据结构地解决了。\n考场代码 #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;fstream\u0026gt; using std::cin; using std::string; using std::vector; typedef long long ll; typedef std::pair\u0026lt;int, int\u0026gt; pii; int n; string s, t; vector\u0026lt;ll\u0026gt; ans; vector\u0026lt;vector\u0026lt;int\u0026gt; \u0026gt; g; vector\u0026lt;vector\u0026lt;pii\u0026gt; \u0026gt; q; vector\u0026lt;int\u0026gt; jump, tot, pa; void dfs(int u, int cnt) { cnt += s[u - 1] == '(' ? 1 : -1; if (s[u - 1] == ')') ans[u] = tot[cnt + n]; if (u == 1) jump[u] = 1; else if (s[u - 1] == ')') jump[u] = jump[pa[jump[pa[u]]]]; else if (s[pa[u] - 1] == ')') jump[u] = jump[pa[pa[u]]]; else jump[u] = u; if (s[u - 1] == ')') q[pa[pa[jump[pa[u]]]]].push_back(pii(u, cnt)); ++tot[cnt + n]; for (int i = 0; i \u0026lt; g[u].size(); ++i) dfs(g[u][i], cnt); for (int i = 0; i \u0026lt; q[u].size(); ++i) ans[q[u][i].first] -= tot[q[u][i].second + n]; --tot[cnt + n]; } int main() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; s; g.resize(n + 1); q.resize(n + 1); ans.resize(n + 1); pa.resize(n + 1, 0); jump.resize(n + 1, 1); tot.resize(2 * n + 1, 0); for (int i = 2; i \u0026lt;= n; ++i) { cin \u0026gt;\u0026gt; pa[i]; g[pa[i]].push_back(i); } jump[0] = 1; tot[n] = 1; dfs(1, 0); ll out = ans[1]; for (int i = 2; i \u0026lt;= n; ++i) { ans[i] += ans[pa[i]]; out ^= ans[i] * i; } std::cout \u0026lt;\u0026lt; out \u0026lt;\u0026lt; std::endl; return 0; }   D1T3 （我在游记里说过大致思路了。）\n把删边视作给边编号，每个点出发先走编号最小的出边，然后走来到当前点的边在当前点出边中编号的后继。于是可以关于每个点用链表维护一个出边的顺序，再枚举每个数字，DFS 求出它的终点可以在哪些位置，选择其中最小的一个。\n然后会发现有很多细节，使用并查集会比链表好写一些（虽然复杂度会略微大一点点）。\n代码是调试了一万遍写出来的，可能有地方会有些冗余..\n参考代码 #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; vector\u0026lt;bool\u0026gt; able; vector\u0026lt;vector\u0026lt;bool\u0026gt; \u0026gt; haspre; vector\u0026lt;int\u0026gt; a, pa, ans, head, tail; vector\u0026lt;vector\u0026lt;int\u0026gt; \u0026gt; f, g, nxt, siz; int find(int u, int x) { return x == f[u][x] ? x : f[u][x] = find(u, f[u][x]); } void dfs(int u) { if (!pa[u]) { if (head[u]) { int v = head[u]; pa[v] = u; dfs(v); } else { for (int i = 0; i \u0026lt; g[u].size(); ++i) { int v = g[u][i]; if (!haspre[u][v] \u0026amp;\u0026amp; !(tail[u] \u0026amp;\u0026amp; find(u, v) == find(u, tail[u]) \u0026amp;\u0026amp; siz[u][find(u, v)] \u0026lt; g[u].size())) { pa[v] = u; dfs(v); } } } } else { if (nxt[u][pa[u]]) { int v = nxt[u][pa[u]]; pa[v] = u; dfs(v); } else { if (!tail[u] \u0026amp;\u0026amp; !(find(u, pa[u]) == find(u, head[u]) \u0026amp;\u0026amp; siz[u][find(u, head[u])] \u0026lt; g[u].size())) able[u] = true; if (find(u, pa[u]) != find(u, tail[u])) { for (int i = 0; i \u0026lt; g[u].size(); ++i) { int v = g[u][i]; if (find(u, v) != find(u, head[u]) \u0026amp;\u0026amp; find(u, pa[u]) != find(u, v) \u0026amp;\u0026amp; !haspre[u][v] \u0026amp;\u0026amp; !(find(u, pa[u]) == find(u, head[u]) \u0026amp;\u0026amp; find(u, v) == find(u, tail[u]) \u0026amp;\u0026amp; siz[u][find(u, pa[u])] + siz[u][find(u, v)] \u0026lt; g[u].size())) { pa[v] = u; dfs(v); } } } } } } void apply(int u, int from) { if (!from) tail[u] = pa[u]; else if (!pa[u]) { head[u] = from; return; } else { nxt[u][pa[u]] = from; haspre[u][from] = true; siz[u][find(u, from)] += siz[u][find(u, pa[u])]; f[u][find(u, pa[u])] = find(u, from); } apply(pa[u], u); } int main() { int T; cin \u0026gt;\u0026gt; T; while (T--) { int n; cin \u0026gt;\u0026gt; n; a.resize(n + 1); ans.resize(n + 1); head.assign(n + 1, 0); tail.assign(n + 1, 0); g.assign(n + 1, vector\u0026lt;int\u0026gt;()); f.assign(n + 1, vector\u0026lt;int\u0026gt;(n + 1, 0)); siz.assign(n + 1, vector\u0026lt;int\u0026gt;(n + 1, 1)); nxt.assign(n + 1, vector\u0026lt;int\u0026gt;(n + 1, 0)); haspre.assign(n + 1, vector\u0026lt;bool\u0026gt;(n + 1, false)); for (int i = 1; i \u0026lt;= n; ++i) cin \u0026gt;\u0026gt; a[i]; for (int i = 1; i \u0026lt; n; ++i) { int u, v; cin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; v; g[u].push_back(v); g[v].push_back(u); f[u][v] = v; f[v][u] = u; } if (n == 1) { puts(\u0026quot;1\u0026quot;); continue; } for (int i = 1; i \u0026lt;= n; ++i) { able.assign(n + 1, false); pa.assign(n + 1, 0); dfs(a[i]); for (int j = 1; j \u0026lt;= n; ++j) { if (able[j]) { cout \u0026lt;\u0026lt; j \u0026lt;\u0026lt; \u0026quot; \\n\u0026quot;[i == n]; apply(j, 0); break; } } } } return 0; }   D2T1 首先可以通过 $O(n^2)$ 的 DP 求出没有 Yazid 的限制（每种主要食材不超过一半）的答案。\n然后枚举每种主要食材，算出超过一半的方案数。\n两部分答案相减即为最终答案。\n第一部分比较简单，我猜大家都会，毕竟这是个基本的背包问题..\n第二部分的话，枚举主要食材后有一个比较容易想到的 $O(n^3)$ DP，但应该是无法通过本题的。\n这个 $O(n^3)$ DP 计算了使用多少种当前枚举的食材以及多少种非当前枚举的食材的方案数，但实际上我们并不关心这两种情况具体有多少种食材，而只关心它们的差，所以可以得到下面这种 $O(n^2)$ 的 DP 方法：\n令 $f_{i, j}$ 表示使用 $1\\sim i$ 这些烹饪方法，做了 $x$ 道当前枚举的食材，$x-j$ 道非当前枚举的食材，的方案数。令当前枚举的食材为 $t$ 。\n转移有三种情况，不做/做枚举的/做非枚举的，所以，$f_{i,j}=f_{i-1,j}+a_{i,t}f_{i-1,j-1}+\\left(\\left(\\sum_{p=1}^m a_{i, p}\\right)-a_{i,t}\\right)f_{i-1,j+1}$ 。\n对第二部分答案的贡献是 $\\sum_{i=1}^nf_{n,i}$ 。\n总复杂度 $O(n^2m)$ 。\n参考代码 #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; typedef long long ll; const int mod = 998244353; int n, m, ans; vector\u0026lt;int\u0026gt; sum; vector\u0026lt;vector\u0026lt;int\u0026gt; \u0026gt; a, f; int main() { scanf(\u0026quot;%d%d\u0026quot;, \u0026amp;n, \u0026amp;m); sum.resize(n + 1, 0); a.resize(n + 1, vector\u0026lt;int\u0026gt;(m + 1)); for (int i = 1; i \u0026lt;= n; ++i) { for (int j = 1; j \u0026lt;= m; ++j) { scanf(\u0026quot;%d\u0026quot;, \u0026amp;a[i][j]); sum[i] = (sum[i] + a[i][j]) % mod; } } f.resize(n + 1, vector\u0026lt;int\u0026gt;(n + 1, 0)); f[0][0] = 1; for (int i = 1; i \u0026lt;= n; ++i) { f[i][0] = 1; for (int j = 1; j \u0026lt;= i; ++j) { f[i][j] = (f[i - 1][j] + (ll) f[i - 1][j - 1] * sum[i]) % mod; } } for (int i = 1; i \u0026lt;= n; ++i) ans = (ans + f[n][i]) % mod; for (int i = 1; i \u0026lt;= m; ++i) { f.assign(n + 1, vector\u0026lt;int\u0026gt;(2 * n + 3, 0)); f[0][n + 1] = 1; // 下标加上 n+1 避免负数下标 for (int j = 1; j \u0026lt;= n; ++j) { for (int k = n + 1 - j; k \u0026lt;= n + 1 + j; ++k) { f[j][k] = ((ll) a[j][i] * f[j - 1][k - 1] + (ll) (sum[j] - a[j][i] + mod) * f[j - 1][k + 1] + f[j - 1][k]) % mod; } } for (int j = n + 2; j \u0026lt;= n * 2 + 1; ++j) ans = (ans - f[n][j] + mod) % mod; } cout \u0026lt;\u0026lt; ans; return 0; }   D2T2 首先是一个结论：最后一个断点最大的解是最优解。证明请参考 myy 的题解。（因为自己并没有想到什么更加简洁的证法..）（当然还可以打表发现。）\n有了这个结论之后，令 $f_i$ 表示 $[1,i]$ 这段的最后一个断点的最大值，那么，$f_i=\\max\\{j|j\\in\\mathbb{N},(\\sum_{t=f_j+1}^ja_t)\\le(\\sum_{t=j+1}^ia_t)\\}$ 。\n预处理前缀和 $pre[i]=\\sum_{j=1}^ia_i$，那么 $f_{i}=\\max\\{j|j\\in\\mathbb{N},2pre[j]-pre[f_j]\\le pre[i]\\}$ ，然后就可以用单调队列优化了。\n需要高精的只有最后的答案计算，这可以用 __int128 实现。\n参考代码 #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; struct IO { #define MAXSIZE (1 \u0026lt;\u0026lt; 20) #define isdigit(x) (x \u0026gt;= '0' \u0026amp;\u0026amp; x \u0026lt;= '9') char buf[MAXSIZE], *p1, *p2; char pbuf[MAXSIZE], *pp; #if DEBUG #else IO() : p1(buf), p2(buf), pp(pbuf) {} ~IO() { fwrite(pbuf, 1, pp - pbuf, stdout); } #endif inline char gc() { #if DEBUG return getchar(); #endif if (p1 == p2) p2 = (p1 = buf) + fread(buf, 1, MAXSIZE, stdin); return p1 == p2 ? ' ' : *p1++; } inline bool blank(char ch) { return ch == ' ' || ch == '\\n' || ch == '\\r' || ch == '\\t'; } template \u0026lt;class T\u0026gt; inline void read(T \u0026amp;x) { register double tmp = 1; register bool sign = 0; x = 0; register char ch = gc(); for (; !isdigit(ch); ch = gc()) if (ch == '-') sign = 1; for (; isdigit(ch); ch = gc()) x = x * 10 + (ch - '0'); if (ch == '.') for (ch = gc(); isdigit(ch); ch = gc()) tmp /= 10.0, x += tmp * (ch - '0'); if (sign) x = -x; } inline void read(char *s) { register char ch = gc(); for (; blank(ch); ch = gc()) ; for (; !blank(ch); ch = gc()) *s++ = ch; *s = 0; } inline void read(char \u0026amp;c) { for (c = gc(); blank(c); c = gc()) ; } inline void push(const char \u0026amp;c) { #if DEBUG putchar(c); #else if (pp - pbuf == MAXSIZE) fwrite(pbuf, 1, MAXSIZE, stdout), pp = pbuf; *pp++ = c; #endif } template \u0026lt;class T\u0026gt; inline void write(T x) { if (x \u0026lt; 0) x = -x, push('-'); static T sta[35]; T top = 0; do { sta[top++] = x % 10, x /= 10; } while (x); while (top) push(sta[--top] + '0'); } template \u0026lt;class T\u0026gt; inline void write(T x, char lastChar) { write(x), push(lastChar); } } io; const int N = 4e7 + 5; typedef long long ll; ll a[N]; int n, type, f[N], q[N], ql = 1, qr; ll calc(int x) { return a[x] * 2 - a[f[x]]; } void write(__int128 x) { if (x \u0026gt; 9) write(x / 10); putchar(x % 10 + '0'); } int main() { io.read(n); io.read(type); if (type == 0) for (int i = 1; i \u0026lt;= n; ++i) io.read(a[i]); else { int x, y, z, b, c, m; io.read(x); io.read(y); io.read(z); io.read(b); io.read(c); io.read(m); int k = 1; for (int i = 1; i \u0026lt;= m; ++i) { int p, l, r; io.read(p); io.read(l); io.read(r); while (k \u0026lt;= p) { int t; if (k == 1) t = b; else if (k == 2) t = c; else { t = ((ll) x * c + (ll) y * b + z) \u0026amp; ((1 \u0026lt;\u0026lt; 30) - 1); b = c; c = t; } a[k++] = t % (r - l + 1) + l; } } } for (int i = 2; i \u0026lt;= n; ++i) a[i] += a[i - 1]; for (int i = 1; i \u0026lt;= n; ++i) { while (ql \u0026lt; qr \u0026amp;\u0026amp; calc(q[ql + 1]) \u0026lt;= a[i]) ++ql; if (ql \u0026gt; qr || calc(q[ql]) \u0026gt; a[i]) f[i] = 0; else f[i] = q[ql]; ll tmp = calc(i); while (ql \u0026lt;= qr \u0026amp;\u0026amp; tmp \u0026lt;= calc(q[qr])) --qr; q[++qr] = i; } __int128 ans = 0; for (int i = n; i; i = f[i]) ans += (__int128) (a[i] - a[f[i]]) * (a[i] - a[f[i]]); write(ans); return 0; }   D2T3 怎么今年 D2T3 又是 NOI 选手们纷纷用神仙做法秒掉，然后题解区窜出一个神奇的倍增做法（\n瞟了眼主席树题解，感觉自己大约能想出来，于是去学习了一下神奇的倍增做法：\n进行树链剖分（实际上只用求出重儿子而不用进行剖分），有一个性质：如果重心在一个子树内，且这个子树的根不是重心，那么重心一定在根的重儿子那棵子树里。\n（如果有多个儿子大小一样，重心只能是根。）\n然后就可以向下倍增找到重心（如果跳过去之后“向上”的子树大小不超过总点数一半就跳过去）。找到之后还要判其父亲是否也是重心。\n然而这样只能处理有根树的子树，另一半的子树（“向上”的子树）需要类似换根 DP 进行处理，需要分几种情况讨论，具体细节可以自行脑补 + 对拍发现自己漏了哪种情况。\n参考代码 #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;cctype\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; typedef pair\u0026lt;int, int\u0026gt; pii; int read() { int out = 0; char c; while (!isdigit(c = getchar())); for (; isdigit(c); c = getchar()) out = out * 10 + c - '0'; return out; } int n, dfntot; long long ans; vector\u0026lt;vector\u0026lt;int\u0026gt; \u0026gt; g, bz; vector\u0026lt;int\u0026gt; dep, siz, pa, dfn, exi; struct Val { pii fi, se; Val() { fi = se = pii(0, 0); } void insert(pii x) { if (x \u0026gt; fi) { se = fi; fi = x; } else if (x \u0026gt; se) se = x; } pii get(pii x = pii(-1, -1)) { if (x == fi) return se; return fi; } }; vector\u0026lt;Val\u0026gt; son; void dfs1(int u) { siz[u] = 1; dfn[u] = ++dfntot; for (int i = 0; i \u0026lt; g[u].size(); ++i) { int v = g[u][i]; if (v == pa[u]) continue; dep[v] = dep[u] + 1; pa[v] = u; dfs1(v); siz[u] += siz[v]; son[u].insert(pii(siz[v], v)); } exi[u] = dfntot; if (u == 1) return; bz[u][0] = son[u].get().second; for (int i = 1; i \u0026lt;= 17; ++i) bz[u][i] = bz[bz[u][i - 1]][i - 1]; int x = u; for (int i = 17; i \u0026gt;= 0; --i) { int v = bz[x][i]; if (v \u0026amp;\u0026amp; siz[u] - siz[v] \u0026lt;= siz[u] / 2) x = v; } ans += x; if (siz[x] \u0026lt;= siz[u] / 2) ans += pa[x]; } bool judge(int u, int v) { if (!v) return false; int f = pa[u]; if (v == f) return true; if (dfn[f] \u0026gt;= dfn[v] \u0026amp;\u0026amp; dfn[f] \u0026lt;= exi[v]) return siz[pa[v]] - siz[u] \u0026lt;= (n - siz[u]) / 2; return n - siz[u] - siz[v] \u0026lt;= (n - siz[u]) / 2; } bool judge2(int u, int v) { if (v == u || !v) return false; int f = pa[u]; if (dfn[f] \u0026gt;= dfn[v] \u0026amp;\u0026amp; dfn[f] \u0026lt;= exi[v]) { return n - siz[v] \u0026lt;= (n - siz[u]) / 2 \u0026amp;\u0026amp; son[v].get(pii(siz[pa[v]], pa[v])).first \u0026lt;= (n - siz[u]) / 2; } return son[v].get().first \u0026lt;= (n - siz[u]) / 2; } void dfs2(int u) { vector\u0026lt;int\u0026gt; tmp = bz[u]; Val rson = son[u]; int f = pa[u]; int paf = pa[f]; if (u != 1) { pa[f] = u; son[u].insert(pii(n - siz[u], f)); bz[f][0] = son[f].get(pii(siz[u], u)).second; for (int i = 1; i \u0026lt;= 17; ++i) bz[f][i] = bz[bz[f][i - 1]][i - 1]; int x = f; for (int i = 17; i \u0026gt;= 0; --i) { int v = bz[x][i]; if (judge(u, v)) x = v; } ans += x; if (judge2(u, pa[x])) ans += pa[x]; } for (int i = 0; i \u0026lt; g[u].size(); ++i) { int v = g[u][i]; if (v == f) continue; dfs2(v); } bz[u] = tmp; pa[f] = paf; son[u] = rson; } int main() { int T; T = read(); while (T--) { n = read(); bz.resize(n + 1, vector\u0026lt;int\u0026gt;(18, 0)); g.assign(n + 1, vector\u0026lt;int\u0026gt;()); son.assign(n + 1, Val()); dep.resize(n + 1, 0); dfn.resize(n + 1, 0); exi.resize(n + 1, 0); siz.resize(n + 1, 0); pa.resize(n + 1, 0); ans = dfntot = 0; for (int i = 1; i \u0026lt; n; ++i) { int u = read(); int v = read(); g[u].push_back(v); g[v].push_back(u); } dfs1(1); dfs2(1); cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; } return 0; }  ","date":"2019-11-18T18:15:31+08:00","permalink":"https://ouuan.github.io/post/%E6%82%AC%E5%B4%96%E8%BE%B9%E7%9A%84%E8%B8%9F%E8%B9%B0-csp-s-2019/","tags":["CCF系列赛事"],"title":"悬崖边的踟蹰 —— CSP-S 2019"},{"categories":["知识点"],"contents":"大多数人所使用的费用流算法，即每次求出残量网络中 $s$ 到 $t$ 关于费用的最短路进行增广（将 Dinic 最大流算法中的 BFS 改为 SPFA），是伪多项式复杂度的，最坏情况下复杂度为 $O(nmf)$，其中 $f$ 为最大流。已知有一种在点数为 $n$，边数为 $O(n^2)$，值域为 $O(2^{n/2})$ 时将其用时卡成关于 $n$ 的指数级复杂度的构造方法。\n本文将介绍一种复杂度为进行 $O(m\\log U)$ 次（$U$ 表示边的最大容量）无负权边单源最短路（使用 priority_queue 实现 Dijkstra 算法，总复杂度即为 $O(m^2\\log U\\log m)$）的弱多项式复杂度算法。\n其实这个算法并不是很复杂（只是相关资料比较少，会对学习造成一定困难，这也是我写这篇博客的原因），最小费用最大流的模板也只需要 $2.5KB$，并不比常见的伪多项式复杂度算法长很多。\nhack 常见的费用流算法 可以参考 这篇博客，里面给出了一个用 Python 写的数据生成器，调用函数 mcmf_worst_instance(k) 可以得到 $2k+2$ 个点的数据，格式为第一行点数和边数，后面每行描述一条边（起点、终点、容量、费用），源点是 $1$ 汇点是 $2k+2$。\nk=20 生成的数据 42 421 1 2 1 0 1 3 3 0 1 4 5 0 1 5 10 0 1 6 20 0 1 7 40 0 1 8 80 0 1 9 160 0 1 10 320 0 1 11 640 0 1 12 1280 0 1 13 2560 0 1 14 5120 0 1 15 10240 0 1 16 20480 0 1 17 40960 0 1 18 81920 0 1 19 163840 0 1 20 327680 0 1 21 655360 0 2 22 5242880 0 2 23 5242880 1 2 24 5242880 3 2 25 5242880 7 2 26 5242880 15 2 27 5242880 31 2 28 5242880 63 2 29 5242880 127 2 30 5242880 255 2 31 5242880 511 2 32 5242880 1023 2 33 5242880 2047 2 34 5242880 4095 2 35 5242880 8191 2 36 5242880 16383 2 37 5242880 32767 2 38 5242880 65535 2 39 5242880 131071 2 40 5242880 262143 2 41 5242880 524287 3 22 5242880 1 3 24 5242880 3 3 25 5242880 7 3 26 5242880 15 3 27 5242880 31 3 28 5242880 63 3 29 5242880 127 3 30 5242880 255 3 31 5242880 511 3 32 5242880 1023 3 33 5242880 2047 3 34 5242880 4095 3 35 5242880 8191 3 36 5242880 16383 3 37 5242880 32767 3 38 5242880 65535 3 39 5242880 131071 3 40 5242880 262143 3 41 5242880 524287 4 22 5242880 3 4 23 5242880 3 4 25 5242880 7 4 26 5242880 15 4 27 5242880 31 4 28 5242880 63 4 29 5242880 127 4 30 5242880 255 4 31 5242880 511 4 32 5242880 1023 4 33 5242880 2047 4 34 5242880 4095 4 35 5242880 8191 4 36 5242880 16383 4 37 5242880 32767 4 38 5242880 65535 4 39 5242880 131071 4 40 5242880 262143 4 41 5242880 524287 5 22 5242880 7 5 23 5242880 7 5 24 5242880 7 5 26 5242880 15 5 27 5242880 31 5 28 5242880 63 5 29 5242880 127 5 30 5242880 255 5 31 5242880 511 5 32 5242880 1023 5 33 5242880 2047 5 34 5242880 4095 5 35 5242880 8191 5 36 5242880 16383 5 37 5242880 32767 5 38 5242880 65535 5 39 5242880 131071 5 40 5242880 262143 5 41 5242880 524287 6 22 5242880 15 6 23 5242880 15 6 24 5242880 15 6 25 5242880 15 6 27 5242880 31 6 28 5242880 63 6 29 5242880 127 6 30 5242880 255 6 31 5242880 511 6 32 5242880 1023 6 33 5242880 2047 6 34 5242880 4095 6 35 5242880 8191 6 36 5242880 16383 6 37 5242880 32767 6 38 5242880 65535 6 39 5242880 131071 6 40 5242880 262143 6 41 5242880 524287 7 22 5242880 31 7 23 5242880 31 7 24 5242880 31 7 25 5242880 31 7 26 5242880 31 7 28 5242880 63 7 29 5242880 127 7 30 5242880 255 7 31 5242880 511 7 32 5242880 1023 7 33 5242880 2047 7 34 5242880 4095 7 35 5242880 8191 7 36 5242880 16383 7 37 5242880 32767 7 38 5242880 65535 7 39 5242880 131071 7 40 5242880 262143 7 41 5242880 524287 8 22 5242880 63 8 23 5242880 63 8 24 5242880 63 8 25 5242880 63 8 26 5242880 63 8 27 5242880 63 8 29 5242880 127 8 30 5242880 255 8 31 5242880 511 8 32 5242880 1023 8 33 5242880 2047 8 34 5242880 4095 8 35 5242880 8191 8 36 5242880 16383 8 37 5242880 32767 8 38 5242880 65535 8 39 5242880 131071 8 40 5242880 262143 8 41 5242880 524287 9 22 5242880 127 9 23 5242880 127 9 24 5242880 127 9 25 5242880 127 9 26 5242880 127 9 27 5242880 127 9 28 5242880 127 9 30 5242880 255 9 31 5242880 511 9 32 5242880 1023 9 33 5242880 2047 9 34 5242880 4095 9 35 5242880 8191 9 36 5242880 16383 9 37 5242880 32767 9 38 5242880 65535 9 39 5242880 131071 9 40 5242880 262143 9 41 5242880 524287 10 22 5242880 255 10 23 5242880 255 10 24 5242880 255 10 25 5242880 255 10 26 5242880 255 10 27 5242880 255 10 28 5242880 255 10 29 5242880 255 10 31 5242880 511 10 32 5242880 1023 10 33 5242880 2047 10 34 5242880 4095 10 35 5242880 8191 10 36 5242880 16383 10 37 5242880 32767 10 38 5242880 65535 10 39 5242880 131071 10 40 5242880 262143 10 41 5242880 524287 11 22 5242880 511 11 23 5242880 511 11 24 5242880 511 11 25 5242880 511 11 26 5242880 511 11 27 5242880 511 11 28 5242880 511 11 29 5242880 511 11 30 5242880 511 11 32 5242880 1023 11 33 5242880 2047 11 34 5242880 4095 11 35 5242880 8191 11 36 5242880 16383 11 37 5242880 32767 11 38 5242880 65535 11 39 5242880 131071 11 40 5242880 262143 11 41 5242880 524287 12 22 5242880 1023 12 23 5242880 1023 12 24 5242880 1023 12 25 5242880 1023 12 26 5242880 1023 12 27 5242880 1023 12 28 5242880 1023 12 29 5242880 1023 12 30 5242880 1023 12 31 5242880 1023 12 33 5242880 2047 12 34 5242880 4095 12 35 5242880 8191 12 36 5242880 16383 12 37 5242880 32767 12 38 5242880 65535 12 39 5242880 131071 12 40 5242880 262143 12 41 5242880 524287 13 22 5242880 2047 13 23 5242880 2047 13 24 5242880 2047 13 25 5242880 2047 13 26 5242880 2047 13 27 5242880 2047 13 28 5242880 2047 13 29 5242880 2047 13 30 5242880 2047 13 31 5242880 2047 13 32 5242880 2047 13 34 5242880 4095 13 35 5242880 8191 13 36 5242880 16383 13 37 5242880 32767 13 38 5242880 65535 13 39 5242880 131071 13 40 5242880 262143 13 41 5242880 524287 14 22 5242880 4095 14 23 5242880 4095 14 24 5242880 4095 14 25 5242880 4095 14 26 5242880 4095 14 27 5242880 4095 14 28 5242880 4095 14 29 5242880 4095 14 30 5242880 4095 14 31 5242880 4095 14 32 5242880 4095 14 33 5242880 4095 14 35 5242880 8191 14 36 5242880 16383 14 37 5242880 32767 14 38 5242880 65535 14 39 5242880 131071 14 40 5242880 262143 14 41 5242880 524287 15 22 5242880 8191 15 23 5242880 8191 15 24 5242880 8191 15 25 5242880 8191 15 26 5242880 8191 15 27 5242880 8191 15 28 5242880 8191 15 29 5242880 8191 15 30 5242880 8191 15 31 5242880 8191 15 32 5242880 8191 15 33 5242880 8191 15 34 5242880 8191 15 36 5242880 16383 15 37 5242880 32767 15 38 5242880 65535 15 39 5242880 131071 15 40 5242880 262143 15 41 5242880 524287 16 22 5242880 16383 16 23 5242880 16383 16 24 5242880 16383 16 25 5242880 16383 16 26 5242880 16383 16 27 5242880 16383 16 28 5242880 16383 16 29 5242880 16383 16 30 5242880 16383 16 31 5242880 16383 16 32 5242880 16383 16 33 5242880 16383 16 34 5242880 16383 16 35 5242880 16383 16 37 5242880 32767 16 38 5242880 65535 16 39 5242880 131071 16 40 5242880 262143 16 41 5242880 524287 17 22 5242880 32767 17 23 5242880 32767 17 24 5242880 32767 17 25 5242880 32767 17 26 5242880 32767 17 27 5242880 32767 17 28 5242880 32767 17 29 5242880 32767 17 30 5242880 32767 17 31 5242880 32767 17 32 5242880 32767 17 33 5242880 32767 17 34 5242880 32767 17 35 5242880 32767 17 36 5242880 32767 17 38 5242880 65535 17 39 5242880 131071 17 40 5242880 262143 17 41 5242880 524287 18 22 5242880 65535 18 23 5242880 65535 18 24 5242880 65535 18 25 5242880 65535 18 26 5242880 65535 18 27 5242880 65535 18 28 5242880 65535 18 29 5242880 65535 18 30 5242880 65535 18 31 5242880 65535 18 32 5242880 65535 18 33 5242880 65535 18 34 5242880 65535 18 35 5242880 65535 18 36 5242880 65535 18 37 5242880 65535 18 39 5242880 131071 18 40 5242880 262143 18 41 5242880 524287 19 22 5242880 131071 19 23 5242880 131071 19 24 5242880 131071 19 25 5242880 131071 19 26 5242880 131071 19 27 5242880 131071 19 28 5242880 131071 19 29 5242880 131071 19 30 5242880 131071 19 31 5242880 131071 19 32 5242880 131071 19 33 5242880 131071 19 34 5242880 131071 19 35 5242880 131071 19 36 5242880 131071 19 37 5242880 131071 19 38 5242880 131071 19 40 5242880 262143 19 41 5242880 524287 20 22 5242880 262143 20 23 5242880 262143 20 24 5242880 262143 20 25 5242880 262143 20 26 5242880 262143 20 27 5242880 262143 20 28 5242880 262143 20 29 5242880 262143 20 30 5242880 262143 20 31 5242880 262143 20 32 5242880 262143 20 33 5242880 262143 20 34 5242880 262143 20 35 5242880 262143 20 36 5242880 262143 20 37 5242880 262143 20 38 5242880 262143 20 39 5242880 262143 20 41 5242880 524287 21 22 5242880 524287 21 23 5242880 524287 21 24 5242880 524287 21 25 5242880 524287 21 26 5242880 524287 21 27 5242880 524287 21 28 5242880 524287 21 29 5242880 524287 21 30 5242880 524287 21 31 5242880 524287 21 32 5242880 524287 21 33 5242880 524287 21 34 5242880 524287 21 35 5242880 524287 21 36 5242880 524287 21 37 5242880 524287 21 38 5242880 524287 21 39 5242880 524287 21 40 5242880 524287 22 42 2 0 23 42 2 0 24 42 5 0 25 42 10 0 26 42 20 0 27 42 40 0 28 42 80 0 29 42 160 0 30 42 320 0 31 42 640 0 32 42 1280 0 33 42 2560 0 34 42 5120 0 35 42 10240 0 36 42 20480 0 37 42 40960 0 38 42 81920 0 39 42 163840 0 40 42 327680 0 41 42 655360 0   前置知识 本文假定读者对网络流有基本的了解（掌握并大致理解了最大流的增广路解法（EK / Dinic）即可）。\n还要会解决无负权边的单源最短路问题（会 Dijkstra 算法即可）。\n一些定义 无源汇的流，每个点需要满足流入量等于流出量（流量平衡），并且每条边的流量不超过上限。\n有源汇的流，存在源点 $s$ 和汇点 $t$，$s$ 只流出不流入，$t$ 只流入不流出，其它点满足流量平衡，并且每条边的流量不超过上限。\n最大流问题，只在有源汇的流中有意义，即最大化 $s$ 的流出量（也就是 $t$ 的流入量）。\n流的费用，是每条边的流量与费用之积的和。\n最小费用最大流问题，在最大流的前提下，最小化流的费用。\n（无源汇）最小费用流问题，只用最小化流的费用。\n残量网络，是原图中每条没满流的边以及每条有流的边的反边（反边指方向相反，费用为相反数）构成的图。\n增广路，在有源汇的流中指残量网络上一条 $s$ 到 $t$ 的路径，在无源汇的流中指残量网络上的一个环。\n增广，指的是将一条增广路流量加一（增广路上的边容量减一，对应的反边容量加一）。\n不加说明时，边的长度 / 路径的长度 / 环的长度（当然还有“最长路径”、“负环”之类的表述）中的“长度”都指费用。\n$(u, v)$ 表示从 $u$ 到 $v$ 的有向边（本文只讨论原图为简单图的情况，非简单图是类似的），$cap(u, v)$ 表示 $(u, v)$ 这条边的容量，$cost(u, v)$ 表示 $(u, v)$ 这条边的费用。\n将最小费用最大流问题转化为无源汇最小费用流问题 最小费用最大流问题可以转化为无源汇最小费用流问题，方法是连一条 $t$ 到 $s$，容量足够大，费用足够小（为一个负数）的边。这里的“容量足够大”指的是不小于最大流，“费用足够小”指的是小于 $s$ 到 $t$ 的最长简单路径费用的相反数。\n由于“费用足够小”，若没有达成最大流，即存在 $s$ 到 $t$ 的增广路，任何一条不经过正环（若存在经过正环的增广路，一定也存在不经过正环的增广路）的 $s$ 到 $t$ 的增广路加上 $(t, s)$ 这条边的费用一定为负，所以通过这条增广路增广总费用一定更小，这说明，无源汇流中满足最小费用时，原问题同时满足了最小费用与最大流。\n下文中讨论的都是无源汇最小费用流问题，也不会再次强调“无源汇”。\n负环 一个流是最小费用流，当且仅当其残量网络中没有负环。\n证明 仅当（必要条件）：若存在负环可以在负环上增广，从而得到费用更小的流。\n当（充分条件）：令所考虑的这个流为 $f$，取任意一个最小费用流 $f^{\\ast}$，计算它们之间的差 $f^{\\ast}-f$（对应边流量相减）。假设 $f$ 不是最小费用流，那么 $f^{\\ast}-f$ 的总费用一定为负。由于 $f$ 和 $f^{\\ast}$ 都流量平衡，$f^{\\ast}-f$ 一定也流量平衡，所以它也是个合法的流，而一个流一定可以拆成若干个环（由于流量平衡，每个联通部分都有欧拉回路），若总费用为负就一定包含负环。又因为 $f^{\\ast}-f$ 是在 $f$ 的基础上增广的，$f^{\\ast}-f$ 一定是 $f$ 残量网络的一个子图，而其包含负环与 $f$ 的残量网络中没有负环矛盾，所以假设不成立。\n 节点势能 \u0026amp; 边的 reduced cost 这两个概念的提出与最小费用流的线性规划形式的对偶问题相关，但了解这个对偶问题并不是必要的，所以本篇博客中不会提及。\n给每个节点 $u$ 指定一个任意的势能 $p(u)$。（这个概念看起来很突兀，总之就是给每个节点新增了一个属性，它的值是任意的。）（本质上是线性规划对偶问题中的一个无限制变量。）\n定义一条边 $(u, v)$ 关于某一组势能 $p$ 的 reduced cost（并不知道怎么翻译..）$C_p(u, v)$ 为 $p(u)+cost(u, v)-p(v)$。\nreduced cost 有两个很好的性质：\n  将原费用替换为 reduced cost 不影响最短路。（不是不影响最短路长度，而是不影响最短路是哪一条。）\n  将原费用替换为 reduced cost 不影响环的总费用。\n  这两个性质都可以由 $C_p(u, v)+C_p(v, w)=p(u)+cost(u, v)+cost(v, w)-p(w)$（中间经过的点的势能相加后抵消）说明。\n如果大家有了解过 Johnson 全源最短路径算法，里面也有类似的操作，用于保证边权非负，使得 Dijkstra 算法可以得到应用。在本文所介绍的最小费用流算法中也是一样，为了能够使用 Dijkstra 算法计算最短路，在过程中需要保证 reduced cost 非负。\ncapacity scaling （这个也不知道怎么翻译..）\ncapacity scaling 从高到低考虑容量的最高若干位（比如容量为 $5$ ($101_2$)，第一次迭代时考虑最高一位，即 $1$ ($1_2$)，第二次迭代时考虑最高两位，即 $2$ ($10_2$)，第三次迭代时考虑最高三位，即 $5$ ($101_2$)），每次加入更低的位后更新答案。（这个过程和求快速幂有点像。）\n它基于一个性质：将原图中每条边的容量乘二后，最小费用流每条边的流量分别乘二。\n那么，若计算出了以 $\\left\\lfloor\\frac{cap(u, v)}{2^k}\\right\\rfloor$ 为边 $(u, v)$ 的容量的最小费用流，现在要得到以 $\\left\\lfloor\\frac{cap(u, v)}{2^{k-1}}\\right\\rfloor$ 为边 $(u, v)$ 的容量的最小费用流，只需要先将流乘二，然后对每条二进制中该位为 $1$ 的边进行容量加一的操作即可。\n所以，问题转化为了给一条边的容量加一，更新最小费用流。\n给一条边的容量加一 在上文中已经证明，最小费用流等价于残量网络中没有负环。\n所以，若容量加一后若产生负环，进行增广即可。\n为了优化常数，可以特判掉容量加一前该边已存在于残量网络的情况，直接跳过。\n令容量加一的这条边为 $(u, v)$，找负环可以先求出从 $v$ 出发以 reduced cost 为长度到每个点 $i$ 的最短路 $d(i)$（这个最短路不包括 $(u, v)$ 这条边， 由于当前维护的残量网络是容量加一之前的最小费用流，不存在负环，所以最短路是可以求的），判断 $d(u)+C_p(u, v)$ 是否小于 $0$ 即可。\n为了使用 Dijkstra 算法，还需要保证 reduced cost 非负，所以需要调整节点的势能。\n这里直接给出一种做法：求出上文所述的最短路 $d(i)$（若 $x$ 不可达就将 $d(x)$ 设为 $\\max_{\\text{节点 }i\\text{ 可达}}\\{d(i)\\}+max(0, -C_p(u, v))$），然后将每个点 $i$ 的势能加上 $d(i)$（用 $p\u0026rsquo;(i)$ 表示节点 $i$ 更新后的势能）。\n这样调整后残量网络中的每一条边的 reduced cost 依然非负的证明 对于 $(u, v)$ 这条边，若 $u$ 不可达，那么：\n$$ \\begin{aligned} C_{p\u0026rsquo;}(u, v) \u0026amp;=p\u0026rsquo;(u)+cost(u, v)-p\u0026rsquo;(v)\\\\\n\u0026amp;=p(u)+max(0, -C_p(u, v))+cost(u, v)-p(v)\\\\\n\u0026amp;\\ge p(u)-(p(u)+cost(u, v)-p(v))+cost(u, v)-p(v)\\\\\n\u0026amp;=0 \\end{aligned} $$\n若 $u$ 可达且 $(u, v)$ 这条边加入后产生了负环，负环会被增广，$(u, v)$ 这条边就不存在了。\n若 $u$ 可达且 $(u, v)$ 这条边加入后没有产生负环，即 $d(u)+C_p(u, v)\\ge 0$，那么 $C_{p\u0026rsquo;}(u, v)=d(u)+C_p(u, v)-d(v)=d(u)+C_p(u, v)\\ge 0$。\ncapacity scaling 算法在初始时所有边容量均为 $0$（也就是说残量网络为空），所以可以在除 $(u, v)$ 外每条边的 reduced cost 均非负的基础上归纳证明。\n对于其它从 $u$ 可达的边 $(x, y)$，由于 $d(y)\\le d(x)+C_p(x, y)$（最短路的性质），即 $d(y)\\le d(x)+p(x)+cost(x, y)-p(y)$，所以 $p(x)+d(x)+cost(x, y)-(p(y)+d(y))\\ge 0$，即 $p\u0026rsquo;(x)+cost(x, y)-p\u0026rsquo;(y)\\ge 0$，也就是说 $u$ 可达的边 reduced cost 调整后非负。\n对于其它从 $u$ 可达与从 $u$ 不可达交界处的边 $(x, y)$（由于这条边不可达，一定是 $x$ 不可达 $y$ 可达），由于 $C_p(x, y)\\ge 0$ 且 $d(x)=\\max_{\\text{节点 }i\\text{ 可达}}\\{d(i)\\}+max(0, -C_p(u, v))\\ge d(y)$，这样的边调整后 reduced cost 也非负。\n对于连接从 $u$ 不可达的两个点 $x$，$y$ 的边，$d(x)=d(y)$，调整后 reduced cost 也非负。\n综上所述，调整后残量网络中的每一条边的 reduced cost 依然非负。\n 进而我们还可以得出，上述流程结束后，残量网络中不存在负环，即上述流程可以计算出当前的最小费用流。\n防止溢出 上一部分中给出的势能调整方式能够保证 reduced cost 非负，但在实际实现时会有势能太大从而溢出的风险。\n防止溢出的方法也很简单，新建一个点 $k$，从 $k$ 向所有点连长度为 $0$ 的边，求从 $k$ 出发以原费用（而非 reduced cost）为长度的最短路（由于更新后的残量网络是当前的最小费用流，不存在负环，新增的 $k$ 以及 $k$ 连向其它节点的边也不会带来新的负环，所以最短路是可以求的），以 $k$ 到 $i$ 的最短路作为调整后节点 $i$ 的势能。这样调整后，$C_p(x, y)=d(x)+cost(x, y)-d(y)\\ge 0$（由最短路性质得到），并且每个节点的势能的值域不会超过 $[\\min(0, (n-1)\\min\\{cost(u, v)\\}), 0]$。\n虽然是以原费用为长度，计算最短路时还是可以利用 reduced cost 来计算。由于只有从 $k$ 连出的边可能 reduced cost 为负，而 $k$ 又是第一个松弛的，所以这不会影响 Dijkstra 算法的正确性（当然，也可以为 $k$ 设置一个足够大的势能来保证从 $k$ 连出的边 reduced cost 也非负）。\n流程总结 若求的是最小费用最大流，首先通过加一条 $t$ 到 $s$ 的边转化为无源汇最小费用流。\n使用 capacity scaling，枚举考虑容量的最高 $k$ 位，每次迭代开始时将残量网络中每条边的容量以及答案乘二，然后枚举每条二进制中该位为 $1$ 的边，使其容量加一。\n给一条边容量加一时，先特判掉这条边本来就在残量网络中的情况（优化常数），然后判是否产生了负环，若产生了负环就增广这个负环，然后调整节点势能使得所有 reduced cost 非负，最后通过计算新增节点到每个节点的最短路来更新节点势能防止溢出。\n复杂度瓶颈在求无负权边单源最短路上，总共需要计算 $O(m\\log U)$ 次（$U$ 为边的最大容量）最短路，如果使用 priority_queue 来实现 Dijkstra 算法，总复杂度为 $O(m^2\\log U\\log m)$。\n代码 模板题。\n代码 #include \u0026lt;iostream\u0026gt; #include \u0026lt;queue\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; typedef long long ll; typedef pair\u0026lt;ll, int\u0026gt; pli; const ll INF = 1e18; const ll LARGE = 1e12; int n, m; vector\u0026lt;bool\u0026gt; vis; vector\u0026lt;int\u0026gt; head, nxt, from, to, pre; vector\u0026lt;ll\u0026gt; raw_cap, cap, cost, p, dis; priority_queue\u0026lt;pli, vector\u0026lt;pli\u0026gt;, greater\u0026lt;pli\u0026gt; \u0026gt; q; void add(int u, int v, ll f, ll w) { nxt.push_back(head[u]); head[u] = to.size(); from.push_back(u); to.push_back(v); raw_cap.push_back(f); cap.push_back(0); cost.push_back(w); } void add_edge(int u, int v, ll f, ll w) { add(u, v, f, w); add(v, u, 0, -w); } ll c(int id) { return p[from[id]] + cost[id] - p[to[id]]; } void dijkstra(int s) { vis.assign(n + 2, false); dis.assign(n + 2, INF); pre.assign(n + 2, -1); dis[s] = 0; q.push(pli(0, s)); while (!q.empty()) { int u = q.top().second; ll w = q.top().first; q.pop(); if (vis[u]) continue; vis[u] = true; for (int i = head[u]; ~i; i = nxt[i]) { int v = to[i]; if (cap[i] \u0026amp;\u0026amp; dis[v] \u0026gt; w + c(i)) { dis[v] = w + c(i); pre[v] = i; q.push(pli(dis[v], v)); } } } } void add_one_cap(int id) { int u = from[id]; int v = to[id]; if (cap[id]) { ++cap[id]; return; } dijkstra(v); if (dis[u] \u0026lt; INF \u0026amp;\u0026amp; dis[u] + c(id) \u0026lt; 0) { ++cap[id ^ 1]; while (u != v) { int x = pre[u]; --cap[x]; ++cap[x ^ 1]; u = from[x]; } } else ++cap[id]; ll max_dis = 0; ll cur_len = c(id); for (int i = 1; i \u0026lt;= n; ++i) if (dis[i] \u0026lt; INF) max_dis = max(max_dis, dis[i]); for (int i = 1; i \u0026lt;= n; ++i) p[i] += dis[i] \u0026lt; INF ? dis[i] : max_dis + max(0ll, -cur_len); dijkstra(n + 1); for (int i = 1; i \u0026lt;= n; ++i) p[i] += dis[i]; } int main() { int s, t; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m \u0026gt;\u0026gt; s \u0026gt;\u0026gt; t; head.resize(n + 2, -1); p.resize(n + 2, 0); for (int i = 1; i \u0026lt;= m; ++i) { ll u, v, f, w; cin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; v \u0026gt;\u0026gt; f \u0026gt;\u0026gt; w; add_edge(u, v, f, w); } add_edge(t, s, LARGE, -LARGE); for (int i = 1; i \u0026lt;= n; ++i) { add_edge(n + 1, i, 0, 0); cap[to.size() - 2] = 1; } for (int i = 40; i \u0026gt;= 0; --i) { for (int j = 0; j \u0026lt;= m * 2 + 1; ++j) cap[j] \u0026lt;\u0026lt;= 1; for (int j = 0; j \u0026lt;= m * 2; j += 2) { if ((raw_cap[j] \u0026gt;\u0026gt; i) \u0026amp; 1) { add_one_cap(j); } } } ll min_cost = 0; for (int i = 0; i \u0026lt; m; ++i) min_cost += cap[i \u0026lt;\u0026lt; 1 | 1] * cost[i \u0026lt;\u0026lt; 1]; cout \u0026lt;\u0026lt; cap[m \u0026lt;\u0026lt; 1 | 1] \u0026lt;\u0026lt; ' ' \u0026lt;\u0026lt; min_cost; return 0; }   关于 SPFA 如果把算法中的 Dijkstra 换成 SPFA，reduced cost 就不需要了，调整势能和防止溢出两部分都可以去掉，加上 SPFA 本身就略微比 Dijkstra 好写，总体会好写不少，复杂度是 $O(nm^2\\log U)$，但很难卡满，而且由于不用防止溢出，少跑很多遍最短路，总体跑的非常快。\n代码 #include \u0026lt;iostream\u0026gt; #include \u0026lt;queue\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; typedef long long ll; typedef pair\u0026lt;ll, int\u0026gt; pli; const ll INF = 1e18; const ll LARGE = 1e12; int n, m; queue\u0026lt;int\u0026gt; q; vector\u0026lt;bool\u0026gt; inq; vector\u0026lt;ll\u0026gt; raw_cap, cap, cost, dis; vector\u0026lt;int\u0026gt; head, nxt, from, to, pre; void add(int u, int v, ll f, ll w) { nxt.push_back(head[u]); head[u] = to.size(); from.push_back(u); to.push_back(v); raw_cap.push_back(f); cap.push_back(0); cost.push_back(w); } void add_edge(int u, int v, ll f, ll w) { add(u, v, f, w); add(v, u, 0, -w); } void spfa(int s) { inq.assign(n + 1, false); dis.assign(n + 1, INF); pre.assign(n + 1, -1); dis[s] = 0; q.push(s); while (!q.empty()) { int u = q.front(); inq[u] = false; q.pop(); for (int i = head[u]; ~i; i = nxt[i]) { int v = to[i]; ll w = cost[i]; if (cap[i] \u0026amp;\u0026amp; dis[v] \u0026gt; dis[u] + w) { dis[v] = dis[u] + w; pre[v] = i; if (!inq[v]) { inq[v] = true; q.push(v); } } } } } void add_one_cap(int id) { int u = from[id]; int v = to[id]; if (cap[id]) { ++cap[id]; return; } spfa(v); if (dis[u] \u0026lt; INF \u0026amp;\u0026amp; dis[u] + cost[id] \u0026lt; 0) { ++cap[id ^ 1]; while (u != v) { int x = pre[u]; --cap[x]; ++cap[x ^ 1]; u = from[x]; } } else ++cap[id]; } int main() { int s, t; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m \u0026gt;\u0026gt; s \u0026gt;\u0026gt; t; head.resize(n + 1, -1); for (int i = 1; i \u0026lt;= m; ++i) { ll u, v, f, w; cin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; v \u0026gt;\u0026gt; f \u0026gt;\u0026gt; w; add_edge(u, v, f, w); } add_edge(t, s, LARGE, -LARGE); for (int i = 40; i \u0026gt;= 0; --i) { for (int j = 0; j \u0026lt;= m * 2 + 1; ++j) cap[j] \u0026lt;\u0026lt;= 1; for (int j = 0; j \u0026lt;= m * 2; j += 2) { if ((raw_cap[j] \u0026gt;\u0026gt; i) \u0026amp; 1) { add_one_cap(j); } } } ll min_cost = 0; for (int i = 0; i \u0026lt; m; ++i) min_cost += cap[i \u0026lt;\u0026lt; 1 | 1] * cost[i \u0026lt;\u0026lt; 1]; cout \u0026lt;\u0026lt; cap[m \u0026lt;\u0026lt; 1 | 1] \u0026lt;\u0026lt; ' ' \u0026lt;\u0026lt; min_cost; return 0; }   关于出题 尽管多数人使用的费用流算法是伪多项式复杂度的，我并不建议在题目中卡掉它。\n但需要注意的是，“不卡掉”是指设置合适的数据范围，使得常见费用流算法可以确保通过。如果设置了不合理的数据范围而测试数据中没有卡掉常见费用流算法，那么不仅 卡了 常见费用流算法，数据也造的不合格。\n参考资料   Min_25 最小費用最大流の悪例題\n  Stanford CS 361B: Advanced Algorithms, Spring 2014 Lecture Notes\n  A Faster Strongly Polynomial Minimum Cost Flow Algorithm\n  Theoretical Improvements in Algorithmic Efficiency for Network Flow Problems\n  Github repo Laakeri/tiralabra\n ","date":"2019-10-26T19:50:25+08:00","permalink":"https://ouuan.github.io/post/%E5%9F%BA%E4%BA%8E-capacity-scaling-%E7%9A%84%E5%BC%B1%E5%A4%9A%E9%A1%B9%E5%BC%8F%E5%A4%8D%E6%9D%82%E5%BA%A6%E6%9C%80%E5%B0%8F%E8%B4%B9%E7%94%A8%E6%B5%81%E7%AE%97%E6%B3%95/","tags":["图论","网络流","费用流"],"title":"基于 Capacity Scaling 的弱多项式复杂度最小费用流算法"},{"categories":["题解"],"contents":"题目链接 CF\n题意简述 有一个长为 $n$ 的括号序列，其中一些位置是问号，每个问号替换成左括号或替换成右括号各有给定的代价，判断是否能够构造出一个合法的括号序列，如果可以，求出最小代价。\n$n\\le 5\\cdot 10^4$（实际上可以大很多）。\n简要做法 考虑使用带反悔的贪心。\n如果用 $cnt[i]$ 表示 $\\sum_{j=1}^i(-1)^{[a_i=\u0026rsquo;)']}$（左括号比右括号多的个数），括号序列合法当且仅当 $\\forall i,cnt[i]\\ge 0$ 且 $cnt[n]=0$。\n如果把右括号反悔成左括号，一定可以保证 $cnt[i]\\ge 0$ 这个条件依然满足。\n但是，如果把左括号反悔成右括号，有可能造成本来 $cnt[i]\\ge 0$ 的位置小于 $0$。\n并且，如果选择了多余的左括号，还会导致 $cnt[n]\u0026gt;0$。\n如何解决这些问题呢？\n可以发现，如果初始时优先选择右括号，上述问题就都得到解决了。\n即，每次碰到问号都选右括号，并且将其标记为可以反悔为左括号。如果 $cnt[i]\u0026lt;0$，就从可反悔的右括号里选反悔代价最小的改成左括号。这样的话，$cnt[i]\\ge 0$ 不会因反悔而被破坏，$cnt[n]\u0026gt;0$ 也不会在有解时发生。\n具体实现可以用堆（priority_queue）。\n参考代码 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;queue\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; typedef pair\u0026lt;int, int\u0026gt; pii; const int N = 50010; int n; char s[N]; long long ans; priority_queue\u0026lt;pii, vector\u0026lt;pii\u0026gt;, greater\u0026lt;pii\u0026gt; \u0026gt; q; int main() { scanf(\u0026quot;%s\u0026quot;, s + 1); n = strlen(s + 1); int cnt = 0; for (int i = 1; i \u0026lt;= n; ++i) { if (s[i] == '(') ++cnt; else if (s[i] == ')') --cnt; else { int a, b; scanf(\u0026quot;%d%d\u0026quot;, \u0026amp;a, \u0026amp;b); --cnt; s[i] = ')'; ans += b; q.push(pii(a - b, i)); } if (cnt \u0026lt; 0) { if (q.empty()) break; cnt += 2; ans += q.top().first; s[q.top().second] = '('; q.pop(); } } if (cnt == 0) printf(\u0026quot;%I64d\\n%s\u0026quot;, ans, s + 1); else puts(\u0026quot;-1\u0026quot;); return 0; } ","date":"2019-10-16T21:50:44+08:00","permalink":"https://ouuan.github.io/post/cf3d-least-cost-bracket-sequence%E8%B4%AA%E5%BF%83/","tags":["贪心"],"title":"CF3D Least Cost Bracket Sequence（贪心）"},{"categories":["题解"],"contents":"题目链接 CF\n题意简述 给你 $n$ 个整数，需要将它们分成任意个至少包含 $3$ 个数的环，使得每相邻两个数加起来是一个质数。\n判断是否有解，若有解输出任意一组解。\n$3\\le n\\le 200$, 数的范围是 $[2,10^4]$。\n简要做法 首先，由于每个数都大于等于 $2$，加起来是质数的必要条件是一奇一偶。\n所以，如果把数看成点，相加得到质数看成边，就得到了一张二分图。\n而题目的要求可以看作是每个点都匹配两个点。因为所有点度数都为 $2$ 的简单无向图一定是一个至少包含 $3$ 个点的环。\n所以可以这样建图：源点到奇数，容量为 $2$；奇数到与其之和为质数的偶数，容量为 $1$；偶数到汇点，容量为 $2$。\n如果最大流为 $n$ 就有解。输出方案就和普通的网络流输出方案差不多（可以参考代码）。\n参考代码 #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;queue\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; const int N = 210; const int W = 20010; int n, a[N], p[W], tot; bool np[W]; struct Flow { const int s = N - 2; const int t = N - 1; int head[N], nxt[N * N], to[N * N], edge[N * N], cnt; queue\u0026lt;int\u0026gt; q; bool vis[N]; int dep[N]; void add(int u, int v, int w) { nxt[++cnt] = head[u]; head[u] = cnt; to[cnt] = v; edge[cnt] = w; } void Add(int u, int v, int w) { add(u, v, w); add(v, u, 0); } bool bfs() { memset(dep, -1, sizeof(dep)); dep[s] = 0; q.push(s); while (!q.empty()) { int u = q.front(); q.pop(); for (int i = head[u]; i; i = nxt[i]) { int v = to[i]; int w = edge[i]; if (w \u0026gt; 0 \u0026amp;\u0026amp; dep[v] == -1) { dep[v] = dep[u] + 1; q.push(v); } } } return ~dep[t]; } int dfs(int u, int flow) { if (dep[u] == dep[t]) return u == t ? flow : 0; int out = 0; for (int i = head[u]; i \u0026amp;\u0026amp; flow - out; i = nxt[i]) { int v = to[i]; int w = edge[i]; if (dep[v] == dep[u] + 1) { int f = dfs(v, min(flow - out, w)); edge[i] -= f; edge[i ^ 1] += f; out += f; } } return out; } int maxFlow() { int out = 0; while (bfs()) out += dfs(s, N); return out; } void init() { cnt = 1; for (int i = 1; i \u0026lt;= n; ++i) { if (a[i] \u0026amp; 1) Add(s, i, 2); else Add(i, t, 2); } for (int i = 1; i \u0026lt;= n; ++i) { if (!(a[i] \u0026amp; 1)) continue; for (int j = 1; j \u0026lt;= n; ++j) { if (np[a[i] + a[j]]) continue; Add(i, j, 1); } } } vector\u0026lt;int\u0026gt; cycle(int u) { vector\u0026lt;int\u0026gt; out(1, u); vis[u] = true; while (1) { bool flag = false; for (int i = head[u]; i; i = nxt[i]) { int v = to[i]; int w = edge[i]; if (((a[u] \u0026amp; 1) ^ (w \u0026gt; 0)) \u0026amp;\u0026amp; v \u0026lt;= n \u0026amp;\u0026amp; !vis[v]) { vis[v] = flag = true; out.push_back(v); u = v; break; } } if (!flag) break; } return out; } void output() { vector\u0026lt;vector\u0026lt;int\u0026gt; \u0026gt; ans; for (int i = 1; i \u0026lt;= n; ++i) if (!vis[i]) ans.push_back(cycle(i)); printf(\u0026quot;%d\\n\u0026quot;, ans.size()); for (int i = 0; i \u0026lt; ans.size(); ++i) { printf(\u0026quot;%d\u0026quot;, ans[i].size()); for (int j = 0; j \u0026lt; ans[i].size(); ++j) printf(\u0026quot; %d\u0026quot;, ans[i][j]); puts(\u0026quot;\u0026quot;); } } } flow; int main() { for (int i = 2; i \u0026lt; W; ++i) { if (!np[i]) p[++tot] = i; for (int j = 1; j \u0026lt;= tot \u0026amp;\u0026amp; i * p[j] \u0026lt; W; ++j) { np[i * p[j]] = true; if (i % p[j] == 0) break; } } scanf(\u0026quot;%d\u0026quot;, \u0026amp;n); for (int i = 1; i \u0026lt;= n; ++i) scanf(\u0026quot;%d\u0026quot;, a + i); flow.init(); if (flow.maxFlow() != n) { puts(\u0026quot;Impossible\u0026quot;); return 0; } flow.output(); return 0; } ","date":"2019-10-15T19:50:54+08:00","permalink":"https://ouuan.github.io/post/cf512c-fox-and-dinner%E4%BA%8C%E5%88%86%E5%9B%BE%E6%9C%80%E5%A4%A7%E6%B5%81/","tags":["图论","二分图","网络流","最大流"],"title":"CF512C Fox And Dinner（二分图，最大流）"},{"categories":["题解"],"contents":"题目链接 CF\n题意简述 有一个字符串 $S[1..n+2]$，告诉你 $\\forall 1\\le i\\le n, S[i..i+2]$（所有长为 $3$ 的子串），求任意一个满足条件的 $S$。\n$1\\le n\\le 2\\cdot 10^5$，字符集为大小写字母 + 数字。\n简要做法 容易想到需要建图。\n但是，如果把每个长为 $3$ 的子串看成点，前后缀匹配看成边，就做不下去了。\n正确做法是把每个长为 $2$ 的子串看成点，长为 $3$ 的子串看成边。这样原问题就转化成了求有向图的欧拉路径。（不会这个的话建议自行搜索一下。）\n如果每次 dfs 同一个点时都遍历所有出边，度数比较大就会挂。使用 vector 存边的话可以 pop_back() 或者记录一下已经遍历到了哪一条边，使用前向星的话可以像当前弧优化那样修改 head。\n参考代码 #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;cctype\u0026gt; #include \u0026lt;cstdlib\u0026gt; using namespace std; const int N = 200010; const int W = 62 * 62; int head[N], nxt[N], to[N], cnt; int n, ind[N], outd[N], tot; char s[N], ans[N]; int charToInt(char x) { if (isdigit(x)) return x - '0'; if (islower(x)) return x - 'a' + 10; return x - 'A' + 36; } char intToChar(int x) { if (x \u0026lt; 10) return x + '0'; if (x \u0026lt; 36) return x - 10 + 'a'; return x - 36 + 'A'; } int wordToInt(char x, char y) { return charToInt(x) * 62 + charToInt(y); } void add(int u, int v) { nxt[++cnt] = head[u]; head[u] = cnt; to[cnt] = v; } void fail() { puts(\u0026quot;NO\u0026quot;); exit(0); } void dfs(int u) { for (int\u0026amp; i = head[u]; i; ) { int v = to[i]; i = nxt[i]; dfs(v); } ans[--tot] = intToChar(u % 62); } int main() { scanf(\u0026quot;%d\u0026quot;, \u0026amp;n); for (int i = 1; i \u0026lt;= n; ++i) { scanf(\u0026quot;%s\u0026quot;, s); int u = wordToInt(s[0], s[1]); int v = wordToInt(s[1], s[2]); ++outd[u]; ++ind[v]; add(u, v); } int oneMoreIn = 0, oneMoreOut = 0; for (int i = 0; i \u0026lt; W; ++i) { if (ind[i] == outd[i]) continue; if (ind[i] == outd[i] + 1) { if (oneMoreIn) fail(); oneMoreIn = i; } else if (ind[i] + 1 == outd[i]) { if (oneMoreOut) fail(); oneMoreOut = i; } else fail(); } if (!oneMoreOut) { for (int i = 0; i \u0026lt; W; ++i) { if (outd[i]) { oneMoreOut = i; break; } } } tot = n + 2; dfs(oneMoreOut); ans[--tot] = intToChar(oneMoreOut / 62); if (!tot) printf(\u0026quot;YES\\n%s\u0026quot;, ans); else puts(\u0026quot;NO\u0026quot;); return 0; } ","date":"2019-10-15T15:01:00+08:00","permalink":"https://ouuan.github.io/post/cf508d-tanya-and-password%E6%AC%A7%E6%8B%89%E8%B7%AF%E5%BE%84/","tags":["图论","建图","欧拉路径"],"title":"CF508D Tanya and Password（欧拉路径）"},{"categories":["题解"],"contents":"题目链接 CF\n题意简述 给你一张二分图：左边 $t$ 个位置，第 $i$ 个位置上有 $a_i$ 个点；右边 $n$ 个带权的点，第 $i$ 个点与位置在 $[l_i, r_i]$ 之间的所有左边的点有连边；匹配权值为匹配中右边点的权值之和；求最大权匹配。\n$1\\le n,t\\le 3\\cdot 10^5$，保证 $l_i\\le l_{i+1}$, $r_i\\le r_{i+1}$。\n简要做法 首先，将右边的点按权值从大到小排序，依次加入，看有没有完全匹配，有就选这个点。这样一定是最优的，好像可以用拟阵相关的理论证明，但我不太会..\n于是，问题转化成了如何判定是否存在完全匹配，而霍尔定理恰恰是用来做这件事的——考虑右边的点中被选择的那些，选择其一个子集，判断是否所有子集的邻域（即与其相邻的点构成的集合）大小都比子集本身大。\n如果选择的子集中元素对应的区间的并集不是连续的，霍尔定理的条件成立等价于对于断点两边分别成立，所以只需要考虑子集对应的区间连续的情况。\n又由于 $l_i\\le l_{i+1}$, $r_i\\le r_{i+1}$，只用考虑子集中的元素本身编号连续的情况。那么，霍尔定理的条件就可以表示为：\n$$ \\forall 1\\le i\u0026lt; j\\le n,[i,j]\\text{中被选择的右侧点个数}\\le [l_i,r_j]\\text{中左侧点数量} $$\n如果处理出 $a_{1..t}$ 的前缀和 $pre[i]=\\sum_{j=1}^ia_j$，用 $p[i]$ 表示 $[1,i]$ 中被选择的右侧点个数，那么式子就变成了：\n$$ \\forall1\\le i\u0026lt; j\\le n, p[j]-p[i-1]\\le pre[r_j]-pre[l_i-1] $$\n也就是：\n$$ \\forall1\\le i\u0026lt; j\\le n, pre[l_i-1]-p[i-1]\\le pre[r_j]-p[j] $$\n所以，可以对每个元素 $i$ 维护 $pre[l_{i+1}-1]-p[i]$ 以及 $pre[r_j]-p[j]$。\n$pre$ 是定值，考虑如何更新 $p$。事实上，往已选择的点中加入一个点，就是把一段后缀的 $p$ 加一。所以可以考虑用线段树维护。\n并且，一段后缀加一（令这段后缀为 $[x..n]$）后，只有 $i\u0026lt; x,j\\ge x$ 的数对 $(i,j)$ 对应的大小关系发生改变，事实上只用判断 $i\u0026lt;x$ 的 $pre[l_i-1]-p[i-1]$ 的最大值与 $j\\ge x$ 的 $pre[r_j]-p[j]$ 的最小值的大小关系即可，同样可以使用线段树维护。\n另一种判断方法，是在线段树上的每个节点处判断左儿子与右儿子有没有出现不满足霍尔定理条件的情况。\n参考代码 代码中使用了 segmenttree.h。\n每次判断前缀与后缀的大小关系 #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;cctype\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026quot;segmenttree.h\u0026quot; using namespace std; typedef long long ll; int read() { int out = 0; char c; while (!isdigit(c = getchar())); for (; isdigit(c); c = getchar()) out = out * 10 + c - '0'; return out; } const int N = 300010; const ll INF = 1e18; int n, m; ll pre[N], ans; struct Girl { int l, r, p, id; bool operator\u0026lt;(const Girl\u0026amp; y) const { return p \u0026gt; y.p; } } g[N]; struct Value { ll mn, mx; Value(ll _mn = INF, ll _mx = -INF) { mn = _mn; mx = _mx; } }; vector\u0026lt;Value\u0026gt; a; Value merge(Value x, Value y) { return Value(min(x.mn, y.mn), max(x.mx, y.mx)); } void update(segmentTreeNode\u0026lt;Value, int\u0026gt;\u0026amp; u, int x) { u.val.mx += x; u.val.mn += x; u.tag += x; } int main() { n = read(); m = read(); for (int i = 1; i \u0026lt;= m; ++i) pre[i] = pre[i - 1] + read(); a.resize(n + 1); for (int i = 1; i \u0026lt;= n; ++i) { g[i].l = read(); g[i].r = read(); g[i].p = read(); g[i].id = i; a[i].mn = pre[g[i].r]; a[i - 1].mx = pre[g[i].l - 1]; } sort(g + 1, g + n + 1); segmentTree\u0026lt;Value, int, merge, update\u0026gt; t(0, n + 1, a, Value()); for (int i = 1; i \u0026lt;= n; ++i) { if (t.query(0, g[i].id).mx \u0026gt;= t.query(g[i].id, n + 1).mn) continue; t.modify(g[i].id, n + 1, -1); ans += g[i].p; } cout \u0026lt;\u0026lt; ans; return 0; }  在线段树的每个节点处判断 #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;cctype\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026quot;segmenttree.h\u0026quot; using namespace std; typedef long long ll; int read() { int out = 0; char c; while (!isdigit(c = getchar())); for (; isdigit(c); c = getchar()) out = out * 10 + c - '0'; return out; } const int N = 300010; const ll INF = 1e18; int n, m; ll pre[N], ans; struct Girl { int l, r, p, id; bool operator\u0026lt;(const Girl\u0026amp; y) const { return p \u0026gt; y.p; } } g[N]; struct Value { ll mn, mx; bool inv; Value(ll _mn = INF, ll _mx = -INF, int _inv = false) { mn = _mn; mx = _mx; inv = _inv; } }; vector\u0026lt;Value\u0026gt; a; Value merge(Value x, Value y) { return Value(min(x.mn, y.mn), max(x.mx, y.mx), x.inv || y.inv || x.mx \u0026gt; y.mn); } void update(segmentTreeNode\u0026lt;Value, int\u0026gt;\u0026amp; u, int x) { u.val.mx += x; u.val.mn += x; u.tag += x; } int main() { n = read(); m = read(); for (int i = 1; i \u0026lt;= m; ++i) pre[i] = pre[i - 1] + read(); a.resize(n + 1); for (int i = 1; i \u0026lt;= n; ++i) { g[i].l = read(); g[i].r = read(); g[i].p = read(); g[i].id = i; a[i].mn = pre[g[i].r]; a[i - 1].mx = pre[g[i].l - 1]; } sort(g + 1, g + n + 1); segmentTree\u0026lt;Value, int, merge, update\u0026gt; t(0, n + 1, a, Value()); for (int i = 1; i \u0026lt;= n; ++i) { t.modify(g[i].id, n + 1, -1); if (t.query(0, n + 1).inv) t.modify(g[i].id, n + 1, 1); else ans += g[i].p; } cout \u0026lt;\u0026lt; ans; return 0; } ","date":"2019-10-11T11:30:32+08:00","permalink":"https://ouuan.github.io/post/gym102268d-dates%E8%B4%AA%E5%BF%83%E4%BA%8C%E5%88%86%E5%9B%BE%E5%8C%B9%E9%85%8D%E7%BA%BF%E6%AE%B5%E6%A0%91/","tags":["贪心","图论","二分图","二分图匹配","数据结构","线段树"],"title":"gym102268D Dates（贪心，二分图匹配，线段树）"},{"categories":["题解"],"contents":"题目链接 CF\n题意简述 对于一个数列，每次操作可以将相邻的两个数 $x$ 和 $y$ 合并成一个数 $x+2y$，定义一个数列的权值为进行操作直至只剩一个数能得到的最大值。\n多组询问，每次给定一个区间，求这个区间的权值。\n数列值域 $-10^9\\sim10^9$，数列长度和询问个数不超过 $10^5$。\n简要做法 先不考虑多组询问。\n经过（并不）简单的推理，可以发现，设数列 $a_{1..n}$ 的权值为 $\\sum_{i=1}^na_i2^{k_i}$，那么 $k_1=0$, $1\\le k_i\\le k_{i-1}+1(i\\ge 2)$。\n那么，最优方案中，$k_{2..n}$ 一定是一块一块从 $1$ 开始严格递增的。\n如果我们已经知道了一个数列 $k_i$ 的构成，这时要在其末端加入一个数，那么可以得到贪心策略：\n 若加入的数是正数，与前一块合并。若合并后整块构成的等比数列之和仍为正数，继续合并。 否则结束合并过程。  这个合并的过程可以用并查集维护。\n问题在于，如何判断一块的正负。可以对每块维护它的大小（块中的第 $i$ 个数与 $2^i$ 的乘积之和），合并时更新。但这样做可能会溢出，但可以发现，一旦一块的大小达到 $10^9$，一定会一直合并到最前面，所以大于 $10^9$ 的都可以视作 $10^9$；一旦前一块的长度超过 $30$ 且当前块大小为正，也一定会一直合并到最前面，也可以视作 $10^9$。\n接下来考虑如何回答询问。\n把询问离线下来，右端点相同的询问一起处理。处理一个询问之前先计算出 $a_{1..r}$ 的块，若 $l=1$ 答案就是所有块大小的和，否则的话答案会是若干块的答案之和加上一个块的后缀。因为取一个块的后缀，断点所在块一定不会分开（一块的真后缀一定为正），后面的块也不会合并到前面去。处理出模意义下块答案的前缀和，以及 $presum_i=\\sum_{j=1}^i2^{i-1}a_i$，就可以快速回答询问了。\n还有一个小问题：只有第一块的系数是从 $2^0=1$ 开始的。由于计算时第一块一定是那个后缀，计算后缀答案时从 $1$ 开始，计算整块答案时从 $2$ 开始即可。\n参考代码 #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; const int N = 100010; const int mod = 1e9 + 7; int n, m, a[N], presum[N], inv2[N], f[N], len[N], sum[N], preans[N], out[N]; vector\u0026lt;pii\u0026gt; q[N]; int find(int x) { return x == f[x] ? x : f[x] = find(f[x]); } int calc(int l, int r) { return (ll) (presum[r] - presum[l - 1] + mod) * inv2[l - 1] % mod; } int main() { scanf(\u0026quot;%d%d\u0026quot;, \u0026amp;n, \u0026amp;m); inv2[0] = 1; for (int i = 1, two = 1; i \u0026lt;= n; ++i, two = two * 2 % mod) { scanf(\u0026quot;%d\u0026quot;, a + i); inv2[i] = (ll) inv2[i - 1] * (mod + 1) / 2 % mod; presum[i] = (presum[i - 1] + (ll) two * a[i] % mod + mod) % mod; } for (int i = 1; i \u0026lt;= m; ++i) { int l, r; scanf(\u0026quot;%d%d\u0026quot;, \u0026amp;l, \u0026amp;r); q[r].push_back(pii(l, i)); } for (int i = 1; i \u0026lt;= n; ++i) { f[i] = i; len[i] = 1; sum[i] = a[i]; while (find(i) \u0026gt; 1 \u0026amp;\u0026amp; sum[find(i)] \u0026gt; 0) { int x = find(i); int y = find(x - 1); if (len[y] \u0026gt;= 30 || (((ll) sum[x]) \u0026lt;\u0026lt; len[y]) + sum[y] \u0026gt;= 1e9) sum[y] = 1e9; else sum[y] += sum[x] \u0026lt;\u0026lt; len[y]; len[y] += len[x]; f[x] = y; } preans[find(i)] = (preans[find(find(i) - 1)] + 2ll * calc(find(i), i)) % mod; for (int j = 0; j \u0026lt; q[i].size(); ++j) { int l = q[i][j].first; int id = q[i][j].second; out[id] = (0ll + preans[find(i)] - preans[find(l)] + mod + calc(l, find(l) + len[find(l)] - 1)) % mod; } } for (int i = 1; i \u0026lt;= m; ++i) printf(\u0026quot;%d\\n\u0026quot;, out[i]); return 0; } ","date":"2019-10-08T20:49:18+08:00","permalink":"https://ouuan.github.io/post/cf878e-numbers-on-the-blackboard%E8%B4%AA%E5%BF%83%E5%B9%B6%E6%9F%A5%E9%9B%86/","tags":["贪心","并查集","离线算法"],"title":"CF878E Numbers on the blackboard（贪心，并查集）"},{"categories":["技术"],"contents":"作为一个刚刚上线两周就回滚了无数次数据的 OJ，备份自然是很重要的~\n一些脚本 commit.sh #!/bin/bash time=$(date \u0026quot;+%Y%m%d%H%M%S\u0026quot;) echo ${time} docker commit uoj uoj_backup_${time} docker images --format \u0026quot;{{.ID}}: {{.CreatedSince}}\u0026quot; | grep 'day' | cut -d : -f 1 | xargs docker image rm  commit，然后删掉比较久远（在 CREATED 中显示为 XX days ago）的镜像节约空间（不然在自动备份下过不了几天硬盘就爆了）。\nsave.sh #!/bin/bash time=$(date \u0026quot;+%Y%m%d%H%M%S\u0026quot;) echo ${time} docker commit uoj uoj_backup_${time} docker save -o /home/ouuan/uoj/uoj_backup_${time}.tar uoj_backup_${time} docker images --format \u0026quot;{{.ID}}: {{.CreatedSince}}\u0026quot; | grep 'day' | cut -d : -f 1 | xargs docker image rm  先 commit，然后存为 tar。即使系统挂了，也能从文件恢复。\nnew.sh #!/bin/bash time=$(date \u0026quot;+%Y%m%d%H%M%S\u0026quot;) echo ${time} docker commit uoj uoj_backup_${time} docker stop uoj docker rm uoj docker image ls echo \u0026quot;Please enter the version (after uoj_backup_): \u0026quot; read version docker run --name uoj -dit -p 23333:80 -p 3690:3690 --cap-add SYS_PTRACE \u0026quot;uoj_backup_$version\u0026quot;  便捷地从镜像创建新容器，在删除当前容器之前 commit。\n计划任务 输入命令 sudo crontab -e。\n（可能会先让你选择一个文本编辑器）然后输入：\n30 * * * * bash path/commit.sh 0 22 * * * bash path/save.sh  path 就是放脚本文件的路径。\n前面五项分别是 分钟 / 小时 / 日期 / 月份 / 星期，在符合条件时就会执行后面的命令。\n上面的例子会在 xx:30 时 commit 一次，在每天晚上 10 点 save 一次。\n","date":"2019-09-27T12:01:05+08:00","permalink":"https://ouuan.github.io/post/uoj-%E8%87%AA%E5%8A%A8%E5%A4%87%E4%BB%BD/","tags":["OJ"],"title":"UOJ 自动备份"},{"categories":["技术"],"contents":"程序员就是代码重用的艺术家（\n这周回到学校，基于 社区版 UOJ 搭了一个校内 OJ。\n过程中现在还记得的遇到的问题，是重启后显示 \u0026ldquo;wrong database\u0026rdquo;，解决方案是 docker 里运行命令 service mysql restart。\n一周里大部分时间都是在魔改，并且是 开源 的。\n这几天算是稍微体验了一下程序员的生活。会为精妙的代码重用而惊叹，也会为一个 bug 而苦苦求索。commit 中的两行代码，可能是若干小时搜索的结果，经过了数十次错误的尝试。\n以前我对程序员的印象是「苦力活」，现在稍微有点改变了。诗人给同一个事物起不同的名字，数学家给不同的事物起相同的名字，程序员给不同的需求使用同一个函数。\n回想起来，不到一年前，也就是我开始使用 hexo 博客之前，我还对 web 开发一无所知。只不过现在所会的那些东西都是通过阅读源码 + 需要什么就搜什么学到的，导致有很多不清楚的地方，这也是导致效率低下的重要原因。\n总之，欢迎大家自由选取 Hinata Online Judge 的 feature copy 到自己的 UOJ 里！\n然而代码太不规范了，所以暂时不太准备发 pr\u0026hellip;也欢迎大家来帮我规范一下发 pr。\n","date":"2019-09-21T21:58:04+08:00","permalink":"https://ouuan.github.io/post/hinata-online-judge-%E7%9A%84%E6%90%AD%E5%BB%BA/","tags":["OJ","工程"],"title":"Hinata Online Judge 的搭建"},{"categories":["题解"],"contents":"题目链接 洛谷\nLOJ\nBZOJ\n题意简述 一个数列是“可删除的”，当且仅当可以通过这种操作将其清空：将数列中等于这个数列长度的数删去。\n如，$[1, 2, 4, 4]$ 是“可删除的”，第一次操作删成 $[1, 2]$，第二次操作删成 $[1]$，第三次操作清空。\n定义一个数列的权值为至少需要进行的单点修改数目，使得这个数列变成“可删除的”。\n现在给你一个数列 $a_{1..n}$，以及 $m$ 次修改操作，你需要在每次修改后回答这个数列的权值。\n修改操作有三种：\n 单点修改。 全局加一。 全局减一。  $1\\le n,m\\le 150000$，数列初始值以及单点修改成的值在 $[1,n]$ 内，但全局修改可能使数列中的元素超过这个范围。\n简要做法 计算数列的权值 如果将数 $i$ 出现的次数 $cnt[i]$ 看做一个高度为 $cnt[i]$、放在位置 $i$ 的柱子，让所有柱子向左倒，每个位置就会被若干个柱子覆盖。也就是说，$i$ 这个柱子覆盖了 $[i-cnt[i]+1,i]$。\n一个数列是“可删除的”当且仅当 $[1,n]$ 都被恰好覆盖了一次。\n并且，一个数列的权值就是它没被覆盖的位置数量，证明如下：\n 这是答案的下界，因为每次单点修改最多覆盖一个新位置。 这是答案的上界，因为你可以把重复覆盖的换到未覆盖处。  全局修改 全局修改会导致 $cnt$ 以及覆盖数量发生位移，所以可以考虑使用一个标记 $delta$ 来表示现在全局加了多少，那么 $cnt[i]$ 表示 $cnt[i+delta]$，位置 $i$ 被覆盖的次数被记录在 $i-delta$ 处，$a[i]$ 表示 $a_i-delta$。\n需要特别注意的是，全局加时需要减去原来位置 $n$ 的贡献，因为它们来到 $n+1$ 后必定会是累赘，全局减时要再加回来。但不需要特殊处理位置 $1$ 的贡献，因为覆盖是向左的，查询时只会查询 $[1,n]$ 的覆盖次数，小于 $1$ 的位置对答案没有影响。\n可以用线段树维护覆盖次数。\n实现细节 使用一个线段树来维护覆盖次数，它支持区间加减、区间查询最小值及其出现次数。\n下面是实现的细节。（代码中所有 $cnt$ 的下标都要加上 $m$ 避免负数下标。）\n单点修改 首先处理原来的 $a_p$。\n先判断 $a_p$ 是否小于等于 $n$，只有 $a_p\\le n$ 时才会有贡献，也就是说，当 $a[p]+delta\\le n$ 时需要在线段树上 $a[p]-cnt[a[p]]+1$ 处单点减一。\n然后将 $cnt[a[p]]$ 减一。\n接着处理新增的 $x$。\n$x$ 必定在 $[1,n]$ 内，所以一定需要在线段树上 $x-cnt[x-delta]-delta$ 处单点加一。\n然后将 $cnt[x-delta]$ 加一。\n最后将 $a[p]$ 修改为 $x-delta$。\n全局加 需要减去位置 $n$ 的贡献：$[n-cnt[n-delta]+1-delta,n-delta]$ 区间减一。\n然后将 $delta$ 加一。\n全局减 先将 $delta$ 减一。\n然后加上位置 $n$ 的贡献：$[n-cnt[n-delta]+1-delta,n-delta]$ 区间加一。\n查询答案 查询 $[1-delta,n-delta]$ 的最小值及出现次数。\n若最小值不为 $0$ 则答案为 $0$。\n否则答案为最小值的出现次数。\n参考代码 #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstdio\u0026gt; using namespace std; const int N = 150010; struct Min { int val, cnt; Min(int _val = 0, int _cnt = 0): val(_val), cnt(_cnt) {} }; Min merge(Min a, Min b) { if (a.val \u0026lt; b.val) return a; if (b.val \u0026lt; a.val) return b; return Min(a.val, a.cnt + b.cnt); } struct SegmentTree { #define ls (cur \u0026lt;\u0026lt; 1) #define rs (cur \u0026lt;\u0026lt; 1 | 1) #define mid ((l + r) \u0026gt;\u0026gt; 1) Min mn[N \u0026lt;\u0026lt; 4]; int tag[N \u0026lt;\u0026lt; 4]; void pushup(int cur) { mn[cur] = merge(mn[ls], mn[rs]); } void add(int cur, int x) { mn[cur].val += x; tag[cur] += x; } void pushdown(int cur) { add(ls, tag[cur]); add(rs, tag[cur]); tag[cur] = 0; } void build(int cur, int l, int r) { if (l == r - 1) mn[cur] = Min(0, 1); else { build(ls, l, mid); build(rs, mid, r); pushup(cur); } } void add(int cur, int l, int r, int L, int R, int x) { if (l \u0026gt;= R || r \u0026lt;= L) return; if (L \u0026lt;= l \u0026amp;\u0026amp; r \u0026lt;= R) add(cur, x); else { pushdown(cur); add(ls, l, mid, L, R, x); add(rs, mid, r, L, R, x); pushup(cur); } } Min min(int cur, int l, int r, int L, int R) { if (l \u0026gt;= R || r \u0026lt;= L) return Min(N, -1); if (L \u0026lt;= l \u0026amp;\u0026amp; r \u0026lt;= R) return mn[cur]; pushdown(cur); return merge(min(ls, l, mid, L, R), min(rs, mid, r, L, R)); } #undef ls #undef rs #undef mid } t; int n, m, delta, a[N], cnt[N * 3]; int main() { scanf(\u0026quot;%d%d\u0026quot;, \u0026amp;n, \u0026amp;m); for (int i = 1; i \u0026lt;= n; ++i) { scanf(\u0026quot;%d\u0026quot;, a + i); ++cnt[a[i] + m]; } const int ll = 1 - m - n, rr = m + n + 2; t.build(1, ll, rr); for (int i = 1; i \u0026lt;= n; ++i) t.add(1, ll, rr, i - cnt[i + m] + 1, i + 1, 1); for (int i = 1; i \u0026lt;= m; ++i) { int p, x; scanf(\u0026quot;%d%d\u0026quot;, \u0026amp;p, \u0026amp;x); if (p == 0) { if (x == -1) { --delta; t.add(1, ll, rr, n + 1 - cnt[n - delta + m] - delta, n - delta + 1, 1); } else { t.add(1, ll, rr, n + 1 - cnt[n - delta + m] - delta, n - delta + 1, -1); ++delta; } } else { if (a[p] + delta \u0026lt;= n) t.add(1, ll, rr, a[p] - cnt[a[p] + m] + 1, a[p] - cnt[a[p] + m] + 2, -1); --cnt[a[p] + m]; t.add(1, ll, rr, x - cnt[x - delta + m] - delta, x - cnt[x - delta + m] - delta + 1, 1); ++cnt[x - delta + m]; a[p] = x - delta; } Min res = t.min(1, ll, rr, 1 - delta, n - delta + 1); if (res.val \u0026gt; 0) puts(\u0026quot;0\u0026quot;); else printf(\u0026quot;%d\\n\u0026quot;, res.cnt); } return 0; } ","date":"2019-09-16T11:11:10+08:00","permalink":"https://ouuan.github.io/post/bjoi2019-%E5%88%A0%E6%95%B0%E8%B4%AA%E5%BF%83%E7%BA%BF%E6%AE%B5%E6%A0%91/","tags":["贪心","数据结构","线段树"],"title":"BJOI2019 删数（贪心，线段树）"},{"categories":["题解"],"contents":"题目链接 CF\n题意简述 给你一张 $n$ 个点 $m$ 条边的无向连通图，一条路径的权值是路径上的边的编号（十进制）顺次连接而成的数字。求 $1$ 到每个点的最短路，输出 对 $10^9+7$ 取模。\n$2\\le n\\le10^5$, $n-1\\le m\\le10^5$。\n简要做法 数字越长就越大，所以转化成优先长度短，其次字典序小。\n把每条边拆成位数条边（如 $(u, v, 718)$ 拆成 $(u, x, 7)$, $(x, y, 1)$, $(y, v, 8)$, $(v, x, 7)$, $(y, u, 8)$），这样的话长度的边权就全是一，可以用 BFS 解决。\n如何使字典序最小呢？容易想到优先遍历边权（拆边后全是一位数）小的边，但是，如果两个点的最短路相同，这样做就会导致错误。（如：$dis[u]=dis[v]=233$，$u$ 在队列里在 $v$ 的前面，$(u, x, 3)$ 和 $(v, x, 2)$ 这两条边都存在，$dis[x]$ 就会被错误地设为 $2333$，而它应当是 $2332$。）\n正确的做法是将最短路相同的点绑在一起放入队列，实现可以使用 vector。\n参考代码 #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;queue\u0026gt; #include \u0026lt;cstring\u0026gt; using namespace std; const int N = 100010; const int mod = 1e9 + 7; int n, m, tot, dis[N * 5], digit[10]; vector\u0026lt;int\u0026gt; g[N * 5][10]; queue\u0026lt;vector\u0026lt;int\u0026gt; \u0026gt; q; int main() { scanf(\u0026quot;%d%d\u0026quot;, \u0026amp;n, \u0026amp;m); tot = n; for (int ww = 1; ww \u0026lt;= m; ++ww) { int u, v, w = ww; scanf(\u0026quot;%d%d\u0026quot;, \u0026amp;u, \u0026amp;v); if (w \u0026lt; 10) { g[u][w].push_back(v); g[v][w].push_back(u); } else // 拆边 { int l = ++tot; int r = l; int d = 0; while (w) { digit[++d] = w % 10; w /= 10; } for (int i = d - 1; i \u0026gt; 1; --i) { g[tot][digit[i]].push_back(tot + 1); r = ++tot; } g[u][digit[d]].push_back(l); g[r][digit[1]].push_back(u); g[v][digit[d]].push_back(l); g[r][digit[1]].push_back(v); } } memset(dis, -1, sizeof(dis)); q.push(vector\u0026lt;int\u0026gt;(1, 1)); dis[1] = 0; while (!q.empty()) { vector\u0026lt;int\u0026gt; vec = q.front(); q.pop(); for (int i = 0; i \u0026lt;= 9; ++i) { vector\u0026lt;int\u0026gt; nxt; // nxt 里存的是最短路相同的点 for (auto u : vec) { for (auto v : g[u][i]) { if (dis[v] == -1) { dis[v] = (dis[u] * 10ll + i) % mod; nxt.push_back(v); } } } if (!nxt.empty()) q.push(nxt); } } for (int i = 2; i \u0026lt;= n; ++i) printf(\u0026quot;%d\\n\u0026quot;, dis[i]); return 0; } ","date":"2019-09-16T08:58:32+08:00","permalink":"https://ouuan.github.io/post/cf1209f-koala-and-notebookbfs%E6%9C%80%E7%9F%AD%E8%B7%AF/","tags":["图论","最短路","BFS"],"title":"CF1209F Koala and Notebook（BFS，最短路）"},{"categories":["题解"],"contents":"题目链接 CF\n洛谷\n题意简述 给定一棵 $n$ 个点带边权的树，定义 $d(u)$ 为树上离它最远的点到它的距离，$q$ 次询问，每次询问给定 $l$，求一个最大的树上连通块 $V'$ 的大小，满足 $\\forall u, v\\in V'$，$|d(u)-d(v)|\\le l$。\n$1\\le n\\le 10^5$, $1\\le q\\le 50$。\n简要做法 首先使用 up and down（两遍 dfs，第一遍求往下走的最远距离，第二遍求往上走的最远距离）求出 $d(u)$。\n有一个性质：如果以 $d(u)$ 最小的 $u$ 为根，$\\forall v, d(v)\\ge d(parent(v))$。（下文中的“子树”都是以 $d$ 最小的点为根的。）\n简单证明 不难发现，我们只要证明 $u$ 的每个儿子 $v$ 都是子树 $v$ 中 $d$ 最小的，即可归纳地证明原命题。\n假设子树 $v$ 中存在一个点 $w$，$d(w)\u0026lt;d(v)$，那么从 $v$ 出发的最长路的第一步一定是 $v$ 到 $w$ 的路径上的第一条边（否则的话，从 $w$ 出发可以走到 $v$ 再走从 $v$ 出发的最长路，就会导致 $d(w)\u0026gt;d(v)$），这样的话，从 $u$ 出发也可以先走到 $v$ 再走 $v$ 出发的最长路，这样的话 $d(u)\u0026gt;d(v)$，与题设矛盾。\n 题目所求的连通块一定是 $d$ 的大小连续的一段，令所求连通块中 $d$ 最小且离根最近的点为 $u$，由上面的性质不难发现，所求连通块一定在子树 $u$ 中。\n如果按 $d$ 从大到小枚举每个点，用并查集维护符合条件的点的连通性以及每块的大小，可以发现，删去一个点（一个 $d\u0026gt;d(u)+l$ 的点）并不影响连通性，只需要将其所在块的大小减一即可。（加入一个点就是合并子树，删去一个点是删去叶子。）\n这样的话答案就是过程中最大的一块的大小。\n总时间复杂度就是 $O(qn\\alpha(n)+n\\log n)$ 或 O(qn+nlogn) 或 $O(qn\\log n)$。\n参考代码 （非常抱歉，使用了 CF 模板 qaq）\n#ifndef OUUAN #pragma GCC optimize(\u0026quot;Ofast,no-stack-protector,unroll-loops,fast-math\u0026quot;) #endif #include\u0026lt;bits/stdc++.h\u0026gt; #define int LoveLive //#define FAST_IOSTREAM 1 #define For(i,l,r)for(int i=(l),i##end=(r);i\u0026lt;=i##end;++i) #define FOR(i,r,l)for(int i=(r),i##end=(l);i\u0026gt;=i##end;--i) #define SON(i,u)for(int i=head[u];i;i=nxt[i]) #define ms(a,x)memset(a,x,sizeof(a)) #define fi first #define se second #define pb emplace_back #define pq priority_queue #define isinf(x)(x\u0026gt;=INF?-1:x) #define y1 why_is_there_a_function_called_y1 #define DEBUG(x)cerr\u0026lt;\u0026lt;(#x)\u0026lt;\u0026lt;\u0026quot;:\u0026quot;\u0026lt;\u0026lt;x\u0026lt;\u0026lt;endl using namespace std; typedef long long LoveLive;typedef pair\u0026lt;int,int\u0026gt;pii;typedef vector\u0026lt;int\u0026gt;vi; #ifdef int const int INF=0x3f3f3f3f3f3f3f3fll; #else const int INF=0x3f3f3f3f; #endif const double eps=1e-9;mt19937 rng(chrono::steady_clock::now().time_since_epoch(). count());int randint(int l,int r){int out=rng()%(r-l+1)+l;return out\u0026gt;=l?out:out+ r-l+1;} #ifdef FAST_IOSTREAM #define br cout\u0026lt;\u0026lt;'\\n' #define sp cout\u0026lt;\u0026lt;' ' long long read(){long long x;cin\u0026gt;\u0026gt;x;return x;}template\u0026lt;typename T\u0026gt;void read(T\u0026amp;x){ cin\u0026gt;\u0026gt;x;}template\u0026lt;typename T\u0026gt;void write(const T\u0026amp;x){cout\u0026lt;\u0026lt;x;} #else #define br putchar('\\n') #define sp putchar(' ') template\u0026lt;typename T\u0026gt;typename enable_if\u0026lt;!is_integral\u0026lt;T\u0026gt;::value,void\u0026gt;::type read(T \u0026amp;x){cin\u0026gt;\u0026gt;x;}long long read(){char c;long long out=0,f=1;for(c=getchar();!isdigit (c)\u0026amp;\u0026amp;c!='-';c=getchar());if(c=='-'){f=-1;c=getchar();}for(;isdigit(c);c=getchar()) out=(out\u0026lt;\u0026lt;3)+(out\u0026lt;\u0026lt;1)+c-'0';return out*f;}template\u0026lt;typename T\u0026gt;typename enable_if \u0026lt;is_integral\u0026lt;T\u0026gt;::value,T\u0026gt;::type read(T\u0026amp;x){char c;T f=1;x=0;for(c=getchar();!isdigit (c)\u0026amp;\u0026amp;c!='-';c=getchar());if(c=='-'){f=-1;c=getchar();}for(;isdigit(c);c=getchar()) x=(x\u0026lt;\u0026lt;3)+(x\u0026lt;\u0026lt;1)+c-'0';return x*=f;}char read(char\u0026amp;x){for(x=getchar();isspace(x); x=getchar());return x;}double read(double\u0026amp;x){scanf(\u0026quot;%lf\u0026quot;,\u0026amp;x);return x;}template\u0026lt; typename T\u0026gt;typename enable_if\u0026lt;!is_integral\u0026lt;T\u0026gt;::value,void\u0026gt;::type write(const T\u0026amp;x ){cout\u0026lt;\u0026lt;x;}template\u0026lt;typename T\u0026gt;typename enable_if\u0026lt;is_integral\u0026lt;T\u0026gt;::value,void\u0026gt;::type write(const T\u0026amp;x){if(x\u0026lt;0){putchar('-');write(-x);return;}if(x\u0026gt;9)write(x/10);putchar (x%10+'0');}void write(const char\u0026amp;x){putchar(x);}void write(const double\u0026amp;x){printf (\u0026quot;%.10lf\u0026quot;,x);} #endif template\u0026lt;typename T,typename...Args\u0026gt;void read(T\u0026amp;x,Args\u0026amp;...args){read(x);read(args ...);}template\u0026lt;typename OutputIt,typename=typename enable_if\u0026lt;is_same\u0026lt;output_iterator_tag ,typename iterator_traits\u0026lt;OutputIt\u0026gt;::iterator_category\u0026gt;::value||( is_base_of\u0026lt;forward_iterator_tag,typename iterator_traits\u0026lt;OutputIt\u0026gt;::iterator_category\u0026gt;::value \u0026amp;\u0026amp;!is_const\u0026lt;OutputIt\u0026gt;::value)\u0026gt;::type\u0026gt;void read(OutputIt __first,OutputIt __last){for(;__first !=__last;++__first)read(*__first);}template\u0026lt;typename InputIt,typename=typename enable_if \u0026lt;is_base_of\u0026lt;input_iterator_tag,typename iterator_traits\u0026lt;InputIt\u0026gt;::iterator_category \u0026gt;::value\u0026gt;::type\u0026gt;void wts(InputIt __first,InputIt __last){bool isFirst=true;for(; __first!=__last;++__first){if(isFirst)isFirst=false;else sp;write(*__first);}br;} template\u0026lt;typename InputIt,typename=typename enable_if\u0026lt;is_base_of\u0026lt;input_iterator_tag ,typename iterator_traits\u0026lt;InputIt\u0026gt;::iterator_category\u0026gt;::value\u0026gt;::type\u0026gt;void wtb(InputIt __first,InputIt __last){for(;__first!=__last;++__first){write(*__first);br;}}template \u0026lt;typename T\u0026gt;void wts(const T\u0026amp;x){write(x);sp;}template\u0026lt;typename T\u0026gt;void wtb(const T\u0026amp;x){write(x);br;}template\u0026lt;typename T\u0026gt;void wte(const T\u0026amp;x){write(x);exit(0);}template \u0026lt;typename T,typename...Args\u0026gt;void wts(const T\u0026amp;x,Args...args){wts(x);wts(args...);} template\u0026lt;typename T,typename...Args\u0026gt;void wtb(const T\u0026amp;x,Args...args){wts(x);wtb(args ...);}template\u0026lt;typename T,typename...Args\u0026gt;void wte(const T\u0026amp;x,Args...args){wts(x); wte(args...);}template\u0026lt;typename T\u0026gt;inline bool up(T\u0026amp;x,const T\u0026amp;y){return x\u0026lt;y?x=y,1 :0;}template\u0026lt;typename T\u0026gt;inline bool dn(T\u0026amp;x,const T\u0026amp;y){return y\u0026lt;x?x=y,1:0;} const int N = 100010; const int mod = 1000000007; int head[N], nxt[N \u0026lt;\u0026lt; 1], to[N \u0026lt;\u0026lt; 1], edge[N \u0026lt;\u0026lt; 1], cnt; int n, f[N], siz[N], id[N], rid[N]; struct Element { int fi, se; Element() { fi = 0; se = -INF; } void insert(int x) { if (x \u0026gt; fi) { se = fi; fi = x; } else if (x \u0026gt; se) se = x; } int get(int x) { if (x == fi) return se; return fi; } } dis[N]; void dfsdn(int u, int fa) { SON (i, u) { int v = to[i]; int w = edge[i]; if (v == fa) continue; dfsdn(v, u); dis[u].insert(dis[v].fi + w); } } void dfsup(int u, int fa) { SON (i, u) { int v = to[i]; int w = edge[i]; if (v == fa) continue; dis[v].insert(dis[u].get(dis[v].fi + w) + w); dfsup(v, u); } } void add(int u, int v, int w) { nxt[++cnt] = head[u]; head[u] = cnt; to[cnt] = v; edge[cnt] = w; } int find(int x) { return x == f[x] ? x : f[x] = find(f[x]); } void merge(int x, int y) { if (find(x) == find(y)) return; if (siz[find(x)] \u0026lt; siz[find(y)]) swap(x, y); siz[find(x)] += siz[find(y)]; f[find(y)] = find(x); } signed main() { #ifdef FAST_IOSTREAM cin.sync_with_stdio(false); cin.tie(0); #endif read(n); For (i, 1, n - 1) { int u, v, w; read(u, v, w); add(u, v, w); add(v, u, w); } dfsdn(1, 0); dfsup(1, 0); For (i, 1, n) id[i] = i; sort(id + 1, id + n + 1, [](int x, int y){return dis[x].fi \u0026gt; dis[y].fi;}); For (i, 1, n) rid[id[i]] = i; int q = read(); while (q--) { int len = read(); int l = 1; int ans = 0; For (i, 1, n) { f[i] = i; siz[i] = 1; } For (u, 1, n) { while (dis[id[l]].fi \u0026gt; dis[id[u]].fi + len) --siz[find(id[l++])]; SON (i, id[u]) { int v = to[i]; if (rid[v] \u0026lt; u) merge(id[u], v); } up(ans, siz[find(id[u])]); } wtb(ans); } return 0; } ","date":"2019-09-10T13:37:12+08:00","permalink":"https://ouuan.github.io/post/cf516d-drazil-and-morning-exerciseup-and-down%E5%B9%B6%E6%9F%A5%E9%9B%86/","tags":["up and down","并查集"],"title":"CF516D Drazil and Morning Exercise（up and down，并查集）"},{"categories":["题解"],"contents":"题目链接 LOJ\n洛谷\n题意简述 你需要给 $n$ 颗珠子的项链染 $m$ 颗黑色，$n-m$ 颗白色，不能有连续的一串黑色珠子长度超过 $k$，求旋转同构下本质不同的染色方案数。\n$1\\le m,k\\le n\\le10^5$\n简要做法 首先套用 Burnside 引理，以及位移为 $r$ 的旋转周期为 $\\gcd(r, n)$ 的结论，得到答案的式子： $$ \\begin{aligned} answer\u0026amp;=\\frac 1 n\\sum\\limits_{i=1}^nf\\left(\\frac n{\\gcd(i,n)}\\right)\\\\\n\u0026amp;=\\frac 1 n\\sum\\limits_{d|n}\\varphi(d)f(d) \\end{aligned} $$ 其中 $f(x)$ 表示在一个长为 $\\frac n x$ 的项链上，染 $\\frac{m}{x}$ 个黑珠子，$\\frac{n-m}x$ 个白珠子，不能有连续的一串黑色珠子长度超过 $k$ 的方案数（在不旋转的意义下计数）。\n可以看出只有 $d|m$ 时 $f(d)$ 可能不为零，如果用 $f(x, y)$ 表示在一个长为 $x+y$ 的项链上，染 $x$ 个黑珠子，$y$ 个白珠子，不能有连续的一串黑色珠子长度超过 $k$ 的方案数（在不旋转的意义下计数），答案的式子可以写成：\n$$ answer=\\frac 1 n\\sum\\limits_{d|\\gcd(n, m)}\\varphi(d)f\\left(\\frac m d, \\frac{n-m}d\\right) $$\n现在的问题转化成了快速求 $f(x, y)$。\n首先，特判掉两种情况：\n $k=n$ $y\\ne 0$ 且 $x\\le k$  这两种情况下 $f(x, y)=\\binom{x+y}x$\n由于是在环上不好处理，枚举两侧的黑珠子个数，就可以转化为序列上的问题。\n而序列上的问题，就相当于求方程 $x_1+x_2+\\cdots+x_{y+1}=x\\ (0\\le x_i\\le k)$ 的解的个数。\n考虑容斥，枚举至少有 $i$ 个变量的值大于 $k$（实际上是枚举大小为 $i$ 的子集都大于 $k$），解的个数为 $\\binom{x+y-i(k+1)}y$。\n这样的话，枚举两侧黑珠子个数最多枚举到 $k$，容斥复杂度为 $O(\\frac{x+y}k)$，计算 $f(x,y)$ 的复杂度为 $O(x+y)$，整道题的复杂度就是 $O(\\text{预处理组合数}+\\sigma(n))$，其中 $\\sigma(n)$ 表示 $n$ 的所有约数之和，在数据范围内最大为 $403200$。\n参考代码 #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstdio\u0026gt; using namespace std; typedef long long ll; const int N = 100005; const int mod = 998244353; int n, m, k, p[N], ptot, phi[N], fact[N], invf[N]; bool np[N]; int qpow(int x, int y) { int out = 1; while (y) { if (y \u0026amp; 1) out = (ll) out * x % mod; x = (ll) x * x % mod; y \u0026gt;\u0026gt;= 1; } return out; } int c(int x, int y) { if (y \u0026gt; x || y \u0026lt; 0) return 0; return (ll) fact[x] * invf[y] % mod * invf[x - y] % mod; } int calc(int x, int y) { int out = 0; for (int i = 0; i * (k + 1) \u0026lt;= x + y; ++i) { out = (out + (i \u0026amp; 1 ? -1ll : 1ll) * c(x + y - (k + 1) * i, y) * c(y + 1, i) % mod + mod) % mod; } return out; } int f(int x, int y) { if (k == n || y != 0 \u0026amp;\u0026amp; x \u0026lt;= k) return c(x + y, x); int out = 0; for (int i = 0; i \u0026lt;= x \u0026amp;\u0026amp; i \u0026lt;= k; ++i) { out = (out + (ll) (i + 1) * calc(x - i, y - 2)) % mod; } return out; } int gcd(int x, int y) { return y ? gcd(y, x % y) : x; } int main() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m \u0026gt;\u0026gt; k; fact[0] = invf[0] = 1; for (int i = 1; i \u0026lt;= n; ++i) fact[i] = (ll) fact[i - 1] * i % mod; invf[n] = qpow(fact[n], mod - 2); for (int i = n - 1; i \u0026gt;= 1; --i) invf[i] = (ll) invf[i + 1] * (i + 1) % mod; phi[1] = 1; for (int i = 2; i \u0026lt;= n; ++i) { if (!np[i]) { p[++ptot] = i; phi[i] = i - 1; } for (int j = 1; j \u0026lt;= ptot \u0026amp;\u0026amp; i * p[j] \u0026lt;= n; ++j) { int x = i * p[j]; np[x] = true; if (i % p[j]) phi[x] = phi[i] * (p[j] - 1); else { phi[x] = phi[i] * p[j]; break; } } } int ans = 0; int g = gcd(m, n); for (int i = 1; i * i \u0026lt;= g; ++i) { if (g % i == 0) { if (i * i == g) ans = (ans + (ll) f(m / i, (n - m) / i) * phi[i]) % mod; else ans = (ans + (ll) f(m / i, (n - m) / i) * phi[i] + (ll) f(m / (g / i), (n - m) / (g / i)) * phi[g / i]) % mod; } } cout \u0026lt;\u0026lt; (ll) ans * qpow(n, mod - 2) % mod; return 0; } ","date":"2019-09-05T10:45:59+08:00","permalink":"https://ouuan.github.io/post/loj6519-%E9%AD%94%E5%8A%9B%E7%8E%AFburnside%E5%BC%95%E7%90%86%E5%AE%B9%E6%96%A5%E5%8E%9F%E7%90%86/","tags":["群论","Burnside引理","组合数学","容斥原理"],"title":"LOJ6519 魔力环（Burnside引理，容斥原理）"},{"categories":["题解"],"contents":"题目链接 LOJ\n题意简述 求长度为 $n$ 逆序对数为 $k$ 的排列个数。\n$1\\le n, k\\le 10^5$，$k\\le \\binom n 2$\n简要作法 从小到大依次考虑将每个数插入排列，那么每个数 $i$ 都可以贡献 $0\\dots i-1$ 个逆序对，所以答案的生成函数为 $(1 + x)(1 + x + x^2)\\cdots(1+x+\\cdots+x^{n-1})$。\n上下同时乘上 $(1-x)^n$，即求： $$ \\frac{(1-x)(1-x^2)\\cdots(1-x^n)}{(1-x)^n} $$ （不约分是为了方便求。）\n分母 $\\frac{1}{(1-x)^n}=\\sum\\limits_{i\\ge 0}\\binom{n-1+i}{n-1}x^i$，是一个大家熟知的结论，可以利用 $(1+x+x^2+\\cdots)^n$ 的组合意义说明。\n分子的 $x^i$ 项系数的组合意义为：考虑从 $1,2,\\ldots,n$ 中选若干个和为 $i$ 的数（每个数只能选一遍）的所有方案，若选了奇数个数贡献为 $-1$，若选了偶数个数贡献为 $1$。\n这个东西可以用类似 LOJ6089 的方法求：\n令 $f_{i,j}$ 表示选 $i$ 个数和为 $j$ 的方案数。\n由于选择的数两两不同，第一维的大小是 $O(\\sqrt k)$ 的。\n转移有两种方式：\n 背包里的所有数加一。 背包里的所有数加一，并向背包中放入一个体积为 $1$ 的物品。  $$ f_{i,j}=f_{i-1,j-i}+f_{i,j-i} $$\n但这样算可能会出现体积大于 $n$ 的物品。\n具体来说，当 $j\\ge n+1$ 时，会有 $f_{i-1,j-n-1}$ 种不合法的方案，需要减去。\n计算完 dp 之后，分子的 $x^i$ 项系数即为 $\\sum\\limits_{j\\ge0}(-1)^jf_{j,i}$\n最后把分子和分母卷积起来即可，总时间复杂度为 $O(n+k\\sqrt k)$ 或 $O(n\\log p+k\\sqrt k)$（取决于计算组合数与逆元的方式）。\n参考代码 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;cstring\u0026gt; using namespace std; typedef long long ll; const int N = 100005; const int mod = 1e9 + 7; int n, k, f[2][N], cur, ans, fact[N \u0026lt;\u0026lt; 1], invf[N \u0026lt;\u0026lt; 1]; int qpow(int x, int y) { int out = 1; while (y) { if (y \u0026amp; 1) out = (ll) out * x % mod; x = (ll) x * x % mod; y \u0026gt;\u0026gt;= 1; } return out; } int c(int x, int y) { return (ll) fact[x] * invf[y] % mod * invf[x - y] % mod; } int main() { scanf(\u0026quot;%d%d\u0026quot;, \u0026amp;n, \u0026amp;k); fact[0] = invf[0] = 1; for (int i = 1; i \u0026lt;= n + k; ++i) { fact[i] = (ll) fact[i - 1] * i % mod; invf[i] = qpow(fact[i], mod - 2); } ans = c(n - 1 + k, n - 1); f[cur][0] = 1; for (int i = 1, sum = 1; sum \u0026lt;= k; sum += (++i)) { memset(f[cur ^= 1], 0, sizeof(int) * i); for (int j = i; j \u0026lt;= k; ++j) { f[cur][j] = (f[cur ^ 1][j - i] + f[cur][j - i]) % mod; if (j \u0026gt;= n + 1) f[cur][j] = (f[cur][j] - f[cur ^ 1][j - n - 1] + mod) % mod; ans = (ans + (i \u0026amp; 1 ? -1ll : 1ll) * f[cur][j] * c(n - 1 + k - j, n - 1) % mod + mod) % mod; } } printf(\u0026quot;%d\u0026quot;, ans); return 0; } ","date":"2019-09-04T09:22:32+08:00","permalink":"https://ouuan.github.io/post/loj6077-%E9%80%86%E5%BA%8F%E5%AF%B9%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B0%E8%AE%A1%E6%95%B0dp/","tags":["组合数学","生成函数","计数dp"],"title":"LOJ6077 逆序对（生成函数，计数dp）"},{"categories":["题解"],"contents":"题目链接 LOJ\n题意简述 你有体积为 $i$ ($1\\le i\\le n$) 的物品 $i$ 个，同体积物品在计数时没有区别，求装满大小为 $n$ 的背包的方案数。\n$1\\le n\\le 10^5$。\n简要作法 体积大于等于 $\\sqrt n$ 的物品可以无限选，所以考虑分开处理小于根号的和大于等于根号的。\n小于根号的 令 $f_{i, j}$ 表示从前 $i$ 种物品中选体积为 $j$ 的方案数。 $$ f_{i, j} = \\sum\\limits_{k = 0}^{\\min(i, \\left\\lfloor\\frac j i\\right\\rfloor)}f_{i-1, j - ik} $$ 可以使用模 $i$ 同余的前缀和优化。\n这部分的时间复杂度为 $O(n\\sqrt n)$，空间复杂度可以优化至 $O(n)$。\n大于等于根号的 令 $g_{i, j}$ 表示选择 $i$ 个物品体积为 $j$ 的方案数。\n转移有两种方式：\n 向背包中放入一个体积为 $\\left\\lceil\\sqrt n\\right\\rceil$ 的物品。 将背包中所有物品体积加一。  $$ g_{i, j} = g_{i - 1, j - \\left\\lceil\\sqrt n\\right\\rceil} + g_{i, j - i} $$\n由于最多选 $\\left\\lfloor\\sqrt n\\right\\rfloor$ 个物品，第一维大小为 $O(\\sqrt n)$，这部分复杂度也是 $O(n\\sqrt n)$。\n合并 相当于求卷积的一位。\n两部分加起来体积为 $n$ 就计入答案。\n需要注意的是，第二部分中体积为 $k$ 的方案数是 $\\sum\\limits_{i=0}^{\\left\\lfloor\\sqrt n\\right\\rfloor}g_{i, k}$，而不是某个单独的 dp 值。\n参考代码 #include \u0026lt;cmath\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;cstring\u0026gt; const int mod = 23333333; const int N = 100010; int n, b, f[N], pre[N], g[2][N], cur, ans; int main() { scanf(\u0026quot;%d\u0026quot;, \u0026amp;n); b = int(sqrt(n) + 1); f[0] = 1; for (int i = 1; i \u0026lt; b; ++i) { for (int j = 0; j \u0026lt;= n; ++j) pre[j] = (f[j] + (j \u0026gt;= i ? pre[j - i] : 0)) % mod; for (int j = 0; j \u0026lt;= n; ++j) { if (j \u0026lt; i * (i + 1)) f[j] = pre[j]; else f[j] = (pre[j] - pre[j - i * (i + 1)] + mod) % mod; } } ans = f[n]; g[cur][0] = 1; for (int i = 1; i \u0026lt; b; ++i) { memset(g[cur ^= 1], 0, sizeof(int) * (i * b)); for (int j = i * b; j \u0026lt;= n; ++j) { g[cur][j] = (g[cur ^ 1][j - b] + g[cur][j - i]) % mod; ans = (ans + 1ll * f[n - j] * g[cur][j]) % mod; } } printf(\u0026quot;%d\u0026quot;, ans); return 0; } ","date":"2019-09-04T09:21:35+08:00","permalink":"https://ouuan.github.io/post/loj6089-%E5%B0%8Fy%E7%9A%84%E8%83%8C%E5%8C%85%E8%AE%A1%E6%95%B0%E9%97%AE%E9%A2%98%E6%A0%B9%E5%8F%B7%E5%88%86%E6%B2%BB%E8%AE%A1%E6%95%B0dp/","tags":["计数dp","根号分治"],"title":"LOJ6089 小Y的背包计数问题（根号分治，计数dp）"},{"categories":["知识点"],"contents":"Lindström–Gessel–Viennot lemma，即 LGV 引理，可以用来处理有向无环图上不相交路径计数等问题。\n前置知识： 图论简介 、 图论基础 、 矩阵 、 高斯消元求行列式 。\nLGV 引理仅适用于 有向无环图 。\n定义 $\\omega(P)$ 表示 $P$ 这条路径上所有边的边权之积。（路径计数时，可以将边权都设为 $1$ ）（事实上，边权可以为生成函数）\n$e(u, v)$ 表示 $u$ 到 $v$ 的 每一条 路径 $P$ 的 $\\omega(P)$ 之和，即 $e(u, v)=\\sum\\limits_{P:u\\rightarrow v}\\omega(P)$ 。\n起点集合 $A$ ，是有向无环图点集的一个子集，大小为 $n$ 。\n终点集合 $B$ ，也是有向无环图点集的一个子集，大小也为 $n$ 。\n一组 $A\\rightarrow B$ 的不相交路径 $S$ ： $S_i$ 是一条从 $A_i$ 到 $B_{\\sigma(S)_i}$ 的路径（ $\\sigma(S)$ 是一个排列），对于任何 $i\\ne j$ ， $S_i$ 和 $S_j$ 没有公共顶点。\n$N(\\sigma)$ 表示排列 $\\sigma$ 的逆序对个数。\n引理 $$ M = \\begin{bmatrix}e(A_1,B_1)\u0026amp;e(A_1,B_2)\u0026amp;\\cdots\u0026amp;e(A_1,B_n)\\\\\ne(A_2,B_1)\u0026amp;e(A_2,B_2)\u0026amp;\\cdots\u0026amp;e(A_2,B_n)\\\\\n\\vdots\u0026amp;\\vdots\u0026amp;\\ddots\u0026amp;\\vdots\\\\\ne(A_n,B_1)\u0026amp;e(A_n,B_2)\u0026amp;\\cdots\u0026amp;e(A_n,B_n)\\end{bmatrix} $$\n$$ \\det(M)=\\sum\\limits_{S:A\\rightarrow B}(-1)^{N(\\sigma(S))}\\prod\\limits_{i=1}^n \\omega(S_i) $$\n其中 $\\sum\\limits_{S:A\\rightarrow B}$ 表示满足上文要求的 $A\\rightarrow B$ 的每一组不相交路径 $S$ ，$\\det$ 表示行列式。\n证明请参考 维基百科 。\n例题 hdu5852 Intersection is not allowed!\n题意：有一个 $n\\times n$ 的棋盘，一个棋子从 $(x, y)$ 只能走到 $(x, y+1)$ 或 $(x + 1, y)$ ，有 $k$ 个棋子，一开始第 $i$ 个棋子放在 $(1, a_i)$ ，最终要到 $(n, b_i)$ ，路径要两两不相交，求方案数对 $10^9+7$ 取模。 $1\\le n\\le 10^5$ , $1\\le k\\le 100$ ，保证 $1\\le a_1\u0026lt;a_2\u0026lt;\\dots\u0026lt;a_n\\le n$ , $1\\le b_1\u0026lt;b_2\u0026lt;\\dots\u0026lt;b_n\\le n$ 。\n观察到如果路径不相交就一定是 $a_i$ 到 $b_i$ ，因此 LGV 引理中一定有 $\\sigma(S)_i=i$ ，不需要考虑符号问题。边权设为 $1$ ，直接套用引理即可。\n从 $(1, a_i)$ 到 $(n, b_j)$ 的路径条数相当于从 $n-1+b_j-a_i$ 步中选 $n-1$ 步向下走，所以 $e(A_i, B_j)=\\binom{n-1+b_j-a_i}{n-1}$ 。\n行列式可以使用高斯消元求。\n复杂度为 $O(n+k^2(k + \\log p))$ ，其中 $\\log p$ 是求逆元复杂度。\n参考代码 #include \u0026lt;algorithm\u0026gt; #include \u0026lt;cstdio\u0026gt; typedef long long ll; const int K = 105; const int N = 100005; const int mod = 1e9 + 7; int T, n, k, a[K], b[K], fact[N \u0026lt;\u0026lt; 1], m[K][K]; int qpow(int x, int y) { int out = 1; while (y) { if (y \u0026amp; 1) out = (ll)out * x % mod; x = (ll)x * x % mod; y \u0026gt;\u0026gt;= 1; } return out; } int c(int x, int y) { return (ll)fact[x] * qpow(fact[y], mod - 2) % mod * qpow(fact[x - y], mod - 2) % mod; } int main() { fact[0] = 1; for (int i = 1; i \u0026lt; N * 2; ++i) fact[i] = (ll)fact[i - 1] * i % mod; scanf(\u0026quot;%d\u0026quot;, \u0026amp;T); while (T--) { scanf(\u0026quot;%d%d\u0026quot;, \u0026amp;n, \u0026amp;k); for (int i = 1; i \u0026lt;= k; ++i) scanf(\u0026quot;%d\u0026quot;, a + i); for (int i = 1; i \u0026lt;= k; ++i) scanf(\u0026quot;%d\u0026quot;, b + i); for (int i = 1; i \u0026lt;= k; ++i) { for (int j = 1; j \u0026lt;= k; ++j) { if (a[i] \u0026lt;= b[j]) m[i][j] = c(b[j] - a[i] + n - 1, n - 1); else m[i][j] = 0; } } for (int i = 1; i \u0026lt; k; ++i) { if (!m[i][i]) { for (int j = i + 1; j \u0026lt;= k; ++j) { if (m[j][i]) { std::swap(m[i], m[j]); break; } } } if (!m[i][i]) continue; for (int j = i + 1; j \u0026lt;= k; ++j) { if (!m[j][i]) continue; int mul = (ll)m[j][i] * qpow(m[i][i], mod - 2) % mod; for (int p = i; p \u0026lt;= k; ++p) { m[j][p] = (m[j][p] - (ll)m[i][p] * mul % mod + mod) % mod; } } } int ans = 1; for (int i = 1; i \u0026lt;= k; ++i) ans = (ll)ans * m[i][i] % mod; printf(\u0026quot;%d\\n\u0026quot;, ans); } return 0; }  ","date":"2019-09-03T21:54:43+08:00","permalink":"https://ouuan.github.io/post/lgv-%E5%BC%95%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","tags":["图论","线性代数"],"title":"LGV 引理学习笔记"},{"categories":["题解"],"contents":"题目链接 CF\n洛谷\n题意简述 给定 $n$ 和 $k$，你需要在圆上画 $k$ 个不超过 $n$ 条边的正多边形，求顶点去重后至少有多少个。\n$3\\le n\\le10^6$，$1\\le k\\le n-2$。\n简要做法   所有正多边形至少有一个公共顶点。可以感性理解，也可以看 imp 的评论。\n  选了 $x$ 边形就选了 $x$ 的所有约数（除了 $1$ 和 $2$）边形一定最优，因为选约数相当于是免费的。\n  那么，我们可以把 $x$ 边形的第 $y$ 个顶点看成分数 $\\dfrac y x$，这样的话，在已经选了 $x$ 的所有约数的前提下，选 $x$ 边形的代价就是 $\\varphi(x)$，问题就变成了求最小的 $k$ 个 $\\varphi$ 之和。\n但是，一边形和二边形是不存在的，需要特殊考虑。\n“一边形”其实就是那个所有正多边形的公共顶点，只需要在计算答案时加一即可。\n“二边形”会且仅会影响偶数边形，相当于“一旦选了某个偶数边形，答案加一”。因为 $\\varphi(x)=1$ 的 $x$ 只有 $1$ 和 $2$， 而 $\\varphi(x)=2$ 的 $x$ 只有 $3$, $4$, $6$，所以只有仅选择正三角形这种情况会受到影响。特判 $k=1$ 输出 $3$ 即可。\n用线性筛 + nth_element（值域不大，其实也可以线性排序）即可做到 $O(n)$。\n参考代码 #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; const int N = 1000010; int n, k, p[N], tot, phi[N]; bool np[N]; int main() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; k; if (k == 1) { puts(\u0026quot;3\u0026quot;); return 0; } phi[1] = 1; for (int i = 2; i \u0026lt;= n; ++i) { if (!np[i]) { p[++tot] = i; phi[i] = i - 1; } for (int j = 1; j \u0026lt;= tot \u0026amp;\u0026amp; i * p[j] \u0026lt;= n; ++j) { int x = i * p[j]; np[x] = true; if (i % p[j]) phi[x] = phi[i] * (p[j] - 1); else { phi[x] = phi[i] * p[j]; break; } } } nth_element(phi + 1, phi + k + 3, phi + n + 1); // 选了最小的 k+2 个，其中前两个是“一边形”和“二边形”的代价 long long ans = 0; for (int i = 1; i \u0026lt;= k + 2; ++i) ans += phi[i]; cout \u0026lt;\u0026lt; ans; return 0; } ","date":"2019-08-27T20:08:56+08:00","permalink":"https://ouuan.github.io/post/cf1208g-polygons%E6%95%B0%E8%AE%BA/","tags":["数论"],"title":"CF1208G Polygons（数论）"},{"categories":["题解"],"contents":"题目链接 洛谷\nAtCoder\n题意简述 给你初始串 $S_0$ 和目标串 $T$，每一步操作可以将当前串 $S_i$ 变成 $S_{i+1}$，其中：\n$$S_{i+1}[j]=\\begin{cases}S_i[1]\u0026amp;j=1\\\\S_i[j]\\text{ 或 }S_{i+1}[j-1]\u0026amp;j\u0026gt;1\\end{cases}$$\n求最少需要几次操作可以将当前串变为 $T$。\n串长 $10^6​$。\n这题题解真的难写..之前觉得别人的题解写的不清楚，然而自己也写的不是很清楚\u0026hellip;\n简要做法 首先，这个过程可以用折线表示：\n（如果您在色觉方面存在障碍，还请见谅。）\n可以发现，每条折线都尽量靠右是最优的，一旦画不下了，就加一行。\n现在问题变成了如何高效地维护这一贪心。\n当 $S_0=T$ 时，先特判掉，输出 $0​$。\n由于每次拐点都会往左下移动一格，我们可以用队列来维护当前折线的每个拐点（折线往右拐的点，也就是 $S_i[j]=S_i[j-1]$ 的 $j-1$ 这个点）（不包括最后一行的拐点），其中靠近队首表示靠下（离 $T$ 较近）的拐点，靠近队尾表示靠上（靠近 $S_0$）的拐点。\n详见代码（因为这题文字写出来不如代码好理解）：\n参考代码 #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;queue\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; int n, ans; string s, t; queue\u0026lt;int\u0026gt; q; int main() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; s \u0026gt;\u0026gt; t; if (s == t) // 特判两串相等 { puts(\u0026quot;0\u0026quot;); return 0; } int up = n - 1, down = n - 1; while (down \u0026gt;= 0) { while (down \u0026amp;\u0026amp; t[down - 1] == t[down]) --down; // 找到当前折线在最后一行最左的位置 while (up \u0026gt;= 0 \u0026amp;\u0026amp; (up \u0026gt; down || s[up] != t[down])) --up; // 找到当前折线在第一行最左的位置 if (up \u0026lt; 0) // 如果第一行没有对应的字符，输出无解 { puts(\u0026quot;-1\u0026quot;); return 0; } while (!q.empty() \u0026amp;\u0026amp; q.front() - q.size() \u0026gt;= down) q.pop(); // 把当前折线不会碰到的部分弹出 if (up != down) q.push(up); // 如果当前折线真的是“折线”而不是竖直下来不拐弯，就把 S1 的拐点压入队列 ans = max(ans, (int)q.size() + 1); // 后文会解释为什么这样更新答案 --down; } cout \u0026lt;\u0026lt; ans; return 0; }  补充说明 这个维护拐点的方式应该画画图就能明白。\n最后剩下一个问题：为什么是这样更新答案？\n换句话说：为什么答案是拐点个数的历史最大值？（加一是因为没有维护最后一行的拐点）\n如果没有这个 pop 操作，应该是很显然的。但 pop 操作破坏了“队列中每个元素对应除最后一行外每一行最左位置”这个性质。\n这里需要一个引理：\n 除了最后一行的拐点，其它拐点一定位于连续的前几行。\n 我们可以归纳地证明：\n 对于最右的那条折线，显然成立。 对于之后的每条折线，一定是先贴着上一条折线，再直接往下到最后一行。由于上一条折线满足引理，如果中途有一段没有拐点而后又出现拐点，中途的那一段就没有紧贴上一条折线。  有了这个引理，就可以感性理解说明为什么有 pop 操作的情况下答案依然是拐点个数的历史最大值了。\n","date":"2019-08-16T23:34:10+08:00","permalink":"https://ouuan.github.io/post/agc007f-shik-and-copying-string%E8%B4%AA%E5%BF%83%E5%AE%9E%E7%8E%B0/","tags":["贪心","实现"],"title":"AGC007F Shik and Copying String（贪心，实现）"},{"categories":["题解"],"contents":"题目链接 洛谷\n题意简述 给你一棵带边权的树，求所有长度在 $[L,U]$ 这个范围内的路径里平均权值（总权值除以边数）的最大值。\n$2\\le n\\le 10^5$，保证至少有一条满足要求的路径。\n简要做法 #define 父亲 单亲（如果有谴责“父亲节点”人士的话）\n首先可以二分答案，就可以把每条边的边权都减去二分的答案，然后转化为判断有没有权值和为正的符合长度要求的路径。\n然后有点分治和长链剖分两种做法，本题解介绍长链剖分的做法。\n由于合并时要区间查询最大值，可以用线段树来维护。\n具体来说，我们可以像重链剖分一样计算 dfs 序时优先 dfs 重（长）儿子，这样的话长链的 dfs 序就是连续的一段。当我们处理到子树 $u$ 时，$dfn_u+k$ 这个位置上的值表示自 $u$ 起向下长度为 $k$ 的路径的最大权值。可以发现不同长链之间不会互相影响，而重儿子的信息只要一个区间加就可以继承给父亲。所以，每次先 dfs 重儿子把信息继承上来，并检查有没有权值和为正的符合长度要求的路径，然后 dfs 轻儿子并枚举深度，在线段树中查询对应的一段长度合法的区间的最大值来检查有没有权值和为正的符合长度要求的路径，并将轻儿子信息也合并上来。\n参考代码 代码用了 CF 模板，还请谅解..（只不过这种题就算按正常码风写估计也很难看懂吧..不如自己思考细节如何实现）\n#ifndef OUUAN #pragma GCC optimize(\u0026quot;Ofast,no-stack-protector,unroll-loops,fast-math\u0026quot;) #endif #include\u0026lt;bits/stdc++.h\u0026gt; #define int LoveLive //#define FAST_IOSTREAM 1 #define For(i,l,r)for(int i=(l),i##end=(r);i\u0026lt;=i##end;++i) #define FOR(i,r,l)for(int i=(r),i##end=(l);i\u0026gt;=i##end;--i) #define SON(i,u)for(int i=head[u];i;i=nxt[i]) #define ms(a,x)memset(a,x,sizeof(a)) #define fi first #define se second #define pq priority_queue #define pb emplace_back #define isinf(x)(x\u0026gt;=INF?-1:x) #define DEBUG(x)cerr\u0026lt;\u0026lt;(#x)\u0026lt;\u0026lt;\u0026quot;:\u0026quot;\u0026lt;\u0026lt;x\u0026lt;\u0026lt;endl using namespace std;typedef long long LoveLive;typedef pair\u0026lt;int,int\u0026gt;pii;typedef vector\u0026lt;int\u0026gt;vi; #ifdef int const int INF=0x3f3f3f3f3f3f3f3fll; #else const int INF=0x3f3f3f3f; #endif const double eps=1e-9;mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());int randint (int l,int r){return(int)rng()%(r-l+1)+l;} #ifdef FAST_IOSTREAM #define br cout\u0026lt;\u0026lt;'\\n' #define sp cout\u0026lt;\u0026lt;' ' long long read(){long long x;cin\u0026gt;\u0026gt;x;return x;}template\u0026lt;typename T\u0026gt;void read(T\u0026amp;x){cin\u0026gt;\u0026gt;x;}template\u0026lt;typename T\u0026gt;void write(const T\u0026amp;x){cout\u0026lt;\u0026lt;x;} #else #define br putchar('\\n') #define sp putchar(' ') template\u0026lt;typename T\u0026gt;typename enable_if\u0026lt;!is_integral\u0026lt;T\u0026gt;::value,void\u0026gt;::type read(T\u0026amp;x){cin\u0026gt;\u0026gt;x;}long long read(){char c;long long out=0,f=1;for(c=getchar();!isdigit(c)\u0026amp;\u0026amp;c!='-';c=getchar());if(c=='-'){f=-1;c =getchar();}for(;isdigit(c);c=getchar())out=(out\u0026lt;\u0026lt;3)+(out\u0026lt;\u0026lt;1)+c-'0';return out*f;}template\u0026lt;typename T \u0026gt;typename enable_if\u0026lt;is_integral\u0026lt;T\u0026gt;::value,T\u0026gt;::type read(T\u0026amp;x){char c;T f=1;x=0;for(c=getchar();!isdigit (c)\u0026amp;\u0026amp;c!='-';c=getchar());if(c=='-'){f=-1;c=getchar();}for(;isdigit(c);c=getchar())x=(x\u0026lt;\u0026lt;3)+(x\u0026lt;\u0026lt;1)+c-'0'; return x*=f;}char read(char\u0026amp;x){for(x=getchar();isspace(x);x=getchar());return x;}double read(double \u0026amp;x){scanf(\u0026quot;%lf\u0026quot;,\u0026amp;x);return x;}void read(char*x){scanf(\u0026quot;%s\u0026quot;,x);}template\u0026lt;typename T\u0026gt;typename enable_if \u0026lt;!is_integral\u0026lt;T\u0026gt;::value,void\u0026gt;::type write(const T\u0026amp;x){cout\u0026lt;\u0026lt;x;}template\u0026lt;typename T\u0026gt;typename enable_if\u0026lt; is_integral\u0026lt;T\u0026gt;::value,void\u0026gt;::type write(const T\u0026amp;x){if(x\u0026lt;0){putchar('-');write(-x);return;}if(x\u0026gt;9)write (x/10);putchar(x%10+'0');}void write(const char\u0026amp;x){putchar(x);}void write(const double\u0026amp;x){printf(\u0026quot;%.10lf\u0026quot; ,x);}void write(const char*x){printf(\u0026quot;%s\u0026quot;,x);} #endif template\u0026lt;typename T,typename...Args\u0026gt;void read(T\u0026amp;x,Args\u0026amp;...args){read(x);read(args...);}template\u0026lt;typename ...Args\u0026gt;void read(char*x,Args\u0026amp;...args){read(x);read(args...);}template\u0026lt;typename OutputIt,typename=typename enable_if\u0026lt;is_same\u0026lt;output_iterator_tag,typename iterator_traits\u0026lt;OutputIt\u0026gt;::iterator_category\u0026gt;::value ||( is_base_of\u0026lt;forward_iterator_tag,typename iterator_traits\u0026lt;OutputIt\u0026gt;::iterator_category\u0026gt;::value\u0026amp;\u0026amp;!is_const \u0026lt;OutputIt\u0026gt;::value)\u0026gt;::type\u0026gt;void read(OutputIt __first,OutputIt __last){for(;__first!=__last;++__first) read(*__first);}template\u0026lt;typename InputIt,typename=typename enable_if\u0026lt;is_base_of\u0026lt;input_iterator_tag,typename iterator_traits\u0026lt;InputIt\u0026gt;::iterator_category\u0026gt;::value\u0026gt;::type\u0026gt;void wts(InputIt __first,InputIt __last){ for(;__first!=__last;++__first){write(*__first);sp;}}template\u0026lt;typename InputIt,typename=typename enable_if \u0026lt;is_base_of\u0026lt;input_iterator_tag,typename iterator_traits\u0026lt;InputIt\u0026gt;::iterator_category\u0026gt;::value\u0026gt;::type\u0026gt;void wtb(InputIt __first,InputIt __last){for(;__first!=__last;++__first){write(*__first);br;}}void wts(const char*x){write(x);sp;}void wtb(const char*x){write(x);br;}void wte(const char*x){write(x);exit(0);}template \u0026lt;typename T\u0026gt;void wts(const T\u0026amp;x){write(x);sp;}template\u0026lt;typename T\u0026gt;void wtb(const T\u0026amp;x){write(x);br;}template \u0026lt;typename T\u0026gt;void wte(const T\u0026amp;x){write(x);exit(0);}template\u0026lt;typename...Args\u0026gt;void wts(const char*x,Args ...args){wts(x);wts(args...);}template\u0026lt;typename...Args\u0026gt;void wtb(const char*x,Args...args){wts(x);wtb( args...);}template\u0026lt;typename...Args\u0026gt;void wte(const char*x,Args...args){wts(x);wte(args...);}template\u0026lt;typename T,typename...Args\u0026gt;void wts(const T\u0026amp;x,Args...args){wts(x);wts(args...);}template\u0026lt;typename T,typename... Args\u0026gt;void wtb(const T\u0026amp;x,Args...args){wts(x);wtb(args...);}template\u0026lt;typename T,typename...Args\u0026gt;void wte (const T\u0026amp;x,Args...args){wts(x);wte(args...);}template\u0026lt;typename T\u0026gt;inline bool up(T\u0026amp;x,const T\u0026amp;y){return x\u0026lt;y?x=y,1:0;}template\u0026lt;typename T\u0026gt;inline bool dn(T\u0026amp;x,const T\u0026amp;y){return y\u0026lt;x?x=y,1:0;} const int N = 100010; struct SegmentTree { #define ls (cur \u0026lt;\u0026lt; 1) #define rs (cur \u0026lt;\u0026lt; 1 | 1) #define mid ((l + r) \u0026gt;\u0026gt; 1) double mx[N \u0026lt;\u0026lt; 2], tag[N \u0026lt;\u0026lt; 2]; void reset() { ms(mx, 0); ms(tag, 0); } void add(int x, double y) { mx[x] += y; tag[x] += y; } void pushdown(int cur) { if (fabs(tag[cur]) \u0026lt; eps) return; add(ls, tag[cur]); add(rs, tag[cur]); tag[cur] = 0; } void modify(int cur, int l, int r, int p, double x) { up(mx[cur], x); if (l == r - 1) return; pushdown(cur); if (p \u0026lt; mid) modify(ls, l, mid, p, x); else modify(rs, mid, r, p, x); } void madd(int cur, int l, int r, int L, int R, double x) { if (l \u0026gt;= R || r \u0026lt;= L) return; if (L \u0026lt;= l \u0026amp;\u0026amp; r \u0026lt;= R) add(cur, x); else { pushdown(cur); madd(ls, l, mid, L, R, x); madd(rs, mid, r, L, R, x); mx[cur] = max(mx[ls], mx[rs]); } } double query(int cur, int l, int r, int L, int R) { if (l \u0026gt;= R || r \u0026lt;= L) return -INF; if (L \u0026lt;= l \u0026amp;\u0026amp; r \u0026lt;= R) return mx[cur]; pushdown(cur); return max(query(ls, l, mid, L, R), query(rs, mid, r, L, R)); } double query(int cur, int l, int r, int p) { if (l == r - 1) return mx[cur]; pushdown(cur); if (p \u0026lt; mid) return query(ls, l, mid, p); return query(rs, mid, r, p); } #undef ls #undef rs #undef mid } t; int head[N], nxt[N \u0026lt;\u0026lt; 1], to[N \u0026lt;\u0026lt; 1], edge[N \u0026lt;\u0026lt; 1], cnt; void add(int u, int v, int w) { nxt[++cnt] = head[u]; head[u] = cnt; to[cnt] = v; edge[cnt] = w; } int n, mnlen, mxlen, dep[N], son[N], f[N], dfn[N], dfntot; void dfs1(int u, int fa) { dep[u] = 1; SON(i, u) { int v = to[i]; if (v == fa) continue; f[v] = edge[i]; dfs1(v, u); if(up(dep[u], dep[v] + 1)) son[u] = v; } } void dfs2(int u, int fa) { dfn[u] = ++dfntot; if (son[u]) dfs2(son[u], u); SON(i, u) { int v = to[i]; if (v != fa \u0026amp;\u0026amp; v != son[u]) dfs2(v, u); } } bool flag; void dfs(int u, int fa, double x) { if (flag || !son[u]) return; dfs(son[u], u, x); t.madd(1, 1, n + 1, dfn[son[u]], dfn[son[u]] + dep[son[u]], f[son[u]] - x); if (dep[u] - 1 \u0026gt;= mnlen \u0026amp;\u0026amp; t.query(1, 1, n + 1, dfn[u] + mnlen, min(dfn[u] + mxlen + 1, dfn[u] + dep[u])) \u0026gt; 0) { flag = true; return; } SON(i, u) { int v = to[i]; if (v != fa \u0026amp;\u0026amp; v != son[u]) { dfs(v, u, x); t.madd(1, 1, n + 1, dfn[v], dfn[v] + dep[v], f[v] - x); For (j, max(0ll, mnlen - dep[u]), min(mxlen - 1, dep[v] - 1)) { if (t.query(1, 1, n + 1, dfn[v] + j) + t.query(1, 1, n + 1, max(0ll, mnlen - j - 1) + dfn[u], min(dep[u], mxlen - j) + dfn[u]) \u0026gt; 0) { flag = true; return; } } For (j, 0, dep[v] - 1) t.modify(1, 1, n + 1, dfn[u] + j + 1, t.query(1, 1, n + 1, dfn[v] + j)); } } } bool check(double x) { flag = false; t.reset(); dfs(1, 0, x); return flag; } signed main() { #ifdef FAST_IOSTREAM cin.sync_with_stdio(false); cin.tie(0); #endif read(n, mnlen, mxlen); For (i, 2, n) { int u, v, w; read(u, v, w); add(u, v, w); add(v, u, w); } dfs1(1, 0); dfs2(1, 0); double l = 0, r = 1e6; For (i, 1, 40) { double mid = (l + r) / 2; if (check(mid)) l = mid; else r = mid; } printf(\u0026quot;%.3lf\u0026quot;, r); return 0; } ","date":"2019-07-23T20:24:05+08:00","permalink":"https://ouuan.github.io/post/bzoj1758-wc2010-%E9%87%8D%E5%BB%BA%E8%AE%A1%E5%88%92%E4%BA%8C%E5%88%86%E7%AD%94%E6%A1%88%E9%95%BF%E9%93%BE%E5%89%96%E5%88%86/","tags":["二分答案","长链剖分"],"title":"BZOJ1758 [WC2010]重建计划（二分答案，长链剖分）"},{"categories":["游记"],"contents":" 我也来到 NOI 了，呢。\n 郑重声明\n本博客内所有与 NOI2019（第 36 届全国青少年信息学奥林匹克竞赛）试题相关之内容，均在对应之机试与复评结束之后发布，详细发布时间与内容可以在 commits 中查看。\nDay 499122177 广二宿舍还是没有网.\n床边的插座不是一般人能插的..（Orz lbw 插上去了）然而因为有时候要去机房（其实基本上也就刚到那天晚上没事去了..），所以后来还是拔下来了。然后发现不带 220V 转 USB 母头的插头真是个错误的决定..虽然可以用笔记本充电，可如果在寝室门口充电就没法用电脑，所以没法一会儿充电脑用手机、一会儿充手机用电脑。\n晚餐有点抽卡的感觉..看名字很难看出拿到手上的到底是什么东西（\n吃完晚饭去自习室水了半小时群，然后打短裙 OJ。\n切完前两题，好像 rk 5..\n然后看 C，问满足一堆条件的个数..一眼容斥..然后真的写了 1h 的容斥 qaq\n好不容易过拍了，提交，又 WA 了..\n在群里一问，woc，p 不是排列\u0026hellip;\n5 min 后过了，愉快地垫底了..\n过于自闭，看了眼 D，没秒掉，就懒得去想了。\n赛后听说 C 可以状压，一想，真的可以状压\u0026hellip;..学傻了.webp\nDay 557219762 咕掉早饭把火车上剩的吃了。\n（开幕式竟然没有 wh 讲话）\n（灯光打得好！覆盖方位广！给灯光师点个赞！）\n果然有公开处刑大头照展示，只不过速度比较快，问题不大。\n感觉大家喊的口号都听不太清啊..\n明 示 爆 零 ：\ndzd 的讲话中，有这么一段话：\n 无论何种情况，这个竞赛都会继续下去。因为这个竞赛是正当的，是正义的，合法的。\n 听到这段话，又想起 ひなた 在桥边含泪喊出的那段话了：\n 但是，我没有后悔，不能后悔，因为，我所做的事情一定没有错！\n NOI 可能真的如 dzd 所说，带有一些“净化灵魂”的成分在吧。\n最后鸽子蛋破不开，明示摆脱不了爆零的命运。\n（离场后目击 dzd 被采访）\n中餐感觉海星..还是得看看别人买到的是什么再选。（千万不要用排除法来选\n中午写了写博客，做了遍笔试，睡了会儿觉。\n还是感觉好方..毕竟被鄙视用的错误选项从来没变过（\n结果笔试挺水的..题目和题库里完全一样（没有之前在 vfk 博客里看见的“那道题不选 foobar.sh”之类的情况），很多题都不是四个选项而是更少，所以没有任何奇怪的错误选项..\nDay 1 看到 T1 就很快想出了 70 分的拆点做法，写完之后几乎一遍过了大样例。\n然后去把 T2 和 T3 的 20 + 28 写了，此时 $1.5h​$ 左右。\n然后去写 T1 $A=0$ 的部分分，各种写挂写了接近 $2h$..\n然后感觉 T2 还是没什么想法，T3 想了几个假贪心，又想了几个假网络流，最后还剩半小时的时候想到了一个考后才叉掉的 $n^3\\log$ 的假贪心（讲题时发现稍微改动一下就是正确的 40 分做法..），幸好没写完，不然万一过了样例就 GG 了。\n出来之后发现大家都 $148​$ 起步..T1 有正解的，但还有一堆利用数据范围改小的，以及一堆 $70​$ 分算错复杂度的。\nT1 我写的数据分治是不可能 $85​$ 以上的，所以特别怕 $70​$ 分做法最后 $90​$ 或者 $95​$。\n然后下午一看，我自己倒是没挂分，$85+20+28=133​$，可其它和我写一样东西的都是 $100+20+40​$..\nT1 数据范围不知道是不是为了防止爆 int 而改小就算了，复杂度完全错误的 $70​$ 分做法竟然直接 A 了..就很自闭。T3 其他人的 $n^4​$ 常数比我小一截，我也不好说什么..只不过那些“数据有梯度”的出题人凭什么不多给几档部分分啊？\n感觉还是赛制问题啊..没有 Subtask 并且现场评测的 OI 赛制出题人也很无奈吧..\n把 NOI 嘉年华咕了（玩一些体育运动之类的游戏得奖品什么的），回寝室躺了一会儿，又看了一遍 四色的NOI，感觉自己的心境和 vfk Cu 那年挺像的..只不过就算把 vfk Fe 那年去掉，我也比 vfk 少一年啊..\n讲题的话..放一张 T2 讲题的图吧：\nDay 116195171 今天是社会活动日。\n听说真的有人没去..不知道会不会扣分。\n坐 D7 的被奶了：\n在博物馆先打了把四人南，然后去随便逛了半个小时。\n暗示 route 数据水：\n暗示 Day 2 Au 线 30 Ag 线 20：\n假毛，请大家自行脑补假毛在风中打转的样子。\n晚上是 zzq 和象的见面会，感觉还是象比较励志，其它三名国家队都是小学开始学的..刷题量好像非常恐怖，而“好好打模拟赛”对我来说几乎不需要解释..我知道平时我是怎样在打模拟赛的，“这个知识点还没学”，“这题没意思”，“题解看不懂”，“这题太简单了，只是考场 sb 了而已，懒得写”，“我先按我的计划补知识点，模拟赛不重要”，最后一题都没有改。这样的话我又在渴求什么呢。\n 以为自己很努力了，但是不知为何还是系统告诉我：Mission Failed. Play Again.\n不知道原因。\n张着嘴巴我可以说出一堆：经验少啦，在弱省啦，题做得少啦，数学太弱啦……\n但是这是不是真正的原因？怎样解决？\n天地无言。\n—— vfk《四色的NOI》\n 可我甚至不能“以为自己很努力了”。\nDay 2 今天的纸质题面考前是正面朝上的。\n果然有交互，还依然是 I 君。\n等等，T2 斗主地？\n等等，T1 128MB？简洁数据结构.pdf\n开始考试，T1，线段树优化连边？爆空间。88 可能能卡过？感觉很难卡，还得数据分治，写了不到 5min 就放弃了，去写了 72 分。\nT2，dp 算洗牌前是 $i​$ 洗牌后是 $j​$ 的概率，第四个点矩阵快速幂，很快就写完了，一遍过样例。这个时候两小时多一点。\n考前就想着靠交互翻盘了，还剩接近 3h 肝交互，感觉海星。\n这个数据范围好像不太统一啊..既然强制数据分治的话不如会一档写一档好了。\n先把 $\\mathcal O(n^2)$ 次询问的写了，一开始还写错了，写成了 $n$ 次修改，差点挂掉 $8$ 分。\n然后想了一会儿想到了性质 $A$ 一个期望 $\\log$ 的做法。写完 + 调完之后 3h 多一点。\n然后开始想 T3 各种各样的部分分，乱搞了 2h 一无所获。\n出来之后发现大家 T1 都会 K-D Tree，又听说 T2 结论题可以打表..感觉 Ag 基本上没了啊。\n我博客用模 998244353 的等比数列，是不是暗示 T2 模 998244353 等差数列，会被禁赛啊。\n下午看成绩，$72+30+36=138$，发现 T2 30，原因是 a 数组开小了\u0026hellip;只不过不挂分应该也是 Cu，问题不大。\n讲题的时候松松松把 NOI 弄成了鸭子营。\nT2 出题人表示：不止要让训练有素的选手进队，也要让那些能够发现题目性质的选手进队。感觉要是不能打表的话这样的想法也挺有道理的..\n出排名，果然 Cu 了。\nHB 只有 jxl 和 lwc Ag。只不过两个 E 都上了 Ag 分数线。\nzyy 捧杯了，zzy rk2，zzq rk3，_rqy rk4，jumpmelon rk6，myh rk7，zhf rk19。\n看到熟悉的名字进集训队的感觉真的很奇妙。\n晚上去高校宣讲看热闹。\n清华那位老师的气质真的就完全不一样（之前 THUWC 和 THUSC 的时候就体会地非常明显了），有条不紊地讲出硬核的优点（而不是那些花里胡哨的东西）（也没有一种”我是来完成任务“的感觉）（也不会说“那我今天就用这个 PPT 来讲一下”“那我就不用 PPT 了”这样的话），感觉讲了非常多，最后正好卡时讲完了（其它学校都感觉没讲啥就匆匆忙忙结束了）（只不过这也可能是学校实力原因）。（顺带一提，THU 没用 PPT）\n北大：我准备了一个 PPT，发邮件的时候挂了，今天我把 PPT 带过来了，我是干讲还是用 PPT，你们觉得怎么样比较好？\n主持人：抱歉，请遵守规则口头讲。\n北大：我觉得准备这么一个 PPT 不给大家看实在是对不起大家。\n（说着就打开了 PPT）\n？？？\n天津大学很快就讲完了，然后说“不用打铃了”，很多人鼓掌..感觉 THU 那样打铃的同时有条不紊地结束才比较帅啊（\n感觉武大也讲的海星，也是真的在讲而不是完成任务，感觉比较自然。\n华东师范大学：男生们可以和很多文科的女生交流。女生们也不要担心，因为你们也可以和很多文科的女生交流。emm\u0026hellip;\n排在最后的三个学校直接咕了\u0026hellip;\n只不过我一个 Cu 凭什么评价高校宣讲啊。\n“我也是有约的人了！”「两年 OI 换一纸签约」—— 一名拿到人大一等约的我省高二选手。\n好像还有面试到晚上十二点，最后拿到“替补二等约”的选手..\n看到身边的人退役更是一种说不出的感觉。\nDay 232390342 早上咕掉嘉年华，去机房把 D1T1 写了，然后试图学习 k-d tree。\n感觉资料还是太少了，也不知道网上那些复杂度是不是对的..\n下午闭幕式。大家该 Au 的 Au，该捧杯的捧杯，该扫射的灯光师继续扫射。\n结束之后真的落雨大了..下了一个多小时的大雨，选手袜子没了。\n我双色 NOI 的第一色，是古铜色的。\nDay 4 本来不想写 Day 4 的，但广州南的便利店竟然没有泡面，必须得吐槽一下。\nG1114 竟然没有插座，更得吐槽了。\n那么，长沙一中再会。\n题解 估计会比较咕\nD1T1 “去年 D1T1 最短路，今年也是呢”选手自闭了。\n出考场听说斜率优化，以为是斜率优化预处理等待时间的连边然后跑最短路。\n看了题解才知道原来这题根本不用最短路，连 DAG 最短路都不用..\n把边按结束时间（$q_i$）排序，令 $f_i$ 表示走完第 $i$ 条边后还需要的烦躁值的最小值。\n$\\begin{aligned}f_i\u0026amp;=\\min\\limits_{p_j\\ge q_i,x_j=y_i}\\{A(p_j-q_i)^2+B(p_j-q_i)+C+q_j-q_i+f_j\\}\\\\\u0026amp;=\\min\\limits_{p_j\\ge q_i,x_j=y_i}\\{Ap_j^2+Bp_j+q_j+f_j-2Ap_jq_i\\}+Aq_i^2-Bq_i+C-q_i\\end{aligned}​$\n然后就可以斜率优化了。（因为转移有 $x_j=y_i$ 的限制，要开 $n$ 个双端队列，但不要开 deque，开大量 deque 是会 MLE 的。写法的话，用 vector 存，普通方法写就好了。）\n参考代码 按理来说题解里不应该包含模板，只不过这也不是什么官方题解，我就懒得换成正常写法了。\n#ifndef OUUAN #pragma GCC optimize(\u0026quot;Ofast,no-stack-protector,unroll-loops,fast-math\u0026quot;) #endif #include\u0026lt;bits/stdc++.h\u0026gt; #define int LoveLive //#define FAST_IOSTREAM 1 #define For(i,l,r)for(int i=(l),i##end=(r);i\u0026lt;=i##end;++i) #define FOR(i,r,l)for(int i=(r),i##end=(l);i\u0026gt;=i##end;--i) #define SON(i,u)for(int i=head[u];i;i=nxt[i]) #define ms(a,x)memset(a,x,sizeof(a)) #define fi first #define se second #define pq priority_queue #define pb emplace_back #define isinf(x)(x\u0026gt;=INF?-1:x) #define DEBUG(x)cerr\u0026lt;\u0026lt;(#x)\u0026lt;\u0026lt;\u0026quot;:\u0026quot;\u0026lt;\u0026lt;x\u0026lt;\u0026lt;endl using namespace std;typedef long long LoveLive;typedef pair\u0026lt;int,int\u0026gt;pii;typedef vector\u0026lt;int\u0026gt;vi; #ifdef int const int INF=0x3f3f3f3f3f3f3f3fll; #else const int INF=0x3f3f3f3f; #endif const double eps=1e-9;mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());int randint (int l,int r){return(int)rng()%(r-l+1)+l;} #ifdef FAST_IOSTREAM #define br cout\u0026lt;\u0026lt;'\\n' #define sp cout\u0026lt;\u0026lt;' ' long long read(){long long x;cin\u0026gt;\u0026gt;x;return x;}template\u0026lt;typename T\u0026gt;void read(T\u0026amp;x){cin\u0026gt;\u0026gt;x;}template\u0026lt;typename T\u0026gt;void write(const T\u0026amp;x){cout\u0026lt;\u0026lt;x;} #else #define br putchar('\\n') #define sp putchar(' ') template\u0026lt;typename T\u0026gt;typename enable_if\u0026lt;!is_integral\u0026lt;T\u0026gt;::value,void\u0026gt;::type read(T\u0026amp;x){cin\u0026gt;\u0026gt;x;}long long read(){char c;long long out=0,f=1;for(c=getchar();!isdigit(c)\u0026amp;\u0026amp;c!='-';c=getchar());if(c=='-'){f=-1;c =getchar();}for(;isdigit(c);c=getchar())out=(out\u0026lt;\u0026lt;3)+(out\u0026lt;\u0026lt;1)+c-'0';return out*f;}template\u0026lt;typename T \u0026gt;typename enable_if\u0026lt;is_integral\u0026lt;T\u0026gt;::value,T\u0026gt;::type read(T\u0026amp;x){char c;T f=1;x=0;for(c=getchar();!isdigit (c)\u0026amp;\u0026amp;c!='-';c=getchar());if(c=='-'){f=-1;c=getchar();}for(;isdigit(c);c=getchar())x=(x\u0026lt;\u0026lt;3)+(x\u0026lt;\u0026lt;1)+c-'0'; return x*=f;}char read(char\u0026amp;x){for(x=getchar();isspace(x);x=getchar());return x;}double read(double \u0026amp;x){scanf(\u0026quot;%lf\u0026quot;,\u0026amp;x);return x;}void read(char*x){scanf(\u0026quot;%s\u0026quot;,x);}template\u0026lt;typename T\u0026gt;typename enable_if \u0026lt;!is_integral\u0026lt;T\u0026gt;::value,void\u0026gt;::type write(const T\u0026amp;x){cout\u0026lt;\u0026lt;x;}template\u0026lt;typename T\u0026gt;typename enable_if\u0026lt; is_integral\u0026lt;T\u0026gt;::value,void\u0026gt;::type write(const T\u0026amp;x){if(x\u0026lt;0){putchar('-');write(-x);return;}if(x\u0026gt;9)write (x/10);putchar(x%10+'0');}void write(const char\u0026amp;x){putchar(x);}void write(const double\u0026amp;x){printf(\u0026quot;%.10lf\u0026quot; ,x);}void write(const char*x){printf(\u0026quot;%s\u0026quot;,x);} #endif template\u0026lt;typename T,typename...Args\u0026gt;void read(T\u0026amp;x,Args\u0026amp;...args){read(x);read(args...);}template\u0026lt;typename ...Args\u0026gt;void read(char*x,Args\u0026amp;...args){read(x);read(args...);}template\u0026lt;typename OutputIt,typename=typename enable_if\u0026lt;is_same\u0026lt;output_iterator_tag,typename iterator_traits\u0026lt;OutputIt\u0026gt;::iterator_category\u0026gt;::value ||( is_base_of\u0026lt;forward_iterator_tag,typename iterator_traits\u0026lt;OutputIt\u0026gt;::iterator_category\u0026gt;::value\u0026amp;\u0026amp;!is_const \u0026lt;OutputIt\u0026gt;::value)\u0026gt;::type\u0026gt;void read(OutputIt __first,OutputIt __last){for(;__first!=__last;++__first) read(*__first);}template\u0026lt;typename InputIt,typename=typename enable_if\u0026lt;is_base_of\u0026lt;input_iterator_tag,typename iterator_traits\u0026lt;InputIt\u0026gt;::iterator_category\u0026gt;::value\u0026gt;::type\u0026gt;void wts(InputIt __first,InputIt __last){ for(;__first!=__last;++__first){write(*__first);sp;}}template\u0026lt;typename InputIt,typename=typename enable_if \u0026lt;is_base_of\u0026lt;input_iterator_tag,typename iterator_traits\u0026lt;InputIt\u0026gt;::iterator_category\u0026gt;::value\u0026gt;::type\u0026gt;void wtb(InputIt __first,InputIt __last){for(;__first!=__last;++__first){write(*__first);br;}}void wts(const char*x){write(x);sp;}void wtb(const char*x){write(x);br;}void wte(const char*x){write(x);exit(0);}template \u0026lt;typename T\u0026gt;void wts(const T\u0026amp;x){write(x);sp;}template\u0026lt;typename T\u0026gt;void wtb(const T\u0026amp;x){write(x);br;}template \u0026lt;typename T\u0026gt;void wte(const T\u0026amp;x){write(x);exit(0);}template\u0026lt;typename...Args\u0026gt;void wts(const char*x,Args ...args){wts(x);wts(args...);}template\u0026lt;typename...Args\u0026gt;void wtb(const char*x,Args...args){wts(x);wtb( args...);}template\u0026lt;typename...Args\u0026gt;void wte(const char*x,Args...args){wts(x);wte(args...);}template\u0026lt;typename T,typename...Args\u0026gt;void wts(const T\u0026amp;x,Args...args){wts(x);wts(args...);}template\u0026lt;typename T,typename... Args\u0026gt;void wtb(const T\u0026amp;x,Args...args){wts(x);wtb(args...);}template\u0026lt;typename T,typename...Args\u0026gt;void wte (const T\u0026amp;x,Args...args){wts(x);wte(args...);}template\u0026lt;typename T\u0026gt;inline bool up(T\u0026amp;x,const T\u0026amp;y){return x\u0026lt;y?x=y,1:0;}template\u0026lt;typename T\u0026gt;inline bool dn(T\u0026amp;x,const T\u0026amp;y){return y\u0026lt;x?x=y,1:0;} const int N = 100010; const int M = 200010; int n, m, a, b, c, id[M]; struct Edge { int u, v, p, q, f; bool operator\u0026lt;(const Edge \u0026amp; b) const { return q \u0026gt; b.q; } } e[M]; struct Point { int x, y; Point(int j = 0): x(2 * a * e[j].p), y(a * e[j].p * e[j].p + b * e[j].p + e[j].q + e[j].f) {} friend bool cmp(const Point \u0026amp; a1, const Point \u0026amp; a2, const Point \u0026amp; a3) { if (a1.x == a2.x) return a1.y \u0026lt; a2.y; return (a1.y - a3.y) * (a2.x - a3.x) \u0026gt;= (a2.y - a3.y) * (a1.x - a3.x); } int cal(int k) const { return y - k * x; } }; struct Deque { vector\u0026lt;Point\u0026gt; q; int ql, qr; Deque() { q.resize(1); ql = 1; qr = 0; } bool empty() const { return ql \u0026gt; qr; } void push_back(const Point \u0026amp; x) { ++qr; if (q.size() == qr) q.push_back(x); else q[qr] = x; } void cal(int i) { while (ql \u0026lt; qr \u0026amp;\u0026amp; q[ql + 1].cal(e[i].q) \u0026lt;= q[ql].cal(e[i].q)) ++ql; e[i].f = q[ql].cal(e[i].q) + a * e[i].q * e[i].q - b * e[i].q + c - e[i].q; } void insert(const Point \u0026amp; x) { while (ql \u0026lt; qr \u0026amp;\u0026amp; cmp(x, q[qr], q[qr - 1])) --qr; push_back(x); } } q[N]; signed main() { #ifdef FAST_IOSTREAM cin.sync_with_stdio(false); cin.tie(0); #endif read(n, m, a, b, c); For (i, 1, m) read(e[i].u, e[i].v, e[i].p, e[i].q); ++m; e[m].u = 0; e[m].v = 1; e[m].p = 0; e[m].q = 0; sort(e + 1, e + m + 1); For (i, 1, m) id[i] = i; sort(id + 1, id + m + 1, [](int x, int y) { return e[x].p \u0026gt; e[y].p; }); int idp = 1; For (i, 1, m) { if (e[i].v == n) { e[i].f = 0; continue; } while (idp \u0026lt;= m \u0026amp;\u0026amp; e[id[idp]].p \u0026gt;= e[i].q) { if (e[id[idp]].f \u0026lt; INF) q[e[id[idp]].u].insert(Point(id[idp])); ++idp; } if (q[e[i].v].empty()) { e[i].f = INF; continue; } q[e[i].v].cal(i); } For (i, 1, m) if (e[i].u == 0) wte(e[i].f); return 0; }   D1T3 其实可以模拟费用流，但如果你写一篇模拟费用流的题解，会发现那是一篇费用流建图的题解和一篇贪心题解拼起来。所以下面是一篇纯贪心题解。\n我们要从两个序列中各选 $k$ 个下标，考虑每一步（选择一组下标）：\n 如果还允许选两个不一样的下标，那就从剩下还没选的数里选最大的 $a$ 和最大的 $b$。 如果无法选择不一样的下标了，那么有三种选择：  选择一组 $a_i+b_i$（即 $a$, $b$ 下标相同） $a_i$ 被选了，$b_i$ 没有被选，那么把 $a_i$ 与 $b_i$ 匹配，再给 $a_i$ 原来匹配的那个 $b_j$ 找到一个剩下的里面最大的 $a_k$，然后把 $b_j$ 和 $a_k$ 匹配。 把第二条的 $a$ 和 $b$ 互换。    那么，维护剩下的最大的 $a$，剩下的最大的 $b$，剩下的最大的 $a+b$，$a_i$ 已匹配的最大的 $b_i$，$b_i$ 已匹配的最大的 $a_i$，剩余可选择的不一样下标个数，每个数匹配的数，就可以完成这个贪心了。\n前三个最大值排序即可，后两个最大值使用堆维护。细节有些多，写的时候注意每一步都确保每个量正确更新了。尤其需要注意的是“剩余可选择的不一样下标个数”的更新。\n参考代码 #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;cctype\u0026gt; #include \u0026lt;queue\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; int read() { int out = 0; char c; while (!isdigit(c = getchar())); for (; isdigit(c); c = getchar()) out = out * 10 + c - '0'; return out; } typedef pair\u0026lt;int, int\u0026gt; pii; const int N = 200010; const int INF = 1e9; int T, n, k, dif, a[N], b[N], ida[N], idb[N], idab[N], pa, pb, pab, fa[N], fb[N]; // dif 是剩余可选择的不一样下标个数，id 是用来排序的，pa，pb，pab 记录用到了第几个值（即当前最大值是 a[pa] 之类的），fa，fb 分别记录 a_i 和 b_i 匹配的数的下标 priority_queue\u0026lt;pii\u0026gt; sa, sb, emptypq; // sa 是 b 已匹配的 a，sb 是 a 已匹配的 b，emptypq 是用来多测清空的 void link(int u, int v) // 匹配两个数 { --dif; fa[u] = v; fb[v] = u; if (u == v) --dif; // 去重，否则会在下面三行代码里加两次 if (fb[u]) ++dif; else sb.push(pii(b[u], u)); if (fa[v]) ++dif; else sa.push(pii(a[v], v)); } void cut(int u, int v) // 断开匹配 { ++dif; if (fb[u]) --dif; if (fa[v]) --dif; if (u == v) ++dif; // 去重 fa[u] = fb[v] = 0; } pii geta() // 获取当前剩余的最大 a { while (fa[ida[pa]]) ++pa; return pii(a[ida[pa]], ida[pa]); } pii getb() // 获取当前剩余的最大 b { while (fb[idb[pb]]) ++pb; return pii(b[idb[pb]], idb[pb]); } pii getab() // 获取当前剩余的最大 a + b { while (pab \u0026lt;= n \u0026amp;\u0026amp; (fa[idab[pab]] || fb[idab[pab]])) ++pab; return pii(pab \u0026lt;= n ? a[idab[pab]] + b[idab[pab]] : -INF, idab[pab]); } pii getsa() // 获取 b 已选的最大 a { while (!sa.empty() \u0026amp;\u0026amp; fa[sa.top().second]) sa.pop(); return sa.empty() ? pii(-INF, 0) : sa.top(); } pii getsb() // 获取 a 已选的最大 b { while (!sb.empty() \u0026amp;\u0026amp; fb[sb.top().second]) sb.pop(); return sb.empty() ? pii(-INF, 0) : sb.top(); } int main() { T = read(); while (T--) { pa = pb = pab = 1; sa = sb = emptypq; memset(fa, 0, sizeof(fa)); memset(fb, 0, sizeof(fb)); n = read(); k = read(); dif = k - read(); for (int i = 1; i \u0026lt;= n; ++i) a[i] = read(); for (int i = 1; i \u0026lt;= n; ++i) b[i] = read(); for (int i = 1; i \u0026lt;= n; ++i) ida[i] = idb[i] = idab[i] = i; sort(ida + 1, ida + n + 1, [](int x, int y){return a[x] \u0026gt; a[y];}); sort(idb + 1, idb + n + 1, [](int x, int y){return b[x] \u0026gt; b[y];}); sort(idab + 1, idab + n + 1, [](int x, int y){return a[x] + b[x] \u0026gt; a[y] + b[y];}); while (k--) { if (dif) link(geta().second, getb().second); else { pii nab = getab(); pii na_a = getsa(); pii na_b = getb(); pii nb_a = geta(); pii nb_b = getsb(); if (nab.first \u0026gt;= na_a.first + na_b.first \u0026amp;\u0026amp; nab.first \u0026gt;= nb_a.first + nb_b.first) link(nab.second, nab.second); else if (na_a.first + na_b.first \u0026gt;= nb_a.first + nb_b.first) { int t = fb[na_a.second]; cut(t, na_a.second); link(t, na_b.second); link(na_a.second, na_a.second); } else { int t = fa[nb_b.second]; cut(nb_b.second, t); link(nb_a.second, t); link(nb_b.second, nb_b.second); } } } long long ans = 0; for (int i = 1; i \u0026lt;= n; ++i) ans += (fa[i] ? a[i] : 0) + (fb[i] ? b[i] : 0); printf(\u0026quot;%lld\\n\u0026quot;, ans); } return 0; }  ","date":"2019-07-15T09:48:38+08:00","permalink":"https://ouuan.github.io/post/nio9102-%E8%90%BD%E9%9B%A8%E5%A4%A7/","tags":["CCF系列赛事"],"title":"NIO9102 落雨大"},{"categories":["技术"],"contents":"今天想更新一下自己的 CF 模板，然后发现由于写法问题可能要给每种整型（int，long，long long，unsigned int，unsigned long long……）分别定义函数，于是尝试搜了一下有没有什么好的代码重用方式，发现了 enable_if，还挺好用的，但去网上搜教程可能比较难学..我乱搞了两三个小时才学会。于是就来分享一下..\n重载的匹配 SFINAE SFINAE 是 substitution failure is not an error 的缩写，即匹配失败不是错误。就是说，匹配重载的函数 / 类时如果匹配后会引发编译错误，这个函数 / 类就不会作为候选。这是一个 C++11 的新特性，也是 enable_if 最核心的原理。\n完整的重载匹配顺序（SFINAE 下）  找到候选函数，去掉其中会引发编译错误的。 完全匹配 \u0026gt; 提升转换 \u0026gt; 标准转换 \u0026gt; 用户定义的转换。  完全匹配：  值 ↔ 引用 [] → * type(argument-list) → (type *)(argument-list)（函数指针） type → const / volatile type type * → const type * type * → volatile type *   提升转换：char / short → int / float → double。 标准转换：int → char，long → double。 用户定义的转换：类中的构造函数，类型转换函数等。   非模板函数优先于模板函数。 寻找“最佳匹配”，我自己也不是很了解，可以参见 《C++ Primer Plus（第五版）》8.5.4 或上网搜索。  若经过以上过程仍有多个候选函数，则会引发二义性错误。\nenable_if 的原理 enable_if 的定义类似于下面的代码：（只有 Cond = true 时定义了 type）\ntemplate\u0026lt;bool Cond, class T = void\u0026gt; struct enable_if {}; template\u0026lt;class T\u0026gt; struct enable_if\u0026lt;true, T\u0026gt; { typedef T type; };  这样的话，enable_if\u0026lt;true, T\u0026gt;::type 即为 T，而 enable_if\u0026lt;false, T\u0026gt;::type 会引发编译错误（在 SFINAE 下，即不将包含这一 enable_if 的函数 / 类作为候选）。\nenable_if 的使用 enable_if 可以在任何地方充当一个类型使用，可以有实际意义，也可以新增一个多余的仅用来 enable / unable 的参数。\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;type_traits\u0026gt; using namespace std; template\u0026lt;int a, int b\u0026gt; typename enable_if\u0026lt;a + b == 233, bool\u0026gt;::type is233() { return true; } template\u0026lt;int a, int b\u0026gt; typename enable_if\u0026lt;a + b != 233, bool\u0026gt;::type is233() { return false; } int main() { cout \u0026lt;\u0026lt; is233\u0026lt;1, 232\u0026gt;() \u0026lt;\u0026lt; endl \u0026lt;\u0026lt; is233\u0026lt;114514, 1919\u0026gt;(); return 0; }  只不过，大多数时候 enable_if 都用来判断模板参数的类型，此时一般要和 is_integral 等模板类结合使用。\n有关 is_integral 等相关模板类的信息可以参见 C++ Reference。\nis_integral\u0026lt;T\u0026gt;::value 是一个布尔值，在 T 为整型时为真，否则为假。\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;type_traits\u0026gt; using namespace std; template\u0026lt;typename T, typename = typename enable_if\u0026lt;is_integral\u0026lt;T\u0026gt;::value, void\u0026gt;::type\u0026gt; bool isodd(T x) { return x % 2; } int main() { cout \u0026lt;\u0026lt; isodd(4) \u0026lt;\u0026lt; endl \u0026lt;\u0026lt; isodd('a'); //cout \u0026lt;\u0026lt; isodd(\u0026quot;qwq\u0026quot;); -- compile error return 0; }  一个 OutputIterator 的例子：\ntemplate \u0026lt;typename OutputIt, typename = typename enable_if\u0026lt;is_same\u0026lt;output_iterator_tag, typename iterator_traits\u0026lt;OutputIt\u0026gt;::iterator_category\u0026gt;::value || (is_base_of\u0026lt;forward_iterator_tag, typename iterator_traits\u0026lt;OutputIt\u0026gt;::iterator_category\u0026gt;::value \u0026amp;\u0026amp; !is_const\u0026lt;OutputIt\u0026gt;::value)\u0026gt;::type\u0026gt; void read(OutputIt __first, OutputIt __last) { for (; __first != __last; ++__first) read(*__first); } ","date":"2019-07-03T01:24:13+08:00","permalink":"https://ouuan.github.io/post/c-11-enable-if-%E7%9A%84%E4%BD%BF%E7%94%A8/","tags":["泛型编程","cpp"],"title":"C++11 enable_if 的使用"},{"categories":["其它知识"],"contents":"今天模拟赛遇到了一道需要超现实数的题目，赛后在阅读 Matrix67 的博客 时听说了唐纳德所著的《Surreal Numbers》（中译：研究之美）这本书，于是就阅读了一下。\n大约会把书里的定理证一遍吧..\n学习超现实数的时候请假装自己不知道关于数字的一切知识，并且不要把定义的名字真的当回事（某些定义有着熟悉的名字，但可能与我们熟知的意义相同，也可能不同）。\n小说下载\n本文可能比较咕，不知道什么时候能填完坑\u0026hellip;\nConway\u0026rsquo;s rules （翻译挺神仙的）\n 创生二道，大小诸数盖由此出。\n   凡数，皆合于前创二数之集，其位左者，无一大于或似于其位右者。\n  甲数小于或似于乙数，当且仅当甲数之左集中无一大于或似于乙数，且乙数之右集中无一小于或似于甲数。\n   Conway 检视二道，连呼妙哉！此二道真妙绝。\n Definitions Symbols 比较运算符上画一道斜线表示不满足该运算符。\n$x\\le y$ 表示 $x$ 小于或似于 $y$。\n$x\\ge y$ 表示 $y\\le x$。\n$x\\equiv y$ 表示 $x$ 似于 $y$，即 $x\\le y$ 且 $y\\le x$。\n根据下文会介绍的定理 (T4)，“不小于或似于” 即 \u0026ldquo;大于且不似于\u0026rdquo;，所以可以定义 $x\u0026lt;y$ 表示 $x\\not\\ge y$，$x\u0026gt;y$ 表示 $x\\not\\le y$。\n$A\\le x$（$A$ 是一个集合，$x$ 是一个数）表示 $A$ 中任意一个元素都 $\\le x$。（其它运算符类似）\n$x\\le A$（$A$ 是一个集合，$x$ 是一个数）表示 $A\\ge x$。（其它运算符类似）\n$A\\le B$（$A$ 和 $B$ 都是集合）表示 $A$ $\\le$ $B$ 中任意一个元素。（其它运算符类似）\nNumber 一个数 $x$ 可以表示为 $(X_L,X_R)$ 的形式，其中 $X_L$ 表示 $x$ 的左集，$X_R$ 表示 $x$ 的右集。即 $x=(X_L,X_R)$。\n$x_L$ 表示 $X_L$ 中的一个元素，$x_R$ 表示 $X_R$ 中的一个元素。\nRule #1 $$x_L\\not\\ge x_R$$\nRule #2 $$x\\le y\\Leftrightarrow X_L\\not\\ge y\\land Y_R\\not\\le x$$\nTheorems T1 $$x\\le y\\land y\\le z\\Rightarrow x\\le z$$\n证明 假设该命题不成立，即存在 $x\\le y,y\\le z,x\\not\\le z$。\n$\\because x\\not\\le z$\n$\\therefore \\exists\\ x_L\\ge z\\lor\\exists\\ z_R\\le x$\n当 $x_L\\ge z$ 时\n​\t$\\because x\\le y$\n​\t$\\therefore x_L\\not\\ge y$\n​\t$\\therefore y\\le z,z\\le x_L,y\\not\\le x_L$\n当 $z_R\\le x$ 时\n​\t$\\because y\\le z$\n​\t$\\therefore z_R\\not\\le y$\n​\t$\\therefore z_R\\le x,x\\le y,z_R\\not\\le y$\n综上，无论是哪种情形，都会得到新的一组不满足原命题的数，而这组数的其中一个数会比原来的三个数中的一个创造的早，新的这组数的另外两个数就是原来的三个数中另外两个数。这样的话，若出现了一组不满足原命题的数，创造时间就会不断向前追溯，而追溯是有尽头的，因此这种情形不可能出现。\n证毕。\n T2 $$X_L\\le x\\le X_R$$\n证明  T3 $x\\le x$\n证明  T4 $$x\\not\\le y\\Rightarrow y\\le x$$\n证明  T5 $$x\u0026lt;y\\land y\\le z\\Rightarrow x\u0026lt;z$$\n证明  T6 $$x\\le y\\land y\u0026lt;z\\Rightarrow x\u0026lt;z$$\n证明  T7 $$Y_L\u0026lt;x\u0026lt;Y_R\\Rightarrow x\\equiv(x_L\\bigcup Y_L,x_R\\bigcup Y_R)$$\n证明  （本文咕咕中……）\n","date":"2019-06-26T15:05:09+08:00","permalink":"https://ouuan.github.io/post/surreal-numbers-%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/","tags":["博弈论","超现实数"],"title":"Surreal Numbers 阅读笔记"},{"categories":["题解"],"contents":"题目链接 CF\n洛谷\n题意简述 给你一棵 $n$ 个点的树，对每个点，判断能否删去一条边再加上一条边，使得这个点成为树的重心。（树的重心：将其删去后每个联通块大小不超过 $\\frac n 2$）\n$2\\le n\\le 4\\cdot10^5​$\n简要做法 up and down，即用两遍 dfs，第一遍用孩子更新父亲，第二遍用父亲更新孩子，好像也叫做“换根 dp”。\n如何修改一条边使一个点成为重心？要把那个点原来最大的子树删掉一条边分成不超过 $\\frac n 2$ 的两半，再把切下来那个子树接到这个点上。切下来的那个子树只要不超过 $\\frac n 2$ 即可，所以我们希望切下来一个尽可能大的不超过 $\\frac n 2$ 的子树，这样剩下来那一半就可以尽量小。\n也就是说，我们需要找到以每个点为根的最大子树，以及每个子树（注意是无根树的每个子树）可以切出来的最大的不超过 $\\frac n 2$ 的子树。求这个可以使用 up and down 这个技巧，详见代码。\n求出这个之后，就可以 $\\mathcal O(1)$ 判断每个点是否合法了。\nup and down 的过程中有一个小技巧：第二遍 dfs 中用父亲更新孩子时，父亲的 down（父亲的孩子们对父亲的贡献）中要减去当前节点的贡献再更新当前节点的值，所以需要存最大值和次大值，这个可以利用一个小数据结构来简化代码，详见代码中的 struct Node。\n参考代码 #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; const int N = 400010; struct Node { int fi, se; void insert(int x) // 向最大值和次大值中插入一个值 { if (x \u0026gt; fi) { se = fi; fi = x; } else if (x \u0026gt; se) se = x; } int get(int x) // 得到除了 x 外的最大值 { if (x == fi) return se; else return fi; } } dn[N]; int calc(int u); void dfs1(int u); void dfs2(int u); void add(int u, int v); int head[N], nxt[N \u0026lt;\u0026lt; 1], to[N \u0026lt;\u0026lt; 1], cnt; int n, siz[N], fa[N], son[N], up[N]; int main() { int i, u, v, mx, sz; scanf(\u0026quot;%d\u0026quot;, \u0026amp;n); for (i = 1; i \u0026lt; n; ++i) { scanf(\u0026quot;%d%d\u0026quot;, \u0026amp;u, \u0026amp;v); add(u, v); add(v, u); } dfs1(1); dfs2(1); for (u = 1; u \u0026lt;= n; ++u) { v = son[u]; if (v == fa[u]) { sz = n - siz[u]; mx = up[u]; // 也可以 max(dn[v].get(calc(u)), up[v]) } else { sz = siz[v]; mx = dn[v].fi; // 也可以 calc(v) } printf(\u0026quot;%d \u0026quot;, sz - mx \u0026lt;= n / 2); } return 0; } void dfs1(int u) { int i, v; siz[u] = 1; for (i = head[u]; i; i = nxt[i]) { v = to[i]; if (v == fa[u]) continue; fa[v] = u; dfs1(v); siz[u] += siz[v]; dn[u].insert(calc(v)); } } void dfs2(int u) { int i, v; if (n - siz[u] \u0026lt;= n / 2) up[u] = n - siz[u]; else up[u] = max(up[fa[u]], dn[fa[u]].get(calc(u))); for (i = head[u]; i; i = nxt[i]) { v = to[i]; if (v == fa[u]) continue; dfs2(v); if (siz[v] \u0026gt; siz[son[u]]) son[u] = v; // son 是一个节点的最大子树 } if (n - siz[u] \u0026gt; siz[son[u]]) son[u] = fa[u]; } int calc(int u) // 计算孩子对父亲的贡献 { return siz[u] \u0026lt;= n / 2 ? siz[u] : dn[u].fi; } void add(int u, int v) { nxt[++cnt] = head[u]; head[u] = cnt; to[cnt] = v; } ","date":"2019-06-23T21:34:21+08:00","permalink":"https://ouuan.github.io/post/cf708c-centroids%E6%A0%91%E5%BD%A2dpup-and-down/","tags":["树形dp","up and down"],"title":"CF708C Centroids（树形dp，up and down）"},{"categories":["题解"],"contents":"题目链接 洛谷\ndarkbzoj\n题意简述 给你一张带边权的无向图，求 $1$ 到 $n$ 的边权异或和最大的路径。\n点数 $5\\times 10^4$，边数 $10^5$。\n简要做法 我们先随便找一条从 $1$ 到 $n$ 的链，然后看能如何修改它。\n如果我们不走这条链，从某个位置分叉出去，为了回到这条链上，我们一定是从某条岔路走出去，走一个环，再沿着这条岔路走回来。由于边权异或，这条岔路就不会产生贡献。因此，最终答案可以表示为一条链 + 若干个环的异或和。这条链是可以随便选的，因为一条链可以异或若干个环得到另一条链。\n然而，环可能有很多，事实上我们可以得到 dfs 树，只需考虑那些仅包含一条返祖边的环，其它环都可以由若干个这样的环异或得到。代码实现非常简单，具体可以看参考代码。\n找到这些环之后用线性基就可以求出答案了。\n参考代码 #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;cctype\u0026gt; using namespace std; typedef long long ll; ll read() { ll out = 0; char c; while (!isdigit(c = getchar())); for (; isdigit(c); c = getchar()) out = out * 10 + c - '0'; return out; } const int N = 50010; const int M = 100010; void add(int u, int v, ll w); void dfs(int u, int fa); void insert(ll x); int n, m, head[N], nxt[M \u0026lt;\u0026lt; 1], to[M \u0026lt;\u0026lt; 1], cnt; ll edge[M \u0026lt;\u0026lt; 1], dis[N], p[70], ans; bool vis[N]; int main() { int i, u, v; ll w; n = read(); m = read(); for (i = 0; i \u0026lt; m; ++i) { u = read(); v = read(); w = read(); add(u, v, w); add(v, u, w); } dfs(1, 0); ans = dis[n]; for (i = 59; ~i; --i) { if (!((ans \u0026gt;\u0026gt; i) \u0026amp; 1)) { ans ^= p[i]; } } cout \u0026lt;\u0026lt; ans; return 0; } void insert(ll x) { for (int i = 59; ~i; --i) { if ((x \u0026gt;\u0026gt; i) \u0026amp; 1) { if (p[i]) x ^= p[i]; else { p[i] = x; break; } } } } void dfs(int u, int fa) { ll w; int i, v; vis[u] = true; for (i = head[u]; i; i = nxt[i]) { v = to[i]; w = edge[i]; if (v == fa) continue; if (vis[v]) insert(dis[u] ^ dis[v] ^ w); else { dis[v] = dis[u] ^ w; dfs(v, u); } } } void add(int u, int v, ll w) { nxt[++cnt] = head[u]; head[u] = cnt; to[cnt] = v; edge[cnt] = w; } ","date":"2019-06-16T20:46:02+08:00","permalink":"https://ouuan.github.io/post/bzoj2115-wc2011-%E6%9C%80%E5%A4%A7xor%E5%92%8C%E8%B7%AF%E5%BE%84%E7%BA%BF%E6%80%A7%E5%9F%BA%E5%9B%BE%E8%AE%BA/","tags":["线性基","图论"],"title":"BZOJ2115 [WC2011]最大XOR和路径（线性基，图论）"},{"categories":["出题"],"contents":"首先，你需要意识到，自己出的题是要 给别人做 的。\n请不要说这是一句废话。这是做一名好的出题人必须要明白的。\n出题比起展示自己，更是服务他人。\nUPD: 本文已于 pr #1672 经优化、扩充后合并至 OI-wiki，推荐在 OI-wiki 上阅读。\n题目内容 关于原题 原题大致可分为完全一致、几乎一致和做法一致三种。\n 完全一致：使用一题的 AC 代码可以 AC 另一题。 几乎一致：由一题的 AC 代码改动至另一题的 AC 代码可以由一个不会该题的人完成。 做法一致：核心思路、做法一致，但代码实现上、不那么关键的细节上有差异。  这三种原题自下而上为包含关系。\n以下情况不应出现：\n 在明知有“几乎一致”的原题的情况下出原题。 由于未使用搜索引擎查找导致自己不清楚有原题，从而出了“几乎一致”的原题。 在“做法一致”的原题广为人知（如：NOIp、NOI 原题）时出原题。 在带有选拔性的考试的非送分题中出现“做法一致”的原题。  以下情况最好不要出现：\n 在明知有至少为“做法一致”的原题的情况下出原题。 由于未使用搜索引擎查找导致自己不清楚有原题，从而出了“做法一致”的原题。 在任何情况下出“几乎一致”的原题。  可以放宽要求的例外情况：\n 校内模拟赛。 以专题训练为目的的模拟赛。 难度较低的比赛，或是定位为送分题的题目。  关于毒瘤题 “毒瘤题”是一个非常模糊而主观的观念，我在这只是引用一些前人关于此的探讨，加以自己的一些理解。这个话题是非常开放的，欢迎大家来发表自己的观点。\n 一道好题不应该是两道题拼在一起，一道好题会有自己的idea —— 而它应该不加过多包装地突出这个idea。\n一道好题应该新颖。真正的好题，应该是能让人脑洞出新的好题的好题。\n—— vfk《UOJ精神之源流》\n 例子：【XR-1】柯南家族，做法的前后两部分完全割裂，前半部分为【模板】树上后缀排序，后半部分是经典树上问题。\n 一类OI题以数学为主，无论是题目描述还是做法都是数学题的特征，并且解法中不含算法相关的知识点，这类OI题目统称为纯数学题。\n—— 王天懿《论偏题的危害》\n 经典例子：NOIP2017 小凯的疑惑\n我自己的标准是：尽量不要出数学填空题。但这样的纯数学题也不是完全不可取，有时纯粹地考察一些 OI 常用数学知识也是可以接受的。\n 一部分偏题中牵涉到了大学物理的内容，导致选手在面对这些从未接触过的物理知识点时变得不知所措，造成了知识上的隔膜。\n—— 王天懿《论偏题的危害》\n 经典例子：【清华集训2015】多边形下海\n不止是物理，OI 题目中不应过多涉及到其它学科的知识，如果涉及应当给予详细的解释，不应使其它学科的知识作为解题的重大障碍。\n 一道好题无论难度如何，都应该具有自己的思维难度，需要选手去思考并发现一些性质。\n一道好题的代码可以长，但一定不是通过强行嵌套或者增加条件而让代码变长，而是长得自然，让人感觉这个题的代码就应该是这么长。\n—— 王天懿《论偏题的危害》\n 经典例子：[SDOI2010]猪国杀，【集训队互测2015】未来程序·改\n在一般的 OI 比赛中，思维难度应占主要部分。当然，如 THUWC / THUSC 的 Day 2+ 那样的工程题也有其存在的道理 —— 毕竟体验营的目的除了考察选手的算法设计能力，还有和大学学习对接的工程代码以及文档学习能力。但在一般的 OI 比赛中，考察更多的应当还是算法设计与思维能力。\n题面 题目背景 题目背景最好尽量简短。\n在题目背景较长时，应当与题目描述分开。\n需要绝对避免的情况：题目背景严重影响题意的理解。\n必要时，可以提供与背景结合的题目描述与简洁的题目描述两个版本。\n题目描述 简而言之，题目描述需要清晰易懂。\n题面中的每个可能不被理解的定义都应得到解释，不应凭空冒出未加定义的概念。例如：在 CF1172D Nauuo and Portals 中，你必须在题面中解释什么是“传送门”。\n题面中涉及到的每个概念应当使用单一的词汇来描述。例如：不应一会儿说“费用”，一会儿说“代价“。\n不应不加说明地使用与原义、常见义不同的词汇。例如：不应不加说明地用“路径”代指一条边。\n你需要保证你的题面不会自相矛盾。例如：在 CF 1173A Nauuo and Votes 中，没有把 \u0026ldquo;?\u0026rdquo; 作为一种 \u0026ldquo;result\u0026rdquo;，是因为 \u0026ldquo;?\u0026rdquo; 的含义是 \u0026ldquo;there are more than one possible results\u0026rdquo;。\n你需要保证你的题面不能被错误理解而自圆其说，即使这种理解是反常识、没有人会这么去想的。例如：在 CF1172D Nauuo and Portals 中，之所以要繁琐地定义 \u0026ldquo;walk into\u0026rdquo; 并与 \u0026ldquo;teleport\u0026rdquo; 区分，是为了防止这种理解：通过传送门可以到另一个传送门，而到了传送门会传送，因此会反复横跳。\n顺着读题目描述应当能看懂每一句话，并理解题目的任务与要求。至少在紧接着的下一段话中疑惑能够得到解释，而不是需要在若干段后才能得到解释，或者要看了输入输出格式才能明白题意，甚至需要根据样例来猜题意。例如：在 「GuOJ Round #1」琪露诺的冰雪宴会 中，在输出格式才第一次出现了题目的目标“雾之湖最终能接收到的最大水量”，再加上“灵梦当然能很快算出来清理完全部小溪的总费用是多少”这句带有误解性质的话，更容易使人读错题意，这是不可取的，应当在题目描述中就对题目的目标进行说明。（在这个例子中还存在题目背景严重影响题意理解的问题。）\n输入输出格式 输入输出格式清晰完整即可，没有死板的要求，个人建议参照 CF 的题目来写输入输出格式，具体可以参考 cf 出题人须知。\n需要特别注意的是，如果输出中含有小数，请尽量使用 SPJ。如果无法使用 SPJ，请保证对精度的要求是有限的。\n如果没有保证，对精度的要求可能是无限的。例如：要求保留三位小数，实际答案为 $0.0015$，此时只要有任意大小的误差导致计算出的答案小于 $0.0015$，即使计算出的答案是 $0.0014999999999\\cdots$ 也会输出错误的答案。\n保证对精度要求有限的例子：请输出答案四舍五入后保留小数点后三位的结果。令标准答案为 $ans$，数据保证对于任意满足 $\\frac{|x-ans|}{\\max(1,ans)}\u0026lt;10^{-9}$ 的 $x$，四舍五入后结果与 $ans$ 四舍五入后相同。\n可以参考的一些句子：\n输入的第一行包含三个正整数 $n$, $m$, $k$ ($1\\le n,m\\le 2\\cdot 10^5$, $1\\le k\\le 100$) — $n$ 表示数列的长度，$m$ 表示操作个数，$k$ 的意义见题目描述。  输入的第二行包含 $n$ 个非负整数 $a_1,a_2,\\ldots,a_n$ ($1\\le a_i\\le 10^9$) — 题目给出的数列。  接下来的 $m$ 行中的第 $i$ 行包含两个正整数 $l_i$ 和 $r_i$ ($1\\le l_i\\le r_i\\le n$)，表示第 $i$ 次操作在区间 $[l_i,r_i]$ 上进行。  接下来的 $n-1$ 行，每行包含两个正整数 $u$ 和 $v$ ($1\\le u,v\\le n$)，表示 $u$ 和 $v$ 之间由一条边相连。 数据保证给出的边能构成一棵树。  输入的唯一一行包含一个由小写英文字母构成的非空字符串，其长度不超过 $10^6$。  输入的第二行包含一个小数点后不超过三位的实数 $x$ ($-10^6\\le x\\le 10^6$)，意义见题目描述。  输出包含一个实数，当你的输出与标准答案之间的绝对误差或相对误差小于 $10^{-6}$ 时视作正确。  输出的第二行包含 $n$ 个正整数，表示你构造的一组方案 — 其中第 $i$ 个数表示你打出的第 $i$ 张牌的编号。 如果有多组合法的答案，可以任意输出其中一组。  数据范围 按照 CF 的要求，数据范围要写在输入格式里，但在国内，数据范围往往是写在题目的最后的。\n数据范围中最容易犯的错误就是不完整。输入中的每一个数、每一个字符串都应该有清晰的界定。在上文所给出的输入输出格式示例中就有一些数据范围的正确写法。\n数据范围的常见遗漏：\n “整数”中的“整”。 题面中只说了是“整数”没说是“正整数”，并且数据范围中只有上限没有下限。 字符串没说字符集。 实数没说小数点后位数。 某些变量没有给范围。  你需要保证标程可以通过满足题面所述数据范围的任何一组数据。\n样例 样例应当有一定的强度，能够查出一些简单的错误。读错题意的人应当能够通过样例发现自己读错了题意。\n有多种操作的题，每种操作都应在样例中出现。\n有多种输出的题（如 CF 1173A Nauuo and Votes），每种输出都应在样例中出现。例外：实际上不可能无解，但要求判断是否有解的题目。\n样例解释 题目描述越复杂、越不易理解就越应当有详细的样例解释。\n题目难度越简单就越应当有详细的样例解释。\n详细的样例解释可以选择配上图片。\n较大的样例可以没有样例解释。\n为了照顾色觉障碍者，最好不要使颜色成为理解样例解释所必备的。可以用彩色图片来美化样例解释，但如果一定要用颜色传递一些必要的信息，最好不要同时出现红黄或者红绿。\n时限、空间限制与部分分 时限与空间限制的目的是卡掉复杂度错误的做法。（当然，也是为了防止评测用时过长，如：只对交互次数有限制而对时间复杂度没有限制的交互题也有时间限制。）\n因此，原则上时间限制应当选取不使错误做法通过的尽量大的值。\n一般地，时限应满足以下要求：\n 至少为 std 在最坏情况下用时的两倍。 如果比赛允许使用 Java，应使 Java 能够通过。 不应使错误做法通过（实在卡不掉、想放某种错解过除外）。  为了更好地在放大常数做法过的同时卡掉错解，一般可以采用同时增大数据范围和时限的方法。但要注意，有时正解（由于缓存等玄学问题）会在数据范围增大时有极大的常数增加，此时增大数据范围不一定能够增大正解与错解之间用时的差距。\n在有部分分的赛制中，还可以通过设置有梯度的数据、数据范围稍小的数据来使较为优秀的错解和大常数正解不能通过，同时使其获得较高的部分分。\n需要注意的是，在数据范围小于 $5\\cdot 10^5$ 时，应当考虑是否能使用指令集通过。\n一般情况下空间限制应当设置的足够大，除非空间复杂度更优的做法的确十分巧妙，值得卡掉空间复杂度大的做法。这种情况下可以考虑设置空间限制较松的部分分。值得注意的是，如果不想卡掉空间消耗较大的做法，数据结构题一般需要设置较大的空间限制。\n 一道好题应该具有它的选拔性质，具有足够的区分度。应该至少4档部分分，让新手可以拿到分，让高手能够展示自己的实力。\n—— vfk《UOJ精神之源流》\n 部分分一般分为较小数据范围与特殊性质两种。\n较小数据范围一般要设置多档，即使你想不到某种复杂度的做法，也可以考虑给这种复杂度一档分。一般来说，为了避免卡常，可以设置一档极限数据除以二的部分分。\n“数据有梯度”最好用多档部分分替代。\n特殊性质部分分的设置要依具体题目而定。理想的特殊性质部分分应当是能够引导选手思考正解的。与较小数据范围部分分不同，在你不会针对某种特殊性质的做法时，最好不要给这种特殊性质一档分。例如：[CTS2019]随机立方体 的 $k=1$ 这档部分分在讲题时就被很多人吐槽，称这档部分分妨碍了思考正解。\n如果不是测试点等分且总分为测试点得分相加（如：绑 Subtask 测试），一定要在题面中说明。\n数据 数据的多样性与强度 在不绑 Subtask，按测试点给分时，本部分内容可以酌情不遵守。\n数据中应当包含每个变量的最小值与最大值。\n数据中应当包含各种各样的构造，即使你不知道什么错解会挂在这组构造上。\n当然，如果你已知一个（正常人能想的到、写的出的）正确性有问题的错解，要尽量卡掉它。（时间复杂度有问题的错解已在上文讨论过了。）\n需要特别提醒的是，如果有整型溢出的可能，一定要卡掉会溢出的做法。在有部分分的赛制中，不应使不开 long long 的人得到和暴力一样甚至更低的分数。\n如果有 pretests pretests 应尽量强（，同时尽量少）。换言之，你需要在 pt 中（用尽量少的数据组数）包含该题的所有已知叉点。（括号中为个人观点。）\n如果你希望出现少量而非没有 fst，你可以问问 Sooke 对这件事的看法（Sooke 曾经坚称“fst 是 CF 的灵魂”，在我的强烈要求下，在 CF1172A Nauuo and Cards 中，他构造了许多数据，在 pt 中卡掉了所有已知错解，最后，这题在比赛中 Div.2 的 fst 率为 $18.5%$）。\n使用 testlib.h 造数据 在平常的出题中使用 Polygon 可能不是最为方便的选择（事实上如果是多人协作出题，即使不是出 cf，使用 Polygon 依然是非常棒的选择），但 Polygon 为我们提供的出题方式十分值得借鉴。\n简而言之，在 Polygon 中，数据要么是手造，要么由 generator 生成。而这个 generator 使用 testlib.h，并且使用命令行参数来设置数据范围、构造类型等参数。\n使用 testlib.h 的好处是，它内置了随机数生成器 rnd.next()，它在不同平台上返回同样的结果，并且其种子是基于整个命令行参数生成的，不用手动设置种子，并且在参数一样时生成的数据总是一样的。\n使用命令行参数的好处是，你可以写一个 .bat 文件（或者 Linux 下的 .sh 文件），把生成数据的命令写进去，可以十分方便地生成数据。\n一个简单的 generator 例子：\n// gen.cpp #include \u0026quot;testlib.h\u0026quot; using namespace std; int n, m, k; vector\u0026lt;int\u0026gt; p; int main(int argc, char* argv[]) { registerGen(argc, argv, 1); int i; n = atoi(argv[1]); m = atoi(argv[2]); k = rnd.next(1, n); for (i = 1; i \u0026lt;= n; ++i) p.push_back(i); shuffle(p.begin(), p.end()); // testlib.h 自带的 random_shuffle，使用 rnd.next() 进行 shuffle printf(\u0026quot;%d %d %d\\n\u0026quot;, n, m, k); for (i = 0; i \u0026lt; n; ++i) printf(\u0026quot;%d%c\u0026quot;, p[i], \u0026quot; \\n\u0026quot;[i == n - 1]); // 把字符串当作数组用，中间空格，末尾换行，是一个造数据时常用的技巧 return 0; }  gen 10 10 \u0026gt; 1.in gen 1 1 \u0026gt; 2.in gen 100 200 \u0026gt; 3.in gen 2000 1000 \u0026gt; 4.in gen 100000 100000 \u0026gt; 5.in  官方 generator 教程。\n如果你愿意，还可以写一个 validator。validator 是用来检查数据合法性的，在 cf 赛制中由于 hack 的存在是必备的，而在其它赛制中，validator 相当于给数据上了一道保险锁，个人十分推荐写一个 validator。\n官方 validator 教程。\n最后推荐一个我自己经常使用的生成输出文件的 bat：\n@echo off for /R \u0026quot;%cd%\u0026quot; %%i in (*.in) do ( echo %%i validator \u0026lt; %%i if errorlevel 1 pause std \u0026lt; %%i \u0026gt; %%~ni.out ) pause  Special Judge 输出方案题和输出浮点数题是两种较为常见的需要使用 SPJ 的题型，其它题目视情况也需要使用 SPJ。在 CF 上，所有题目都必须使用基于 testlib.h 的 checker，例如：题目要求输出若干个整数时，你可以任意输出空白字符（既可以空格也可以换行）。\nchecker 一般使用 testlib.h 编写，在 lemon 中也可以使用 testlib.h。一般来说，不使用 testlib.h 是很难写好 checker 的，因为你要应对各种各样的不合法输出，需要极强的鲁棒性。\n编写 checker 需要注意以下两点：\n 你需要应对各种不合法的输出，因此，请检查读入的每个变量是否在合法范围中（readInt(minvalue, maxvalue)）。例如：读入一个在 check 过程中会作为数组下标的变量时必须检查其范围，否则可能引发数组越界，有时这会导致 RE，有时则可能判为 AC。 原则上 checker 中不应检查空白字符（即，不应使用 readSpace()、readEoln()、readEof()，值得一提的是，testlib.h 会自动检查是否有多余的输出）。  官方 checker 教程。\n题解 题解的目标是让预计会来参加比赛的人都能看懂。所以官方题解详细程度的要求会比一般的题解高。\n关于部分分 在有部分分的题目中，题解里可以考虑写一写部分分的做法。\n关于知识点 解题中用到的知识点应当写出来。对于一些难度和题目难度相当的知识点，最好给出学习该知识点的资料（比如一篇博客的地址）。“这样，再这样，然后用一些技巧就可以了”，而其中的“一些技巧”并不是谁都会的，这种情况要绝对避免。\n关于定义 题解中不要凭空冒出来一些概念。\n例如：dp 的题解要解释清楚状态的定义。\n再例如：cy 曾经写过一版 CF1172F Nauuo and Bug 的题解，其中对“分段函数”没有定义，这是绝对不可取的。\n关于细节 具体的实现细节如果比较巧妙最好写出来，否则的话“详见代码”也是可以的。如果“详见代码”的话，最好在代码中加上一定的注释。\n标程 标程中最好去掉冗余部分。比如，有人在题解中保留了完整的 define 模板（为了提高做题速度，包含大量 define 与常用函数，常用于 CF 等在线比赛），并且其中很大一部分都没有用到，这是不好的。\n上文已经说过了，如果涉及到一些题解中没有详细说明的实现细节，最好加上适量的注释。\n比赛 比赛通知中的题目难度需真实 感觉这个是比赛通知中比较需要注意的一点。\n如果不会评难度可以不评..\n Remember that authors tend to underestimate the difficulty of their problems.\n—— Codeforces PROPOSE A PROBLEM 页面的提醒\n 需要特别强调的是，如果你以 CF 的难度来进行类比（如：该比赛为 Div.2 A ~ Div.2 E 难度），不仅是难度需要与 CF Div.2 类似，题型也应当是 CF 风格。\n题目难度的分配 在类国内 OI 的模拟赛中，往往是三道题的整体难度与比赛难度相当即可。\n在类 CF / ATC 这种线上赛的比赛中，需要尽量保证难度的递增（虽然由于对难度的误估很多时候都并不能真正做到），并且尽量避免出现大的 difficulty gap。可以通过把一题分为难易两题（两个 Subtask）来减少 difficulty gap。\n题目知识点的分配 一场比赛应尽量涵盖较广的知识点（专题训练赛当然除外）。\n经典反例：涵盖了动态规划、期望、组合计数、容斥原理、多项式等多种知识点的 CTS2019。（组题人：我要从五道题里选六道，我也很无奈啊。）\n参考资料  vfk《UOJ精神之源流》 王天懿《论偏题的危害》 cf 出题人须知 vfk 博客中的CF出题人的自我修养 ","date":"2019-06-16T11:24:12+08:00","permalink":"https://ouuan.github.io/post/ouuan-%E7%9A%84%E5%87%BA%E9%A2%98%E8%A7%84%E8%8C%83/","tags":["出题规范"],"title":"ouuan 的出题规范"},{"categories":["题解"],"contents":"题目链接 洛谷\ndarkbzoj\n题意简述 给你 $n$ 个带权值的数（数和权值是两个东西），求一个权值最大的异或线性无关子集，即取这个子集的任意一个非空子集，异或和都不为零。\n原题 $n\\le1000$，实际上可以轻松 $n\\le10^5$。数 $10^{18}$，权值 $10^4$。\n简要做法 看到这题，就随便贪心一下：按权值排序，插入到线性基所在的线性空间的元素集合里（说的这么绕口是因为“插入到线性基里”是一种极不严谨的表述，而且无法和真正的“插入到线性基里”区分开），如果插入到了线性基里，就把答案加上这个数的权值。\n然后\u0026hellip;过了？\n仔细一想发现也不难证。\n首先，一堆线性无关的向量中，如果加进来一个线性相关的，一定可以删掉这些向量（包括刚加进来这个）中的某一个（并不是任意一个，但只要一个就可以了），让它们变得线性无关。这个性质在异或中可能不那么显然，但线性相关就相当于方程组中有一个多余的方程（可以由其它方程推出来），这时只要删掉一个方程就不会有多余的方程了，这样就是大家所熟知的了。\n因此，考虑加入一个元素时删掉谁呢？当然是权值小的那一个。如果事先排好序，加不进去的时候不加就好了。\n参考代码 #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; typedef long long ll; typedef pair\u0026lt;int, ll\u0026gt; pil; const int N = 1010; pil a[N]; ll p[70]; int n, ans; int main() { int i, j; scanf(\u0026quot;%d\u0026quot;, \u0026amp;n); for (i = 1; i \u0026lt;= n; ++i) scanf(\u0026quot;%lld%d\u0026quot;, \u0026amp;a[i].second, \u0026amp;a[i].first); sort(a + 1, a + n + 1); for (i = n; i \u0026gt;= 1; --i) { ll x = a[i].second; for (j = 59; ~j; --j) { if ((x \u0026gt;\u0026gt; j) \u0026amp; 1) { if (p[j]) x ^= p[j]; else { p[j] = x; ans += a[i].first; break; } } } } cout \u0026lt;\u0026lt; ans; return 0; }  三倍经验 [JLOI2015]装备购买 和 [CQOI2013]新Nim游戏 是两道和此题几乎完全一样的题，前者是用一个类似高斯消元的过程代替异或，后者要利用到 Nim 游戏的经典结论。\n","date":"2019-06-14T22:00:27+08:00","permalink":"https://ouuan.github.io/post/bzoj2460-bjwc2011-%E5%85%83%E7%B4%A0%E7%BA%BF%E6%80%A7%E5%9F%BA%E8%B4%AA%E5%BF%83/","tags":["线性基","贪心"],"title":"BZOJ2460 [BJWC2011]元素（线性基，贪心）"},{"categories":["知识点"],"contents":"又是在网上搜不到讲的比较清楚的博客的算法\u0026hellip;虽然没找到写的好的博客，但结合若干篇写的不算太差的博客，勉强是学会了..\n线性基在 OI 中特指集合为若干个非负整数，运算为异或的线性基，通常用来处理一些异或相关的问题。\n线性空间 百度百科说的就非常详细了，请完整阅读一遍。\n3b1b 的视频也很不错，如果不了解线性代数相关知识可以看一看。（如果打不开可以尝试复制网址打开）\n线性基的定义 下文中的“线性基”均指 OI 中“线性基”的常见意思。\n线性基所在的线性空间   元素集合：若干个非负整数（线性基可以说是关于若干个非负整数的，在有的教程中称其为“异或集合”）。\n  数域： $\\{0,1\\}$（也就是说，线性组合是选择一个子集异或起来，$0$, $1$ 就分别代表不选或选某个元素）。\n  元素间运算：异或。\n  数乘：普通的数乘。\n  线性基 线性基就是上文所述的线性空间的一组基底，它具有以下性质：\n  在线性基中任取若干个元素，它们的异或不为零。即它们线性无关。\n  其所在线性空间中每个元素都有唯一的方案由线性基中元素异或得到。\n  选取线性基中若干个元素异或起来得到一个元素，用这个元素去替换原线性基中任意一个元素，得到的新线性基张成的空间不变。\n  可以发现这就是线性空间基底的性质和线性基所在线性空间的定义合在一起。\n线性基的构造 构造出的线性基额外满足的性质 线性基中的每个元素的二进制最高位均不同，并且，我们称二进制最高位为第 $i$ 位的元素称为“线性基的第 $i$ 位”。\n这个性质在构造和实际应用中非常方便，但要注意，它并不是线性基所在线性空间的基底所满足的必要条件。然而下文所述线性基均满足此性质，因为它真的很实用。\n构造方式 我们考虑如何在已有一组线性基的情况下，向线性空间的元素集合中插入一个元素。\n插入新的元素后，我们需要满足：\n 线性基张成的空间中包含新插入的元素。 线性基仍然线性无关。  具体地，我们依次考虑新插入元素的每个为一的二进制位，若线性基不存在这一位，那么将这个新元素加入线性基中。\n否则，将新元素异或上线性基的这一位，然后继续处理下一位。\n因为插入一个元素等同于插入其异或上线性基中的一个元素，所以性质一满足。\n从构造过程中就可以看出，已有线性基无法异或得到这个新元素，所以性质二满足。\n参考代码：\n// p[i] 表示线性基的第 j 位 for (i = 1; i \u0026lt;= n; ++i) { cin \u0026gt;\u0026gt; x; for (j = 60; ~j; --j) { if (((x \u0026gt;\u0026gt; j) \u0026amp; 1)) { if (p[j]) x ^= p[j]; else { p[j] = x; break; } } } }  线性基的经典应用 判断一个数能否由若干数的子集异或得到 假装你要把它插入到线性空间的元素集合中，看线性基是否需要新增元素即可。\n最大子集异或和 求出线性基，依次考虑线性基的每一位，若异或上能让答案更大（即答案的这一位为零）就异或上。因为如果不异或上，这一位就是零，无论后面的位如何，都比这一位为 $1$ 劣。\nLuogu P3812 【模板】线性基\n第 $k$ 小子集异或和 需要构造特殊的线性基，满足线性基中有的位都只在线性基中的一个数中出现。例如：原线性基为 1100 和 0111，这时线性基中有 $2,3$ 两位，而第二位（$2^2$ 这一位）在 1100 和 0111 中都出现了，所以应该修改为 1011 和 0111。\n这可以用一个类似于高斯消元的过程完成：处理第 $i$ 位时，依次考虑每个比 $i$ 小的线性基中的位，若第 $i$ 位的该二进制位为 $1$ 就异或这一位。除了先用普通方法构建线性基再转化，也可以在构建时就进行处理（详见代码）。无论哪种方式，复杂度都会再乘上一个额外的二进制位数。\n得到这样一个具有特殊性质的线性基后，就可以构造第 $k$ 小子集异或和了：把 $k$ 二进制拆分，每一位的 $0$ / $1$ 对应异或时选 / 不选线性基存在的这一位（比如说，二进制位的 $2^3$ 位对应线性基中第四小的存在的位）。证明也很简单，线性基中存在的位的 0/1 唯一确定了一个异或出的数，由于每个位只在一个基中为 $1​$，这些位组成的二进制数的大小就可以代表异或出的数的大小。\nLOJ #114. k 大异或和，毒瘤题，先不说题目名是假的，这个“非空集合”的限制非常的无聊..$0$ 本来就是线性基的线性组合之一，非要选“非空集合”，就得判一下给你的数中有没有能被其它线性基表示的数，实际上判一下线性基中元素个数是否为 $n​$ 即可。\n参考代码 #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;cctype\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; typedef unsigned long long ull; const int N = 100010; int n, m, cnt; ull p[60], a[60]; int main() { int i, j; ull x, k; scanf(\u0026quot;%d\u0026quot;, \u0026amp;n); for (i = 1; i \u0026lt;= n; ++i) { scanf(\u0026quot;%llu\u0026quot;, \u0026amp;x); for (j = 51; ~j; --j) { if ((x \u0026gt;\u0026gt; j) \u0026amp; 1) { if (p[j]) x ^= p[j]; else { for (k = j - 1; ~k; --k) if ((x \u0026gt;\u0026gt; k) \u0026amp; 1) x ^= p[k]; for (k = j + 1; k \u0026lt;= 60; ++k) if ((p[k] \u0026gt;\u0026gt; j) \u0026amp; 1) p[k] ^= x; p[j] = x; break; } } } } for (i = 0; i \u0026lt;= 51; ++i) if (p[i]) a[cnt++] = p[i]; scanf(\u0026quot;%d\u0026quot;, \u0026amp;m); while (m--) { scanf(\u0026quot;%lld\u0026quot;, \u0026amp;k); if (k \u0026gt;= (1ull \u0026lt;\u0026lt; cnt) + (cnt != n)) { puts(\u0026quot;-1\u0026quot;); continue; } if (cnt != n) --k; for (x = i = 0; i \u0026lt; cnt; ++i) { if ((k \u0026gt;\u0026gt; i) \u0026amp; 1ull) { x ^= a[i]; } } printf(\u0026quot;%llu\\n\u0026quot;, x); } return 0; }   一些例题 [SCOI2016]幸运数字，由于不带修，倍增维护线性基即可。用点分治可以一个 log 解决。\n[BJWC2011]元素，贪心，从大到小判断是否能加入线性基。\n[JLOI2015]装备购买，和上一题基本一样，就是把异或换成高斯消元。\n[CQOI2013]新Nim游戏，结合 Nim 游戏经典结论，还是和上面两题一样的。\n[WC2011]最大XOR和路径，异或的结果必然是一条链异或上若干个环，找出任意一条链以及只含一条返祖边的环即可线性基解决。\nshallot，线段树分治维护线性基。\n","date":"2019-06-12T15:20:12+08:00","permalink":"https://ouuan.github.io/post/%E7%BA%BF%E6%80%A7%E5%9F%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","tags":["线性基","线性代数"],"title":"线性基学习笔记"},{"categories":["出题"],"contents":" 等你等了五千年，只为这一刹那的回眸一笑。\n 这句话作为台前幕后的标准开头应该是没问题的。\n只不过果然还是写不出 vfk 的水平啊\u0026hellip;写的比较散乱。而且是前后断断续续地写的，有的写于赛前，有的写于赛后，所以会有行文不连贯的地方，可能也会有后来忘记修正的地方。\n比赛地址\n前奏 （借用一下 vfk 的标题 qaq）\n一切源于一篇博客。\n大约是这篇和这篇。\n看到这篇博客的时候，是去年（2018）十二月，手里正有刚刚想到的一个 idea，也就是 1C —— Pictures。\n当时我自己搞了个简单的随机图片，然后脑海里就冒出了这个 idea，虽然刚想出来的时候并不会做..\n然后就拿着去找 Sooke 了..\n我：您有兴趣看一眼我出的一道题吗？\nSooke：我会 $2^n​$。\nSooke：想出洛谷公开赛？\n我：不。\nSooke：想出 cf？\n我：嗯。\n翻翻消息记录发现当时自己太天真了\u0026hellip;（2 months 都算少的）\n然后我在不会做的情况下第二天写了个英文题面..\n然后 Sooke 给我扔了套他出给 PJ 组的题，让我从里面挑给 Div.2，然后我挑了 2B —— Chess。一开始 Sooke 还想把它放在 2A..\nylh 想了道不错的 1A，然而后来因为树太多就换掉了..\n然后 PinkRabbit 加入了团队，把 Pictures 切掉了（其实花了 2h\u0026hellip;只不过比赛和出题还是不一样的，应该有不少人 A？）。\n之后莫名想到了 2A 的 idea，只不过题面一开始不是 upvote / downvote，是幼儿园里老师给小朋友发两种类型的糖果..后来感觉出 cf 用 upvote / downvote 挺合适的。\n“我们这场要有交互题！” 我在群里喊出这句话，然后没过几天我就在洗澡的时候想到了 1D —— Binary Tree。一开始我还加了个它是堆的限制，过了几个月才想到可以 BFS\u0026hellip;树剖的做法是 Sooke 想到的，之前我差点想用我的 nsqrtn 做 std。这道题是这样的，有一棵以 $1$ 为根的二叉树，你可以询问两点间距离，在 $n\\log n$ 次询问内求每个点的父亲。\n然后 ylh 想了个 1B，结果最后也没有被采用 qaq\n这样六道题就齐了，然而果然还是不想出 div.2 only 鸭\u0026hellip;到处找人要题没要到（包括后来出了两一题的 lk..），结果 lk 跟我说 lxl 可以出题。然后就有了 1F1E。lxl 说要自己写题面，然而一直咕了几个月都没写..\n然后..当时我们的想法是出五题场，把 pictures / binary tree 放 div.1，差点都提交 proposal 了，然而我还是觉得 1B 得换..\n然后，我去了雅礼集训，和 lk 面基了，就有了 1E —— GCD。一开始 GCD 是没有根号不带 log 做法的，可 lxl 问了 ccz，就有了。\n然后 Sooke 出了一道 dl 的博弈论，我不太喜欢，然而一开始还是让它过了..最后还是给换了 qaq\n后来 lk 出了 2C（一开始手牌和牌堆的牌不一定相等，我不会做，就改成了相等..），Sooke 拿出了 2D，这场就有了。\n准备 一开始我们还想抢 round 555 的（受 vfk 250 的影响 qaq）..\n给 300iq 发了个私信，问什么时候能审，能不能抢 555。然后..\n一开始还以为可以的，结果发现第一条才是真的，第二条是假的..（注意 cf 私信顺序从下往上）\n我们之前出题的时候就几乎把 Polygon 上要干的事干完了，然而，Aleph0（round 551 出题人）发来了一份 cf 出题须知（不知道是不是 vfk 博客里提到那个长篇英语阅读..），然后发现一堆东西要改..只不过一两天也就改完了。最大的问题是数据要么纯手造要么用 generator，即不能用数据生成器生成出来放 Polygon 上..我自己造的数据还好，lxl 的数据 generator 的参数已经弄丢了，而且lxl 又特别咕。\n听说 300iq 有 qq，所以就试着加了一下 300iq，拉进了群里。\n然后是 300iq 开始审（gu）题（gu），题目比较顺利地全过审了，（然而断断续续的等了好几天），binary tree 获得了 \u0026ldquo;Great problem!\u0026rdquo; 的评价。得知必须放 Java 过，然而不需要让 Java 在一半时限内通过（尤指 GCD 这题，不然卡不掉带 log 做法了\u0026hellip;），还是比较可以接受的..\n300iq 好像有验不完的题和无尽的 coordinating，所以经常失踪..contribution 只排第七举报了。\n决定比赛时间真是件难事..从一开始的 round 555 抢不到，到 5.18 是 APIO \u0026amp; 俄罗斯最后一轮国家队选拔（这俩是一个东西..），再到 5.21 ~ 5.26 得放弃 whk / sc 选手，然后 6.8 和 Google Code Jam 冲突，6 月一堆 whk 考试，7 月不仅太晚还有 ISIJ，NOI……无论选什么时间都会放弃一部分人，就像某部门决定调整某些政策一样。\n最后还是端午节拯救世界..大家好像都比较同意 6.7。\n从北京回来的高铁上，突然看到 Sooke 在群里“A big hug to 300iq!”\n诶诶诶，上 contests 了！\n诶诶诶，之前开玩笑说的 0x233 真来了！\n于是想搞个什么宣传一下。\n想了想感觉雀不错，就 p 了张图：\n结果最后还是插进来一场 Div.2 \u0026hellip; 0x233 没了\u0026hellip;\nlxl 自己说要写题面，咕了两个多月，终于：\n然后 xht37 和神仙 rushcheyo 都来验题了。听说所有题都被 rushcheyo 秒了..\n风怒 Round #0x233 开始了。\nSooke：这个 F 也是树上问距离诶。\n我：好像和 WC2018 即时战略有点像？\n再一看..非常冷静地在群里宣布，我们的 1D binary tree 没了。\nUPD：Binary Tree 已上传至 GuOJ 和 LOJ。\n二叉树被替换为了操作二，剩下的部分和我们题的做法完全一样——树剖。\n感觉挺难受的..赛前四天撞题谁顶得住啊。而且我自己挺喜欢这题的，感觉做法非常巧妙。而且我们的题不给出树的形态，有的做法只能过那道题，不能过我们这题。\n只不过 Sooke 之前就提过 Portals 这道题，于是就想换成 Portals。\n一波未平，一波又起。\ncy：这个 GCD 好像和一场中国比赛有点像。\n然后扔上来一篇题解，求的东西不一样，但做法大同小异。\nok，风怒撞题。\n然后群里就各种方案了..\ncy 扔上来了四道题..\nlk：我去找 _rqy 要一道计数！\nlxl：第十一分块！\n于此同时，我们发现 Portals 原来想的做法是假的，给 300iq 也没能切掉..\n当时有点想出五题场，或者强行把 GCD 出出来，毕竟不完全一样。\n只不过好消息还是传来了，Sooke 想到了 Portals 的正解，Bug（其实我现在想换这题名字了，还是 modadd 好听）的分块做法和线段树做法也相继有了。\n然后，经过讨论，我们不知道为什么觉得换题之后码量比原来减少了，结果就决定把时间改成 2h。\nlk 坚持认为 portals 是一道非常难的题。cy 给 portals 的评分比 1EF 都高。最后还是放在了 1D。然后赛后被喷 PJ 题放 1D。最后每题 AC 人数还是单调下降的，说明题目顺序安排的没有任何问题。关于 cards 和 circle，我们是认为对于 div.2 选手 circle 更难，而 div.1 选手顺切无所谓，所以就这样放了。而且 circle 更简单也可能是对于中国选手。而且我们这场每个偶数题都比前一题好写。\n因为 cy 把 lxl 题切了，modadd 做了比较久，而且 lxl 和 300iq 都认为 modadd 更难，而且我看了题解之后会做 lxl 题不会 modadd，所以就把 modadd 放在了 F。\n于是比赛的题目得到了最终的确定，也就是大家看到的这几题。\n然后就是紧张的造题了。\n写 modadd 题面里的伪代码时，去网上搜了半天，终于搞出来了一份特别丑的..然后想起来 3 LGM 那场 Chinese Round 的 G 有伪代码，就去找象要，结果没要到..自己研究了半天文档还是不会，就去找 zzq 要，然后顺利要到了。\n由于自己本来就菜，又被长期的睡眠不足 + 极度紧张的造题给降智，我看了半天 cy 写的 modadd 题解都不会做..然后我要在不会做的情况下造数据..就胡乱造了一点。只不过这题就算纯随机应该也够强。\n本来 lxl 题的数据也是个大问题，我自己是个链菊花随机完全二叉树出题人，lxl 又是只鸽子..幸好 300iq 帮忙造了一点数据，把 Spaly（单旋）也卡掉了。\n大约在比赛前 2h，基本上所有东西都造完了。然后，KAN 突然在赛前 1h 出现，删掉了一堆题面里的逗号，提了一堆题面的 Issues..然后就不停修锅，差点都忘记发 scoring distribution 了。\n赛前 5min 的时候终于把 KAN 提的所有 Issues fix 了..\n为了连贯性先讲了下造题的事。\n然后是上帝视角..其实其它权限都没怎么用，只不过 ban 掉了 xht37 参加比赛（\n只不过有的选项看着很爽，比如，一开始 problems 是空的你可以 add problems（最后是 300iq 还是谁加的，那时我还在修锅），还有喜闻乐见的 Is it rated? 选项，rated 范围，能否查看排行榜，什么时候开始封榜，能不能 vp。\n赛前在造锅和修锅之余，也会盯着 registrants 看。然后就看到 JOHNKRAM 报了，司报了，xyx 报了，myy 报了，ACRush 报了，_rqy 报了，txc 报了，Radewoosh 报了，800iq 报了，dmy 报了，kcz 报了，yyb 报了，ljh 报了，wqy 报了，yww 报了……群里大约就是上文去掉逗号，加上换行符和感叹号。\n最后倒计时的时候真的就像 vfk 那篇博客一样。\n还有 5 秒。\n题面有锅吗？\n还有 4 秒。\n数据有锅吗？\n还有 3 秒。\n题面或者数据有锅吗？\n还有 2 秒。\n题面和数据有锅吗？\n还有 1 秒。\n有锅也修不了了，contribution 见鬼去吧！\n\u0026hellip;..\n没办法，赛前 5min 还在修锅的我就是这么想的..只不过最后除了 circle 的样例解释没什么锅。\n比赛 比赛就这么开始了。cf 并没有卡诶。\nDiv.1 怎么卡住了..\n完了，史上最难 1A 实锤了..\n6min 的时候终于有人过了 1A，div.2 那边已经成片过 A 了。\n然后第二个 div.1 AC 是 B..完了，要被喷 swap(A, B) 了。\n25min 的时候有人过 1D 了。赛前我就奶过 portals 一血会比 pictures 早，lk 还不信。\n然后我们就看着司登顶之后一点点地往下掉..\n赛时真的可以看 system test 的结果，只不过评测优先度比较低。在 problems 界面还可以看到每题已经测了几个人的 st，其中有多少个过了。成功让 Sooke 学到了再强的 pt 也会有人 fst 这个道理。\n当然我们还得回答参赛者的提问。\n what mean is the draw the top card from the pile?\n意思是 可以在最顶上的一张画画？\n 海星，是不是可以画数字上去。\n In Test 1\nwhy is the output:\n2\n1 1\n2 1\nis wrong?\nI think it is legitimate.\n 一看评测记录，他第一行输出的 1，悲惨的故事。\n问的最多的是 pictures 权值减到负怎么办..于是让 300iq 发了个 announcement。\n还有一位坚称 cards 样例 3 答案是 16 的老哥，好像是在手上把牌排好序了。\n Hi! I am a Chinese! Could you explain why there is a \u0026ldquo;19****17\u0026rdquo; in the sample 3?\n 回答分为 text，yes，no 和 no comments，正好可以回答他。\n problem D in the example the edges for bad permutation are drawn incorrectly\n 嗯，额，诶？？woc 真的画错了..打开本地造 notes 的 pptx，发现是对的..这个锅 Sooke 背了。\n赶紧让 300iq 发了个 announcement，然后去修锅。\n修好了之后让 300iq 发个 fixed，结果一直没发..\n然后看到司在猛肝 1F..然后听群友们说，他写的是 1 log 正解，被卡常了..woc，那不是得去谢罪，卡分块把 treap 卡掉了..但我们不能做什么，只能为他默哀。后来才听说司写的 $\\log^2$..\n300iq：check it out，https://codeforces.com/contest/1172/submission/55260499 。\n然后之后半个小时几乎都在尝试卡他..然而根本卡不掉..赛后私信问他，也没太看懂他的做法，只不过他说他相信这个做法是对的..\n然后在迷迷糊糊的看榜，回答问题，尝试卡人中，2h 就这么过去了。\ndmy 被我们送上黑红了，然而好多神仙被狙了..\n1F 的英文题解还没好..contribution 要没了。\n果然比赛结束 announcement 的 up 就开始往下掉，只不过没掉很多。\n有位神仙 hack 了 cards，而且是 hack 了过了 st 的..之后我才发现，我之前没意识到不打空白牌可能步数比求那个 max 还大，他的 test 就是针对这个卡的，如果你发现能直接 1~n 就输出答案就过了，如果把两者取 min 就挂了。\n然后开始弄中文题解。hexo 博客折叠块总是漏掉百分号，漏掉引号，搞了半个多小时才搞好..\n搞了一整天，整个人都非常晕，然而这时我要尝试去写自己还不完全会的 1F 的英文题解..写到一半还是放弃了，就去发 editorial，先把 1F 空着了。\n之后 300iq 同意帮忙写题解，就去睡觉了。\n自我感觉 good problems, bad round。如果能不强求在原定的端午节把比赛出出来，或许能办的更好。\n后记 出这场 cf，究竟是为了什么。\n肯定不是为了钱。虽然 cf 会发工资，但要是为了钱，我肯定不会去出 cf，要耗费的时间精力太多了。\n真的不推荐其他人在退役之前去出 cf，不然的话，可能出着出着就退役了。\n把这么多本可以用来刷题的时间用来出 cf，后悔吗？\n其实，也是一份宝贵的经历吧。与其说后悔，不如说害怕自己的努力不被人认可，如果数百小时的努力换来的是他人的批评甚至 unrated，可能就真的不只是后悔了。\n出这场 cf，我得到了什么呢？\n以往的团队合作中，我要么是作为参与者而非组织者，要么其他成员都只是默默完成自己的任务。而且所谓的“团队合作”多半是学校里所谓的“研究性学习”。要统一各方面的意见，的确是一件难事。一开始面对“fst 是 cf 灵魂”的 Sooke（看来他负责的 cards 挺有灵魂的\u0026hellip;），然后是“我一眼就切了”和“我想不到啊”的 lk，“来道大分块啊” 的 lxl，还有自说自话，不对自己说的话里提到的概念加以定义或解释，让人根本看不懂的 cy。协调各方的意见可能是一件需要学习的事情吧。\n然后的话，也是影响比较大的，我对题目和出题人的要求提升了很多。回首自己之前在洛谷的两场公开赛，第一场漏洞满篇，满屏毒瘤，第二场也有不少的问题。出了 cf 之后，不仅是自己出题变得更加规范了，对自己做的题要求也更严了。国内很多题目质量堪忧，因为题目的外在（题面、题解、数据范围、输入输出格式）而非 idea 本身过于毒瘤而不想做题的事也会发生，抱怨其他题目、比赛成了家常便饭。但回首想来，我也是从一个毒瘤大模拟、无意义 dp 出题人成长起来的。\n我讨厌不用心的出题人，讨厌不严谨甚至误导人的博客，因为，我认为出题给别人做、写博客给别人看是应当对别人负责的。如果没有精力、不想负责的话，出题给自己做，博客保存在本地就好了，发出来干什么？即使是能力不够，也得有认真负责的态度才行。如果没有，别人骂你，只当骂醒好了。如果骂不醒，那着实该骂。\n 一道好题应该被仔细推敲过。好题应该有很强的数据，好题应该有清晰的题面，好题的标程应该优美题解应该详尽。\n一道好题不应该是两道题拼在一起，一道好题会有自己的idea —— 而它应该不加过多包装地突出这个idea。\n一道好题应该新颖。真正的好题，应该是能让人脑洞出新的好题的好题。\n一道好题应该具有它的选拔性质，具有足够的区分度。应该至少4档部分分，让新手可以拿到分，让高手能够展示自己的实力。\n—— vfk《UOJ精神之源流》\n 当我指出其他人题目里的种种不足，当我抛开他人博客中不严谨的话语而豁然开朗大叫原文之漏洞满篇时，有没有想过他人付出的心血呢？当然有，只是我认为尊重不是基于付出，而是基于负责的态度，基于真正做了什么的。就好比你追一个女孩子，辛辛苦苦付出了那么多，如果不提升自己，如果不付出真心，别人凭什么喜欢你？\n说到底，对写给别人的东西负责，是我自己的一种坚守，我自己并不是总能做到，也不是生来就能做到。但我会努力去做，无论在怎样的大环境下，我想尽我所能创造一片小小的净土。\n 我们所可以自慰的，想来想去，也还是所谓对于将来的希望。希望是附丽于存在的，有存在，便有希望，有希望，便是光明。如果历史家的话不是诳话，则世界上的事物可还没有因为黑暗而长存的先例。黑暗只能附丽于渐就灭亡的事物，一灭亡，黑暗也就一同灭亡了，它不永久。然而将来是永远要有的，并且总要光明起来;只要不做黑暗的附着物，为光明而灭亡，则我们一定有悠久的将来，而且一定是光明的将来。\n—— 鲁迅《记谈话》（十二省联考 2019 hope 题解）\n 说回这场 cf，我按照 cf 出题规范去出题，一遍遍地检查，直接原因当然是 cf 是如此要求的。但我这么去做，绝不只是为了过审，而是为了上千名参赛者，我认为我有理由以认真负责的态度，准备一场好的 cf，呈现给大家 —— 当然也包括正在读着这篇博客的你。\n现在我也能够体会到 vfk 当时写《UOJ精神之源流》时的心情了。执著的坚守与残酷现实的矛盾，出题人与参赛者的隔阂，心中交杂的歉意与不甘……无论这场 cf 是否让你满意，我想，我做到了我应该做的，仍然走在自己一直坚持的那条路上。\n尽管发生了一些意外，或许这场 cf 并不让你满意，但我认为，I did my best.\n附：cf 出题须知\nafter 后记 CF 的工资大约咕了一个月。\n付款方式千万不要选 PayPal。\n","date":"2019-06-09T12:56:10+08:00","permalink":"https://ouuan.github.io/post/bad-round-%E4%B8%8E%E5%87%BA%E9%A2%98%E4%BA%BA%E7%9A%84%E5%9D%9A%E5%AE%88/","tags":["Codeforces"],"title":"bad round 与出题人的坚守"},{"categories":["题解"],"contents":"台前幕后\n比赛地址\n2A Nauuo and Votes 题意 $x$ 个人 upvote，$y$ 个人 downvote，$z$ 个人随机 upvote / downvote，问最后总计 up 的多 / down 的多 / up = down / 结果不确定。\n 题解 考虑两种极端情况：\n 所有随机投的人都 upvote。 所有随机投的人都 downvote。  如果这两种情况结果一样，结果就是答案；否则结果不确定。\n 参考代码 #include \u0026lt;iostream\u0026gt; using namespace std; const char result[4] = {'+', '-', '0', '?'}; int solve(int x, int y) { return x == y ? 2 : x \u0026lt; y; } int main() { int x, y, z; cin \u0026gt;\u0026gt; x \u0026gt;\u0026gt; y \u0026gt;\u0026gt; z; cout \u0026lt;\u0026lt; result[solve(x + z, y) == solve(x, y + z) ? solve(x, y) : 3]; return 0; }   2B Nauuo and Chess 题意  在一个 $m\\times m$ 的棋盘上放 $n$ 颗棋子，第 $i$ 颗棋子的坐标为 $(r_i,c_i)$，需要满足 $|r_i-r_j|+|c_i-c_j|\\ge|i-j|$，求 $m$ 的最小值以及任意一种摆放方案。\n 题解   $m\\ge\\left\\lfloor\\frac n 2\\right\\rfloor+1$\n$\\because\\begin{cases}|r_1-r_n|+|c_1-c_n|\\ge n-1\\\\|r_1-r_n|\\le m-1\\\\|c_1-c_n|\\le m-1\\end{cases}$\n$\\therefore m-1+m-1\\ge n-1$\n$\\therefore m\\ge\\frac{n+1}2$\n$\\because m\\text{是整数}$\n$\\therefore m\\ge\\left\\lfloor\\frac n 2\\right\\rfloor+1$\n  $m$ 可以取到 $\\left\\lfloor\\frac n 2\\right\\rfloor+1$\n在每一斜行放一颗棋子即可，即：$r_i+c_i=i+1$。因为 $|r_i-r_j|+|c_i-c_j|\\ge|r_i+c_i-r_j-c_j|$。\n   参考代码 #include \u0026lt;cstdio\u0026gt; using namespace std; int main() { int n, i, ans; scanf(\u0026quot;%d\u0026quot;, \u0026amp;n); ans = n / 2 + 1; printf(\u0026quot;%d\u0026quot;, ans); for (i = 1; i \u0026lt;= ans; ++i) printf(\u0026quot;\\n%d 1\u0026quot;, i); for (i = 2; i \u0026lt;= n - ans + 1; ++i) printf(\u0026quot;\\n%d %d\u0026quot;, ans, i); return 0; }   1A Nauuo and Cards 题意 $n$ 张带标号的牌和 $n$ 张空白牌，$n$ 张在手上剩下在牌堆里（牌堆有序），每次可以从手上选一张牌放牌堆底部并从牌堆顶部抽一张牌，需要使牌堆从上到下递增地放 $1$ ~ $n$，求最小操作数。\n$1\\le n\\le2\\times10^5$。\n 题解 首先尝试不打空白牌能否直接完成。如果能就是最优解，否则最优解一定是先打若干空白牌然后再也不打空白牌。计 $p_i$ 为 $i$ 在牌堆的初始位置（初始在手上为 $0$），那么答案为 $\\max\\limits_{i = 1}^n(p_i - i + 1 + n)$（每张牌最早在第 $p_i + 1$ 张被打出，还要打 $n-i$ 张）。\n 参考代码 #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; const int N = 200010; int n, a[N], b[N], p[N], ans; int main() { int i, j; scanf(\u0026quot;%d\u0026quot;, \u0026amp;n); for (i = 1; i \u0026lt;= n; ++i) { scanf(\u0026quot;%d\u0026quot;, a + i); p[a[i]] = 0; } for (i = 1; i \u0026lt;= n; ++i) { scanf(\u0026quot;%d\u0026quot;, b + i); p[b[i]] = i; } if (p[1]) { for (i = 2; p[i] == p[1] + i - 1; ++i); if (p[i - 1] == n) { for (j = i; j \u0026lt;= n \u0026amp;\u0026amp; p[j] \u0026lt;= j - i; ++j); if (j \u0026gt; n) { printf(\u0026quot;%d\u0026quot;, n - i + 1); return 0; } } } for (i = 1; i \u0026lt;= n; ++i) ans = max(ans, p[i] - i + 1 + n); printf(\u0026quot;%d\u0026quot;, ans); return 0; }   1B Nauuo and Circle 题意 圆上画一 $n$ 点树，树给定，边要求直而不交，画法与排列一一对应，求方案数。\n$2\\le n\\le 2\\times10^5$。\n 题解 首先，如果选一个根使其变为有根树，可以发现每棵子树一定在一段连续的弧上。\n考虑 DP，令 $f_u$ 为子树 $u$ 方案数，那么 $f_u=(|son(u)| + [u\\ne root])!\\prod\\limits_{v\\in son(u)}f_v$，$ans = nf_{root}​$。（先固定根的位置，每棵子树要为儿子排位置，如果非根自己也要参与排位置，然后再画子树。）\n事实上不需要 DP，答案为每个点的度数阶乘之积乘上 $n​$。\n 参考代码 #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstdio\u0026gt; using namespace std; typedef long long ll; const int N = 200010; const int mod = 998244353; int n, ans, d[N]; int main() { int i, u, v; scanf(\u0026quot;%d\u0026quot;, \u0026amp;n); ans = n; for (i = 1; i \u0026lt; n; ++i) { scanf(\u0026quot;%d%d\u0026quot;, \u0026amp;u, \u0026amp;v); ans = (ll) ans * (++d[u]) % mod * (++d[v]) % mod; } cout \u0026lt;\u0026lt; ans; return 0; }   1C Nauuo and Pictures 题意 给你一个长度为 $n$ 的数列 $w_{1..n}$，其中有一些位置是\u0026quot;被喜欢的\u0026rdquo;，其它位置是“不被喜欢的”，进行 $m$ 次操作，每次随机选一个数，选到第 $i$ 个数的概率是 $\\frac{w_i}{\\sum_{j=1}^nw_j}$，如果选到一个“被喜欢的”位置，就会把这个位置上的数加一，否则减一。问 $m$ 次操作过后每个数的期望值，对 $998244353$ 取模。\n$1\\le n\\le2\\times 10^5$，$1\\le m\\le3000$。\n 题解 裸dp\n先只看一个“被喜欢的”位置，这个位置的初始值是 $w$。\n计 $SA$ 为“被喜欢的”数之和，$SB$ 为“不被喜欢的”数之和。\n令 $f_w[i][j][k]$ 表示：现在 $SA=j$，$SB=k$，一个值为 $w$ 、“被喜欢的”位置经过 $i$ 次操作后的期望值。\n边界情况：$f_w[0][j][k]=w$。\n转移：\n 下一次操作选到了当前这个位置。概率：$\\frac w{j+k}$。转移到：$f_{w+1}[i-1][j+1][k]$。 下一次操作选到了另一个“被喜欢的”位置。概率：$\\frac{j-w}{j+k}$。转移到：$f_w[i-1][j+1][k]$。 下一次操作选到了一个“不被喜欢的”位置。概率：$\\frac k{j+k}$。转移到：$f_w[i-1][j][k-1]$。  所以，$f_w[i][j][k]=\\frac w{j+k}f_{w+1}[i-1][j+1][k]+\\frac{j-w}{j+k}f_w[i-1][j+1][k]+\\frac k{j+k}f_w[i-1][j][k-1]​$。\n令 $g_w[i][j][k]$ 表示“不被喜欢的”的对应状态，计算方式类似。\n这样大约能过简单版。\n优化\n有两个优化：\n  $f_w[i][j][k]=wf_1[i][j][k]$\n证明：\n$i=0$ 时显然成立。\n假设已经证明了 $f_w[i-1][j][k]=wf_1[i-1][j][k]$，就可以归纳地证明 $f_w[i][j][k]=wf_1[i][j][k]$：\n$\\begin{aligned}f_1[i][j][k]\u0026amp;=\\frac 1{j+k}f_2[i-1][j+1][k]+\\frac{j-1}{j+k}f_1[i-1][j+1][k]+\\frac k{j+k}f_1[i-1][j][k-1]\\\\\u0026amp;=\\frac2{j+k}f_1[i-1][j+1][k]+\\frac{j-1}{j+k}f_1[i-1][j+1][k]+\\frac k{j+k}f_1[i-1][j][k-1]\\\\\u0026amp;=\\frac{j+1}{j+k}f_1[i-1][j+1][k]+\\frac k{j+k}f_1[i-1][j][k-1]\\end{aligned}$\n$\\begin{aligned}f_w[i][j][k]\u0026amp;=\\frac w{j+k}f_{w+1}[i-1][j+1][k]+\\frac{j-w}{j+k}f_w[i-1][j+1][k]+\\frac k{j+k}f_w[i-1][j][k-1]\\\\\u0026amp;=\\frac{w(w+1)}{j+k}f_1[i-1][j+1][k]+\\frac{w(j-w)}{j+k}f_1[i-1][j+1][k]+\\frac {wk}{j+k}f_1[i-1][j][k-1]\\\\\u0026amp;=\\frac{w(j+1)}{j+k}f_1[i-1][j+1][k]+\\frac {wk}{j+k}f_1[i-1][j][k-1]\\\\\u0026amp;=wf_1[i][j][k]\\end{aligned}$\n还有一个比较简单但不那么严谨的理解方式：每一步期望的增量都与期望成正比。（这里被 _rqy 喷了，出题人就是菜，这个证明写不严谨。）\n这样的话就只用计算 $f_1[i][j][k]$ 了。\n  注意到 $i$, $j$, $k$, $m$ 有一些联系。实际上可以令 $f\u0026rsquo;_w[i][j]$ 表示 $f_w[m-i-j][SA+i][SB-j]$（这里的 $SA$ 和 $SB$ 都是未操作时的初始值）。\n  令 $g\u0026rsquo;_1[i][j]$ 表示 $g_w[m-i-j][SA+i][SB-j]$，计算方式类似。\n总结\n$$ \\begin{aligned} f\u0026rsquo;_1[i][j]\u0026amp;=1\u0026amp;(i+j=m)\\\\\nf\u0026rsquo;_1[i][j]\u0026amp;=\\frac{SA+i+1}{SA+SB+i-j}f\u0026rsquo;_1[i+1][j]+\\frac{SB-j}{SA+SB+i-j}f\u0026rsquo;_1[i][j+1]\u0026amp;(i+j\u0026lt;m)\\\\\ng\u0026rsquo;_1[i][j]\u0026amp;=1\u0026amp;(i+j=m)\\\\\ng\u0026rsquo;_1[i][j]\u0026amp;=\\frac{SA+i}{SA+SB+i-j}g\u0026rsquo;_1[i+1][j]+\\frac{SB-j-1}{SA+SB+i-j}g\u0026rsquo;_1[i][j+1]\u0026amp;(i+j\u0026lt;m) \\end{aligned} $$\n“被喜欢的”位置答案是 $w_if\u0026rsquo;_1[0][0]$，“不被喜欢的”位置答案是 $w_ig\u0026rsquo;_1[0][0]$。\n如果每次去算逆元就是 $\\mathcal O(n+m^2\\log p)$，预处理出来就是 $\\mathcal O(n+m^2+m\\log p)$。\n 参考代码 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; typedef long long ll; const int N = 200010; const int M = 3010; const int mod = 998244353; int qpow(int x, int y) //calculate the modular multiplicative inverse { int out = 1; while (y) { if (y \u0026amp; 1) out = (ll) out * x % mod; x = (ll) x * x % mod; y \u0026gt;\u0026gt;= 1; } return out; } int n, m, a[N], w[N], f[M][M], g[M][M], inv[M \u0026lt;\u0026lt; 1], sum[3]; int main() { int i,j; scanf(\u0026quot;%d%d\u0026quot;, \u0026amp;n, \u0026amp;m); for (i = 1; i \u0026lt;= n; ++i) scanf(\u0026quot;%d\u0026quot;, a + i); for (i = 1; i \u0026lt;= n; ++i) { scanf(\u0026quot;%d\u0026quot;, w + i); sum[a[i]] += w[i]; sum[2] += w[i]; } for (i = max(0, m - sum[0]); i \u0026lt;= 2 * m; ++i) inv[i] = qpow(sum[2] + i - m, mod - 2); for (i = m; i \u0026gt;= 0; --i) { f[i][m - i] = g[i][m - i] = 1; for (j = min(m - i - 1, sum[0]); j \u0026gt;= 0; --j) { f[i][j] = ((ll) (sum[1] + i + 1) * f[i + 1][j] + (ll) (sum[0] - j) * f[i][j + 1]) % mod * inv[i - j + m] % mod; g[i][j] = ((ll) (sum[1] + i) * g[i + 1][j] + (ll) (sum[0] - j - 1) * g[i][j + 1]) % mod * inv[i - j + m] % mod; } } for (i = 1; i \u0026lt;= n; ++i) printf(\u0026quot;%d\\n\u0026quot;, int((ll) w[i] * (a[i] ? f[0][0] : g[0][0]) % mod)); return 0; }   1D Nauuo and Portals 题意 在一个 $n\\times n$ 的网格里放传送门，指定从第 $i$ 行进从第 $r_i$ 行出，从第 $i$ 列进从第 $c_i$ 列出，$r_{1..n}$ 和 $c_{1..n}$ 都是排列，求方案。\n 题解 考虑一个 $n*n$ 的问题如何转化成 $(n-1)\\times(n-1)$：满足第一行和第一列。\n如果已经满足直接变成 $(n-1)\\times(n-1)$。\n否则找到第一行中应该放在第一列那个和第一列中应该放在第一行那个，这两个位置各放一个传送门即可。\n这题可以 $\\mathcal O(n)$ 做，但 checker 要 $\\mathcal O(n^2)$。\n 参考代码 #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; const int N = 1010; struct Portal { int x, y, p, q; Portal(int _x, int _y, int _p, int _q): x(_x), y(_y), p(_p), q(_q) {} }; vector\u0026lt;Portal\u0026gt; ans; int n, a[N], b[N], c[N], d[N], ra[N], rb[N], rc[N], rd[N]; int main() { int i; scanf(\u0026quot;%d\u0026quot;, \u0026amp;n); for (i = 1; i \u0026lt;= n; ++i) { scanf(\u0026quot;%d\u0026quot;, b + i); rb[b[i]] = i; } for (i = 1; i \u0026lt;= n; ++i) { scanf(\u0026quot;%d\u0026quot;, a + i); ra[a[i]] = i; } for (i = 1; i \u0026lt;= n; ++i) c[i] = d[i] = rc[i] = rd[i] = i; for (i = 1; i \u0026lt; n; ++i) { if (c[i] == ra[i] \u0026amp;\u0026amp; d[i] == rb[i]) continue; ans.push_back(Portal(i, rc[ra[i]], rd[rb[i]], i)); int t1 = c[i]; int t2 = d[i]; swap(c[i], c[rc[ra[i]]]); swap(d[i], d[rd[rb[i]]]); swap(rc[ra[i]], rc[t1]); swap(rd[rb[i]], rd[t2]); } printf(\u0026quot;%d\\n\u0026quot;, ans.size()); for (auto k : ans) printf(\u0026quot;%d %d %d %d\\n\u0026quot;, k.x, k.y, k.p, k.q); return 0; }   1E Nauuo and ODT 题意 给你一棵 $n$ 个点，点有颜色的树。一条简单路径的权值是其上颜色数，求所有简单路径的权值之和（路径有序，即 $u\\rightarrow v$ 和 $v\\rightarrow u$ 算两条）。带修，$m$ 次单点颜色修改，每修改一次输出一次。\n$n,m\\le 4\\times10^5$，$7.5s$。\n 题解 对每种颜色分别考虑不含该颜色的简单路径条数。\n令当前处理的颜色为 $c$，把颜色为 $c$ 的视为白色，不是 $c$ 的视为黑色，那么不含 $c$ 的路径条数就是每个黑联通块的大小的平方和，修改就是当颜色是 $c$ $\\leftrightarrow$ 颜色不是 $c$ 时翻转一个点的颜色。所以，问题转化成了黑白两色的树，单点翻转颜色，维护黑联通块大小的平方和。这个转化后的问题可以用很多数据结构做，比如：lxl：top tree 随便维护。这篇题解里使用 Link/cut Tree.\n对每个点维护子树大小，儿子大小平方和，在 link/cut 的时候更新答案即可。有一个大家熟知的 trick，就是每个黑点向父亲连边，这样真正的联通块就是 Link/cut Tree 里的联通块删掉根。\n具体看图吧，图讲的挺清楚的：\nLCT 的部分就是这样，计算答案的时候先初始化一个全是黑点的树，离线处理每个颜色，处理完一个颜色反着改回去。\n 参考代码 #include \u0026lt;algorithm\u0026gt; #include \u0026lt;cctype\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; typedef long long ll; const int N = 400010; struct Node { int fa, ch[2], siz, sizi; ll siz2i; ll siz2() { return (ll) siz * siz; } } t[N]; bool nroot(int x); void rotate(int x); void Splay(int x); void access(int x); int findroot(int x); void link(int x); void cut(int x); void pushup(int x); void add(int u, int v); void dfs(int u); int head[N], nxt[N \u0026lt;\u0026lt; 1], to[N \u0026lt;\u0026lt; 1], cnt; int n, m, c[N], f[N]; ll ans, delta[N]; bool bw[N]; vector\u0026lt;int\u0026gt; mod[N][2]; int main() { int i, j, u, v; ll last; scanf(\u0026quot;%d%d\u0026quot;, \u0026amp;n, \u0026amp;m); for (i = 1; i \u0026lt;= n; ++i) { scanf(\u0026quot;%d\u0026quot;, c + i); mod[c[i]][0].push_back(i); mod[c[i]][1].push_back(0); } for (i = 1; i \u0026lt;= n + 1; ++i) t[i].siz = 1; for (i = 1; i \u0026lt; n; ++i) { scanf(\u0026quot;%d%d\u0026quot;, \u0026amp;u, \u0026amp;v); add(u, v); add(v, u); } for (i = 1; i \u0026lt;= m; ++i) { scanf(\u0026quot;%d%d\u0026quot;, \u0026amp;u, \u0026amp;v); mod[c[u]][0].push_back(u); mod[c[u]][1].push_back(i); c[u] = v; mod[v][0].push_back(u); mod[v][1].push_back(i); } f[1] = n + 1; dfs(1); for (i = 1; i \u0026lt;= n; ++i) link(i); for (i = 1; i \u0026lt;= n; ++i) { if (!mod[i][0].size()) { delta[0] += (ll)n * n; continue; } if (mod[i][1][0]) { delta[0] += (ll)n * n; last = (ll)n * n; } else last = 0; for (j = 0; j \u0026lt; mod[i][0].size(); ++j) { u = mod[i][0][j]; if (bw[u] ^= 1) cut(u); else link(u); if (j == mod[i][0].size() - 1 || mod[i][1][j + 1] != mod[i][1][j]) { delta[mod[i][1][j]] += ans - last; last = ans; } } for (j = mod[i][0].size() - 1; ~j; --j) { u = mod[i][0][j]; if (bw[u] ^= 1) cut(u); else link(u); } } ans = (ll) n * n * n; for (i = 0; i \u0026lt;= m; ++i) { ans -= delta[i]; printf(\u0026quot;%I64d \u0026quot;, ans); } return 0; } bool nroot(int x) { return x == t[t[x].fa].ch[0] || x == t[t[x].fa].ch[1]; } void rotate(int x) { int y = t[x].fa; int z = t[y].fa; int k = x == t[y].ch[1]; if (nroot(y)) t[z].ch[y == t[z].ch[1]] = x; t[x].fa = z; t[y].ch[k] = t[x].ch[k ^ 1]; t[t[x].ch[k ^ 1]].fa = y; t[x].ch[k ^ 1] = y; t[y].fa = x; pushup(y); pushup(x); } void Splay(int x) { while (nroot(x)) { int y = t[x].fa; int z = t[y].fa; if (nroot(y)) (x == t[y].ch[1]) ^ (y == t[z].ch[1]) ? rotate(x) : rotate(y); rotate(x); } } void access(int x) { for (int y = 0; x; x = t[y = x].fa) { Splay(x); t[x].sizi += t[t[x].ch[1]].siz; t[x].sizi -= t[y].siz; t[x].siz2i += t[t[x].ch[1]].siz2(); t[x].siz2i -= t[y].siz2(); t[x].ch[1] = y; pushup(x); } } int findroot(int x) { access(x); Splay(x); while (t[x].ch[0]) x = t[x].ch[0]; Splay(x); return x; } void link(int x) { int y = f[x]; Splay(x); ans -= t[x].siz2i + t[t[x].ch[1]].siz2(); int z = findroot(y); access(x); Splay(z); ans -= t[t[z].ch[1]].siz2(); t[x].fa = y; Splay(y); t[y].sizi += t[x].siz; t[y].siz2i += t[x].siz2(); pushup(y); access(x); Splay(z); ans += t[t[z].ch[1]].siz2(); } void cut(int x) { int y = f[x]; access(x); ans += t[x].siz2i; int z = findroot(y); access(x); Splay(z); ans -= t[t[z].ch[1]].siz2(); Splay(x); t[x].ch[0] = t[t[x].ch[0]].fa = 0; pushup(x); Splay(z); ans += t[t[z].ch[1]].siz2(); } void pushup(int x) { t[x].siz = t[t[x].ch[0]].siz + t[t[x].ch[1]].siz + t[x].sizi + 1; } void add(int u, int v) { nxt[++cnt] = head[u]; head[u] = cnt; to[cnt] = v; } void dfs(int u) { int i, v; for (i = head[u]; i; i = nxt[i]) { v = to[i]; if (v != f[u]) { f[v] = u; dfs(v); } } }   1F Nauuo and Bug 题意 给 $a$ 和 $p$，多组询问 $sum(a,l,r,p)$。\n数列长度 $10^6$，询问次数 $2\\times10^5$，值域 $-10^9$ ~ $10^9$。\n 题解 区间询问一般采用分块、线段树等方法维护，这些方法都要求我们单独求出较少个区间的答案后进行合并。我们考虑将 Sum 函数改成如下：\nint sum(int l, int r, int p, int x) { for (int i = l; i \u0026lt;= r; ++i) x = modadd(x, a[i], p); return x; }  固定 $p$ 和一个区间，sum 是一个关于 x 的分段函数，可以看出段数为 $O(r-l)$，因为 sum 的结果一定可以写成 $x+s_{l..r}-np$，其中 $s_{l..r}$ 是 $a_{l..r}$ 的区间和，随着 $x$ 的增大，$n$ 不会减小，而 $0 \\le n \\le r-l+1$，所以段数是线性的。\n此时有一个简单的分块做法。将序列分为大小为 $B$ 的 $\\frac n B$ 块，每块内预处理出这个块的 sum 函数后用一个存有每段端点的数组记录下来；计算这个函数的方法相当暴力，采用增量法，每次将已有的函数和单点合并后重构每段的起止端点，这将消耗 $O(\\frac n B \\times B^2=nB)$ 的时间。查询时用二分计算单点上函数的值即可，每次询问的时间是 $O(B+\\frac n B \\log B)$。认为 $n,q$ 同阶，取 $B=\\Theta(\\sqrt{n \\log n})$ 时复杂度最优为 $O(n \\sqrt{n \\log n})$。\n得到更好的时间复杂度需要一个观察：分段函数中每段的长度都至少是 $P$。证明考虑对区间长度 $n$ 归纳。当 $n=1$ 时由于只有两段，长度均为无穷大，显然；$n\u0026gt;1$ 时考虑将前 $n-1$ 个形成的函数和最后一个合并。详细考虑合并的过程，对于 $f(x)=x+s_{1..n-1}-mP(a \\le x \\le b)$ 的段，$x + s_{1..n}-mP\\ge P \\to x \\ge (m+1)P-s_{1..n}$ 的部分需要多减一次 $P$，从而会和下一段进行合并。考虑这段函数，减少了一个后缀 $[(m+1)P-s_{1..n},b]$，从上一段合并过来的增加了一段前缀 $[mP-s_{1..n},a]$，新的区间为 $[\\min(a,mP-s_{1..n}),\\min(b,(m+1)P-s_{1..n}-1]$，简单讨论可知长度仍然不小于 $P$。\n我们改为采用线段树维护，查询区间被分解成 $O(\\log n)$ 个线段树上区间，假如我们能求出所有线段树上区间的分段函数，即可每次查询 $O(\\log^2 n)$ 时间解决。我们求解 $[l..r]$ 的函数时，考虑从 $[l..mid]$ 的函数 $f(x)$ 和 $[mid+1..r]$ 的函数 $g(x)$ 合并而来，合并后的函数即为 $g(f(x))$。我们在的分段函数 $f$ 上按 $x$ 升序扫描，维护 $f(x)$ 对应 $g$ 中的哪一段。当 $x$ 移向 $f$ 中的下一段时，我们从之前 $f(x)$ 的位置暴力移动向新的函数。注意每次移动到下一段 $f(x)$ 只是减 $P$，$f(x)$ 在 $g$ 中的位置会左移，但前面证明过所有段的长度都至少为 $P$，所以 $f(x)$ 的位置只会左移至多一段。当 $x$ 在 $f$ 的同一段中移动时，$f(x)$ 的位置只会右移，从而由均摊分析知道合并的时间是线性的。综上我们在 $O(n \\log n+q \\log ^2 n)$ 的时间内解决了本题，这是非常优秀的。\n 参考代码 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; typedef long long ll; const int N = 1000005; const ll inf = (ll)1e16; int n, m, P, a[N]; ll sum[N]; vector\u0026lt;ll\u0026gt; func[N \u0026lt;\u0026lt; 2]; vector\u0026lt;ll\u0026gt; merge(int l, int r, int mid, const vector\u0026lt;ll\u0026gt; \u0026amp;f, const vector\u0026lt;ll\u0026gt; \u0026amp;g) { ll suml = sum[mid] - sum[l - 1], sumr = sum[r] - sum[mid]; vector\u0026lt;ll\u0026gt; ret(f.size() + g.size() - 1, inf); for (int i = 0, j = 0; i \u0026lt; (int)f.size(); ++i) { ll xl = f[i], xr = (i + 1 == (int)f.size() ? inf : f[i + 1] - 1), yl = xl + suml - (ll)i * P, yr = xr + suml - (ll)i * P; while (j \u0026gt; 0 \u0026amp;\u0026amp; g[j] \u0026gt; yl) --j; while (j \u0026lt; (int)g.size() \u0026amp;\u0026amp; (j == 0 || g[j] \u0026lt;= yl)) ++j; --j; for (; j \u0026lt; (int)g.size() \u0026amp;\u0026amp; g[j] \u0026lt;= yr; ++j) ret[i + j] = min(ret[i + j], max(xl, g[j] - suml + (ll)i * P)); } ret[0] = -inf; return ret; } void build(int u, int l, int r) { if (l == r) { func[u].push_back(-inf); func[u].push_back(P - a[l]); return; } int mid = l + r \u0026gt;\u0026gt; 1; build(u \u0026lt;\u0026lt; 1, l, mid); build(u \u0026lt;\u0026lt; 1 | 1, mid + 1, r); func[u] = merge(l, r, mid, func[u \u0026lt;\u0026lt; 1], func[u \u0026lt;\u0026lt; 1 | 1]); } ll query(int u, int l, int r, int ql, int qr, ll now) { if (l \u0026gt;= ql \u0026amp;\u0026amp; r \u0026lt;= qr) return now + sum[r] - sum[l - 1] - (ll)P * (upper_bound(func[u].begin(), func[u].end(), now) - func[u].begin() - 1); int mid = l + r \u0026gt;\u0026gt; 1; if (qr \u0026lt;= mid) return query(u \u0026lt;\u0026lt; 1, l, mid, ql, qr, now); if (ql \u0026gt; mid) return query(u \u0026lt;\u0026lt; 1 | 1, mid + 1, r, ql, qr, now); return query(u \u0026lt;\u0026lt; 1 | 1, mid + 1, r, ql, qr, query(u \u0026lt;\u0026lt; 1, l, mid, ql, qr, now)); } int main() { scanf(\u0026quot;%d%d%d\u0026quot;, \u0026amp;n, \u0026amp;m, \u0026amp;P); for (int i = 1; i \u0026lt;= n; ++i) scanf(\u0026quot;%d\u0026quot;, a + i), sum[i] = sum[i - 1] + a[i]; build(1, 1, n); for (int l, r; m--;) { scanf(\u0026quot;%d%d\u0026quot;, \u0026amp;l, \u0026amp;r); printf(\u0026quot;%I64d\\n\u0026quot;, query(1, 1, n, l, r, 0)); } return 0; }  ","date":"2019-06-07T22:38:47+08:00","permalink":"https://ouuan.github.io/post/codeforces-round-564-%E4%B8%AD%E6%96%87%E9%A2%98%E8%A7%A3/","tags":["Codeforces"],"title":"Codeforces Round #564 中文题解"},{"categories":["技术"],"contents":"不用 testlib.h 是不可能写好 checker 的（逃\n大约这样就可以了：\n#include \u0026lt;fstream\u0026gt; #include \u0026lt;cstdlib\u0026gt; #include \u0026lt;cstdio\u0026gt; using namespace std; ofstream fscore; char cmd[1000]; int main(int argc, char * argv[]) { fscore.open(argv[5]); int score = atoi(argv[4]); sprintf(cmd, \u0026quot;testlibchecker %s %s %s %s\u0026quot;, argv[1], argv[2], argv[3], argv[6]); if (system(cmd)) fscore \u0026lt;\u0026lt; 0 \u0026lt;\u0026lt; endl; else fscore \u0026lt;\u0026lt; score \u0026lt;\u0026lt; endl; fscore.close(); return 0; }  注意 testlibchecker 实际使用时要使用绝对路径。\n","date":"2019-05-22T13:59:32+08:00","permalink":"https://ouuan.github.io/post/%E4%BD%BF%E7%94%A8-testlib-h-%E5%86%99-lemon-spj/","tags":["评测"],"title":"使用 testlib.h 写 lemon SPJ"},{"categories":["游记"],"contents":"由于实在想不到这次是什么记了，所以就叫 300iq 奔北坡好了。\n实际上是一篇 CTS \u0026amp; APIO \u0026amp; THUSC 2019 游记。\nArrival 因为是去北京所以要二次安检，然后剪刀被收了..一开始还说我有两把剪刀，然后又过了一次安检就没有了..最后的结果是吃方便面的时候撕不开酱料包，用圆规戳开的。\n车上先是在熟悉的文章、字符串和 Reverses 三道题上分别自闭，然后开始看题解，看 border 相关论文，然后就开始看 THUPC 的榜，然后不小心被 300iq 看到了 300iq_ben_bei_po。\n到了之后，发现 Sooke 就比我们早到一点点——实际上比我们早一趟地铁左右。到酒店的时候办入住排队，Sooke 刚好就在我们几个人前面，然后就愉快地面基了。\n下午去试机，现场写了一道我们那场 cf 的题，（证明了如果会做还是可以在场上写出来的）。\n然后，从 Sooke 来试机起，简单教了一下 Sooke 用 noilinux，一起吃了晚饭，一起走回酒店，然后发现 Sooke 房间就在我隔壁，然后 Sooke 就待在我房间里了，准备看我打他验的那场 cf。\n之前 THUWC 的时候试机坐 pr 右边的右边，这次又是来的时间差不多 + 住隔壁..比较神奇。\n晚上智商比较掉线（可能和前一天没睡好略有关系），掉了波分。\nCTS Day 1 咕了 5min（为什么 cf 每次都是 35 开始）\n开考前就注意到 T1 12s，原来是 10 组数据\u0026hellip;（ctr：我本机 1.Xs，评测姬 6.Xs，怎么办啊）\n第一眼就觉得 T1 的暴力好像不太会做，阶乘会挂。\n然后去看 T2，3min 想到三方做法，然后又花了 3min 去掉一维，然后 10min 左右写 + 调完了 48 分。\nT3 是个提答，（可能是雅礼集训那道五子棋的原因），我就直接搞了个估价函数，每次枚举所有可能的位置，选估价函数最大的那个。前三个点都是立刻出结果，第二个点只有 9 分，然后就把后面的点挂着跑。发现第四个点非常特殊，所以就数了一下每种块各有几个，然后直接在草稿纸上算出方案，然后若干个 for 循环输出。\n然后，本来以为 T2 $m=0, 1, 2$ 的几个点要大力数据分治，然后发现如果 $n\\ge d+2m-1$ 直接输出 $d^n$ 就好了..\n然后，发现 T3 后面的一个点跑了 1h 还没跑出来，于是就开始乱搞。先是调循环步长，发现还是跑的特别慢。然后就加了个剪枝，每一行找到第一个可以放的位置就放，快了很多。最后把两个点分别跑出来了 3 分和 4 分。\n回去看 T1，发现一个剪枝搜索的方法（实际上和那个七方 dp 思路差不多\u0026hellip;），然后写到一半想起来可以打表..最后写了个可以在 1s 内跑完一组的搜索，还是打了个表交上去。\n最后是 $10+60+46$，被所有人踩了。\n为什么我没想到 T1 的七方 dp 呢..当时脑子里大概是 $12\\rightarrow2^n$，然而有三维，要 $2^{nml}$，做不了，不做了\u0026hellip;（题解：一看就是指数级多项式算法）\nCTS Day 2 又咕了 5min。\n第一眼，T1 计几，考场不能开计几。\n第二眼，T2 字符串！woc，还是个计数。\n第三眼，T3 这是棵树！这边怎么还有反的..\n看了一圈还是感觉 T1 最可做\u0026hellip;然而我先去推了一会儿 T2，没有任何成果。T3 的暴力也不会写..\n冷静了一下想到了 T1 $30​$ 分做法，就写了一个。考场上还算错复杂度了..只不过问题不大。\n然后在三题之间轮流自闭，T1 猜到了凸包合并后更优肯定要合并，也写了个两两尝试合并，然而过不去样例三，就没管了。（95 分做法：随机合并，记录过程中最优解，直到快超时。）\n快结束的时候写了个 T2 10 分爆搜，发现要跑 4s，然后就写了个字符离散化..实际上可以被类似 bdfhjlnprt 之类的串卡掉，只不过还是过了。\n最后是 $10+30+0$，好像还挺大众（\nCTS 其它 讲题比较自闭..就记得 _rqy 自己上台吐槽两天四道计数，组题人（同时是 D1T3 出题人）说“我要从五道题里面选六道题，我也很无奈啊”。\n另外首师大附中里的有张摄影的标题戳到我了\u0026hellip;（不要说我中二）（也不要在意右边，那是手指挡住了）\n录了个论文答辩。\n最后闭幕式的时候 wh 和 dzd 的讲话还是非常精彩。譬如：知识点涵盖了容斥原理，动态规划，概率论……为什么要去掉这个 C 呢？没有钱是干不了这个活的，收的钱也不一定够\ndzd 还抱着好像是某位博士的女儿上了台..\n在 cf 上抢了个评论。上午答辩完就差不多猜到了名单，然而不敢提前发，就提前写好了评论，一公布立马发出去了。感觉的确可以从答辩判断名单，某个 twr 硬是觉得有黑幕还被 up 了我就很没有办法。\ncf 出题组全员 Ag。\nAPIO 讲课 Day 1 上午缓存管理，下午 PJ dp ？？\nAPIO 考试 开场 5min 就交了一发 WA..把 A 的暴力交错题了，一看发现纸质题面和实际顺序不一样（好像是翻译的时候还没给题目顺序\u0026hellip;）\n评测系统果然是不需要数据分治的，每个子任务分别提交就可以了，会分别在所有提交中取 max。只不过如果出现特殊情况，要由 CCF 来收题，这样写可能会比较惨..\n先把 T1 的暴力和无修改写了，然后把 T2 的 10 分写了，然后把 T3 暴力、询问长度一、零变一写了，然后把 T1 链写了。这些分好像都比较水..过程中想了会儿各种正解，写完的时候大约是 3h。\n然后，感觉 T1 的树应该可做，然而不会做。T3 的修改在询问前好像也不太会。然后去看只有 10 分的 T2，怎么这么多 subtask，我一个都不会啊..然后，我发现好像有循环节，然后就是本场比赛最蠢的一个地方，我把循环节暴力跑出来，然后用 map 判下标..然后想了个特别麻烦的 5 分做法，一直调到考试结束\u0026hellip;\n最后分数就是前 3h 写的 $43+10+60$，一出考场发现所有人都是 243 / 203 \u0026hellip; 说好的 100+ Au 呢？以后再也不能按往年分数线打比赛了\u0026hellip;\nAPIO 讲题  考虑让大象写题解 大象写了一篇题解 讲完了  APIO 讲课 Day 2 上午是 THUWC 时来过的 lzj，又是图像渲染。\n下午是四场讲题里最正常的一场（树上线性问题），前半部分是 希望的超详细题解 自顶向下 dp + 长链剖分，后半部分，后半部分是什么啊..好像是各种神仙题，比如树上线性（不带反阿克曼）并查集……\nAPIO 颁奖 五页 113 艹，成功压线 Cu。\n四页 203 Au 比 Ag 多艹。\nAg 前几都是神仙艹。\nTHUSC Day -1 THUSC 电脑的用户名是 THUSC Day 0-Test、THUSC Day0、THUSC Day1-1 和 THUSC Day1-2。（为什么 Day -1 要提 THUSC 电脑用户名？因为今天是 Day -1。）\n收到选手须知，划重点：WireShark，O3，python，Ubuntu 16.04，没写考试安排。\n学一波 WireShark 好了。\n结果颓了一整天\n晚上 11 点睡了，好像很久没睡这么早了..\nTHUSC Day 0 为什么 tdoj waiting 显示满分啊..一开始我还以为 pt 是假的（\n试机自闭了，sb 字符串二分想了无限假做法，开始怀疑自己的智商。\n开营式全是硬广，感觉还是 THUWC 的有意思些，哦不对，那好像是闭幕式\u0026hellip;\n一进考场就发生了一件很神奇的事，94 和 96 中间没有 95..于是我换了一台机子。\n比赛咕了 $40min$（传统艺能）。\n开场看 T1，很快发现了（在没有操作 3 时）取空的情况只会发生不超过 $n$ 次，20min 的时候已经完全构思好了正解，然而不知道为什么以为操作 3 会破坏复杂度，就写了个 60 分..第一次尝试在草稿纸上完整地写下要维护哪些量，每个操作各要具体怎么修改怎么询问，写了半张草稿纸，然后写代码极其顺畅，1h 的时候就把 60 分部分分 1A 了。然后发现 $l=r$ 也很水，就写了个 $80$ 分的数据分治，然后各种挂，又过了 $40min$ 才写完，共 $6.2KB$。\n然后看了眼 T2，$k=20\\rightarrow2^k$，$\\min\\rightarrow minmax$ 容斥 $\\rightarrow$ 不会做（鬼知道我怎么想的），然后去看 T3，侧信道攻击是什么啊..OI 题名全是骗人的.jpg。往后一看，好像还真是题目背景里说的那回事..好像不太可做，回去看 T2。woc 这不是个 sb 题吗\u0026hellip;在最短路上就是 $dis[u][k]+dis[k][v]=dis[u][v]$，然后随手写了个 $3^k$——对每个救援队记录哪些点可以。然后发现改成对每个点记录哪些救援队可以，就可以轻松 $n2^k$ 了..pt 1A，然后就没管了。\n犹豫了一下，决定还是先别侧信道攻击了，回来看 T1。woc 我又 sb 了，操作三不破坏复杂度啊，每次单点加最多把一个空的变成不空，所以还是只会有不超过 $n+m$ 次取空..于是在 $60​$ 分代码的基础上只加一个函数，其它全都不用改，就 pp 了。\n然后去看 T3，这个 $10$ 分，可以枚举 $w$，枚举 $y$，枚举 $q$……诶，询问数超了，那就 get_w().. woc，直接 for (i = 0; i \u0026lt; 500; ++i) Qs[i] = i; 不就可以了吗，我又 sb 了..把枚举删掉，写上 for 循环，一交，怎么爆零了？woc，没设置 $u$ 和 ​$v$\u0026hellip;那后面的分怎么做啊..先 get_w() get_y() 吧..二分一下 $q$..怎么过不了啊..哦，是快速幂，所以 $time$ 并不关于 $q$ 单调..那就以二分结果为中心往两边爆搜吧..$subtask2$ 拿了 $16$，继续各种乱搞，拿不到分了，考试结束了。\n感觉好像比较大众分啊..可能会被 T3（\u0026amp; 可能比较弱的 pt \u0026amp; 把 THUSC 当成 IOI 赛制打的选手）区分出来了。\n大约在宾馆见识到了真正的“抽水马桶”\u0026hellip;不是按，不是转，是抽..\n晚上睡得比前一天还早（\nTHUSC Day 1-1 94 和 96 中间还是没有 95\u0026hellip;\n比赛又咕了 $30min$。\n开场，T1 不是 sb 题吗 $\\rightarrow$ 没过 pt $\\rightarrow $ 读错题了？$\\rightarrow​$ 草，只有灯塔可以点亮..（鬼知道我为什么在点亮数轴（大约是以为每个点都有灯塔，只是一部分有游客吧..\n于是 20min 才把 T1 过掉（\n然后去看 T2，前两个 subtask 好像挺好写的..继续看 T3，考场上好像不能开计算几何来着（\n然而我还是开了..emm..这玩意不用取模诶..哦，好像每种本质不同的划分都可以用一条两圆公切线表示。但是，怎么求公切线啊..用各种方法算了一个小时，算出来的结果都很麻烦，感觉会算错，于是就没管了（然而降智的效果已经达到了\n先写了前两个 subtask，然后发现好像可以处理出每个右端点向左种类数增加的地方，然后写了个假做法写自闭了，最后大致上想到了单调栈做法，然后好像是以为假掉了，也可能没太想清楚，最后写了个 $\\mathcal O(nm^2)​$ 交上去\u0026hellip;\n成功被计几 \u0026amp; 自己的假做法降智，被区分了，白给 $48$ 分。\nTHUSC Day 1-2 果然是网络题..\n有了 WC 的经验，没仔细阅读学习手册直接开始做，还是写了 $1h$ T1..\nT2 的 $8$ 分是 CRC32，WC 写过，然后..写了 $1h$，WA 了 $1h$。学习手册里的 CRC32 样例过了，输出中间结果 data 转 01 看起来也没什么问题..不知道怎么回事。\n大众分好像是 $48$，㕛被区分了。\nTHUSC Day 2 听说线 428 ？emm..成功被白给区分了。\n只不过也没什么白给不白给的，就是不熟练才会白给，会做也没用啊.\n网传线假掉了\u0026hellip;\n我妈在八点半接到我爸的电话，说我爸接到了 THU 电话\u0026hellip;\n然后，赶去西郊宾馆，等了 2.5h，好像是分块后按字典序排？中途还见到了在其它 SC 游记里听说过的搭矿泉水瓶。\n面试大约是自我介绍 + 提问 + 嘤语阅读。毕竟我也是受了其他人游记一定的帮助，简单说一下需要注意的问题..\n 自我介绍不需要提 OI 成绩。我一开始说我的 OI 成绩被打断了，好像是考官有成绩..（其实是看别人游记说教官提问“你的 OI 最好成绩”我才说的 qaq 提问会和自我介绍相关。反正我是这样的..比如，我自我介绍的时候提了一下对人工智能略有了解，就被问了有哪些了解、有什么看法之类的。所以建议自我介绍可以提一提自己熟悉的计算机科学领域，然后在相关方面准备一下可能的问题回答。 嘤语阅读要尝试看懂。大约是计算机科学专业文章，一开始会给你 $30s$ 左右看一遍，然后我当时只是想了想应该怎么读，没有仔细看。读了一遍之后他问我看懂了什么，然后就 GG 了..个人感觉这个部分是我面试挂的最惨的地方（  下午讲题 + 科研 / 科协 / 蒜算协 介绍，感觉不如 WC 有意思..可能是时间比较短，而且也听过一遍类似的内容了..（有个人工智能简笔画妹子挺有意思的）\n然后，荣获 3=，就去赶火车了..\n","date":"2019-05-12T21:45:13+08:00","permalink":"https://ouuan.github.io/post/300iq%E5%A5%94%E5%8C%97%E5%9D%A1/","tags":["CCF系列赛事","清华营"],"title":"300iq奔北坡"},{"categories":["知识点"],"contents":"PAM 是一种处理回文串相关问题的有力工具。\n又是一句废话。\nPAM 是什么？ 首先它是个自动机\u0026hellip; PAM 是一个接受且仅接受某个字符串的所有回文子串的中心及右半部分的 DFA。\n“中心及右边部分”在奇回文串中就是字面意思，在偶回文串中定义为一个特殊字符加上右边部分。这个定义看起来很奇怪，但它能让 PAM 真正成为一个自动机，而不仅是两棵树。\nPAM 的状态及转移 PAM 的每个状态都表示一个回文子串，其中包含两个特殊状态，$len​$ 分别为 $0​$ 和 $-1​$，它们分别作为偶回文子串和奇回文子串两棵树的根。\nPAM 的转移表示在串的两侧各加上同一个字符，因此 $len​$ 也会加二。PAM 显然是分别以 $0​$ 和 $-1​$ 为根的两棵树，因为每个状态由唯一的状态转移而来（删掉两端的字符）。\n和 SAM / AC 自动机一样，PAM 也有 $fail​$ 边，同样表示真后缀中在自动机里的最长状态（也就是最长回文真后缀）。\n为了让 PAM 符合自动机的定义，可以在概念上从 $-1​$ 到 $0​$ 连一条特殊字符边，然后以 $-1​$ 作为起始状态。然而在代码实现里没有人会这么做。\nPAM 的构建 一个性质 在一个字符串后添加一个字符，至多增加一个之前没有出现过的回文子串，且该回文子串必定是原串的一个回文真后缀两侧加上新添加的这个字符。\n简单证明：如果新添加的字符处在多个回文子串内，找到最长的一个，剩下的都可以沿其中心翻折过去，所以一定出现过。\n这个性质既说明了 PAM 的状态数是 $\\mathcal O(n)​$ 的，也为后文的构建方法提供了依据。\n基础构建法 这是一个增量算法，即每次以均摊 $\\mathcal O(1)​$ 的复杂度向 PAM 基于的字符串的末尾添加一个字符。\n记上次达到的状态为 $p​$，字符串为 $s​$，当前添加的字符是字符串中第 $pos​$ 位，我们在 $p​$ 的 $fail​$ 链上找到最长的一个状态满足 $s[pos-len(u)-1]=s[pos]​$，那么当前到达的状态就是 $\\delta(u,s[pos])​$，如果这个转移不存在则新建节点并连 $fail​$：在 $fail(p)​$ 的 $fail​$ 链上找到最长的满足上述条件的状态，其 $s[pos]​$ 转移即为新建节点的 $fail​$。特别地，如果 $p​$ 是特殊状态 $-1​$，新建节点的 $fail​$ 要设为 $0​$。\n因为 $p​$ 和 $fail(p)​$ 都是在 $fail​$ 树上爬上爬下，其中每添加一个字符最多向下爬一次，所以复杂度是均摊 $\\mathcal O(1)​$ 的。\n当然如果用 map 存边复杂度就会带 log。\n参考代码 #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; const int N = 300010; struct PAM { int len, fail, ch[26]; } pam[N]; void extend(); char s[N]; int n, p = 2, tot = 2, pos; int main() { scanf(\u0026quot;%s\u0026quot;, s + 1); n = strlen(s + 1); pam[1].len = -1; pam[2].fail = 1; for (pos = 1; pos \u0026lt;= n; ++pos) extend(); return 0; } void extend() { int x = s[pos] - 'a'; while (s[pos - pam[p].len - 1] != s[pos]) p = pam[p].fail; if (pam[p].ch[x]) p = pam[p].ch[x]; else { int np = ++tot; pam[p].ch[x] = np; pam[np].len = pam[p].len + 2; if (p == 1) pam[np].fail = 2; else { for (p = pam[p].fail; s[pos - pam[p].len - 1] != s[pos]; p = pam[p].fail); pam[np].fail = pam[p].ch[x]; } p = np; } }   其它构建法 PAM 还有支持前后端插入删除、复杂度不是均摊的构建方法，但我先咕着..感兴趣的话可以看 2017 国家候选队论文《回文树及其应用 翁文涛》。\n一些例题 [APIO2014]回文串，裸题。和其它自动机一样通过 fail 树子树和来统计出现次数。\nCF835D Palindromic characteristics（注意原题数据范围较小，这题可以线性做），从 fail 链上 len / 2 处转移即可，我比较菜只会倍增所以多个 log。\n","date":"2019-05-10T22:31:05+08:00","permalink":"https://ouuan.github.io/post/%E5%9B%9E%E6%96%87%E8%87%AA%E5%8A%A8%E6%9C%BApam%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","tags":["字符串","PAM"],"title":"回文自动机（PAM）学习笔记"},{"categories":["题解"],"contents":"题目链接 洛谷\nCF\n题意简述 给你一个字符串，求有多少对相交的回文子串。（包含算作相交，自交不算）\n字符串长度小于等于 $2\\times 10^6$。\n简要做法 首先 manacher 求出每个中心的最长回文串半径。\n然后，通过差分可以求出每个位置作为左端点 / 右端点各有多少个回文串（知道每个中心的半径之后就相当于区间加），记为 $l_i$, $r_i$。\n最后，我们把问题转化为求不相交的回文子串对数，这样的话就是 $\\sum\\limits_{i = 2}^n\\sum\\limits_{j=1}^{i-1}l_ir_j$，预处理一下 $r​$ 的前缀和就可以算了。\n参考代码 #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; typedef long long ll; const int N = 2000010; const int mod = 51123987; char s[N \u0026lt;\u0026lt; 1]; int n, p[N \u0026lt;\u0026lt; 1], mid, rt, l[N], r[N], pre[N], ans; int main() { int i; scanf(\u0026quot;%d%s\u0026quot;, \u0026amp;n, s + 1); s[0] = '$'; for (i = n * 2 + 1; i \u0026gt;= 1; --i) { if (i \u0026amp; 1) s[i] = '#'; else s[i] = s[i / 2]; } mid = rt = 1; for (i = 2; i \u0026lt;= n * 2 + 1; ++i) { p[i] = min(rt - i, p[mid * 2 - i]); while (s[i + p[i] + 1] == s[i - p[i] - 1]) ++p[i]; if (i + p[i] \u0026gt; rt) { mid = i; rt = i + p[i]; } ++l[(i - p[i] + 1) \u0026gt;\u0026gt; 1]; --l[(i \u0026gt;\u0026gt; 1) + 1]; ++r[(i + 1) \u0026gt;\u0026gt; 1]; --r[(i + p[i] + 1) \u0026gt;\u0026gt; 1]; ans = (ans + (p[i] + 1) / 2) % mod; } ans = (ll) ans * (ans - 1) % mod * (mod + 1) / 2 % mod; for (i = 1; i \u0026lt;= n; ++i) { l[i] += l[i - 1]; r[i] += r[i - 1]; pre[i] = (pre[i - 1] + r[i]) % mod; ans = (ans - (ll) l[i] * pre[i - 1] % mod + mod) % mod; } cout \u0026lt;\u0026lt; ans; return 0; } ","date":"2019-05-10T22:06:18+08:00","permalink":"https://ouuan.github.io/post/cf17e-palisectionmanacher/","tags":["字符串","manacher"],"title":"CF17E Palisection（manacher）"},{"categories":["题解"],"contents":"题目链接 洛谷\nCF\n题意简述 给你一个字符串，分别求出每个长度的既是其前缀又是其后缀的串出现的次数。\n字符串长度小于等于 $10^5$。\n简要做法 第一眼，SAM 裸题。\n然后意识到只用管前缀，KMP 可以达到同样的效果。\n做法和 SAM 完全一样：从末尾跳 next 来找到所有前后缀相同的位置（也就是 SAM 的接受状态），然后倒序枚举 $f_{next[i]}+=f_i$（也就是 SAM 的统计子树和）。\n多说两句：fail、parent 和 next 其实是一样的东西，但 KMP / AC 自动机的状态是所有前缀，SAM 的状态是所有子串（并被压缩为了 right 集合等价类）。\n参考代码 #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;cstdio\u0026gt; using namespace std; const int N = 100010; char s[N]; int n, nxt[N], stk[N], top, f[N]; int main() { int i, k; scanf(\u0026quot;%s\u0026quot;, s + 1); n = strlen(s + 1); for (i = 2, k = 0; i \u0026lt;= n; ++i) { while (k \u0026amp;\u0026amp; s[i] != s[k + 1]) k = nxt[k]; if (s[i] == s[k + 1]) ++k; nxt[i] = k; } for (i = n; i \u0026gt;= 1; --i) { ++f[i]; f[nxt[i]] += f[i]; } for (i = n; i; i = nxt[i]) stk[++top] = i; printf(\u0026quot;%d\\n\u0026quot;, top); while (top) { printf(\u0026quot;%d %d\\n\u0026quot;, stk[top], f[stk[top]]); --top; } return 0; } ","date":"2019-05-10T21:56:54+08:00","permalink":"https://ouuan.github.io/post/cf432d-prefixes-and-suffixeskmp/","tags":["字符串","KMP"],"title":"CF432D Prefixes and Suffixes（KMP）"},{"categories":["题解"],"contents":"题目链接 洛谷\nCF contest\nCF problemset\n题意简述 给你两个字符串 $S$ 和 $T$，你需要在 $S$ 中取若干个（至少一个）不相交的子串，使得每个子串都包含 $T$，求方案数模 $10^9+7$。\n字符串长度小于等于 $10^5$。\n简要做法 首先用某种字符串算法求出 $T$ 在 $S$ 中匹配的所有位置（一般人都会选择 KMP）。\n记 $|S|=n$, $|T|=m$。\n然后，我们记 $p_i$ 表示 $[i+m,n]$ 中最小的匹配位置（也就是 $S[i+1..n]$ 这个子串第一个匹配的位置），记 $q_i$ 表示 $[1,i]$ 中最大的匹配位置（也就是 $S[1..i]$ 这个子串最后一个匹配的位置）。\n然后开始 dp，令 $f_i​$ 表示子串 $S[i+1..n]​$ 的答案。转移时，我们考虑选择下一个子串的右端点和左端点。右端点可以在 $[q_i,n]​$ 中选取，而对于一个右端点 $j​$，可以选择的左端点有 $p_j-m-i+1​$ 个。另外，也可以不继续选择下一个子串。所以可以得到转移方程：\n$$f_i=1+\\sum\\limits_{j=q_i}^nf_j(p_j-m-i+1)$$\n如果我们把 $g_i=\\sum\\limits_{j=i}^nf_jp_j$ 和 $h_i=\\sum\\limits_{j=i}^nf_j$ 分别存下来，就可以得到 $f_i=1+g_{q_i}-(m+i-1)f_{q_i}$，然后就可以 $\\mathcal O(n)$ 计算了。\n最后，这样计算的话会把一个子串都不选计入总数，所以答案要减一。\n参考代码 #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;cstring\u0026gt; using namespace std; typedef long long ll; const int N = 100010; const int mod = 1e9 + 7; char s[N], t[N]; int n, m, nxt[N], q[N], p[N], f[N], g[N]; int main() { int i, k; scanf(\u0026quot;%s%s\u0026quot;, s + 1, t + 1); n = strlen(s + 1); m = strlen(t + 1); for (i = 2, k = 0; i \u0026lt;= m; ++i) { while (k \u0026amp;\u0026amp; t[i] != t[k + 1]) k = nxt[k]; if (t[i] == t[k + 1]) ++k; nxt[i] = k; } for (i = 1, k = 0; i \u0026lt;= n; ++i) { while (k \u0026amp;\u0026amp; s[i] != t[k + 1]) k = nxt[k]; if (s[i] == t[k + 1]) ++k; if (k == m) q[i - m] = p[i] = i; } for (i = 1; i \u0026lt;= n; ++i) if (!p[i]) p[i] = p[i - 1]; for (i = n; i \u0026gt;= 0; --i) { if (!q[i]) q[i] = q[i + 1]; if (q[i]) f[i] = (1 + g[q[i]] - (ll) f[q[i]] * (m + i - 1) % mod + mod) % mod; else f[i] = 1; g[i] = ((ll) f[i] * p[i] + g[i + 1]) % mod; f[i] = (f[i] + f[i + 1]) % mod; } cout \u0026lt;\u0026lt; (f[0] - f[1] + mod - 1) % mod; return 0; } ","date":"2019-05-05T13:16:44+08:00","permalink":"https://ouuan.github.io/post/cf494b-obsessive-string-kmp-%E8%AE%A1%E6%95%B0dp/","tags":["字符串","KMP","计数dp"],"title":"CF494B Obsessive String (KMP,计数dp)"},{"categories":["题解"],"contents":"题目链接 洛谷\ndarkbzoj\n题意简述 给一个长为 $m$ 的字符串，字符集 $0$ ~ $9$，求长为 $n$ 的字符串中不含给定字符串作为子串的字符串有多少个，对 $k$ 取模。\n$n\\le10^9$，$m\\le20$，$k\\le1000$。\n简要做法 首先用 KMP / AC 自动机搞出转移：$f_{i,j}$ 表示从状态 $i$ （或者说位置 $i$，KMP 里就是位置，AC 自动机里虽然是节点但也和位置差不多）起，在后面加 $j$ 个字符，满足要求的字符串个数，则 $f_{i,j} = \\sum\\limits_{x=0}^9f_{tr[i][x],j-1}$，其中 $tr[i][x]$ 表示状态 $i$ 的字符 $x$ 转移。AC 自动机中不用解释了，KMP 里面就是 $tr[i][x]=\\begin{cases}i+1\u0026amp;(s[i+1]=x)\\\\tr[next[i]][x]\u0026amp;(s[i+1]\\ne x)\\end{cases}$。\n发现每层（相同的 $j$）的转移都是类似的，实际上可以用矩阵表示两层间的转移：\n$$A\\times\\begin{bmatrix}f_{0,j}\\\\f_{1,j}\\\\\\vdots\\\\f_{m-1,j}\\end{bmatrix}=\\begin{bmatrix}f_{0,j+1}\\\\f_{1,j+1}\\\\\\vdots\\\\f_{m-1,j+1}\\end{bmatrix}$$\n（只到 $m-1$ 是因为 $f_{m,j}=0$）\n其中 $A​$ 是我们要求的一个矩阵，$A_{i,j}​$ 就是 $\\sum\\limits_{x=0}^9[tr[i][x]=j]​$，求出来之后矩阵快速幂就好了。\n参考代码 KMP #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;cctype\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; const int N = 21; int n, m, mod, nxt[N]; char s[N]; struct Matrix { int a[N][N]; Matrix() { memset(a, 0, sizeof(a)); } int* operator[](int x) { return a[x]; } Matrix operator*(Matrix \u0026amp; b) { Matrix out; int i, j, k; for (i = 0; i \u0026lt; m; ++i) { for (j = 0; j \u0026lt; m; ++j) { for (k = 0; k \u0026lt; m; ++k) { out[i][j] = (out[i][j] + a[i][k] * b[k][j]) % mod; } } } return out; } }; Matrix qpow(Matrix x, int y); int main() { int i, j, k, ans = 0; Matrix mul; scanf(\u0026quot;%d%d%d%s\u0026quot;, \u0026amp;n, \u0026amp;m, \u0026amp;mod, s + 1); for (i = 2, k = 0; i \u0026lt; m; ++i) { while (k \u0026amp;\u0026amp; s[i] != s[k + 1]) k = nxt[k]; if (s[i] == s[k + 1]) ++k; nxt[i] = k; } for (i = 0; i \u0026lt; m; ++i) { for (j = 0; j \u0026lt;= 9; ++j) { for (k = i; k \u0026amp;\u0026amp; s[k + 1] - '0' != j; k = nxt[k]); if (s[k + 1] - '0' == j) ++k; ++mul[i][k]; } } mul = qpow(mul, n); for (i = 0; i \u0026lt; m; ++i) ans = (ans + mul[0][i]) % mod; cout \u0026lt;\u0026lt; ans; return 0; } Matrix qpow(Matrix x, int y) { Matrix out; for (int i = 0; i \u0026lt; m; ++i) out[i][i] = 1; while (y) { if (y \u0026amp; 1) out = out * x; x = x * x; y \u0026gt;\u0026gt;= 1; } return out; }  AC 自动机 如果觉得我的 AC 自动机写法比较清奇可以看看我的 AC 自动机学习笔记..\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;cctype\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; const int N = 21; int n, m, mod, tr[N][10], fail[N]; char s[N]; struct Matrix { int a[N][N]; Matrix() { memset(a, 0, sizeof(a)); } int* operator[](int x) { return a[x]; } Matrix operator*(Matrix \u0026amp; b) { Matrix out; int i, j, k; for (i = 0; i \u0026lt; m; ++i) { for (j = 0; j \u0026lt; m; ++j) { for (k = 0; k \u0026lt; m; ++k) { out[i][j] = (out[i][j] + a[i][k] * b[k][j]) % mod; } } } return out; } }; Matrix qpow(Matrix x, int y); int main() { int i, j, ans = 0; Matrix mul; scanf(\u0026quot;%d%d%d%s\u0026quot;, \u0026amp;n, \u0026amp;m, \u0026amp;mod, s + 2); for (i = 0; i \u0026lt;= 9; ++i) tr[0][i] = 1; for (i = 1; i \u0026lt;= m; ++i) { tr[i][s[i + 1] - '0'] = i + 1; for (j = 0; j \u0026lt;= 9; ++j) { if (s[i + 1] - '0' == j) fail[i + 1] = tr[fail[i]][j]; else tr[i][j] = tr[fail[i]][j]; ++mul[i - 1][tr[i][j] - 1]; } } mul = qpow(mul, n); for (i = 0; i \u0026lt; m; ++i) ans = (ans + mul[0][i]) % mod; cout \u0026lt;\u0026lt; ans; return 0; } Matrix qpow(Matrix x, int y) { Matrix out; for (int i = 0; i \u0026lt; m; ++i) out[i][i] = 1; while (y) { if (y \u0026amp; 1) out = out * x; x = x * x; y \u0026gt;\u0026gt;= 1; } return out; } ","date":"2019-05-03T19:07:11+08:00","permalink":"https://ouuan.github.io/post/bzoj1009-hnoi2008-gt%E8%80%83%E8%AF%95kmp-ac%E8%87%AA%E5%8A%A8%E6%9C%BA%E7%9F%A9%E9%98%B5%E4%B9%98%E6%B3%95/","tags":["字符串","KMP","AC自动机","矩阵"],"title":"BZOJ1009 [HNOI2008]GT考试（KMP/AC自动机，矩阵乘法）"},{"categories":["题解"],"contents":"题目链接 洛谷\ndarkbzoj\n题意简述 初始一个空串，三种操作：\n 添加一个字符。 删除一个字符。 打印当前字符串、  多组询问，每次问第 $x$ 个打印的字符串在第 $y$ 个打印的字符串中出现了几次。\n操作数和询问数都不超过 $10^5$。\n简要做法 先建个 AC 自动机。\nfail 树上的祖先是后缀，Trie 上根到一个点的路径是一个前缀，后缀的前缀是子串，因此只要把 Trie 上路径标出来，在 fail 树里统计子树就好了。也就是说，求出 $y$ 的所有前缀中以 $x$ 为后缀的数量。\n具体来说，用 fail 树求 dfs 序，然后对 Trie 树进行 dfs，进入一个节点将其（在树状数组中）加一，退出时减一，把询问按 $y$ 存下来，访问到一个点时对以其作为 $y$ 的所有询问计算 $x​$ 在 fail 树中的子树和即为答案。\n参考代码 #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;cctype\u0026gt; #include \u0026lt;queue\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; int read() { int out = 0; char c; while (!isdigit(c = getchar())); for (; isdigit(c); c = getchar()) out = out * 10 + c - '0'; return out; } typedef pair\u0026lt;int, int\u0026gt; pii; const int N = 100010; void modify(int p, int x); void add(int u, int v); void dfs1(int u); void dfs2(int u); int qsum(int p); int head[N], nxt[N], to[N], cnt; int n, m, tr[N][26], trie[N][26], tot = 1, fail[N], fa[N], id[N], BIT[N], dfn[N], dfntot, exi[N], ans[N]; vector\u0026lt;pii\u0026gt; query[N]; queue\u0026lt;int\u0026gt; q; char s[N]; int main() { int i, u, x, y; scanf(\u0026quot;%s\u0026quot;, s); for (i = 0; i \u0026lt; 26; ++i) tr[0][i] = 1; for (i = 0, u = 1; s[i]; ++i) { if (s[i] == 'B') u = fa[u]; else if (s[i] == 'P') id[++n] = u; else { int c = s[i] - 'a'; if (!tr[u][c]) fa[tr[u][c] = ++tot] = u; u = tr[u][c]; } } memcpy(trie, tr, sizeof(tr)); q.push(1); while (!q.empty()) { u = q.front(); q.pop(); for (i = 0; i \u0026lt; 26; ++i) { if (tr[u][i]) { fail[tr[u][i]] = tr[fail[u]][i]; q.push(tr[u][i]); } else tr[u][i] = tr[fail[u]][i]; } } for (i = 2; i \u0026lt;= tot; ++i) add(fail[i], i); m = read(); for (i = 1; i \u0026lt;= m; ++i) { x = read(); y = read(); query[id[y]].push_back(pii(id[x], i)); } dfs1(1); dfs2(1); for (i = 1; i \u0026lt;= m; ++i) printf(\u0026quot;%d\\n\u0026quot;, ans[i]); return 0; } void dfs1(int u) { dfn[u] = ++dfntot; for (int i = head[u]; i; i = nxt[i]) dfs1(to[i]); exi[u] = dfntot; } void dfs2(int u) { int i, v; modify(dfn[u], 1); for (i = 0; i \u0026lt; query[u].size(); ++i) ans[query[u][i].second] = qsum(exi[query[u][i].first]) - qsum(dfn[query[u][i].first] - 1); for (i = 0; i \u0026lt; 26; ++i) { v = trie[u][i]; if (v) dfs2(v); } modify(dfn[u], -1); } void modify(int p, int x) { for (; p \u0026lt;= tot; p += (p \u0026amp; -p)) { BIT[p] += x; } } int qsum(int p) { int out = 0; for (; p; p -= (p \u0026amp; -p)) { out += BIT[p]; } return out; } void add(int u, int v) { nxt[++cnt] = head[u]; head[u] = cnt; to[cnt] = v; } ","date":"2019-04-29T21:36:58+08:00","permalink":"https://ouuan.github.io/post/bzoj2434-noi2011-%E9%98%BF%E7%8B%B8%E7%9A%84%E6%89%93%E5%AD%97%E6%9C%BAac%E8%87%AA%E5%8A%A8%E6%9C%BA%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/","tags":["字符串","AC自动机","树状数组"],"title":"BZOJ2434 [NOI2011]阿狸的打字机（AC自动机，树状数组）"},{"categories":["知识点"],"contents":"AC 自动机其实我去年就学过了，但当时大约只是会敲模板而已..现在几乎全忘光了。于是复习一下，顺便（较为本质地）讲解一下。\nAC 自动机是什么？ 说到这我真的想喷一下网上的各种教程..连“是什么”都不说清楚就开始讲“有什么用”和”怎么用“，怎能知其所以然？\n形式上，AC 自动机基于由若干模式串构成的 Trie 树，并在此之上增加了一些 fail 边；本质上，AC 自动机是一个关于若干模式串的 DFA（确定有限状态自动机），接受且仅接受以某一个模式串作为后缀的字符串。\n并且，与一般自动机不同的，AC 自动机还有 关于某个模式串的接受状态（我自己起的名字..），也就是与某个模式串匹配（以某个模式串为后缀）的那些状态。\n关于 DFA，我在 SAM 学习笔记里 已经讲过了。\n引用一下 2006 年集训队论文《王赟\u0026ndash;Trie图的构造活用及改进》中的一张图：\n有了 AC 自动机，我们把一个文本串逐位地输入到自动机中，当匹配时就会处于接受状态。\nAC 自动机怎样构建？ 大致分为两个过程：\n 构建模式串组成的 Trie 树。 连 fail 边。  第一个过程不用讲吧。\nfail 边是什么？ fail 边是 AC 自动机上一种特殊的边，其意义为：当 $u​$ 在 Trie 树上没有字符 $c​$ 的出边时，将 $\\delta(u,c)​$ 定义为 $\\delta(fail(u),c)​$（特例：初始状态若不存在某字符出边则连向自己，也可以理解为 $\\forall c\\in\\Sigma,\\delta(fail(start),c)=start​$）。\n另外，fail 边的作用类似于 KMP 算法中的 next 数组。\nfail 边怎么连？ 我们发现一个状态的 fail 边连向的其实就是这个状态的一个自动机上最长真后缀。\n为什么呢..感性理解一下，失配了就不看前几位了..\n然后就很好连了：对 Trie 树进行 BFS，将 $fail(\\delta(u,c))$ 设为 $\\delta(fail(u),c)$。因为一个串加上一个字符的最长真后缀就是这个串的最长真后缀加上这个字符..\n另外，将 $\\delta(u,c)$ 设为 $\\delta(fail(u),c)$ 可以显式地在代码中完成。\n再另外，要么 BFS 开始的时候将根节点的孩子入队，要么将 $fail(root)$ 的每个儿子都设为 $root​$。否则根的儿子的 fail 边会连向自己。（也就是上文所述的“特例”。）\nfor (i = 0; i \u0026lt; 26; ++i) tr[0][i] = 1; q.push(1); while (!q.empty()) { u = q.front(); q.pop(); for (i = 0; i \u0026lt; 26; ++i) { if (tr[u][i]) { fail[tr[u][i]] = tr[fail[u]][i]; q.push(tr[u][i]); } else tr[u][i] = tr[fail[u]][i]; } }  fail 树 由于每个点都只连出一条 fail 边，且连到的点对应的字符串长度更小，所以 fail 边构成了一棵 fail 树。\n如果学过 SAM 的话，可能会发现 fail 树和 parent 树很像..实际上它们具有的性质是相同的，然而构成它们的状态不同——parent 树是所有 right 集合等价类（也就是 SAM 上的所有节点），而 fail 树是 Trie 上的每个前缀（也就是 AC 自动机上的所有节点）。\n作为一个自动机，我还没讲 AC 自动机的接受状态是哪些..其实就是 Trie 树上的那些终止节点在 fail 树上的整个子树的并。\n而 关于某个模式串的接受状态，也就是与某个模式串匹配（以某个模式串为后缀）的那些状态，就是那个串在 Trie 树上的终止节点在 fail 树上的子树。知道这个也就知道怎么用 AC 自动机进行多模式串匹配了（建出 fail 树，记录自动机上的每个状态被匹配了几次，最后求出每个模式串在 Trie 上的终止节点在 fail 树上的子树总匹配次数就可以了）。\n洛谷 P3796 参考代码 #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;queue\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; typedef pair\u0026lt;int, int\u0026gt; pii; const int N = 160; const int L = 80; const int M = 1000010; void add(int u, int v); void dfs(int u); int head[N * L], nxt[N * L], to[N * L], cnt; int n, tr[N * L][26], fail[N * L], tot, suc[N * L], siz[N * L]; char s[N][L], t[M]; queue\u0026lt;int\u0026gt; q; pii ans[N]; int main() { int i, j, u; scanf(\u0026quot;%d\u0026quot;, \u0026amp;n); while (n) { memset(tr, 0, sizeof(tr)); memset(suc, 0, sizeof(suc)); memset(siz, 0, sizeof(siz)); memset(head, 0, sizeof(head)); tot = 1; cnt = 0; for (i = 0; i \u0026lt; 26; ++i) tr[0][i] = 1; scanf(\u0026quot;%d\u0026quot;, \u0026amp;n); for (i = 1; i \u0026lt;= n; ++i) { scanf(\u0026quot;%s\u0026quot;, s[i]); ans[i].first = 0; ans[i].second = i; for (j = 0, u = 1; s[i][j]; ++j) { int c = s[i][j] - 'a'; if (!tr[u][c]) tr[u][c] = ++tot; u = tr[u][c]; } suc[u] = i; } q.push(1); while (!q.empty()) { u = q.front(); q.pop(); for (i = 0; i \u0026lt; 26; ++i) { if (tr[u][i]) { fail[tr[u][i]] = tr[fail[u]][i]; q.push(tr[u][i]); } else tr[u][i] = tr[fail[u]][i]; } } scanf(\u0026quot;%s\u0026quot;, t); for (i = 0, u = 1; t[i]; ++i) { u = tr[u][t[i] - 'a']; ++siz[u]; } for (i = 2; i \u0026lt;= tot; ++i) add(fail[i], i); dfs(1); sort(ans + 1, ans + n + 1); printf(\u0026quot;%d\\n\u0026quot;, -ans[1].first); for (i = 1; i \u0026lt;= n \u0026amp;\u0026amp; ans[i].first == ans[1].first; ++i) printf(\u0026quot;%s\\n\u0026quot;, s[ans[i].second]); scanf(\u0026quot;%d\u0026quot;, \u0026amp;n); } return 0; } void dfs(int u) { int i, v; for (i = head[u]; i; i = nxt[i]) { v = to[i]; dfs(v); siz[u] += siz[v]; } ans[suc[u]].first -= siz[u]; } void add(int u, int v) { nxt[++cnt] = head[u]; head[u] = cnt; to[cnt] = v; }   一些例题 [TJOI2013]单词，基本上是道裸题。\n[POI2000]病毒，不访问接受状态找环即可。\n[NOI2011]阿狸的打字机，对 Trie 进行 dfs 并打根到当前点的标记，在 fail 树上统计子树标记和。我的题解\n与 KMP 之间的关系 放在最后面是因为我认为 KMP 并不是 AC 自动机的前置知识..然而他们之间的确有着千丝万缕的联系。\n「KMP 是个自动机」\n要是早有人告诉我这句话估计我早就（真正地）学会 KMP 了..\nKMP 自动机的主体是一条链，加上了一些“next 边”（其实就是 AC 自动机的 fail 边）。\n而 KMP 自动机之于 AC 自动机，就像 SAM 之于广义 SAM。\n也就是很多人常说的一句话：AC 自动机就是 Trie 上 KMP。\n递归地计算转移函数 简介 “将 $\\delta(u,c)​$ 设为 $\\delta(fail(u),c)​$”这一步是可以不去显式完成的，并且，在绝大多数情况下（事实上我并不知道任何反例）这样做复杂度是线性的，可以将复杂度中的字符集大小去掉，并节省空间。\n做法非常简单：当你需要 $\\delta(u,c)$ 而其没有定义时，递归地去计算 $\\delta(fail(u),c)$。\n构建 fail 的过程复杂度为线性 一个节点到根的路径上这些点总共跳 fail 的次数不会超过其深度。\n所以总共跳 fail 次数不会超过 Trie 树所有叶子的深度和。\n证完了。\n将字符串输入进自动机复杂度为线性 每输入一个字符串最多深度加一。\n每次跳 fail 深度减一。\n证完了。\n","date":"2019-04-29T15:39:10+08:00","permalink":"https://ouuan.github.io/post/ac%E8%87%AA%E5%8A%A8%E6%9C%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","tags":["字符串","AC自动机"],"title":"AC自动机学习笔记"},{"categories":["题解"],"contents":"题目链接 洛谷\n题意简述 给你一个 DAG，每个点有个值 $k_i$。\n第一问：求一个拓扑排序，使每个点出现的位置不超过 $k_i$。\n第二问：在满足第一问的拓扑排序中，求每个点分别的最早出现位置。\n简要做法 第一眼看到这题，在多少之前 $\\rightarrow$ 反过来考虑，因为之前好像做过 PJ 难度的类似题目..\n然而第二眼就变成了：拓扑排序裸题！然后愉快地写了个假贪心..\n不能随便放过自己的直觉啊..\n正解就是建反图，这样一定可以每次选 $k$ 最大的，用优先队列拓扑排序就可以了。\n第二问的话，还是建反图，依次考虑每个点，不把当前考虑的点加入优先队列中，直到无法符合要求便是答案。\n参考代码 #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;queue\u0026gt; #include \u0026lt;cstring\u0026gt; using namespace std; typedef pair\u0026lt;int, int\u0026gt; pii; const int N = 2010; const int M = 10010; void add(int u, int v); int head[N], nxt[M], to[M], cnt; int n, m, k[N], ind[N], in[N], stk[N], top; priority_queue\u0026lt;pii\u0026gt; q; int main() { int i, u, v, x, ans; scanf(\u0026quot;%d%d\u0026quot;, \u0026amp;n, \u0026amp;m); for (i = 1; i \u0026lt;= n; ++i) scanf(\u0026quot;%d\u0026quot;, k + i); for (i = 1; i \u0026lt;= m; ++i) { scanf(\u0026quot;%d%d\u0026quot;, \u0026amp;u, \u0026amp;v); add(v, u); ++ind[u]; } memcpy(in, ind, sizeof(in)); for (i = 1; i \u0026lt;= n; ++i) if (!in[i]) q.push(pii(k[i], i)); while (!q.empty()) { u = stk[++top] = q.top().second; q.pop(); for (i = head[u]; i; i = nxt[i]) { v = to[i]; if (--in[v] == 0) q.push(pii(k[v], v)); } } while (top) printf(\u0026quot;%d \u0026quot;,stk[top--]); puts(\u0026quot;\u0026quot;); for (x = 1; x \u0026lt;= n; ++x) { ans = n; memcpy(in, ind, sizeof(in)); for (i = 1; i \u0026lt;= n; ++i) if (!in[i]) q.push(pii(k[i], i)); while (!q.empty()) { u = q.top().second; q.pop(); if (u == x) continue; if (k[u] \u0026lt; ans) { while (!q.empty()) q.pop(); break; } --ans; for (i = head[u]; i; i = nxt[i]) { v = to[i]; if (--in[v] == 0) q.push(pii(k[v], v)); } } printf(\u0026quot;%d \u0026quot;, ans); } return 0; } void add(int u, int v) { nxt[++cnt] = head[u]; head[u] = cnt; to[cnt] = v; } ","date":"2019-04-19T13:00:29+08:00","permalink":"https://ouuan.github.io/post/noi2010-%E8%88%AA%E7%A9%BA%E7%AE%A1%E5%88%B6%E5%BB%BA%E5%8F%8D%E5%9B%BE%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/","tags":["图论","优先队列","拓扑排序"],"title":"[NOI2010]航空管制（建反图，拓扑排序，优先队列）"},{"categories":["游记"],"contents":"口中喊着「僕勝つから。ぜったい、勝て来るから。」的你，真的付出了桐山般的努力吗？\nDay -1 晚上看 WF 直播，为了看滚榜睡得很晚，结果最后滚的时候 b 站那几个直播的去海底捞吃火锅，然后断断续续的\u0026hellip;.最后也没有看完滚榜，还是第二天才看的排名\u0026hellip;\nDay 0 由于前一天睡得比较晚，所以下午睡了两个小时。晚上 vp 了一场 cf。\n然后..本来想早点睡，结果由于下午睡了两个小时，睡不着了..最后很晚才睡。在床上看了四集半《三月的狮子》..（半是因为看困了，于是赶紧抓住机会睡了。）\nDay 1 早上起来的时候感觉特别清醒，后来才想起来，初三有段时间也不怎么睡，也是刚起来的时候并不会很困..走起路来有种 ふわふわ 的感觉..一直持续到快到华科的时候，才稍微觉得有点困..\n拿到题之后看了眼 T1，异或 $\\rightarrow$ 可持久化 01 Trie，求前 $k$ 大之和 $\\rightarrow$ 分成 $n$ 类每类的最大值塞堆里。大致的思路真的是一眼就想出来了..然而并没有想到三元组的做法，虽然 18 年暑假去安师大附中集训的时候做过一道那样的题..\n我想的做法是记录在 Trie 上 dfs 到的位置，然后根据位置求下一个。一开始我写的是每个点记录父亲，然后写+调 $2h$ 才想起来：这是可持久化啊，怎么记录父亲\u0026hellip;然后尝试加了个 map 来记录不同版本的父亲，变成 $\\log^2$，然后大样例跑了 $13s$，还 WA\u0026hellip;\n于是就先把 T1 放了一下，去看 T2。这 T2 什么鬼题面？（赛后结合讲题 PPT 里的简述一下就明白题意了，可能是简述的原因，也可能是没睡好考场上 sb 了..只不过一个没有题目背景的题为什么不写简述题意呢..）看了半天稍微看懂题意了，然后一看第一档暴力，好像第一档就得写个 $20min$ ~ $0.5h$ 的..我的习惯是先写 PJ 难度暴力，然后写正解，最后写不好写的部分分，所以就先放着了。\n然后去看 T3..没想到竟然能在考场上碰到 ydc 的题面..先把 998244353 切了，然后写了个从最大值起枚举模数，然后..1145141？唐 突 恶 臭，//echouctr 警告。赛后得知有人直接（抱着恶臭的想法）试出来了..还有只枚举质数的..想不明白为什么要给个质数..搞的我还写了扩展欧拉定理和求 $\\varphi$（虽然也没有太麻烦..）。1_?+ 直接弃了。wa 尝试把快速幂里的 long long 去掉，然后没过，就也弃了。后面的..猜到了 p 是质数，根据 0/+/- 猜到了 u 是 $\\mu$，猜到了 g 是原根..nmdwsm是区间筛啊..\n回来看 T1，重构的决定还算比较果断，换了种找后继的方式：记录 dfs 路径以及每个点被搜到的次数，满了就换个儿子，否则按原路径往下。写的还算比较顺利，不到 $1h$ 就过了大样例，然后开始对拍，也过拍了。然后，把 rand() 的范围开到 unsigned..不过拍了？？检查了一下，所有该开 unsigned 的地方都开了，于是把所有参与位运算的 1 都改成了 1u，还是过不了..然后我就开始 sb 了：先把 unsigned int 改成 unsigned long long，发现过不了，然后改回 unsigned int，再把循环的范围从 31 改成 32.. 然后我就各种检查，直到考试结束也没过拍..考后发现，是一种边界情况的一行代码放错位置了，除了同时开 unsigned long long 和循环范围 32，也可以把那行代码换个位置来解决。\n下午得知正式选手好像必须参加讲题？看分，发现第一题竟然过了..脸挺好的。T2 puts(\u0026quot;-1\u0026quot;) 果然没分。T3 写多少是多少（废话，这种题..）。$100+0+19$，$rk6$，被吊锤了..在其他省就垫底了..\n晚上打了场 Global，神仙 Div.2 A~C \u0026amp; Div.1 E/F 场..写完 A ~ E 之后发现所有人包括 tourist 都是五题，而且 tourist 在我之前半个小时就写完五题了..于是就不想打了。又过了快一个小时，发现有好多人在 hack A，于是就去看了下，hack 了一个写法奇怪的 A。最后涨了不少分..\n还好晚上顺利睡着了..\nDay 2 由于昨天调 T1 调的心态爆炸才去看后面的题导致整场爆炸，于是这次先看了每道题..\n看了看 T1，除了 dp 没啥想法，先写了个 $20$ 分暴力，准备把 dp 留到后面写。真的是 sb 了，没想到可以压两维，只压了一维..\n然后去看 T2，第一眼并没有什么想法..暴力连第二档都不太会写，于是先写了个 $\\mathcal O(n^n)$。\n然后去看 T3，emm..暴力怎么写啊.webp。\n然后去上了个厕所。在厕所里想到了 T2 的做法..写的比较顺利，大概不到 $1h$ 吧..就第一次测挂了，改了个小地方就过了所有样例。然后对拍，也过拍了。然后测了下链..RE了？？冷静了一下，猜测是爆栈了，直接去问了监考，答复是栈空间和内存限制一样，然后就愉快地本地开栈过了。\n然后去写 T1 的 dp..一开始尝试单数组滚动，然后挂了。于是改成 01 滚动，又调了好久才过..\n最后去写 T3，决定只写 $k=1$。先写了下 $k=1$ \u0026amp; $l=n$ 的 dp，很快就写完了。然后去写剩下的 $k=1$，算了下复杂度，$\\mathcal O(nl^2)$，感觉好悬..然后发现可以用 NTT 优化到 $\\mathcal O(nl\\log l)$，然后开始写 NTT，然后..NTT 没调出来..考前应该写一写的..因为比较头铁，NTT 一直调到了离考试结束 $15min$，然后开始 rush $\\mathcal O(nl^2)$，失败了..\n出考场不久，想起来自己 T1 好像忘清空了..辣鸡温馨提示。然后我在影响正确性/不影响正确性之间反复切换了几次结论..最后在看成绩之前得出的结论是，我没有限制（$k=0$）的点稳挂，剩下的点大概率挂。\n去看成绩，$20+100+8$。T1 竟然有 $20$？难道是 $k\\ne0$ 的点都过了？听完讲题之后去看评测结果，发现是 $k=0$ 的两个点过了\u0026hellip;至今没想明白，只不过如果清空了数组就是 $40$ 了。\n最后是两天总分第四（和去年一样，白学了），加上 NOIP 还是被胡队爆踩了..\n晚上两天挂分 $100+$ 的裸罗队在裙里问为什么 D2T2 $75​$ 分，我把他的代码复制到 LOJ 发现过了..\n冷静了一下，感觉不可能是 OJ 的问题，所以不开 C++11 测了一下，果然没过..因为前几天写 OI Wiki 的时候查过，所以很快就猜到了，是 swap 的问题.. priority_queue 的 swap 在不开 C++11 时是 $\\mathcal O(n)$ 的。\n题解 D1T1 考场做法 建可持久化 01 Trie，把区间异或和转化成两个前缀异或和的异或，然后对每个右端点就可以找到最大的异或和，扔进堆里。找最大值的时候记录一下在 Trie 上的路径，以及每一层经过的次数。堆里弹出一个值后插入下一个值时根据记录的路径来找：如果经过次数大于子树当前节点的 siz 就换个儿子并清空比他更深的节点的记录的经过次数，否则按记录的路径走。如果 Trie 的根都满了就不 push 了。\n参考代码 #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;queue\u0026gt; #include \u0026lt;map\u0026gt; #include \u0026lt;cctype\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; int n,k; typedef unsigned int ui; typedef pair\u0026lt;ui,int\u0026gt; pui; ui read() { ui out=0; char c; while (!isdigit(c=getchar())); for (;isdigit(c);c=getchar()) out=out*10+c-'0'; return out; } const int N=500010; struct Node { int val,ch[2]; } t[N*35]; int rt[N],tot,d[N][35],cnt[N][35]; ui pre[N]; unsigned long long ans; priority_queue\u0026lt;pui\u0026gt; q; int ins(int x,ui y) { int i,u,v,root; u=root=++tot; t[u].val=t[x].val+1; for (i=31;i\u0026gt;=0;--i) { v=((y\u0026gt;\u0026gt;i)\u0026amp;1u); t[u].ch[v^1]=t[x].ch[v^1]; u=t[u].ch[v]=++tot; x=t[x].ch[v]; t[u].val=t[x].val+1; } return root; } signed main() { scanf(\u0026quot;%d %d\u0026quot;,\u0026amp;n,\u0026amp;k); int i,j,u,v,r; ui x; for (i=1;i\u0026lt;=n;++i) { pre[i]=pre[i-1]^read(); u=rt[i]=ins(rt[i-1],pre[i-1]); for (x=0,j=31;j\u0026gt;=0;--j) { v=(((pre[i]\u0026gt;\u0026gt;j)\u0026amp;1u)^1u); if (t[u].ch[v]) { x|=(1u\u0026lt;\u0026lt;j); d[i][j]=u=t[u].ch[v]; } else d[i][j]=u=t[u].ch[v^1]; ++cnt[i][j]; } q.push(pui(x,i)); } while (k--) { ans+=q.top().first; r=q.top().second; q.pop(); x=0; for (u=rt[r],i=31;i\u0026gt;=0;--i) { v=(((pre[r]\u0026gt;\u0026gt;i)\u0026amp;1u)^1u); if (cnt[r][i]==0) { ++cnt[r][i]; if (t[u].ch[v]) { x|=(1u\u0026lt;\u0026lt;i); u=d[r][i]=t[u].ch[v]; } else u=d[r][i]=t[u].ch[v^1]; } else if (cnt[r][i]\u0026lt;t[d[r][i]].val) { if (d[r][i]==t[u].ch[v]) x|=(1u\u0026lt;\u0026lt;i); ++cnt[r][i]; u=d[r][i]; } else { for (j=i;j\u0026gt;=0;--j) cnt[r][j]=0; ++cnt[r][i]; u=d[r][i]=t[u].ch[v^1]; } } if (cnt[r][31]==t[rt[r]].val) continue; q.push(pui(x,r)); } printf(\u0026quot;%lld\\n\u0026quot;,ans); return 0; }   题解做法 除了找后继都是差不多的，找后继的方法是找完 $[0,r)$ 之后把 $[0,ans)$ 和 $(ans,r)$ 塞进堆里。\n正常人做法 翻了下 LOJ 最短解，然后被自己蠢哭了..\n直接记录每个右端点已经找到第 $k$ 大了，然后找第 $k$ 大的方式类似值域线段树/平衡树找第 $k​$ 大\u0026hellip;\nD1T2 讲一下 SAM 做法.. sb 选手不适合打 SA。\n把所有串翻转，B 是 A 的前缀就变成了 B 是 A 的后缀。\n是后缀就是 parent 树上的祖先，或者同一个节点且 len 更小。\n把所有 A/B 串对应的节点按在 A/B 中的 len 拆点，每个 parent 树上的节点从较小的 len 向较大的 len 连边，A 串对应的点 \u0026amp; len 向 A 串连边，B 串向对应的点 \u0026amp; len 连边。\n然后拓扑排序/记忆化搜索即可。\n当然如果你像我一样 sb，可以按 dfs 序用线段树优化连边，就可以（假装）不用拆点了..\n参考代码 #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;set\u0026gt; #include \u0026lt;map\u0026gt; #include \u0026lt;cctype\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; int read() { int out=0; char c; while (!isdigit(c=getchar())); for (;isdigit(c);c=getchar()) out=out*10+c-'0'; return out; } const int N=200010; struct Node { int len,par,ch[26]; } sam[N\u0026lt;\u0026lt;1]; void insert(int x); int p,tot,fa[N\u0026lt;\u0026lt;1][20],sta[N]; void add(int u,int v); long long dp(int u); int head[N*5],nxt[N*6],to[N*6],cnt; int n,na,nb,m,a[N],alen[N],b[N],blen[N],w[N*5],tot2; set\u0026lt;int\u0026gt; aln[N\u0026lt;\u0026lt;1],bln[N\u0026lt;\u0026lt;1]; map\u0026lt;int,int\u0026gt; aid[N\u0026lt;\u0026lt;1],bid[N\u0026lt;\u0026lt;1]; long long ans,f[N*5]; bool vis1[N*5],vis2[N*5],loop; char s[N]; int main() { int i,j,l,r,u,pre,T; T=read(); while (T--) { scanf(\u0026quot;%s\u0026quot;,s+1); n=strlen(s+1); reverse(s+1,s+n+1); for (i=1;i\u0026lt;=2*n;++i) { memset(sam[i].ch,0,sizeof(sam[i].ch)); aln[i].clear(); aid[i].clear(); bln[i].clear(); bid[i].clear(); } memset(w,0,sizeof(w)); memset(head,0,sizeof(head)); memset(vis1,false,sizeof(vis1)); memset(vis2,false,sizeof(vis2)); cnt=ans=0; p=tot=1; loop=false; for (i=1;i\u0026lt;=n;++i) { sta[i]=tot+1; insert(s[i]-'a'); } for (i=2;i\u0026lt;=tot;++i) fa[i][0]=sam[i].par; for (j=1;j\u0026lt;=18;++j) { for (i=2;i\u0026lt;=tot;++i) { fa[i][j]=fa[fa[i][j-1]][j-1]; } } na=read(); for (i=1;i\u0026lt;=na;++i) { r=n+1-read(); l=n+1-read(); u=sta[r]; for (j=18;j\u0026gt;=0;--j) { if (sam[fa[u][j]].len\u0026gt;r-l) { u=fa[u][j]; } } a[i]=u; alen[i]=r-l+1; aln[u].insert(alen[i]); bln[u].insert(alen[i]); } nb=read(); for (i=1;i\u0026lt;=nb;++i) { r=n+1-read(); l=n+1-read(); u=sta[r]; for (j=18;j\u0026gt;=0;--j) { if (sam[fa[u][j]].len\u0026gt;r-l) { u=fa[u][j]; } } b[i]=u; blen[i]=r-l+1; bln[u].insert(blen[i]); } tot2=tot; for (i=2;i\u0026lt;=tot;++i) { if (bln[i].empty()) add(sam[i].par,i); else { for (auto k : aln[i]) w[aid[i][k]=++tot2]=k; pre=sam[i].par; for (auto k : bln[i]) { add(pre,bid[i][k]=++tot2); if (aln[i].find(k)!=aln[i].end()) add(tot2,aid[i][k]); pre=tot2; } add(tot2,i); } } m=read(); for (i=1;i\u0026lt;=m;++i) { l=read(); r=read(); add(aid[a[l]][alen[l]],bid[b[r]][blen[r]]); } for (i=1;i\u0026lt;=na;++i) ans=max(ans,dp(aid[a[i]][alen[i]])); if (loop) puts(\u0026quot;-1\u0026quot;); else printf(\u0026quot;%lld\\n\u0026quot;,ans); } return 0; } long long dp(int u) { if (vis2[u]) return f[u]; if (vis1[u]) loop=true; if (loop) return 0; vis1[u]=true; int i,v; f[u]=w[u]; for (i=head[u];i;i=nxt[i]) { v=to[i]; f[u]=max(f[u],dp(v)+w[u]); } vis2[u]=true; return f[u]; } void insert(int x) { int np=++tot; sam[np].len=sam[p].len+1; while (p\u0026amp;\u0026amp;!sam[p].ch[x]) { sam[p].ch[x]=np; p=sam[p].par; } if (!p) sam[np].par=1; else { int q=sam[p].ch[x]; if (sam[q].len==sam[p].len+1) sam[np].par=q; else { int nq=++tot; sam[nq].len=sam[p].len+1; memcpy(sam[nq].ch,sam[q].ch,sizeof(sam[q].ch)); sam[nq].par=sam[q].par; sam[q].par=sam[np].par=nq; while (p\u0026amp;\u0026amp;sam[p].ch[x]==q) { sam[p].ch[x]=nq; p=sam[p].par; } } } p=np; } void add(int u,int v) { nxt[++cnt]=head[u]; head[u]=cnt; to[cnt]=v; }   D1T3 快速幂 # 3 欧拉定理，边读入边取模。\n# 4 找到最大值往上枚举 / 抱着恶臭的想法直接猜出来。\n# 5 按 $x$ 排序后发现有两组相邻的 $x$ 差小于等于 $10$，由于 $p|(y_119^{x_2-x_1}-y_2)$，求出这两组的 $gcd$ 即可。\n# 6 / 7 先自然溢出再取模。\n# 7 暴力找循环节即可。需要注意循环节中不含 $1$ .. 所以不能直接通过 $1$ 来判断循环节，可以用 set。\n区间筛质数/莫比乌斯函数 # 9 / 12 用 $\\sqrt n$ 以内的质数筛后面的。\n# 10 / 13 用 $5\\times10^7$ 以内的数筛后面的，然后把错误的项打表。\n好像可以用 Miller-Rabin 不打表做，不太会..\n几个优化码长的小技巧：\n 数组里面存差分。 把 $5\\times10^7$ 略微调大，但要注意不要 TLE。 把数组压成字符串。  区间筛原根 # 14 直接判断 $p-1$ 除掉每个质因数后是否是 $a^x\\equiv1\\pmod p$ 的解。\n# 15 先找到任意一个原根 $g$。\n预处理出 $x​$ 是 $g​$ 的 $k​$ 次幂，那么 $x​$ 是原根当且仅当 $k​$ 和 $p-1​$ 互质。\n# 16 枚举质数判断即可快速找到 $p$。（说是快速还是要跑几十秒..）\n参考代码 LOJ 最慢解\nD2T1 搞三个背包：\n 整个城市都没有限制的城市选择阵营。 没有限制的学校选择派系。 有限制的学校选择阵营\u0026amp;派系，注意每个有限制的城市要选一个有限制的学校作为“代表”，在背包时对阵营的贡献为整个城市的总和。  最后再枚举第三个背包的每一项，对答案的贡献就是这一项乘上前两个背包中可以和这一项一起选的方案数，实际上是一段连续的区间，所以前两个背包预处理一下前缀和就可以算了。\n用值域优化一下背包的枚举范围，总复杂度是 $\\mathcal O(nm+k^2wm)$。\n整体思路不难，知识点只有背包..然而还是写了整整一晚上。\n在寝室调到快十二点，虽然觉得自己挺 sb 的，但本地在 lemon 上 ac 的时候..真的好爽啊。\n不得不说寝室写题效率就是高，又爽。写完还能看一集三狮\n参考代码 #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; typedef long long ll; const int N=1005; const int M=2505; const int K=35; const int V=10; const int mod=998244353; struct Node { int b,s,p; bool operator\u0026lt;(const Node\u0026amp; y) const { if ((~p\u0026amp;\u0026amp;~y.p)||(p==-1\u0026amp;\u0026amp;y.p==-1)) return b\u0026lt;y.b; if (p==-1) return false; return true; } } a[N]; int n,c,m,f[M],g[M],h[M][K*V][2],zy[2],px[2],sum[N],tot[4],ans; bool ban[N]; int main() { int T,i,j,k,x,y,tmp[2]; scanf(\u0026quot;%d\u0026quot;,\u0026amp;T); while (T--) { memset(f,0,sizeof(f)); memset(g,0,sizeof(g)); memset(h,0,sizeof(h)); memset(tot,0,sizeof(tot)); memset(sum,0,sizeof(sum)); memset(ban,false,sizeof(ban)); scanf(\u0026quot;%d%d%d%d%d%d\u0026quot;,\u0026amp;n,\u0026amp;c,zy+0,zy+1,px+0,px+1); for (i=1;i\u0026lt;=n;++i) { scanf(\u0026quot;%d%d\u0026quot;,\u0026amp;a[i].b,\u0026amp;a[i].s); sum[a[i].b]+=a[i].s; a[i].p=-1; tot[0]+=a[i].s; tot[1]+=a[i].s; } scanf(\u0026quot;%d\u0026quot;,\u0026amp;m); for (i=1;i\u0026lt;=m;++i) { scanf(\u0026quot;%d%d\u0026quot;,\u0026amp;x,\u0026amp;y); a[x].p=y; ban[a[x].b]=true; tot[0]-=a[x].s; tot[2]+=a[x].s; } sort(a+1,a+n+1); f[0]=1; for (i=1;i\u0026lt;=c;++i) { if (ban[i]||!sum[i]) { tot[1]-=sum[i]; tot[3]+=sum[i]; continue; } for (j=min(zy[0],tot[1]);j\u0026gt;=sum[i];--j) { if (j\u0026gt;=sum[i]) f[j]=(f[j]+f[j-sum[i]])%mod; } } for (j=1;j\u0026lt;=zy[0];++j) f[j]=(f[j-1]+f[j])%mod; g[0]=1; for (i=m+1;i\u0026lt;=n;++i) { for (j=min(px[0],tot[0]);j\u0026gt;=a[i].s;--j) { if (j\u0026gt;=a[i].s) g[j]=(g[j]+g[j-a[i].s])%mod; } } for (j=1;j\u0026lt;=px[0];++j) g[j]=(g[j-1]+g[j])%mod; h[0][0][0]=1; for (i=m;i\u0026gt;=1;--i) { for (j=min(tot[3],zy[0]);j\u0026gt;=0;--j) { for (k=tot[2];k\u0026gt;=0;--k) { for (x=0;x\u0026lt;=1;++x) { tmp[x]=0; for (y=0;y\u0026lt;=1;++y) { if ((x^1)*2+(y^1)==a[i].p||j\u0026lt;x*sum[a[i].b]||k\u0026lt;y*a[i].s) continue; if (a[i].b!=a[i+1].b||i==m) tmp[x]=(0ll+tmp[x]+h[j-x*sum[a[i].b]][k-y*a[i].s][x^1]+h[j-x*sum[a[i].b]][k-y*a[i].s][x])%mod; else tmp[x]=(tmp[x]+h[j][k-y*a[i].s][x])%mod; } } h[j][k][0]=tmp[0]; h[j][k][1]=tmp[1]; } } } ans=0; for (j=0;j\u0026lt;=tot[3]\u0026amp;\u0026amp;j\u0026lt;=zy[0];++j) { if (zy[0]-j\u0026lt;tot[3]-j+tot[1]-zy[1]) continue; for (k=0;k\u0026lt;=tot[2];++k) { if (px[0]-k\u0026lt;tot[2]-k+tot[0]-px[1]) continue; ans=(ans+(ll)(h[j][k][0]+h[j][k][1])*(f[zy[0]-j]-(tot[3]-j+tot[1]-zy[1]\u0026gt;0?f[tot[3]-j+tot[1]-zy[1]-1]:0))%mod*(g[px[0]-k]-(tot[2]-k+tot[0]-px[1]\u0026gt;0?g[tot[2]-k+tot[0]-px[1]-1]:0)))%mod; } } cout\u0026lt;\u0026lt;(ans+mod)%mod\u0026lt;\u0026lt;endl; } return 0; }   D2T2 用堆维护每个子树的答案（堆里每个元素为每一组的最大值），合并的时候弹出两个堆顶取 max 记录下来，直到其中一个堆为空，再把记录的值加到非空的那个堆里，就是新的答案。可以两两合并，也可以把儿子合并了再加上自己。合并时每弹出两个元素、加入一个元素，元素的总数就会减少一，所以总复杂度是 $\\mathcal O(n\\log n)$。注意，不能用 = 来复制堆，而要用 swap，而且要开 C++11。如果不开 C++11 可以记录 id 然后 swap id。\n贪心合并就不严格证了，感觉稍有点类似最近那场 CF 的 B？\n参考代码 #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;cctype\u0026gt; #include \u0026lt;queue\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; int read() { int out=0; char c; while (!isdigit(c=getchar())); for (;isdigit(c);c=getchar()) out=out*10+c-'0'; return out; } const int N=200010; void dfs1(int u); void dfs2(int u); vector\u0026lt;int\u0026gt; son[N]; int n,a[N],mxdep[N]; priority_queue\u0026lt;int\u0026gt; q[N]; int main() { int i; long long ans=0; n=read(); for (i=1;i\u0026lt;=n;++i) a[i]=read(); for (i=2;i\u0026lt;=n;++i) son[read()].push_back(i); dfs1(1); for (i=1;i\u0026lt;=n;++i) sort(son[i].begin(),son[i].end(),[](int x,int y){return mxdep[x]\u0026gt;mxdep[y];}); dfs2(1); while (!q[1].empty()) { ans+=q[1].top(); q[1].pop(); } cout\u0026lt;\u0026lt;ans; return 0; } void dfs2(int u) { int i,v,mx; vector\u0026lt;int\u0026gt; tmp; for (i=0;i\u0026lt;son[u].size();++i) { v=son[u][i]; dfs2(v); } if (son[u].size()) { if (son[u].size()\u0026gt;1) { while (!q[son[u][1]].empty()) { mx=0; for (i=0;i\u0026lt;son[u].size();++i) { v=son[u][i]; if (q[v].empty()) break; mx=max(mx,q[v].top()); q[v].pop(); } tmp.push_back(mx); } } q[u].swap(q[son[u][0]]); for (i=0;i\u0026lt;tmp.size();++i) q[u].push(tmp[i]); } q[u].push(a[u]); } void dfs1(int u) { int i,v; for (i=0;i\u0026lt;son[u].size();++i) { v=son[u][i]; dfs1(v); mxdep[u]=max(mxdep[u],mxdep[v]+1); } }   D2T3 待填。\n","date":"2019-04-08T15:39:51+08:00","permalink":"https://ouuan.github.io/post/%E5%8D%81%E4%BA%8C%E7%9C%81%E8%81%94%E8%80%832019-%E6%B8%B8%E8%AE%B0-%E9%A2%98%E8%A7%A3/","tags":["CCF系列赛事","省选"],"title":"十二省联考2019 游记 \u0026 题解"},{"categories":["知识点"],"contents":"最近发现 OI Wiki 的“树分块”是空的，本来想凭着之前写的莫队教程水一水，结果被告知已经有人写过树上莫队了..于是就得详细介绍一下树分块除了树上莫队以外的应用..然而我除了糖果公园只做过一道树分块..（结果最后并没有找到这道题以外的其它题..）\n树分块的方式 可以参考 OI Wiki/莫队算法/真-树上莫队。\n也可以参考 ouuan的博客/莫队、带修莫队、树上莫队详解/树上莫队。\n树上莫队同样可以参考以上两篇文章。\n树分块的应用 树分块除了应用于莫队，还可以灵活地运用到某些树上问题中。但可以用树分块解决的题目往往都有更优秀的做法，所以相关的题目较少。\n顺带提一句，“gty的妹子树”的树分块做法可以被菊花图卡掉。\nBZOJ4763 雪辉 先进行树分块，然后对每个块的关键点，预处理出它到祖先中每个关键点的路径上颜色的 bitset，以及每个关键点的最近关键点祖先，复杂度是 $\\mathcal O(n\\sqrt n+\\frac{nc}{32})​$，其中 $n\\sqrt n​$ 是暴力从每个关键点向上跳的复杂度，$\\frac{nc}{32}​$ 是把 $\\mathcal O(n)​$ 个 bitset 存下来的复杂度。\n回答询问的时候，先从路径的端点暴力跳到所在块的关键点，再从所在块的关键点一块一块地向上跳，直到 $lca$ 所在块，然后再暴力跳到 $lca$。关键点之间的 bitset 已经预处理了，剩下的在暴力跳的过程中计算。单次询问复杂度是 $\\mathcal O(\\sqrt n+\\frac c{32})$，其中 $\\sqrt n$ 是块内暴力跳以及块直接向上跳的复杂度，$\\mathcal O(\\frac c{32})$ 是将预处理的结果与暴力跳的结果合并的复杂度。数颜色个数可以用 bitset 的 count()，求 $\\operatorname{mex}$ 可以用 bitset 的 _Find_first()。\n所以，总复杂度为 $\\mathcal O((n+m)(\\sqrt n+\\frac c{32}))​$。\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;cctype\u0026gt; #include \u0026lt;bitset\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; int read() { int out=0; char c; while (!isdigit(c=getchar())); for (;isdigit(c);c=getchar()) out=out*10+c-'0'; return out; } const int N=100010; const int B=666; const int C=30000; void add(int u,int v); void dfs(int u); int head[N],nxt[N\u0026lt;\u0026lt;1],to[N\u0026lt;\u0026lt;1],cnt; int n,m,type,c[N],fa[N],dep[N],sta[N],top,tot,bl[N],key[N/B+5],p[N],keyid[N]; bool vis[N]; bitset\u0026lt;C\u0026gt; bs[N/B+5][N/B+5],temp; int main() { int i,u,v,x,y,k,lastans=0; n=read(); m=read(); type=read(); for (i=1;i\u0026lt;=n;++i) c[i]=read(); for (i=1;i\u0026lt;n;++i) { u=read(); v=read(); add(u,v); add(v,u); } dfs(1); if (!tot) ++tot; if (keyid[key[tot]]==tot) keyid[key[tot]]=0; key[tot]=1; keyid[1]=tot; while (top) bl[sta[top--]]=tot; for (i=1;i\u0026lt;=tot;++i) //预处理 { if (vis[key[i]]) continue; vis[key[i]]=true; temp.reset(); for (u=key[i];u;u=fa[u]) { temp[c[u]]=1; if (keyid[u]) { if (!p[key[i]]\u0026amp;\u0026amp;u!=key[i]) p[key[i]]=u; bs[keyid[key[i]]][keyid[u]]=temp; } } } while (m--) { k=read(); temp.reset(); while (k--) { u=x=read()^lastans; v=y=read()^lastans; while (key[bl[x]]!=key[bl[y]]) { if (dep[key[bl[x]]]\u0026gt;dep[key[bl[y]]]) { if (x==u) //若是第一次跳先暴力跳到关键点 { while (x!=key[bl[u]]) { temp[c[x]]=1; x=fa[x]; } } else x=p[x]; //否则跳一整块 } else { if (y==v) { while (y!=key[bl[v]]) { temp[c[y]]=1; y=fa[y]; } } else y=p[y]; } } if (keyid[x]) temp|=bs[keyid[key[bl[u]]]][keyid[x]]; if (keyid[y]) temp|=bs[keyid[key[bl[v]]]][keyid[y]]; while (x!=y) { if (dep[x]\u0026gt;dep[y]) { temp[c[x]]=1; x=fa[x]; } else { temp[c[y]]=1; y=fa[y]; } } temp[c[x]]=true; } int ans1=temp.count(),ans2=(~temp)._Find_first(); printf(\u0026quot;%d %d\\n\u0026quot;,ans1,ans2); lastans=(ans1+ans2)*type; } return 0; } void dfs(int u) { int i,v,t=top; for (i=head[u];i;i=nxt[i]) { v=to[i]; if (v==fa[u]) continue; fa[v]=u; dep[v]=dep[u]+1; dfs(v); if (top-t\u0026gt;=B) { key[++tot]=u; if (!keyid[u]) keyid[u]=tot; while (top\u0026gt;t) bl[sta[top--]]=tot; } } sta[++top]=u; } void add(int u,int v) { nxt[++cnt]=head[u]; head[u]=cnt; to[cnt]=v; }  BZOJ4812 由乃打扑克 这题和上一题基本一样，唯一的区别是得到 bitset 后如何计算答案。\n由于BZOJ是计算所有测试点总时限，不好卡，所以可以用 _Find_next() 水过去。\n正解是每 $16$ 位一起算，先预处理出 $2^{16}$ 种可能的情况高位连续 $1$ 的个数、低位连续 $1$ 的个数以及中间的贡献。只不过这样要手写 bitset，因为标准库的 bitset 不能取某 $16$ 位..\n代码可以参考这篇博客。\n","date":"2019-03-30T21:18:50+08:00","permalink":"https://ouuan.github.io/post/%E6%A0%91%E5%88%86%E5%9D%97%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","tags":["数据结构","分块","树分块"],"title":"树分块学习笔记"},{"categories":["计划"],"contents":"随便找了点省选前需要复习的知识点相关的题目..\n题目 LCT/树剖 共价大爷游长沙\n小清新数据结构题\n最小差值生成树\nQTREE4\n淀粉质 树上游戏\n字符串 [APIO2014]回文串\n[HEOI2016/TJOI2016]字符串\nTrie 最大异或和\n最长异或路径\n整体二分/树套树 [ZJOI2013]K大数查询\ncdq分治 [Violet]天使玩偶/SJY摆棋子\n[NOI2007]货币兑换\n莫比乌斯反演 [SDOI2014]数表\n最小公倍数之和\nLucas的数论\n组合数学、容斥原理、斯特林数 重返现世\n[HEOI2016/TJOI2016]求和\n[国家集训队] Crash 的文明世界\n多项式、生成函数 食物\n[CodeChef] COUNTARI\n万径人踪灭\nThe Child and Binary Tree\n城市规划\n付公主的背包\n玩游戏\n记录 共价大爷游长沙：如果要获取一个点的子树信息，要么 access 父亲 Splay 自己然后看实+虚+自己，要么 access 自己然后看虚+自己。\n最大异或和：一开始尝试用线段树合并做，复杂度是 $\\mathcal O(n(\\log(n+m)+\\log w)+m\\log(n+m)\\log w)$，卡常卡不过去，尝试用 bitset 优化，后来发现除以 $32$ 被 $\\log$ 掉了，加上带来的一些常数后根本没有优化.. 只不过后来发现可持久化 Trie 真的挺好写的，（只要会主席树不需要学也能 yy 出来的感觉）。\n最后果然没做几道题..只不过比我想象中还要少一点..\n写了点 OI Wiki，过程中也写了几道计划外的题。\n","date":"2019-03-30T09:25:04+08:00","permalink":"https://ouuan.github.io/post/2019%E7%9C%81%E9%80%89%E5%A4%8D%E4%B9%A0%E5%91%A8%E5%81%9A%E9%A2%98%E8%AE%A1%E5%88%92/","tags":["省选","CCF系列赛事","计划"],"title":"2019省选复习周做题计划"},{"categories":["知识点"],"contents":"这是一篇披着PJ组数据结构外衣的树套树教程。\n大约会（尝试着）较为本质地简介一下树状数组？\n基础树状数组 树状数组，英文名 BIT(Binary Indexed Tree)（不是TreeArray）。\n原理的话..看图大约是一目了然的：\n其中，黑色的矩形（包括红色的正方形）代表这一部分的和，而红色的正方形代表这部分和在树状数组中的下标。如果把这些区间连边，就像是一棵二叉树，所以叫树状数组。\n举几个栗子，$BIT[3]$ 表示 $A[3]$，$BIT[6]$ 表示 $A[5]+A[6]$，$BIT[12]$ 表示 $A[9]+A[10]+A[11]+A[12]$。\n我们把每个下标用二进制表示，可以发现，二进制表示的末尾有 $k​$ 个 $0​$，在树状数组里它就代表一段长为 $2^k​$ 的区间的和。由于树状数组和下标的二进制联系紧密，所以英文叫 Binary Indexed Tree。\n可以定义 $lowbit(x)$ 为 $x$ 的二进制表示中最低位的 $1$ 表示的数。如 $lowbit(101_{(2)})=1$，$lowbit(110100_{(2)}=4)$，这样的话，树状数组中下标为 $x$ 的元素就表示了一段长为 $lowbit(x)$ 的区间的和。\n由于计算机中存储带符号整数的方式，$lowbit(x)=$x\u0026amp;-x，具体原因可以自行搜索“补码”。\n考虑如何更新树状数组：如果我们要更新第 $p$ 位，先更新 $BIT[p]$，再更新 $BIT[p+lowbit(p)]$，再更新 $BIT[p+lowbit(p)+lowbit(p+lowbit(p))]$……一直更新到原数列的长度。\n考虑如何查询某个前缀和：如果我们要查询前 $p$ 位的前缀和，结果就是 $BIT[p]+BIT[p-lowbit(p)]+BIT[p-lowbit(p)-lowbit(p-lowbit(p))]$……一直查询到 $lowbit$ 为 $1$ 的节点。\n把树状数组看成二叉树，深度不超过 $\\log(n)$，所以单次操作复杂度是 $\\mathcal O(\\log n)$。\n大概就是这样，代码比较简短：\nvoid add(int p,int x) { for (;p\u0026lt;=n;p+=(p\u0026amp;-p)) BIT[p]+=x; } int query(int p) { int out=0; for (;p;p-=(p\u0026amp;-p)) out+=BIT[p]; return out; }  稍进阶一点点的树状数组 由于本篇教程是“从背模板到树套树”而不是“摆脱线段树与平衡树”，所以不会提及那方面的高级用法。\n维护前缀积 把+改成*。\n维护前缀异或和 把+改成^。\n维护前缀矩阵积 把+改成矩阵乘法。\n诶，等等，怎么全WA了？\n因为矩阵乘法不具有交换律..\n比如说，两个矩阵 $A$ 和 $B$，树状数组里存的是 $A$ 和 $A\\times B$，把 $A$ 乘上 $C$ 后树状数组里第二项我们期望它是 $A\\times C\\times B$，而实际上它是 $A\\times B\\times C$..\n所以树状数组到底在维护什么？  警告：本人其实没怎么学过群论..下文群论相关可能有口胡成分。\n 在维护一个阿贝尔群..\n等等，群是什么？群号多少？\n..就是一堆元素，定义了一种运算，它满足结合律、交换律，有单位元（谁和它运算都得到本身）、逆元（每个元素都存在一个元素运算后得到单位元）。如果只是前缀信息按理来说是不需要逆元的..然而一般都是要维护区间信息，而不只是前缀信息，所以需要逆元..\n树状数组套动态开点线段树 简介 终于到正题了。\n我们来定义一个阿贝尔群：\n它的元素是一些同构的动态开点线段树，运算是把对应节点的信息相加，要求节点维护的信息是阿贝尔群。\n一般来说，主席树可以解决的静态问题带修就要用树套树了..\n修改就是把树状数组里的+换成动态开点线段树的修改操作，询问就是把+换成merge。直接 merge 复杂度好像不太对..（其实我不太会证线段树合并复杂度..）所以可以开个数组，把需要询问的节点存下来，然后在询问函数里合并信息。如果是询问区间，就把两个端点在树状数组里对应的节点存下来。\n例题 Dynamic Rankings 代码 #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;cctype\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; int read() { int out=0; char c; while (!isdigit(c=getchar())); for (;isdigit(c);c=getchar()) out=out*10+c-'0'; return out; } const int N=100001; struct Node { int val,ls,rs; } t[N\u0026lt;\u0026lt;9]; int modify(int x,int l,int r,int p,int type); int merge(int x,int y); int query(int l,int r,int k); void change(int p,int x,int y); int n,m,tot,a[N],BIT[N],lsh[N\u0026lt;\u0026lt;1],cnt,tp[N],l[N],r[N],xx[N],totx,toty,x[N],y[N]; char op[10]; int main() { int i,j; n=read(); m=read(); for (i=1;i\u0026lt;=n;++i) lsh[++cnt]=a[i]=read(); for (i=1;i\u0026lt;=m;++i) { scanf(\u0026quot;%s\u0026quot;,op); if (op[0]=='Q') { tp[i]=0; l[i]=read(); r[i]=read(); xx[i]=read(); } else { tp[i]=1; l[i]=read(); lsh[++cnt]=xx[i]=read(); } } sort(lsh+1,lsh+cnt+1); cnt=unique(lsh+1,lsh+cnt+1)-lsh; for (i=1;i\u0026lt;=n;++i) { a[i]=lower_bound(lsh+1,lsh+cnt,a[i])-lsh; change(i,a[i],1); } for (i=1;i\u0026lt;=m;++i) { if (tp[i]) { change(l[i],a[l[i]],-1); change(l[i],a[l[i]]=xx[i]=lower_bound(lsh+1,lsh+cnt,xx[i])-lsh,1); } else { totx=toty=0; for (j=l[i]-1;j;j-=(j\u0026amp;-j)) x[++totx]=BIT[j]; for (j=r[i];j;j-=(j\u0026amp;-j)) y[++toty]=BIT[j]; printf(\u0026quot;%d\\n\u0026quot;,query(1,cnt,xx[i])); } } return 0; } void change(int p,int x,int y) { for (;p\u0026lt;=n;p+=(p\u0026amp;-p)) BIT[p]=modify(BIT[p],1,cnt,x,y); } int modify(int x,int l,int r,int p,int type) { int u=++tot; t[u]=t[x]; t[u].val+=type; if (l==r-1) return u; int mid=l+r\u0026gt;\u0026gt;1; if (p\u0026lt;mid) t[u].ls=modify(t[u].ls,l,mid,p,type); else t[u].rs=modify(t[u].rs,mid,r,p,type); return u; } int query(int l,int r,int k) { if (l==r-1) return lsh[l]; int i,sum=0; for (i=1;i\u0026lt;=totx;++i) sum-=t[t[x[i]].ls].val; for (i=1;i\u0026lt;=toty;++i) sum+=t[t[y[i]].ls].val; if (sum\u0026gt;=k) { for (i=1;i\u0026lt;=totx;++i) x[i]=t[x[i]].ls; for (i=1;i\u0026lt;=toty;++i) y[i]=t[y[i]].ls; return query(l,l+r\u0026gt;\u0026gt;1,k); } else { for (i=1;i\u0026lt;=totx;++i) x[i]=t[x[i]].rs; for (i=1;i\u0026lt;=toty;++i) y[i]=t[y[i]].rs; return query(l+r\u0026gt;\u0026gt;1,r,k-sum); } }   【模板】二逼平衡树（树套树） 代码 #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;cctype\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; const int N=50010; const int INF=0x7fffffff; int read() { int out=0; char c; while (!isdigit(c=getchar())); for (;isdigit(c);c=getchar()) out=out*10+c-'0'; return out; } struct Node { int val,ls,rs; } t[N\u0026lt;\u0026lt;8]; int insert(int x,int l,int r,int p,int type); int qsum(int l,int r,int L,int R,int d); int kth(int l,int r,int k); void modify(int p,int x,int y); int n,m,tot,a[N],BIT[N],lsh[N\u0026lt;\u0026lt;1],cnt,op[N],l[N],r[N],k[N],totx,toty,X[20][N],Y[20][N]; int main() { int i,p; n=read(); m=read(); for (i=1;i\u0026lt;=n;++i) a[i]=lsh[++cnt]=read(); for (i=1;i\u0026lt;=m;++i) { op[i]=read(); if (op[i]==3) { l[i]=read(); k[i]=lsh[++cnt]=read(); } else { l[i]=read(); r[i]=read(); k[i]=read(); if (op[i]!=2) lsh[++cnt]=k[i]; } } sort(lsh+1,lsh+cnt+1); cnt=unique(lsh+1,lsh+cnt+1)-lsh; for (i=1;i\u0026lt;=n;++i) { a[i]=lower_bound(lsh+1,lsh+cnt,a[i])-lsh; modify(i,a[i],1); } for (i=1;i\u0026lt;=m;++i) { if (op[i]==3) { k[i]=lower_bound(lsh+1,lsh+cnt,k[i])-lsh; modify(l[i],a[l[i]],-1); modify(l[i],a[l[i]]=k[i],1); } else { totx=toty=0; for (p=l[i]-1;p;p-=(p\u0026amp;-p)) X[0][++totx]=BIT[p]; for (p=r[i];p;p-=(p\u0026amp;-p)) Y[0][++toty]=BIT[p]; if (op[i]==2) printf(\u0026quot;%d\\n\u0026quot;,kth(1,cnt,k[i])); else { k[i]=lower_bound(lsh+1,lsh+cnt,k[i])-lsh; if (op[i]==1) printf(\u0026quot;%d\\n\u0026quot;,qsum(1,cnt,1,k[i],0)+1); else if (op[i]==4) { int rk=qsum(1,cnt,1,k[i],0); if (rk) printf(\u0026quot;%d\\n\u0026quot;,kth(1,cnt,rk)); else printf(\u0026quot;%d\\n\u0026quot;,-INF); } else { int rk=qsum(1,cnt,1,k[i]+1,0); if (rk\u0026lt;=r[i]-l[i]) printf(\u0026quot;%d\\n\u0026quot;,kth(1,cnt,rk+1)); else printf(\u0026quot;%d\\n\u0026quot;,INF); } } } } return 0; } void modify(int p,int x,int y) { for (;p\u0026lt;=n;p+=(p\u0026amp;-p)) BIT[p]=insert(BIT[p],1,cnt,x,y); } int insert(int x,int l,int r,int p,int type) { int u=++tot; t[u]=t[x]; t[u].val+=type; if (l==r-1) return u; int mid=l+r\u0026gt;\u0026gt;1; if (p\u0026lt;mid) t[u].ls=insert(t[u].ls,l,mid,p,type); else t[u].rs=insert(t[u].rs,mid,r,p,type); return u; } int qsum(int l,int r,int L,int R,int d) { if (l\u0026gt;=R||r\u0026lt;=L) return 0; int i,sum=0; if (L\u0026lt;=l\u0026amp;\u0026amp;R\u0026gt;=r) { for (i=1;i\u0026lt;=totx;++i) sum-=t[X[d][i]].val; for (i=1;i\u0026lt;=toty;++i) sum+=t[Y[d][i]].val; return sum; } for (i=1;i\u0026lt;=totx;++i) X[d+1][i]=t[X[d][i]].ls; for (i=1;i\u0026lt;=toty;++i) Y[d+1][i]=t[Y[d][i]].ls; sum=qsum(l,l+r\u0026gt;\u0026gt;1,L,R,d+1); for (i=1;i\u0026lt;=totx;++i) X[d+1][i]=t[X[d][i]].rs; for (i=1;i\u0026lt;=toty;++i) Y[d+1][i]=t[Y[d][i]].rs; return sum+qsum(l+r\u0026gt;\u0026gt;1,r,L,R,d+1); } int kth(int l,int r,int k) { if (l==r-1) return lsh[l]; int i,sum=0; for (i=1;i\u0026lt;=totx;++i) sum-=t[t[X[0][i]].ls].val; for (i=1;i\u0026lt;=toty;++i) sum+=t[t[Y[0][i]].ls].val; if (sum\u0026gt;=k) { for (i=1;i\u0026lt;=totx;++i) X[0][i]=t[X[0][i]].ls; for (i=1;i\u0026lt;=toty;++i) Y[0][i]=t[Y[0][i]].ls; return kth(l,l+r\u0026gt;\u0026gt;1,k); } for (i=1;i\u0026lt;=totx;++i) X[0][i]=t[X[0][i]].rs; for (i=1;i\u0026lt;=toty;++i) Y[0][i]=t[Y[0][i]].rs; return kth(l+r\u0026gt;\u0026gt;1,r,k-sum); }   [CQOI2011]动态逆序对 这题用树套树做有点卡空间..需要把带返回值的动态开点改成直接修改。\n代码 #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;cctype\u0026gt; #include \u0026lt;cstring\u0026gt; using namespace std; int read() { int out=0; char c; while (!isdigit(c=getchar())); for (;isdigit(c);c=getchar()) out=out*10+c-'0'; return out; } const int N=100010; struct Node { int val,ls,rs; } t[N*90]; void change(int\u0026amp; u,int l,int r,int p); int query(int l,int r,int L,int R,int d); int n,m,a[N],p[N],del[N],BIT[N],x[20][20],y[20][20],xtot,ytot,tot; bool deleted[N]; long long ans,out[N]; int main() { int i,j; n=read(); m=read(); for (i=1;i\u0026lt;=n;++i) { a[i]=read(); p[a[i]]=i; } for (i=1;i\u0026lt;=m;++i) { del[i]=p[read()]; deleted[del[i]]=true; } for (i=n;i\u0026gt;=1;--i) { if (!deleted[i]) { for (j=a[i];j;j-=(j\u0026amp;-j)) ans+=BIT[j]; for (j=a[i];j\u0026lt;=n;j+=(j\u0026amp;-j)) ++BIT[j]; } } memset(BIT,0,sizeof(BIT)); for (i=1;i\u0026lt;=n;++i) { if (!deleted[i]) { for (j=i;j\u0026lt;=n;j+=(j\u0026amp;-j)) { change(BIT[j],1,n+1,a[i]); } } } for (i=m;i\u0026gt;=1;--i) { xtot=ytot=0; for (j=del[i];j;j-=(j\u0026amp;-j)) y[0][++ytot]=BIT[j]; ans+=query(1,n+1,a[del[i]]+1,n+1,0); xtot=ytot=0; for (j=del[i];j;j-=(j\u0026amp;-j)) x[0][++xtot]=BIT[j]; for (j=n;j;j-=(j\u0026amp;-j)) y[0][++ytot]=BIT[j]; ans+=query(1,n+1,1,a[del[i]],0); for (j=del[i];j\u0026lt;=n;j+=(j\u0026amp;-j)) change(BIT[j],1,n+1,a[del[i]]); out[i]=ans; } for (i=1;i\u0026lt;=m;++i) printf(\u0026quot;%lld\\n\u0026quot;,out[i]); return 0; } void change(int\u0026amp; u,int l,int r,int p) { if (!u) u=++tot; ++t[u].val; if (l==r-1) return; int mid=l+r\u0026gt;\u0026gt;1; if (p\u0026lt;mid) change(t[u].ls,l,mid,p); else change(t[u].rs,mid,r,p); } int query(int l,int r,int L,int R,int d) { if (l\u0026gt;=R||r\u0026lt;=L) return 0; int i,ret=0,mid=l+r\u0026gt;\u0026gt;1; if (L\u0026lt;=l\u0026amp;\u0026amp;R\u0026gt;=r) { for (i=1;i\u0026lt;=xtot;++i) ret-=t[x[d][i]].val; for (i=1;i\u0026lt;=ytot;++i) ret+=t[y[d][i]].val; return ret; } for (i=1;i\u0026lt;=xtot;++i) x[d+1][i]=t[x[d][i]].ls; for (i=1;i\u0026lt;=ytot;++i) y[d+1][i]=t[y[d][i]].ls; ret+=query(l,mid,L,R,d+1); for (i=1;i\u0026lt;=xtot;++i) x[d+1][i]=t[x[d][i]].rs; for (i=1;i\u0026lt;=ytot;++i) y[d+1][i]=t[y[d][i]].rs; ret+=query(mid,r,L,R,d+1); return ret; }  ","date":"2019-03-26T21:38:45+08:00","permalink":"https://ouuan.github.io/post/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%E4%BB%8E%E8%83%8C%E6%A8%A1%E6%9D%BF%E5%88%B0%E6%A0%91%E5%A5%97%E6%A0%91/","tags":["数据结构","树状数组","树套树"],"title":"树状数组——从背模板到树套树"},{"categories":["知识点"],"contents":"cdq分治也是咕了好久了..最近总算把它学了。\ncdq分治是一种离线算法，可以代替一些复杂的数据结构，降低代码难度，减小常数。废话大家都知道。\n本文未完待续（cdq分治的其它应用，如维护凸壳，待填坑）。\n简介 感觉cdq分治不如叫“ex归并排序”，就是以操作的时间作为初始顺序，在递归处理的过程中按位置归并排序。\n更一般地说，对于一个二维偏序 $P(i,j)=P_1(a_i,a_j)\\land P_2(b_i,b_j)​$，位置 $i​$ 的修改对位置 $j​$ 的询问（询问为类前缀和形式，区间询问需拆成两个前缀询问）有影响当且仅当 $P(i,j)=true​$，cdq分治就是以其中一维为初始顺序，对另一维进行归并排序的过程中计算左区间里修改的总和，将左区间修改的影响应用到右区间。\n学会了之后就会发现，cdq分治的确就是这样，已经描述的很清楚了，然而在没学会的时候估计是看不懂上面这段话的..所以结合具体题目来看一看吧。\n例题 【模板】树状数组 1 树状数组裸题！冷静，我们来用ex归并排序做..（嗯，我决定就这么叫它了）\n按照我们上面说的，我们把操作存下来，询问拆成两个前缀和相减，初始值视作修改，需要存的信息有操作的种类（修改、询问的左端点减一、询问的右端点），操作的位置（$p$、$l-1$、$r$）以及修改加上的值/询问的编号。如果写法正常的话你已经以操作的时间作为初始顺序了..\n然后，写个归并排序，按操作的位置排序，同一个位置的修改要放在询问的前面。然后，在归并排序的过程中，遇到左区间里的修改就更新左区间修改的总和，遇到右区间里的询问就用记录的“左区间修改的总和”更新这个询问的答案。\n具体见代码 #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstdio\u0026gt; using namespace std; typedef long long ll; const int N=500010; struct Node { int type,p,val; //type为2表示修改，type为-1表示左端点减一，type为1表示右端点 bool operator\u0026lt;(const Node\u0026amp; b) const { return p==b.p?type\u0026gt;b.type:p\u0026lt;b.p; } } q[N\u0026lt;\u0026lt;2],tmp[N\u0026lt;\u0026lt;2]; void solve(int l,int r); int n,m,tot,qtot; ll ans[N]; int main() { int i,op,x,y; scanf(\u0026quot;%d%d\u0026quot;,\u0026amp;n,\u0026amp;m); for (i=1;i\u0026lt;=n;++i) //初始值视作修改 { scanf(\u0026quot;%d\u0026quot;,\u0026amp;x); q[++tot].type=2; q[tot].p=i; q[tot].val=x; } for (i=1;i\u0026lt;=m;++i) { scanf(\u0026quot;%d%d%d\u0026quot;,\u0026amp;op,\u0026amp;x,\u0026amp;y); if (op==1) { q[++tot].type=2; q[tot].p=x; q[tot].val=y; } else //询问拆成两个前缀和相减 { q[++tot].type=-1; q[tot].p=x-1; q[tot].val=++qtot; q[++tot].type=1; q[tot].p=y; q[tot].val=qtot; } } solve(1,tot+1); for (i=1;i\u0026lt;=qtot;++i) printf(\u0026quot;%lld\\n\u0026quot;,ans[i]); return 0; } void solve(int l,int r) { if (l==r-1) return; int i,j,k,mid; ll sum=0; i=k=l; j=mid=(l+r)\u0026gt;\u0026gt;1; solve(l,mid); solve(mid,r); while (i\u0026lt;mid\u0026amp;\u0026amp;j\u0026lt;r) { if (q[i]\u0026lt;q[j]) { if (q[i].type==2) sum+=q[i].val; //记录左区间里的修改之和 tmp[k++]=q[i++]; } else { if (q[j].type!=2) ans[q[j].val]+=q[j].type*sum; //将左区间里的修改应用到右区间里的询问 tmp[k++]=q[j++]; } } while (i\u0026lt;mid) tmp[k++]=q[i++]; while (j\u0026lt;r) { if (q[j].type!=2) ans[q[j].val]+=q[j].type*sum; tmp[k++]=q[j++]; } for (i=l;i\u0026lt;r;++i) q[i]=tmp[i]; }   之前说过ex归并排序本质上是一个二维偏序限制了修改对询问的影响，所以也可以先按位置排序再按时间排序。只不过..这样写很奇怪，很麻烦，常数又大。然而为了理解ex归并排序的本质，我还是写了份这个做法..\n一种奇怪的写法 #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; typedef long long ll; const int N=500010; struct Node { int type,tim,p,val; Node(int _type=0,int _tim=0,int _p=0,int _val=0):type(_type),tim(_tim),p(_p),val(_val){} } q[N\u0026lt;\u0026lt;2],tmp[N\u0026lt;\u0026lt;2]; void solve(int l,int r); int n,m,tot,qtot; ll ans[N]; int main() { int i,j,op,x,y; scanf(\u0026quot;%d%d\u0026quot;,\u0026amp;n,\u0026amp;m); for (i=1;i\u0026lt;=n;++i) { scanf(\u0026quot;%d\u0026quot;,\u0026amp;x); q[++tot]=Node(2,0,i,x); } for (i=1;i\u0026lt;=m;++i) { scanf(\u0026quot;%d%d%d\u0026quot;,\u0026amp;op,\u0026amp;x,\u0026amp;y); if (op==1) q[++tot]=Node(2,i,x,y); else { q[++tot]=Node(-1,i,x-1,++qtot); q[++tot]=Node(1,i,y,qtot); } } sort(q+1,q+tot+1,[](const Node\u0026amp; x,const Node\u0026amp; y){return x.p==y.p?x.type\u0026gt;y.type:x.p\u0026lt;y.p;}); solve(1,tot+1); for (i=1;i\u0026lt;=qtot;++i) printf(\u0026quot;%lld\\n\u0026quot;,ans[i]); return 0; } void solve(int l,int r) { if (l==r-1) return; int i,j,k,mid; ll sum=0; i=k=l; j=mid=(l+r)\u0026gt;\u0026gt;1; solve(l,mid); solve(mid,r); while (i\u0026lt;mid\u0026amp;\u0026amp;j\u0026lt;r) { if (q[i].tim\u0026lt;q[j].tim) { if (q[i].type==2) sum+=q[i].val; tmp[k++]=q[i++]; } else { if (q[j].type!=2) ans[q[j].val]+=q[j].type*sum; tmp[k++]=q[j++]; } } while (i\u0026lt;mid) tmp[k++]=q[i++]; while (j\u0026lt;r) { if (q[j].type!=2) ans[q[j].val]+=q[j].type*sum; tmp[k++]=q[j++]; } for (i=l;i\u0026lt;r;++i) q[i]=tmp[i]; }   【模板】三维偏序（陌上花开） 有两种做法，一种是cdq分治套树状数组，需要注意的有两点，一是清空树状数组可以用时间戳，二是 $a$, $b$, $c$ 都相等的元素要合并。\n参考代码 #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; const int N=100010; const int K=200010; struct Node { int a,b,c,w,f; } a[N],b[N]; void solve(int l,int r); void add(int p,int x); int query(int p); int n,k,d[N],BIT[K],vis[K],tim,tot; int main() { int i; scanf(\u0026quot;%d%d\u0026quot;,\u0026amp;n,\u0026amp;k); for (i=1;i\u0026lt;=n;++i) { scanf(\u0026quot;%d%d%d\u0026quot;,\u0026amp;b[i].a,\u0026amp;b[i].b,\u0026amp;b[i].c); b[i].w=1; } sort(b+1,b+n+1,[](const Node\u0026amp; x,const Node\u0026amp; y){return x.a==y.a?(x.b==y.b?x.c\u0026lt;y.c:x.b\u0026lt;y.b):x.a\u0026lt;y.a;}); for (i=1;i\u0026lt;=n;++i) { if (b[i].a!=b[i+1].a||b[i].b!=b[i+1].b||b[i].c!=b[i+1].c) a[++tot]=b[i]; else b[i+1].w+=b[i].w; } solve(1,tot+1); for (i=1;i\u0026lt;=tot;++i) d[a[i].f+a[i].w]+=a[i].w; for (i=1;i\u0026lt;=n;++i) printf(\u0026quot;%d\\n\u0026quot;,d[i]); return 0; } void solve(int l,int r) { if (l==r-1) return; int i,j,k,mid; i=k=l; j=mid=(l+r)\u0026gt;\u0026gt;1; solve(l,mid); solve(mid,r); ++tim; while (i\u0026lt;mid\u0026amp;\u0026amp;j\u0026lt;r) { if (a[i].b\u0026lt;=a[j].b) { add(a[i].c,a[i].w); b[k++]=a[i++]; } else { a[j].f+=query(a[j].c); b[k++]=a[j++]; } } while (i\u0026lt;mid) b[k++]=a[i++]; while (j\u0026lt;r) { a[j].f+=query(a[j].c); b[k++]=a[j++]; } for (i=l;i\u0026lt;r;++i) a[i]=b[i]; } void add(int p,int x) { for (;p\u0026lt;=k;p+=(p\u0026amp;-p)) { if (vis[p]!=tim) { BIT[p]=0; vis[p]=tim; } BIT[p]+=x; } } int query(int p) { int out=0; for (;p;p-=(p\u0026amp;-p)) if (vis[p]==tim) out+=BIT[p]; return out; }   还有一种做法是cdq分治套cdq分治：\n参考代码 #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; const int N=100010; struct Node { int a,b,c,d,w,id; } a[N],b[N],c[N]; void solve(int l,int r); void solve2(int l,int r); int n,k,d[N],tot,ans[N]; int main() { int i; scanf(\u0026quot;%d%d\u0026quot;,\u0026amp;n,\u0026amp;k); for (i=1;i\u0026lt;=n;++i) { scanf(\u0026quot;%d%d%d\u0026quot;,\u0026amp;b[i].a,\u0026amp;b[i].b,\u0026amp;b[i].c); b[i].w=1; b[i].id=i; } sort(b+1,b+n+1,[](const Node\u0026amp; x,const Node\u0026amp; y){return x.a==y.a?(x.b==y.b?x.c\u0026lt;y.c:x.b\u0026lt;y.b):x.a\u0026lt;y.a;}); for (i=1;i\u0026lt;=n;++i) { if (b[i].a!=b[i+1].a||b[i].b!=b[i+1].b||b[i].c!=b[i+1].c) a[++tot]=b[i]; else b[i+1].w+=b[i].w; } solve(1,tot+1); for (i=1;i\u0026lt;=tot;++i) d[ans[a[i].id]+a[i].w]+=a[i].w; for (i=1;i\u0026lt;=n;++i) printf(\u0026quot;%d\\n\u0026quot;,d[i]); return 0; } void solve(int l,int r) { if (l==r-1) return; int i,j,k,mid; i=k=l; j=mid=(l+r)\u0026gt;\u0026gt;1; solve(l,mid); solve(mid,r); while (i\u0026lt;mid\u0026amp;\u0026amp;j\u0026lt;r) { if (a[i].b\u0026lt;=a[j].b) { a[i].d=a[i].w; b[k++]=a[i++]; } else { a[j].d=0; b[k++]=a[j++]; } } while (i\u0026lt;mid) { a[i].d=a[i].w; b[k++]=a[i++]; } while (j\u0026lt;r) { a[j].d=0; b[k++]=a[j++]; } for (i=l;i\u0026lt;r;++i) a[i]=b[i]; solve2(l,r); } void solve2(int l,int r) { if (l==r-1) return; int i,j,k,mid,sum=0; i=k=l; j=mid=(l+r)\u0026gt;\u0026gt;1; solve2(l,mid); solve2(mid,r); while (i\u0026lt;mid\u0026amp;\u0026amp;j\u0026lt;r) { if (b[i].c\u0026lt;=b[j].c) { sum+=b[i].d; c[k++]=b[i++]; } else { if (!b[j].d) ans[b[j].id]+=sum; c[k++]=b[j++]; } } while (i\u0026lt;mid) c[k++]=b[i++]; while (j\u0026lt;r) { if (!b[j].d) ans[b[j].id]+=sum; c[k++]=b[j++]; } for (i=l;i\u0026lt;r;++i) b[i]=c[i]; }   cdq分治求偏序对的本质 （下文中“偏序问题”即求满足偏序关系的数对个数。而”高维偏序“实际上是多个严格弱序的并。非严格偏序与之类似，主要是在代码上有些细节改变。）\n大家知道，二维偏序可以先按一维排序后用普通的归并排序解决，那为什么“三维偏序”不可以呢？\n首先，按其中一维排序相当于降了一维，问题就变成了“为什么一维偏序可以用普通的归并排序解决，而二维偏序不可以”。\n原因就在于，两个偏序关系的并，不一定具有不可比性的传递性。（Strict Weak Ordering 相关内容参见我的另一篇博客）\n可以证明，两个严格弱序的并一定是一个严格偏序，但不一定是一个严格弱序。而 cdq 分治可以将多个严格弱序的并进行降维，每一次 cdq 分治都标记出哪些位置会对其它位置有贡献，并按某一维排序。\n上面说的有点乱..简单概括一下。排序可以降维，只有严格弱序能排序，高维偏序不一定是严格弱序，cdq 分治在排序的过程中标记了元素之间如何贡献答案。所以 cdq 分治就可以解决高维偏序问题了..\n所以，我们可以写出一份 cdq 分治求 $k$ 维偏序对的代码：\n题意简述：第一行 $n$, $k$，后 $n$ 行每行 $k$ 个数 $a_{i,1..k}$，对每个 $i$ 求 $\\forall d\\in[1,k],a_{i,d}\u0026lt;a_{j,d}$ 的 $j$ 个数。\n当然，$n$ 要足够大，否则会被暴力艹。只不过理论上来说，如果维数是常数，复杂度就比暴力更优\u0026hellip;\n随便造的一个模板题\n代码 #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; const int N=10005; const int K=15; void solve(int l,int r,int d); int n,k,ans[N]; struct Node { int w[K],type,id; bool operator\u0026lt;(const Node\u0026amp; y) const { if (w[0]!=y.w[0]) return w[0]\u0026lt;y.w[0]; for (int i=1;i\u0026lt;k;++i) if (w[i]!=y.w[i]) return w[i]\u0026gt;y.w[i]; //如果是非严格偏序都应该顺着排，严格偏序除了第一维都应该倒着排。这是由于相等元素可以/不可以转移。 return false; } } a[K][N],tmp[N]; int main() { int i,j; scanf(\u0026quot;%d%d\u0026quot;,\u0026amp;n,\u0026amp;k); for (i=1;i\u0026lt;=n;++i) { a[0][i].id=i; for (j=0;j\u0026lt;k;++j) scanf(\u0026quot;%d\u0026quot;,a[0][i].w+j); } sort(a[0]+1,a[0]+n+1); solve(1,n+1,1); for (i=1;i\u0026lt;=n;++i) printf(\u0026quot;%d\\n\u0026quot;,ans[i]); return 0; } void solve(int l,int r,int d) { if (l==r-1) return; int i,j,p,mid,sum=0; i=p=l; j=mid=(l+r)\u0026gt;\u0026gt;1; solve(l,mid,d); solve(mid,r,d); while (i\u0026lt;mid\u0026amp;\u0026amp;j\u0026lt;r) { if (a[d-1][i].w[d]\u0026lt;a[d-1][j].w[d]) { a[d][p]=tmp[p]=a[d-1][i++]; if (d\u0026gt;1\u0026amp;\u0026amp;a[d][p].type!=1) a[d][p].type=0; else { a[d][p].type=1; if (d==k-1) ++sum; } ++p; } else { a[d][p]=tmp[p]=a[d-1][j++]; if (d\u0026gt;1\u0026amp;\u0026amp;a[d][p].type!=2) a[d][p].type=0; else { a[d][p].type=2; if (d==k-1) ans[a[d][p].id]+=sum; } ++p; } } while (i\u0026lt;mid) { a[d][p]=tmp[p]=a[d-1][i++]; if (d\u0026gt;1\u0026amp;\u0026amp;a[d][p].type!=1) a[d][p].type=0; else a[d][p].type=1; ++p; } while (j\u0026lt;r) { a[d][p]=tmp[p]=a[d-1][j++]; if (d\u0026gt;1\u0026amp;\u0026amp;a[d][p].type!=2) a[d][p].type=0; else { a[d][p].type=2; if (d==k-1) ans[a[d][p].id]+=sum; } ++p; } for (i=l;i\u0026lt;r;++i) a[d-1][i]=tmp[i]; if (d\u0026lt;k-1) solve(l,r,d+1); }  ","date":"2019-03-26T18:49:44+08:00","permalink":"https://ouuan.github.io/post/cdq%E5%88%86%E6%B2%BB%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","tags":["离线算法","cdq分治","分治"],"title":"cdq分治学习笔记"},{"categories":["题解"],"contents":"题目链接 洛谷\ndarkbzoj\n题意简述 带通配符的单模式串、单文本串匹配。\n字符串长度 $3\\times10^5$。\n简要做法 这题是利用字符串的距离函数来匹配字符串，使用 FFT 优化距离函数的计算。\n将通配符的值设为零，定义 $dis(s,t)=\\sum(s[i]-t[i])^2s[i]t[i]​$，那么两个等长的字符串匹配当且仅当它们的距离为零。\n为了方便卷积，将题目中的 $A$ 串翻转​得到串 $A'​$。\n推一波式子：\n$$\\begin{aligned}\u0026amp;dis(A,B[i..i+m-1])\\\\=\u0026amp;\\sum\\limits_{j=0}^{m-1}(A\u0026rsquo;[m-j-1]-B[i+j])^2A\u0026rsquo;[m-j-1]B[i+j]\\\\=\u0026amp;\\left(\\sum\\limits_{j=0}^{m-1}A\u0026rsquo;[m-j-1]B^3[i+j]\\right)-2\\left(\\sum\\limits_{j=0}^{m-1}(A\u0026rsquo;)^2[m-j-1]B^2[i+j]\\right)+\\left(\\sum\\limits_{j=0}^{m-1}(A\u0026rsquo;)^3[m-j-1]B[i+j]\\right)\\end{aligned}$$\n设 $f(i)=\\sum\\limits_{j=0}^{i}A\u0026rsquo;[i-j]B^3[j]​$（即它们的卷积），将 $A\u0026rsquo;[m..n-1]​$ 设为 $0​$，那么 $\\sum\\limits_{j=0}^{m-1}A\u0026rsquo;[m-j-1]B^3[i+j]=f(i+m-1)​$。\n可以类似地计算另外两项，就可以求出所有 $dis(A,B[i..i+m-1])​$，看看哪些等于零就好了。\n参考代码 #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;cmath\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; const int N=1\u0026lt;\u0026lt;19; const double PI=acos(-1); struct cp { double re,im; cp(double _re=0.0,double _im=0.0) { re=_re; im=_im; } cp operator+(const cp\u0026amp; b) const { return cp(re+b.re,im+b.im); } cp operator-(const cp\u0026amp; b) const { return cp(re-b.re,im-b.im); } cp operator*(const cp\u0026amp; b) const { return cp(re*b.re-im*b.im,re*b.im+im*b.re); } } a[N],a2[N],a3[N],b[N],b2[N],b3[N],c1[N],c2[N],c3[N]; void fft(cp* A,int type); int n,m,lim,L,r[N]; char s[N],t[N]; vector\u0026lt;int\u0026gt; ans; int main() { int i; scanf(\u0026quot;%d%d%s%s\u0026quot;,\u0026amp;m,\u0026amp;n,s,t); for (i=0;i\u0026lt;n;++i) { if (m-i\u0026gt;0\u0026amp;\u0026amp;s[m-i-1]!='*') { a[i].re=s[m-i-1]-'a'+1; a2[i].re=a[i].re*a[i].re; a3[i].re=a[i].re*a2[i].re; } if (t[i]!='*') { b[i].re=t[i]-'a'+1; b2[i].re=b[i].re*b[i].re; b3[i].re=b[i].re*b2[i].re; } } for (lim=0,L=1;L\u0026lt;=n;++lim,L\u0026lt;\u0026lt;=1); for (i=1;i\u0026lt;L;++i) r[i]=(r[i\u0026gt;\u0026gt;1]\u0026gt;\u0026gt;1)|((i\u0026amp;1)\u0026lt;\u0026lt;(lim-1)); fft(a,1); fft(a2,1); fft(a3,1); fft(b,1); fft(b2,1); fft(b3,1); for (i=0;i\u0026lt;L;++i) { c1[i]=a[i]*b3[i]; c2[i]=a2[i]*b2[i]; c3[i]=a3[i]*b[i]; } fft(c1,-1); fft(c2,-1); fft(c3,-1); for (i=m-1;i\u0026lt;n;++i) { if (c1[i].re-2*c2[i].re+c3[i].re\u0026lt;0.5) { ans.push_back(i-m+2); } } printf(\u0026quot;%d\\n\u0026quot;,int(ans.size())); for (i=0;i\u0026lt;ans.size();++i) printf(\u0026quot;%d \u0026quot;,ans[i]); return 0; } void fft(cp* A,int type) { int i,j,k; for (i=1;i\u0026lt;L;++i) if (i\u0026lt;r[i]) swap(A[i],A[r[i]]); for (i=1;i\u0026lt;L;i\u0026lt;\u0026lt;=1) { cp w1(cos(PI/i),type*sin(PI/i)); for (j=0;j\u0026lt;L;j+=2*i) { cp w(1,0); for (k=j;k\u0026lt;i+j;++k,w=w*w1) { cp t=A[k+i]*w; A[k+i]=A[k]-t; A[k]=A[k]+t; } } } if (type==-1) for (i=0;i\u0026lt;L;++i) A[i].re=A[i].re/L; } ","date":"2019-03-19T16:27:51+08:00","permalink":"https://ouuan.github.io/post/bzoj4259-%E6%AE%8B%E7%BC%BA%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2fft/","tags":["字符串","FFT"],"title":"BZOJ4259 残缺的字符串（FFT）"},{"categories":["游记"],"contents":"时隔半年又来到了YALI。\nDay 0 中午放学，下午就坐火车走了。\n晚上被骗去吃火宫殿..\n然后做了一个 slide.\nDay 1 T1是个字符串，一开始以为可以 $50$，先把 $30$ 写了然后去看后两题，回来发现那 $20$ 没法写..最后因为数组名 $end$ CE了..\nT2还是个字符串，只不过是在图上，是道大象题，求期望，要高斯消元，利用非 $0​$ 项很少来降低复杂度。一开始先把不用求期望（每个点出度为 $1​$）的 $20​$ 分写了，然后就去看 $T3​$。后来回头发现 $T1​$ 的 $20​$ 写不出来，就来写这题的 $10​$ 分暴力高斯消元，然后调了 $1h​$，一开始先是概率各种算错，后来其它的都写对了，结果我脑抽写成了字符串失配跳到 $0​$ \u0026hellip;\nT3是zzq最爱的提答，又是给一种计算机。随便玩了 $47​$ 分。下午讲题的时候有几位神仙在那快乐地碾了碾标算..\n做题的时候先是看到 ctr zzq，然后往右一看，发现 zzq 就在黑板前的电脑前坐着..之前就听说 _rqy 也要来，做题做到一半的时候看到 _rqy 去找 zzq 报告了两个 bug..\n之前就有猜测过：\n然后..下午果然是神仙聊天场，_rqy 现场推多项式三角函数..\n晚上没去机房..游记就是晚上写的qaq\nDay 2 今天有三种类型的题目，性价比高。\nT1 是道图论交互，只会暴力 $20$..\nT2 是道图论传统题，一开始以为直接欧拉回路就是正解，然后随便一拍就挂了..后来得知欧拉回路是正解的一部分。\nT3 是道扫雷提答，暴力跑了 $4​$ 个点，构造了两个点，下午的时候手玩了一个点..是除了周围雷数还有行/列之和，行/列连续段个数之类的那种。\n下午讲题的时候竟然有人讲美樱的颜料..个人认为那题出的不是很好..尤其是Sooke为卡loglogn设的空间限制..\nDay 3 今天是讲题..感觉全场可能就我不会生成函数，只不过感觉好像大概弄明白了。\n晚上把讲题咕咕了，结果不小心错过了 _rqy 的难题选讲..\nDay 4 T1 是个数据结构，看了看觉得有 $41$ 分非常可做，先写了个暴力去肝后面两题，最后回来写这题，很快写完了 $30$ 分，然后把 $30$ 分备份了一下去写剩下的 $11$ 分，写的过程中发现 $30$ 分有个地方挂了，就在 $41$ 分代码里面改过来了，后来剩下 $11$ 分没写完，就把备份（没修改那个地方）的代码交上去了..最后连询问数为 $0$ 的 subtask 都挂了，只有 $22$ 分。\nT2 是道小清新0.5KB找规律题。成功找到规律然后 A 掉了..\nT3 是俄罗斯方块提答..搞了三个点，剩下的随机..获得了 $16$ 分的好成绩。之后 _rqy 说自己写了个模拟器手玩，于是我下午就自己写了个模拟器手玩..草，真的又好写又好玩，$1h$ 十几分绝对没问题..\nDay 5 今天大众分 $200$..窝愉快垫底了。\nT1 是个数据结构，定义数列中每个数的后继为它后面比它大的第一个数，区间询问跳到后继最多能跳多少步。暴力 $30$ 分滚粗。\nT2 是个树交互，还比较简单吧..然而 std 做法看起来就很麻烦，所以没仔细听具体是怎么做的。\nT3 是道 MO 题，全场只有暴力 $15$ 和爆零..然后我考场上愉快地调了 $2h​$ 暴力，RETLEWA……最后还是没调出来。\nDay 6 今天又是讲题..晚上轮到我难题讨论，讲了下早就被我讲烂了的皇后游戏\u0026amp;由乃大母神原型与偶像崇拜。\nDay 7 T1 是一个树上的神仙题..把暴力 $68$ 分打满了（$n^2$\u0026amp;链\u0026amp;菊花）。考场上写完菊花之后去看 T2，T3，然后放在那对拍，错了五六次才调对..\nT2 是个神仙博弈论，只写了暴力 $17$ 分..\nT3 是个神仙交互，用随机化搞到了 $66$ 分（期望得分 $67$，脸黑被卡到了 $66.99$），然而没有发现把 subtask3 的代码复制到 subtask4 后面就可以轻松获得 $60%$ subtask5 的分数..\n这场虽然没 A 题，然而好像是我得分最高的一场？\nDay 8 T1指令集RE了..只不过写了数据分治还有暴力分。本地比正解跑的还快qaq..ylh用 $\\mathcal O(n\\sqrt n\\log n)$ 艹过去了 Orz.\nT2暴力。\nT3暴力被卡常了。\n垫底..分最低的一次。\nDay 9 讲课，颓。\nDay 10 T1暴力，ylh的暴力偏序被卡了。\nT2会求答案不会求方案，结果下午才知道大家都会求答案..\nT3暴力，不会类欧自闭了。\nDay 11 和第二天互换了，讲课，继续春眠zzz..\nDay 12 今天 T1 是五子棋互打，想着今天是最后一天，于是就真的写了整场（$3.5h$）的 T1。一开始写了个爆搜，后来发现很蠢，于是就算了个估价函数，然后感觉很对。然而 ctr 乱测..之后我把 ctr 测出来的前 $21$ 名测了一下，和 ctr 测出来的差别还挺大的..只不过我好像在执黑/执白的情况下都打过了其它人写的AI..然而被 ylh（人）击败了..\nT2 题面掉了个关键条件，于是不会做..花 $20min$ 写了 $35$ 分。\nT3 觉得部分分写起来很麻烦，于是最后半个多小时就一直在看自己的 AI 和自己的 AI 下棋..\n总结 要是省选没有非传统题就要凉凉的感觉\u0026hellip;\n","date":"2019-03-17T19:36:39+08:00","permalink":"https://ouuan.github.io/post/2019yali%E7%9C%81%E9%80%89%E9%9B%86%E8%AE%AD%E5%9E%AB%E5%BA%95%E8%AE%B0/","tags":["集训"],"title":"2019YALI省选集训垫底记"},{"categories":["题解"],"contents":"题目链接 洛谷\ndarkbzoj\n题意简述 给你两个长为 $n$ 、无重复元素的数列 $a,b$，求将 $b$ 重排后 $\\left(\\sum\\limits_{i=1}^n[a_i\u0026gt;b_i]\\right)-\\left(\\sum\\limits_{i=1}^n[a_i\u0026lt;b_i]\\right)=k$（$k$ 给定）的方案数。\n$n\\le2000$。\n简要做法 首先，$a$ 大于 $b$ 比 $b$ 大于 $a$ 多 $k$ 对可以转化为 $a$ 大于 $b$ 有 $\\frac{n+k}2$ 对。\n考虑 $dp​$，设 $f(i,j)​$ 为 $a_{1..i}​$ 中选 $j​$ 个数，给这 $j​$ 个数每个数匹配一个小于它的 $b​$ 的方案数。为方便转移，一开始要先对 $a,b​$ 分别从小到大排序，这样的话若 $a_i\u0026gt;b_j​$，必然有 $a_{i+1}\u0026gt;b_j​$。\n设比 $a_i$ 大的 $b$ 有 $cnt_i$ 个，转移方程就是 $f(i,j)=f(i-1,j)+(cnt_i-j+1)\\times f(i-1,j-1)$。$cnt_i$ 可以二分查找/双指针计算。\n考虑这样一个式子：$f(n,i)\\times(n-i)!$，它的意义是，先从 $a$ 中选 $i$ 个数，给它们分别匹配一个小于它们的 $b$，再把剩下的 $n-i$ 个数随意匹配。这个式子并不是某种“方案数”，因为它可能会将相同的匹配方案算重。事实上，对于每种恰有 $j$ 对 $a\u0026gt;b$ 的匹配方案，它在 $f(n,i)\\times(n-i)!$ 中被计算了 $\\binom{j}{i}$ 次。令 $ans_i$ 表示恰好有 $i$ 对 $a$ 大于 $b$ 的方案数，就有 $ans_i=f(n,i)\\times(n-i)!-\\sum\\limits_{j=i+1}^n\\binom{j}{i}ans_j$。这样的话，就可以递推地计算答案。\n这题还有另一种做法，叫二项式反演。我自己没有太理解清楚这种方法，所以不详细阐述。这种做法可以 $O(n)​$ 地计算某个 $ans_i​$，但不影响总复杂度（$dp​$ 还是 $O(n^2)​$ 的）：\n$$ans_i=\\sum\\limits_{j=i}^n(-1)^{j-i}\\binom j i f(n,j)\\times(n-j)​$$\n参考代码 #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; typedef long long ll; const int N=2010; const int mod=1e9+9; int qpow(int x,int y); int n,k,a[N],b[N],f[N][N],ans[N],c[N][N],fac[N]; int main() { int i,j,cnt=0; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;k; if ((n\u0026amp;1)!=(k\u0026amp;1)) { cout\u0026lt;\u0026lt;0; return 0; } k=(n+k)/2; for (i=1;i\u0026lt;=n;++i) scanf(\u0026quot;%d\u0026quot;,a+i); for (i=1;i\u0026lt;=n;++i) scanf(\u0026quot;%d\u0026quot;,b+i); sort(a+1,a+n+1); sort(b+1,b+n+1); fac[0]=1; for (i=1;i\u0026lt;=n;++i) fac[i]=(ll)fac[i-1]*i%mod; c[0][0]=1; for (i=1;i\u0026lt;=n;++i) { c[i][0]=1; for (j=1;j\u0026lt;=i;++j) c[i][j]=(c[i-1][j-1]+c[i-1][j])%mod; } f[0][0]=1; for (i=1;i\u0026lt;=n;++i) { f[i][0]=1; while (cnt\u0026lt;n\u0026amp;\u0026amp;b[cnt+1]\u0026lt;a[i]) ++cnt; for (j=1;j\u0026lt;=cnt;++j) { f[i][j]=(f[i-1][j]+(ll)f[i-1][j-1]*(cnt-j+1))%mod; } } for (i=n;i\u0026gt;=k;--i) { ans[i]=(ll)f[n][i]*fac[n-i]%mod; for (j=n;j\u0026gt;i;--j) ans[i]=(ans[i]+mod-(ll)ans[j]*c[j][i]%mod)%mod; } cout\u0026lt;\u0026lt;ans[k]; return 0; } int qpow(int x,int y) { int out=1; while (y) { if (y\u0026amp;1) out=(ll)out*x%mod; x=(ll)x*x%mod; y\u0026gt;\u0026gt;=1; } return out; } ","date":"2019-03-15T12:48:17+08:00","permalink":"https://ouuan.github.io/post/bzoj3622-%E5%B7%B2%E7%BB%8F%E6%B2%A1%E6%9C%89%E4%BB%80%E4%B9%88%E5%A5%BD%E5%AE%B3%E6%80%95%E7%9A%84%E4%BA%86%E4%BA%8C%E9%A1%B9%E5%BC%8F%E5%8F%8D%E6%BC%94%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/","tags":["组合数学","二项式反演"],"title":"BZOJ3622 已经没有什么好害怕的了（二项式反演，组合数学）"},{"categories":["题解"],"contents":"题目链接 darkbzoj\n题意简述 给你一个数列，求重排后每个位置都变了的方案数。\n数列长度和值域都是 $2000$。\n简要做法 考虑容斥，计 $g(S)​$ 为 $S​$ 这个集合内的所有位置都不变的方案数，$U​$ 为位置的全集（即 $1​$ ~ $n​$），$i​$ 这个数出现了 $cnt[i]​$ 次，答案即为 $\\frac{n!}{\\prod\\limits_{i=1}^ncnt[i]!}+\\sum\\limits_{S\\subseteq U,S\\ne\\varnothing}(-1)^{|S|}g(S)​$。\n计 $P_i$ 为 $i$ 这个数出现的位置集合，那么 $g(S)=\\frac{(n-|S|)!\\prod\\limits_{i=1}^n\\frac{cnt[i]!}{(cnt[i]-|P_i\\bigcap S|)!}}{\\prod\\limits_{i=1}^ncnt[i]!}​$。\n暴力枚举子集肯定是过不了的，考虑如何优化。\n容斥原理的优化一般是将答案相同/结构相似的部分合在一起算，这题中，可以尝试将 $|S|$ 相同的集合合在一起算，问题就在于如何快速计算 $|S|$ 相同的所有 $\\prod\\limits_{i=1}^n\\frac{cnt[i]!}{(cnt[i]-|P_i\\bigcap S|)!}$ 之和。\n这个东西可以用 $dp$ 解决：设 $f(i,j)$ 为从值为 $1$ ~ $i$ 的所有数中选 $j$ 个数的所有不同方案的贡献之和，其中，一种选法的贡献就是将选的数作为 $S$ 的 $\\prod\\limits_{i=1}^n\\frac{cnt[i]!}{(cnt[i]-|P_i\\bigcap S|)!}$。转移时枚举值为 $i$ 的数选了 $k$ 个，那么 $f(i,j)=\\sum\\limits_{k=0}^{\\min(j,cnt[i])}\\frac{cnt[i]!}{(cnt[i]-k)!}\\binom{cnt[i]}kf(i-1,j-k)$. 由于 $cnt[i]$ 之和为 $n$，$dp$ 复杂度是 $O(n^2)$。\n这样的话，最终的答案就是 $\\frac{n!+\\sum\\limits_{i=1}^n(-1)^i(n-i)!f(n,i)}{\\prod\\limits_{i=1}^ncnt[i]!}$，实际上 $f(n,0)=1$，所以也可以化简为 $\\frac{\\sum\\limits_{i=0}^n(-1)^i(n-i)!f(n,i)}{\\prod\\limits_{i=1}^ncnt[i]!}$.\n参考代码 #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstdio\u0026gt; using namespace std; typedef long long ll; const int N=2010; const int mod=1e9+9; int qpow(int x,int y); int n,cnt[N],fac[N],inv[N],f[N][N],c[N][N],ans; int main() { int i,j,k,x; cin\u0026gt;\u0026gt;n; fac[0]=inv[0]=1; for (i=1;i\u0026lt;=n;++i) { cin\u0026gt;\u0026gt;x; ++cnt[x]; fac[i]=(ll)fac[i-1]*i%mod; inv[i]=qpow(fac[i],mod-2); } c[0][0]=1; for (i=1;i\u0026lt;=n;++i) { c[i][0]=1; for (j=1;j\u0026lt;=i;++j) c[i][j]=(c[i-1][j-1]+c[i-1][j])%mod; } f[0][0]=1; for (i=1;i\u0026lt;=n;++i) { for (j=0;j\u0026lt;=n;++j) { for (k=0;k\u0026lt;=cnt[i]\u0026amp;\u0026amp;k\u0026lt;=j;++k) { f[i][j]=(f[i][j]+(ll)fac[cnt[i]]*inv[cnt[i]-k]%mod*f[i-1][j-k]%mod*c[cnt[i]][k])%mod; } } } for (i=0;i\u0026lt;=n;++i) ans=(ans+(ll)(i\u0026amp;1?-1:1)*fac[n-i]*f[n][i]+mod)%mod; for (i=1;i\u0026lt;=n;++i) ans=(ll)ans*inv[cnt[i]]%mod; cout\u0026lt;\u0026lt;ans; return 0; } int qpow(int x,int y) { int out=1; while (y) { if (y\u0026amp;1) out=(ll)out*x%mod; x=(ll)x*x%mod; y\u0026gt;\u0026gt;=1; } return out; } ","date":"2019-03-13T21:10:56+08:00","permalink":"https://ouuan.github.io/post/bzoj4665-%E5%B0%8Fw%E7%9A%84%E5%96%9C%E7%B3%96%E5%AE%B9%E6%96%A5%E5%8E%9F%E7%90%86%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/","tags":["容斥原理","组合数学","计数dp"],"title":"BZOJ4665 小w的喜糖（容斥原理，组合数学）"},{"categories":["题解"],"contents":"题目链接 洛谷\ndarkbzoj\n题意简述 给你一棵树，每个节点有 $h$ 值，一个勇士来到一个节点时如果他的战斗力大于等于 $h$ 就能占领城池并前往这个节点的父亲（除非已经到了根节点），否则阵亡；攻占一个节点后，勇士的战斗力会加/减/乘一个正整数（根据节点而定）；每个勇士有初始战斗力和想占领的第一个节点。问，每个节点各有多少个勇士阵亡，每个勇士各占领了几个节点。\n简要做法 每个节点搞个小根可并堆维护该节点所有勇士（包括一开始就在这的和爬上来的），当堆顶小于 $h$ 时弹出并更新答案，直到堆为空或者堆顶大于等于 $h$，然后再加/减/乘，合并到父亲。\n加/减/乘：更新堆顶并打标记，在所有需要访问儿子的地方（弹出堆顶时/合并时）下传标记。\n合并复杂度：每个勇士初始位置需要合并一次，每个节点合并到父亲要一次，$O((n+m)\\log m)$；弹出复杂度：每个勇士最多被弹出一次，$O(m\\log m)$；修改复杂度：除了下传标记外每次修改都是 $O(1)$ 的，所以是 $O(n)$；总复杂度：$O((n+m)\\log m)$。\n参考代码 #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;cctype\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; typedef long long ll; ll read() { ll out=0; int f=1; char c; for (c=getchar();!isdigit(c)\u0026amp;\u0026amp;c!='-';c=getchar()); if (c=='-') f=-1,c=getchar(); for (;isdigit(c);c=getchar()) out=out*10+c-'0'; return out*f; } const int N=300010; struct Node { int ls,rs,d; ll val,add,mul; Node(){ls=rs=add=0;d=mul=1;} } t[N]; int merge(int x,int y); int pop(int x); void madd(int u,ll x); void mmul(int u,ll x); void pushdown(int x); void add(int u,int v); void dfs(int u); int head[N],nxt[N],to[N],cnt; int n,m,p[N],f[N],a[N],dep[N],c[N],ans1[N],ans2[N]; ll h[N],b[N]; int main() { int i; n=read(); m=read(); for (i=1;i\u0026lt;=n;++i) h[i]=read(); for (i=2;i\u0026lt;=n;++i) { f[i]=read(); add(f[i],i); a[i]=read(); b[i]=read(); } for (i=1;i\u0026lt;=m;++i) { t[i].val=read(); c[i]=read(); p[c[i]]=merge(i,p[c[i]]); } dfs(1); for (i=1;i\u0026lt;=n;++i) printf(\u0026quot;%d\\n\u0026quot;,ans1[i]); for (i=1;i\u0026lt;=m;++i) printf(\u0026quot;%d\\n\u0026quot;,ans2[i]); return 0; } void dfs(int u) { int i,v; for (i=head[u];i;i=nxt[i]) { v=to[i]; dep[v]=dep[u]+1; dfs(v); } while (p[u]\u0026amp;\u0026amp;t[p[u]].val\u0026lt;h[u]) { ++ans1[u]; ans2[p[u]]=dep[c[p[u]]]-dep[u]; p[u]=pop(p[u]); } if (a[u]) mmul(p[u],b[u]); else madd(p[u],b[u]); if (u\u0026gt;1) p[f[u]]=merge(p[u],p[f[u]]); else while (p[u]) { ans2[p[u]]=dep[c[p[u]]]+1; p[u]=pop(p[u]); } } void add(int u,int v) { nxt[++cnt]=head[u]; head[u]=cnt; to[cnt]=v; } int merge(int x,int y) { if (!x||!y) return x|y; if (t[x].val\u0026gt;t[y].val) swap(x,y); pushdown(x); t[x].rs=merge(t[x].rs,y); if (t[t[x].rs].d\u0026gt;t[t[x].ls].d) swap(t[x].ls,t[x].rs); t[x].d=t[t[x].rs].d+1; return x; } int pop(int x) { pushdown(x); return merge(t[x].ls,t[x].rs); } void madd(int u,ll x) { t[u].val+=x; t[u].add+=x; } void mmul(int u,ll x) { t[u].val*=x; t[u].add*=x; t[u].mul*=x; } void pushdown(int x) { mmul(t[x].ls,t[x].mul); madd(t[x].ls,t[x].add); mmul(t[x].rs,t[x].mul); madd(t[x].rs,t[x].add); t[x].add=0; t[x].mul=1; } ","date":"2019-03-12T16:14:15+08:00","permalink":"https://ouuan.github.io/post/bzoj4003-jloi2015-%E5%9F%8E%E6%B1%A0%E6%94%BB%E5%8D%A0%E5%B7%A6%E5%81%8F%E6%A0%91/","tags":["数据结构","左偏树"],"title":"BZOJ4003 [JLOI2015]城池攻占（左偏树）"},{"categories":["题解"],"contents":"题目链接 洛谷\nCF problemset\nCF contest\n题意简述 给你一个字符串 $s$ 和 $n$ 个字符串 $x_{1..n}$，对每个 $x_i$，求有多少个 $s$ 的子串可以由 $x_i$ 旋转得到。\n旋转一个字符串就是把它的一个前缀移到后面，如 abcd 可以旋转得到的字符串有 abcd，bcda，cdab，dabc。\n简要做法 对 $s$ 建 SAM，把 $x_i$ 旋转得到的每个字符串用 SAM 读入，就可以求答案了。（SAM 求子串出现次数是经典问题，可以参考我的博客）\n分开读入每个 $x_i$ 旋转得到的字符串显然会超时，然而，SAM 读入字符串是支持删除首字符的：记录当前读入的长度 $l$ 以及所处状态 $u$，删除字符就把 $l$ 减一，若减一后 $l=len(parent(u))$，则转移到 $parent(u)$（把 $u$ 赋值为 $parent(t)$）。需要注意的是，如果读入一个字符的时候当前状态没有这个字符的出边，就需要在 $parent$ 树上向上跳，直到有这个字符的出边，同时更新 $l$ 。这样的话，删除字符前就要先判断 $l$ 与需要保留的字符串的长度的关系。具体细节可以参考代码及注释。\n所以，先读入 $x_i$ 统计答案，再删去首字符读入 $x_i[0]$ 统计答案，删去首字符读入 $x_i[1]$ 统计答案……就只用读入 $O(len(x_i))​$ 个字符。\n还有一个问题，就是去重。$s$ 的一个子串可能可以和 $x_i$ 不同的旋转匹配。解决这个问题有两个方法，第一个是求出 $x_i​$ 的周期（可以用 kmp 求），第二个方法是在 SAM 上打标记。我用的是打标记的方法，具体细节还是可以参考代码及注释。\n参考代码 #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;cstdio\u0026gt; using namespace std; const int N=1000010; struct Node { int len,par,ch[26],vis,cnt; } sam[N\u0026lt;\u0026lt;1]; void insert(int x); void read(int x); void del(); void calc(); void add(int u,int v); void dfs(int u); char s[N]; int head[N\u0026lt;\u0026lt;1],nxt[N\u0026lt;\u0026lt;1],to[N\u0026lt;\u0026lt;1],cnt; int p,tot,n,m,l,u,tim,ans; int main() { int i; scanf(\u0026quot;%s%d\u0026quot;,s,\u0026amp;n); sam[0].par=-1; for (i=0;s[i];++i) insert(s[i]-'a'); for (i=1;i\u0026lt;=tot;++i) add(sam[i].par,i); dfs(0); for (tim=1;tim\u0026lt;=n;++tim) { scanf(\u0026quot;%s\u0026quot;,s); m=strlen(s); ans=u=l=0; for (i=0;i\u0026lt;m;++i) read(s[i]-'a'); calc(); for (i=0;i\u0026lt;m-1;++i) { read(s[i]-'a'); del(); calc(); } printf(\u0026quot;%d\\n\u0026quot;,ans); } return 0; } void read(int x) //读入一个字符 { while (u\u0026amp;\u0026amp;!sam[u].ch[x]) l=sam[u=sam[u].par].len; //向上跳直至有这个字符的出边 if (sam[u].ch[x]) { ++l; u=sam[u].ch[x]; } } void del() //删除首字符 { if (l\u0026gt;m\u0026amp;\u0026amp;--l==sam[sam[u].par].len) u=sam[u].par; //m表示当前xi的长度，只有l\u0026gt;m的时候才删除 } void calc() //计算当前的答案 { if (l==m\u0026amp;\u0026amp;sam[u].vis\u0026lt;tim) //只有当前读入的串长度恰好为m且当前状态没有打上标记时才统计答案 { ans+=sam[u].cnt; sam[u].vis=tim; //打标记 } } void insert(int x) //向SAM中插入字符，有人把这个函数叫做extend { int np=++tot; sam[np].len=sam[p].len+1; sam[np].cnt=1; while (~p\u0026amp;\u0026amp;!sam[p].ch[x]) { sam[p].ch[x]=np; p=sam[p].par; } if (p==-1) sam[np].par=0; else { int q=sam[p].ch[x]; if (sam[q].len==sam[p].len+1) sam[np].par=q; else { int nq=++tot; sam[nq].len=sam[p].len+1; memcpy(sam[nq].ch,sam[q].ch,sizeof(sam[q].ch)); sam[nq].par=sam[q].par; sam[q].par=sam[np].par=nq; while (~p\u0026amp;\u0026amp;sam[p].ch[x]==q) { sam[p].ch[x]=nq; p=sam[p].par; } } } p=np; } void add(int u,int v) //加边，用于遍历parent树 { nxt[++cnt]=head[u]; head[u]=cnt; to[cnt]=v; } void dfs(int u) //遍历parent树，计算每个状态的出现次数 { int i,v; for (i=head[u];i;i=nxt[i]) { v=to[i]; dfs(v); sam[u].cnt+=sam[v].cnt; } } ","date":"2019-02-27T13:23:19+08:00","permalink":"https://ouuan.github.io/post/cf235c-cyclical-questsam/","tags":["字符串","SAM"],"title":"CF235C Cyclical Quest（SAM）"},{"categories":["知识点"],"contents":"后缀自动机是一种处理字符串问题的有力工具（废话），它的码量不比后缀数组大（实际代码难度不比后缀数组小，但也不难），处理问题时的思维难度往往比后缀数组小，复杂度更优秀。若字符集大小为 $|\\Sigma|$，则：构建时间复杂度 $O(n|\\Sigma|)$，转移时间复杂度 $O(1)$，空间复杂度 $O(n|\\Sigma|)$ 或 构建时间复杂度 $O(n\\log|\\Sigma|)$，转移时间复杂度 $O(\\log|\\Sigma|)$，空间复杂度 $O(n)$。\n确定有限状态自动机（DFA） 一个 确定有限状态自动机（DFA） 由以下五部分构成：\n 字符集（$\\Sigma$），该自动机只能输入这些字符。 状态集合（$Q$）。如果把一个DFA看成一张有向图，那么 DFA 中的状态就相当于图上的顶点。 起始状态（$start$），$start\\in Q$，是一个特殊的状态。起始状态一般用 $s$ 表示，为了避免混淆，本文中使用 $start$。 接受状态集合（$F$），$F\\subseteq Q$，是一堆特殊的状态。 转移函数（$\\delta$），$\\delta$ 是一个接受两个参数返回一个值的函数，其中第一个参数和返回值都是一个状态，第二个参数是字符集中的一个字符。如果把一个DFA看成一张有向图，那么 DFA 中的转移函数就相当于顶点间的边，而每条边上都有一个字符。  DFA 的作用就是识别字符串，一个自动机 $A$，若它能识别（接受）字符串 $S$，那么 $A(S)=True$，否则 $A(S)=False$。\n当一个DFA读入一个字符串时，从初始状态起按照转移函数一个一个字符地转移。如果读入完一个字符串的所有字符后位于一个接受状态，那么我们称这个 DFA 接受 这个字符串，反之我们称这个 DFA 不接受 这个字符串。\n如果一个状态 $v$ 没有字符 $c$ 的转移，那么我们令 $\\delta(v,c)=null$，而 $null$ 只能转移到 $null$，且 $null$ 不属于接受状态集合。无法转移到任何一个接受状态的状态都可以视作 $null$，或者说，$null$ 代指所有无法转移到任何一个接受状态的状态。\n我们扩展定义转移函数 $\\delta$，令其第二个参数可以接收一个字符串：$\\delta(v,s)=\\delta(\\delta(v,s[1]),s[2..|s|])$，这个扩展后的转移函数就可以表示从一个状态起接收一个字符串后转移到的状态。那么，$A(s)=[\\delta(start,s)\\in F]$。\n如，一个接受且仅接受字符串 \u0026ldquo;a\u0026rdquo;, \u0026ldquo;ab\u0026rdquo;, \u0026ldquo;aac\u0026rdquo; 的 DFA：\n后缀自动机（SAM） 定义 一个字符串的 后缀自动机（SAM） 就是一个 接受且仅接受 这个字符串的 所有后缀 的 DFA。\n下文中以 $SAM_s$ 代指字符串 $s$ 的后缀自动机，$\\delta_s$ 代指 $SAM_s$ 的转移函数。若不带下标则表示字符串为母串 $s$（需要构建 SAM 的那个字符串）。\n根据定义，一个字符串 $t$ 是一个字符串 $s$ 的后缀，当且仅当 $SAM_s(t)=True$。\n性质 一个字符串 $t$ 是一个字符串 $s$ 的子串，当且仅当 $\\delta_s(start_s,t)\\neq null$。\n因为，若 $t$ 是 $s$ 的子串，则在 $t$ 之后添加字符可能成为 $s$ 的一个后缀，反之不可能。\n一个朴素的SAM 若我们将一个字符串的所有后缀插入到一个字典树（Trie 树）中，并将每次插入的终止节点标记为接受状态，就可以得到一个状态数为 $O(n^2)$ 的SAM。\n如，串 \u0026ldquo;abaaabaa\u0026rdquo; 的一个 朴素SAM：\n最简SAM 上文中的“朴素SAM”状态数是 $O(n^2)$ 的，而 最简SAM 的状态数和转移数（点数和边数）都是 $O(n)$ 的。\n$right$ 集合 对于一个字符串 $t$，若它在 $s$ 中出现的位置集合为：$\\{[l_1,r_1),[l_2,r_2),\\cdots,[l_n,r_n)\\}$（下标从 $0$ 开始），那么定义 $right(t)$ 为 $\\{r_1,r_2,\\cdots,r_n\\}$。\n如，又是串 \u0026ldquo;abaaabaa\u0026rdquo;，那么 $right(a)=\\{1,3,4,5,7,8\\}$，$right(aa)=\\{4,5,8\\}$，$right(aab)=\\{6\\}$。\n在有的教程中，也称其为 $endpos$ 集合。\n$right$ 集合等价类 $right$ 集合等价类的定义 $right$ 集合相等的字符串组成一个 $right$ 集合等价类。\n如，双是串 \u0026ldquo;abaaabaa\u0026rdquo;，那么 $right$ 集合为 $\\{4,8\\}$ 的字符串有 $\\{abaa,baa\\}$，这两个字符串组成一个 $right$ 集合等价类。\n$right$ 集合等价类与最简SAM 我们定义 $reg(v)$ 表示 从状态 $v$ 开始能识别的字符串的集合。即：$t\\in reg(v)$ 当且仅当 $\\delta(v,t)\\in F$（$F$ 为接受状态集合）。\n如果在 $t$ 的后面补上一个字符串 $s[r_i..n]$（$r_i\\in right(t)$，$n$ 表示 $s$ 的长度），就得到了 $s$ 的一个后缀。所以，若 $right(t_1)=right(t_2)$，那么 $reg(SAM(t_1))=reg(SAM(t_2))=\\{s[r_i..n]|r_i\\in right(t_1)\\}$。\n对于每个状态 $v$，我们只关心 $reg(v)$，所以可以用SAM上的每一个状态去表示一个 $right$ 集合等价类，转移函数也相应地更改为对应的等价类（令 $f(v)$ 表示原状态 $v$ 对应的字符串的 $right$ 集合等价类在最简SAM中对应的状态，那么原来的转移函数 $\\delta(u,c)=v$ 更改为 $\\delta\u0026rsquo;(f(u),c)=f(v)$。可以证明，若 $right(u_1)=right(u_2)$，那么 $right(\\delta(u_1,c))=right(\\delta(u_2,c))$，因为 $right(\\delta(u,c))=\\{r_i|r_i\\in right(u),s[r_i]=c\\}$）。\n这样的SAM是状态数最少的，因为状态的 $reg$ 两两不同。这样的SAM若要和朴素SAM区分，可以叫做 最简SAM。但一般不加说明的SAM都指最简SAM。\n这样的SAM，从起始状态到某个状态可能有多条路径，每条路径都对应一个字符串，那么我们称这个状态 对应 着这些字符串。\n如，叒是串 \u0026ldquo;abaaabaa​\u0026rdquo; 的最简SAM：\n$right$ 集合等价类的性质 对于每个状态 $v$，定义 $max(v)$ 和 $min(v)$ 分别表示 这个状态对应的 最长 和 最短 的字符串。\n那么，$v$ 对应的任意一个字符串都是 $max(v)$ 的后缀，且不是 $min(v)$ 的真后缀。并且，$v$ 包含了所有这样的字符串。\n第一点（$v$ 中的任意一个字符串都是 $max(v)$ 的后缀）可以由 $right$ 集合的定义得到。\n第二点（且不是 $min(v)$ 的真后缀）可以由 $min(v)$ 的定义得到。\n第三点（$v$ 包含了所有这样的字符串）可以由一个引理证明：**对于一个字符串 $t$ ，它的 $right$ 集合是它的任意一个后缀的 $right$ 集合的子集。**这个引理很好证明，进而可以证明这条性质。\n如，叕是串 \u0026ldquo;abaaabaa\u0026rdquo;，$right$ 集合为 $\\{6\\}$ 的串有 $\\{aab,aaab,baaab,abaaab\\}$，若这个 $right$ 集合等价类对应状态 $v$，那么 $max(v)=abaaab$，$min(v)=aab$。\n这条性质说明 \u0026ldquo;aaab\u0026rdquo; 和 \u0026ldquo;baaab\u0026rdquo; 都属于这个 $right$ 集合等价类，且 \u0026ldquo;ab\u0026rdquo; 和 \u0026ldquo;b\u0026rdquo; 不属于这个 $right$ 集合等价类。\n证明第三点所用的引理说明，$right(aaab)\\subseteq right(aab)\\subseteq right(ab)\\subseteq right(b)$，也就是 $\\{6\\}\\subseteq\\{6\\}\\subseteq\\{2,6\\}\\subseteq\\{2,6\\}$ 。\n$parent$ $parent$ 的定义 $parent$ 有两种等价的定义（你也可以把其一视作定义，另一个视作性质）：\n定义一 对于每个状态 $v$（除了起始状态），找到最长的一个字符串 $t$ 所对应的状态，使得 $right(v)\\subsetneq right(t)$（注意是真子集；如果不存在这样的字符串就找起始状态），这样的状态就是 $parent(v)$。\n定义二 对于每个状态 $v$（除了起始状态），$min(v)[1..n-1]$ 对应的状态（$n$ 表示 $min(v)$ 的长度，假定空串对应起始状态）就是 $parent(v)$。\n有的教程中把 $parent$ 叫做后缀连接 $link$。\n$parent$ 的性质 $len(min(v))=len(max(parent(v)))+1$，这个可以由定义二说明。\n$parent$ 树 $parent$ 连接可以构成一棵树。\n由定义一，由 $right$ 集合要么包含要么不相交可以说明。$parent$ 树可以看成 $right$ 集合的包含关系所构成的树。\n由定义一或定义二，由除起始状态外的状态都有且仅有一条出边并且 $parent$ 连接无环（$right$ 集合大小递增/对应字符串长度递减）可以说明。\n如，醊是串 \u0026ldquo;abaaabaa\u0026rdquo;，它的 $parent$ 树：（用 $max(v)$ 代表每个状态）\nSAM上的接受状态就是包含 $r_i=n$（字符串长度）的一些 $right$ 集合等价类，也就是 $parent$ 树上 $\\{n\\}$ 对应的状态及其祖先。因此，可以通过 $parent$ 树确定SAM的接受状态集合。\n最简SAM状态数为线性的证明 每次把 $right$ 集合分成 $k$ 部分需要 $k$ 条边，最坏情况下每次都只分成两部分，总共要分成至多 $n$ 部分，所以状态数不会超过 $2n-1$（分 $n-1$ 次最多 $2n-2$ 条边，也就是 $2n-1$ 个点）。\n最简SAM转移数为线性的证明 考虑SAM的任意一个生成树，那么SAM上的边就会被分成树边和非树边。\n树边最多只有 $2n-2$ 条。\n对于字符串的每个后缀，将其输入到SAM中都会经过一条终点为接受状态的路径，若经过了一条非树边，则称该后缀对应它经过的 第一条 非树边。\n对于每条非树边 $(u,v)$，一定存在一条从起始状态到 $u$ 的不经过任何非树边的路径（因为树上两点间必定有路径），也一定存在一条从 $v$ 到任意一个接受状态的路径（否则 $v=null$），所以，至少有一个后缀对应着这条非树边。\n因此，非树边数量不会超过后缀数量。总的边数就是 $O(n)$ 的。\n最简SAM的线性构造 SAM的线性构造可以在均摊 $O(1)$ 的时间复杂度内向SAM增加一个字符（从 $SAM_{s[0..i-1]}$ 变成 $SAM_{s[0..i]}$）。\n向SAM增加一个字符，就是在所有接受状态后增加一个字符。所以，我们需要考虑上一次插入时的最后一个状态（$last$）以及它在 $parent$ 树上的祖先（也就是所有接受状态）。\n加入一个字符 $x$ 时，我们先创建一个新状态 $np$，这个状态刚插入时代表 $right$ 集合 $\\{i\\}$（$i$ 表示这是插入的第 $i$ 个字符）。\n一个引理：若一个状态有字符 $c$ 的转移，则它在 $parent$ 树上的祖先都有。\n引理的证明：$right(\\delta(v,c))=\\{r_i|r_i\\in right(v),s[r_i]=c\\}$，而 $right(v)\\subsetneq right(parent(v))$。\n因此，找到 $last$ 最深的有出边 $x$ 的祖先 $p$ 后，在其之上的祖先都有出边 $x$。\n对于在其之下的状态，直接向 $np$ 连边即可。\n接下来要分三种情况讨论：\n若不存在 $p$（起始状态都没有出边 $x$），则将 $parent(np)$ 设为初始状态。\n否则，令 $len(v)$ 表示 $max(v)$ 的长度，$q$ 表示 $\\delta(p,x)$。\n若 $len(q)=len(p)+1$，将 $parent(np)$ 设为 $q$ 即可。\n否则，新建状态 $nq$，$len(nq)$ 设为（实际上不是人为设定，它本来就是）$len(p)+1$，将 $q$ 的转移函数复制到 $nq$，然后将 $parent(nq)$ 设为 $parent(q)$，再将 $parent(q)$ 和 $parent(np)$ 都设为 $nq$，最后把 $p$ 及 $p$ 的祖先中所有出边 $x$ 连到 $q$ 的都改为连到 $nq$。实际上，枚举祖先时只要遇到出边 $x$ 不连到 $q$ 的就可以停止枚举了。\n至于为什么这样做..恕我表达能力有限，还请参考陈立杰WC课件第 $35$ 页。\n构建过程的复杂度证明可以参考 OI-Wiki。\n参考代码 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;cstring\u0026gt; const int N=1000010; struct Node { int len,par,ch[26]; } sam[N\u0026lt;\u0026lt;1]; void insert(int x); char s[N]; int p,tot; int main() { int i; scanf(\u0026quot;%s\u0026quot;,s); sam[0].par=-1; for (i=0;s[i];++i) insert(s[i]-'0'); return 0; } void insert(int x) { int np=++tot; sam[np].len=sam[p].len+1; while (~p\u0026amp;\u0026amp;!sam[p].ch[x]) { sam[p].ch[x]=np; p=sam[p].par; } if (p==-1) sam[np].par=0; else { int q=sam[p].ch[x]; if (sam[q].len==sam[p].len+1) sam[np].par=q; else { int nq=++tot; sam[nq].len=sam[p].len+1; memcpy(sam[nq].ch,sam[q].ch,sizeof(sam[q].ch)); sam[nq].par=sam[q].par; sam[q].par=sam[np].par=nq; while (~p\u0026amp;\u0026amp;sam[p].ch[x]==q) { sam[p].ch[x]=nq; p=sam[p].par; } } } p=np; }  SAM的一些应用 一些应用我还没有写过..写过之后可能会补（gu）上（gu）来（gu）。可以参考OI wiki。\n判断子串/后缀 根据SAM的定义和性质，建出文本串的SAM，将模式串分别输入SAM，若转移到 $null$ 则不是子串，否则是；若转移到接受状态则是后缀，否则不是。\n读入字符串时删除首字符 记录一下已读入的字符串长度，若小于等于当前状态的 $parent.len$，就转移到 $parent$。\n例题：CF235C Cyclical Quest\n子串出现次数 一个子串出现次数就是其对应 $right$ 集合的元素个数。\n在创建 $np$ 时，将其 $cnt$ 赋为 $1$，建好SAM后，每个状态的出现次数就是 $parent$ 子树内的 $cnt$ 之和。\n例题：【模板】后缀自动机\n子串第一次出现位置 和子串出现次数差不多，创建 $np$ 时，将 $firstpos(np)$ 设为 $len(np)-1$，复制 $nq$ 时，将 $firstpos(nq)$ 设为 $firstpos(q)$，最后对子树内取 $min$。\n本质不同子串数 每个状态表示 $maxlen-minlen+1$ 个字符串，而 $minlen=len(parent)+1$，所以一个状态表示的字符串数量就是 $len-parent.len$。求和即可。\n例题：[SDOI2016]生成魔咒\n第 $k$ 大子串 预处理每个状态可以转移到多少个不同的子串，然后就可以做了。\n例题：\nSP7258 SUBLEX\n[TJOI2015]弦论\n两串的最长公共子串 对其中一个串建SAM，从起始状态开始，读入另一个字符串，若有转移则转移，将已匹配长度 $+1$，否则跳到 $parent$（这里和 $kmp$ 有点像），并将已匹配长度修改为 $len(parent)$。过程中最大的已匹配长度就是答案。\n例题：SP1811 LCS\n多串的最长公共子串 还是对其中一个串建SAM，以同样的方式依次读入每个字符串，只不过对每个状态要保存当前字符串的最大匹配长度，所有字符串在某个状态的最大匹配长度的最小值就是这一堆字符串在这个状态能匹配的最大长度。如果能在一个状态匹配，一定能在 $parent$ 处匹配，所以要对子树取 $max$，但也不要忘了对 $len$ 取 $min$。\n例题：\nSP1812 LCS2\n[SDOI2008]Sandy的卡片\n任意DFA的压缩 UPD: 这部分内容非常 naive，建议阅读 Wikipedia 或自行搜索易于访问的中文资料，关键词：自动机最小化，Myhill-Nerode 定理。\n我就是要看！ 这部分估计没人感兴趣..OI里没用，也不是证明SAM最小性必需的（最小性的证明我在前文中已经简略说明了：状态的 $reg$ 两两不同）。只不过或许会对理解SAM本质以及发明它的人怎么想到的有些帮助\u0026hellip;\n或许这种方式在很多年前就已经被人提出了..总之这部分内容完全是我自己yy的，我也懒得去查有没有人发明过。\n这部分内容不保证正确性，如果有误欢迎指正。如果有人愿意提供严谨证明（怎么可能有人啊..只不过我这里都懒得严谨证明了，随便口头地说了一下）一定非常感谢。\n“DFA的压缩”的定义\n一个可用于压缩DFA的映射 $f:Q_A\\rightarrow Q_B$ 需要满足以下几个条件：\n $\\forall v\\ne start_A,f(v)\\ne f(start_A)$ $\\forall u\\in F,v\\notin F,f(u)\\ne f(v)$ $\\forall f(u)=f(v),c\\in\\Sigma,f(\\delta_A(u,c))=f(\\delta_A(v,c))$  如：在SAM中，把所有 $right$ 集合相同的状态映射到同一状态就是一个符合条件的映射。\n定义DFA $A$ 在映射 $f$ 下的压缩为 $B$，其中：\n $\\Sigma_B=\\Sigma_A$ $Q_B=f(Q_A)$ $start_B=f(start_A)$ $F_B=f(F_A)$ $\\delta_B(f(v),c)=f(\\delta_A(v,c))$，这一定义依赖于 $f$ 的性质 $3$。  如：用 $right$ 集合等价类这个映射可以将朴素SAM压缩成最简SAM。\n压缩后的自动机与原自动机等价的证明\n我们证明一个比 $A(s)=B(s)$ 更强的命题：$[\\delta_A(v,s)\\in F_A]=[\\delta_B(f(v),s)\\in F_B]$。\n当 $s$ 只有一个字符时，根据 $f$ 满足的性质 $2$ 以及 $B$ 的定义 $4,5$，命题显然成立。\n当 $s$ 不止一个字符时，可以归纳地说明命题成立。\nDFA的最简压缩方法\n这里给出一个将任意DFA压缩至最简的方法：\n由于DFA是一个DAG，它的任意生成子图都必定有出度为 $0$ 的点。每次找到这些点，然后从中选取尽量多的点，使其映射到同一个状态后满足 $f$ 需要满足的三条性质（也就是，同一字符转移到的状态映射到的状态相同，且没有一个是接受状态另一个不是的情况），然后将这些点从图中删去，重复直至所有点都有了映射后的状态（所有点都被删去）。这样得到的映射 $f$ 能够将原DFA压缩至最简。\n压缩至最简的证明\n我们先证明每个状态的 $reg$（定义参见上文，表示从一个状态起能识别的字符串集合）两两不等。我们按照拓扑序归纳地证明。\n没有出边的非接受状态可以视作 $null$，而没有出边的接受状态按上文所述方法必定会被映射至同一状态。所以命题对没有出边的状态成立。\n假设一个状态所有出边的对应状态都已被证明，那么转移函数不同就等价于 $reg$ 不同，所以命题成立。\n接着，我们由 $reg$ 两两不同证明压缩至最简：\n若状态数继续减少，那么必然存在原来 $reg$ 不同的两个状态 $B(s_1)$ 和 $B(s_2)$ 被压缩到了一起，任取一个只在 $reg(B(s_1))$ 或只在 $reg(B(s_2))$ 中的字符串 $t$，原来 $B(s_1+t)\\ne B(s_2+t)$，压缩后却使得 $B\u0026rsquo;(s_1+t)=B\u0026rsquo;(s_2+t)$，不符合要求。\n","date":"2019-02-22T12:31:37+08:00","permalink":"https://ouuan.github.io/post/%E5%90%8E%E7%BC%80%E8%87%AA%E5%8A%A8%E6%9C%BAsam%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","tags":["字符串","SAM"],"title":"后缀自动机（SAM）学习笔记"},{"categories":["题解"],"contents":"题目链接 洛谷\n题意简述 求 出现次数不为 $1$ 的子串的 出现次数 $\\times$ 长度 的最大值。\nSAM 做法 简要做法 一个状态的出现次数可以这么计算：\n插入一个字符时，$np$ 的 $cnt$ 设为 $1$，一个状态的出现次数就是它在 $parent$ 树上的子树的 $cnt$ 之和。\n证明..简要说一下：因为 $np$ 的 $right$ 集合为 $\\{L\\}$ 。\n所以，插入整个字符串后 dfs 一遍 $parent$ 树算一算就好了。\n参考代码 #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; typedef long long ll; const int N=1000010; const int DELTA=26; struct Node { int len,ch[DELTA],par,cnt; Node(){ memset(ch,0,sizeof(ch)); } } sam[N\u0026lt;\u0026lt;1]; void insert(int x); void add(int u,int v); void dfs(int u); char s[N]; int p,tot,head[N\u0026lt;\u0026lt;1],nxt[N\u0026lt;\u0026lt;1],to[N\u0026lt;\u0026lt;1],cnt; ll ans; int main() { int i; scanf(\u0026quot;%s\u0026quot;,s); for (i=0;s[i];++i) insert(s[i]-'a'); for (i=1;i\u0026lt;=tot;++i) add(sam[i].par,i); dfs(0); cout\u0026lt;\u0026lt;ans; return 0; } void insert(int x) { int np=++tot; sam[np].len=sam[p].len+1; sam[np].cnt=1; while (p\u0026amp;\u0026amp;!sam[p].ch[x]) { sam[p].ch[x]=np; p=sam[p].par; } if (sam[p].ch[x]) { int q=sam[p].ch[x]; if (sam[q].len==sam[p].len+1) sam[np].par=q; else { int nq=++tot; sam[nq].len=sam[p].len+1; memcpy(sam[nq].ch,sam[q].ch,sizeof(sam[q].ch)); sam[nq].par=sam[q].par; sam[q].par=sam[np].par=nq; while (sam[p].ch[x]==q) { sam[p].ch[x]=nq; p=sam[p].par; } } } else { sam[p].ch[x]=np; sam[np].par=0; } p=np; } void add(int u,int v) { nxt[++cnt]=head[u]; head[u]=cnt; to[cnt]=v; } void dfs(int u) { int i,v; for (i=head[u];i;i=nxt[i]) { v=to[i]; dfs(v); sam[u].cnt+=sam[v].cnt; } if (sam[u].cnt\u0026gt;1) ans=max(ans,(ll)sam[u].cnt*sam[u].len); }  后缀数组做法 简要做法 一个长度为 $h$ 的子串出现 $k$ 次就是有 $k-1$ 个连续的 $height\\ge h$。单调栈维护即可。\n然而..卡常卡不过去QAQ\n参考代码（最高80分） #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; const int N=1000010; char s[N]; int n,sa[N],rk[N\u0026lt;\u0026lt;1],id[N\u0026lt;\u0026lt;1],px[N],cnt[N],ht[N],l[N],sta[N],top; long long ans; bool cmp(int x,int y,int w){ return id[x]==id[y]\u0026amp;\u0026amp;id[x+w]==id[y+w]; } int main() { int i,w,p,m=300,k; scanf(\u0026quot;%s\u0026quot;,s+1); n=strlen(s+1); for (i=1;i\u0026lt;=n;++i) ++cnt[rk[i]=s[i]]; for (i=1;i\u0026lt;=m;++i) cnt[i]+=cnt[i-1]; for (i=n;i\u0026gt;=1;--i) sa[cnt[rk[i]]--]=i; for (w=1;w\u0026lt;n;w\u0026lt;\u0026lt;=1,m=p) { memset(cnt,0,sizeof(cnt)); for (p=0,i=n;i\u0026gt;n-w;--i) id[++p]=i; for (i=1;i\u0026lt;=n;++i) if (sa[i]\u0026gt;w) id[++p]=sa[i]-w; for (i=1;i\u0026lt;=n;++i) ++cnt[px[i]=rk[id[i]]]; for (i=1;i\u0026lt;=m;++i) cnt[i]+=cnt[i-1]; for (i=n;i\u0026gt;=1;--i) sa[cnt[px[i]]--]=id[i]; swap(id,rk); for (p=0,i=1;i\u0026lt;=n;++i) rk[sa[i]]=cmp(sa[i],sa[i-1],w)?p:++p; } for (i=1,k=0;i\u0026lt;=n;++i) { if (k) --k; while (s[i+k]==s[sa[rk[i]-1]+k]) ++k; ht[rk[i]]=k; } for (i=1;i\u0026lt;=n;++i) { while (top\u0026amp;\u0026amp;ht[sta[top]]\u0026gt;=ht[i]) --top; l[i]=sta[top]; sta[++top]=i; } sta[top=1]=n+1; for (i=n;i\u0026gt;=1;--i) { while (top\u0026amp;\u0026amp;ht[sta[top]]\u0026gt;ht[i]) --top; if (sta[top]-l[i]\u0026gt;1) ans=max(ans,(long long)ht[i]*(sta[top]-l[i])); sta[++top]=i; } cout\u0026lt;\u0026lt;ans; return 0; } ","date":"2019-02-21T15:47:52+08:00","permalink":"https://ouuan.github.io/post/p3804-%E6%A8%A1%E6%9D%BF%E5%90%8E%E7%BC%80%E8%87%AA%E5%8A%A8%E6%9C%BA/","tags":["字符串","SAM","后缀数组"],"title":"P3804 【模板】后缀自动机（SAM/后缀数组）"},{"categories":["题解"],"contents":"题目链接 洛谷\ndark bzoj\n题意简述 给你一个字符串（字符集大小 $10^9$，长度 $10^5$），求每个前缀的本质不同子串数。\n简要做法 如果只求整个串的本质不同子串，由于每个本质不同子串可以与 SAM 上一个状态+串的长度一一对应，所以本质不同子串数就是每个状态的 $maxlen-minlen+1$，也就是 $len-parent.len$。\n$parent$ 不改变时，逐个加入字符并计算即可。\n考虑 $parent$ 改变的情况，四次 $parent$ 改变分别为 $nq-q.parent$，$-(q-q.parent)$，$q-nq$，$np-nq$。总贡献为 $nq-q.parent-q+q.parent+q-nq+np-nq=np-nq$，也是新加入的点的 $len$ 减去 $parent.len$，是一样的。\n由于字符集较大，用 map 存边。\n参考代码 #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;map\u0026gt; #include \u0026lt;cctype\u0026gt; using namespace std; typedef long long ll; int read() { int out=0; char c; while (!isdigit(c=getchar())); for (;isdigit(c);c=getchar()) out=out*10+c-'0'; return out; } const int N=100010; struct Node { int len,par; map\u0026lt;int,int\u0026gt; ch; } sam[N\u0026lt;\u0026lt;1]; void insert(int x); int n,p,tot; ll ans; int main() { int i; n=read(); sam[0].par=-1; for (i=1;i\u0026lt;=n;++i) { insert(read()); printf(\u0026quot;%lld\\n\u0026quot;,ans); } return 0; } void insert(int x) { int np=++tot; sam[np].len=sam[p].len+1; while (~p\u0026amp;\u0026amp;sam[p].ch.find(x)==sam[p].ch.end()) { sam[p].ch[x]=np; p=sam[p].par; } if (p==-1) sam[np].par=0; else { int q=sam[p].ch[x]; if (sam[q].len==sam[p].len+1) sam[np].par=q; else { int nq=++tot; sam[nq].len=sam[p].len+1; sam[nq].ch=sam[q].ch; sam[nq].par=sam[q].par; sam[q].par=sam[np].par=nq; while (~p\u0026amp;\u0026amp;sam[p].ch[x]==q) { sam[p].ch[x]=nq; p=sam[p].par; } } } ans+=sam[np].len-sam[sam[np].par].len; p=np; } ","date":"2019-02-21T14:10:35+08:00","permalink":"https://ouuan.github.io/post/bzoj4516-sdoi2016-%E7%94%9F%E6%88%90%E9%AD%94%E5%92%92sam/","tags":["字符串","SAM"],"title":"BZOJ4516 [SDOI2016]生成魔咒（SAM）"},{"categories":["知识点"],"contents":"后缀数组是一种处理字符串问题的有力工具（废话），本文的主要特点是一步步地由最朴素的后缀数组构建方法逐步优化，而非直接给出最终优化后的代码。\n希望这篇文章能让更多的人看懂后缀数组的代码，学会后缀数组。\n本文已于 pr #1730 优化并合并至 OI Wiki，推荐在 OI Wiki 上阅读。\n模板题链接 洛谷（只用求 $sa$）\nLOJ（只用求 $sa$）\nUOJ（求 $sa$ 和 $height$）\n评测鸭（求 $sa$ 和 $height$）\n两（can）篇（kao）论（zi）文（liao） [1]：[2004]后缀数组 by.徐智磊\n[2]：[2009]后缀数组——处理字符串的有力工具 by.罗穗骞\n这两篇论文还是写的很好的，大家可以看看。\n下文中如果有引用这两篇论文中的内容，将以上标形式标出（$^{[1]}$ $^{[2]}$）。\n关于字符串.. 说到字符串算法，就得先提一些定（fei）义（hua），知道的就可以不看了..\n字符集$^{[1]}$ 一个字符集 $Σ$ 是一个建立了全序关系的集合，也就是说，$Σ$ 中的任意两个不同的元素 $α$ 和 $β$ 都可以比较大小，要么 $α\u0026lt;β$，要么 $β\u0026lt;α$（也就是$α\u0026gt;β$）。字符集 $Σ$ 中的元素称为字符。\n字符串$^{[1]}$ 一个字符串 $S$ 是将 $n$ 个字符顺次排列形成的数组，$n$ 称为 $S$ 的长度，表示为 $len(S)$。$S$ 的第 $i$ 个字符表示为 $S[i]$。\n子串$^{[1]}$ 字符串 $S$ 的子串 $S[i..j]，i≤j$，表示 $S$ 串中从 $i$ 到 $j$ 这一段，也就是顺次排列 $S[i],S[i+1],\\ldots,S[j]$ 形成的字符串。\n后缀 后缀是指从某个位置 $i$ 开始到整个串末尾结束的一个特殊子串。字符串 $S$ 的从 $i$ 开头的后缀表示为 $Suffix(S,i)$，也就是 $Suffix(S,i)=S[i..len(S)]$。$^{[1]}$\n下文中以 \u0026ldquo;后缀 $i$\u0026rdquo; 代指字符串从 $i$ 开头的后缀。$i$ 称作这个后缀的编号。\n字典序 以第 $i$ 个字符作为第 $i$ 关键字进行大小比较，空字符小于字符集内任何字符（即：$a\u0026lt;aa$）。\n后缀数组是什么？ 后缀数组主要是两个数组：$sa$ 和 $rk$。\n其中，$sa[i]$ 表示将所有后缀排序后第 $i$ 小的后缀的编号。$rk[i]$ 表示后缀 $i$ 的排名。\n这两个数组满足性质：$sa[rk[i]]=rk[sa[i]]=i$。\n后缀数组示例：$^{[2]}$\n后缀数组怎么求？ $O(n^2\\log n)$ 做法 我相信这个做法大家还是能自己想到的..用string+sort就可以了。由于比较两个字符串是 $O(n)$ 的，所以排序是 $O(n^2\\log n)$ 的。\n$O(n\\log^2n)$ 做法 这个做法要用到倍增的思想。\n先对每个长度为 $1$ 的子串（即每个字符）进行排序。\n假设我们已经知道了长度为 $w$ 的子串的排名 $rk_w[1..n]$（即，$rk_w[i]$ 表示 $s[i..\\min(i+w-1,n)]$ 在 $\\{s[x..\\min(x+w-1,n)]|x\\in\\mathbb{N}\\bigcap[1,n]\\}$ 中的排名），那么，以 $rk_w[i]$ 为第一关键字， $rk_w[i+w]$ 为第二关键字（若 $i+w\u0026gt;n$ 则令 $rk_w[i+w]$ 为 $-INF$）进行排序，就可以求出 $rk_{2w}[1..n]$。\n倍增排序示意图：$^{[2]}$\n如果用 sort 进行排序，复杂度就是 $O(n\\log^2n)$ 的。\n参考代码 #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; const int N=1000010; char s[N]; int n,w,sa[N],rk[N\u0026lt;\u0026lt;1],oldrk[N]; //为了防止访问rk[i+w]导致数组越界，开两倍数组。当然也可以在访问前判断是否越界，但直接开两倍数组方便一些。 int main() { int i,p; scanf(\u0026quot;%s\u0026quot;,s+1); n=strlen(s+1); for (i=1;i\u0026lt;=n;++i) rk[i]=s[i]; for (w=1;w\u0026lt;n;w\u0026lt;\u0026lt;=1) { for (i=1;i\u0026lt;=n;++i) sa[i]=i; sort(sa+1,sa+n+1,[](int x,int y){return rk[x]==rk[y]?rk[x+w]\u0026lt;rk[y+w]:rk[x]\u0026lt;rk[y];}); //这里用到了lambda表达式 memcpy(oldrk,rk,sizeof(oldrk)); //由于计算rk的时候原来的rk会被覆盖，要先复制一份 for (p=0,i=1;i\u0026lt;=n;++i) rk[sa[i]]=oldrk[sa[i]]==oldrk[sa[i-1]]\u0026amp;\u0026amp;oldrk[sa[i]+w]==oldrk[sa[i-1]+w]?p:++p; //若两个子串相同，它们对应的rk也需要相同，所以要去重 } for (i=1;i\u0026lt;=n;++i) printf(\u0026quot;%d \u0026quot;,sa[i]); return 0; }   $O(n\\log n)$ 做法 在刚刚的 $O(n\\log^2n)$ 做法中，一次排序是 $O(n\\log n)$ 的，如果能 $O(n)$ 排序，就能 $O(n\\log n)$ 计算后缀数组了。\n计数排序 计数排序的核心思想还是比较好理解的，可以先看代码：\n//对a这个数组进行排序，结果存到数组b中（b[i]表示第i名的编号），cnt是一个辅助数组，m是a的值域 for (i=1;i\u0026lt;=n;++i) ++cnt[a[i]]; for (i=1;i\u0026lt;=m;++i) cnt[i]+=cnt[i-1]; for (i=n;i\u0026gt;=1;--i) b[cnt[a[i]]--]=i;  其实就是先数一数小于等于 $a[i]$ 的数有多少个，然后从后往前看每个数的名次。感性理解/手玩一下就能明白这个排序算法了。\n这个算法有两个特点：\n 它是 $O(n+m)$ 的（$m$ 为待排序数据的值域范围）。 它是一个稳定排序，即，相等的数会按原位置（下标）进行排序。  基数排序 值得一提的是很多人经常把计数排序和基数排序搞混..\n基数排序是一个基于稳定排序的多关键字排序算法，复杂度为关键字个数乘上稳定排序的复杂度。而这个稳定排序通常用计数排序实现。\n它的思想是，如果有 $k$ 个关键字，先以第 $k$ 关键字进行一次稳定排序，然后再以第 $k-1$ 关键字进行一次稳定排序，……，最后以第一关键字进行一次稳定排序。可以看出，这样做就完成了以这 $k$ 个关键字的排序。\n具体实现大约是这样的：\n//key[i][j]表示第j个数的第i关键字，b[i]依然表示第i名的编号，m是key的值域，cnt和id都是辅助数组 for (i=1;i\u0026lt;=n;++i) id[i]=i; for (i=k;i\u0026gt;=1;--i) { memset(cnt,0,sizeof(cnt)); for (j=1;j\u0026lt;=n;++j) id[j]=b[j]; for (j=1;j\u0026lt;=n;++j) ++cnt[key[i][id[j]]]; for (j=1;j\u0026lt;=m;++j) cnt[j]+=cnt[j-1]; for (j=n;j\u0026gt;=1;--j) b[cnt[key[i][id[j]]]--]=id[j]; }  将基数排序运用于求后缀数组 如果你学会了基数排序，也会 $O(n\\log^2n)$ 求后缀数组，那你应该可以自己写出一个 $O(n\\log n)$ 求后缀数组的程序了。\n参考代码 #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; const int N=1000010; char s[N]; int n,sa[N],rk[N\u0026lt;\u0026lt;1],oldrk[N\u0026lt;\u0026lt;1],id[N],cnt[N]; int main() { int i,m,p,w; scanf(\u0026quot;%s\u0026quot;,s+1); n=strlen(s+1); m=max(n,300); for (i=1;i\u0026lt;=n;++i) ++cnt[rk[i]=s[i]]; for (i=1;i\u0026lt;=m;++i) cnt[i]+=cnt[i-1]; for (i=n;i\u0026gt;=1;--i) sa[cnt[rk[i]]--]=i; for (w=1;w\u0026lt;n;w\u0026lt;\u0026lt;=1) { memset(cnt,0,sizeof(cnt)); for (i=1;i\u0026lt;=n;++i) id[i]=sa[i]; for (i=1;i\u0026lt;=n;++i) ++cnt[rk[id[i]+w]]; for (i=1;i\u0026lt;=m;++i) cnt[i]+=cnt[i-1]; for (i=n;i\u0026gt;=1;--i) sa[cnt[rk[id[i]+w]]--]=id[i]; memset(cnt,0,sizeof(cnt)); for (i=1;i\u0026lt;=n;++i) id[i]=sa[i]; for (i=1;i\u0026lt;=n;++i) ++cnt[rk[id[i]]]; for (i=1;i\u0026lt;=m;++i) cnt[i]+=cnt[i-1]; for (i=n;i\u0026gt;=1;--i) sa[cnt[rk[id[i]]]--]=id[i]; memcpy(oldrk,rk,sizeof(oldrk)); for (p=0,i=1;i\u0026lt;=n;++i) rk[sa[i]]=oldrk[sa[i]]==oldrk[sa[i-1]]\u0026amp;\u0026amp;oldrk[sa[i]+w]==oldrk[sa[i-1]+w]?p:++p; } for (i=1;i\u0026lt;=n;++i) printf(\u0026quot;%d \u0026quot;,sa[i]); return 0; }   一些常数优化 如果你把上面那份代码交到洛谷上..\n怎么会这样呢？是这题卡常吗？\n一翻其他人的代码，最慢点也不过 $1s$..\n这是因为，上面那份代码的常数的确很大..\n第二关键字无需计数排序 实际上，像这样就可以了：\nfor (p=0,i=n;i\u0026gt;n-w;--i) id[++p]=i; for (i=1;i\u0026lt;=n;++i) if (sa[i]\u0026gt;w) id[++p]=sa[i]-w;  意会一下，先把 $s[i+w..i+2w-1]$ 为空串的位置放前面，再把剩下的按排好的顺序放进去。\n优化计数排序的值域 每次对 $rk$ 进行去重之后，我们都计算了一个 $p$，这个 $p$ 即是 $k$ 的值域，将值域改成它即可。\n将 $rk[id[i]]$ 存下来，减少不连续内存访问 这个优化在数据范围较大时效果非常明显。\n用函数cmp来计算是否重复 同样是减少不连续内存访问，在数据范围较大时效果比较明显。\n把 oldrk[sa[i]]==oldrk[sa[i-1]]\u0026amp;\u0026amp;oldrk[sa[i]+w]==oldrk[sa[i-1]+w] 替换成 cmp(sa[i],sa[i-1],w)，bool cmp(int x,int y,int w){ return id[x]==id[y]\u0026amp;\u0026amp;id[x+w]==id[y+w]; }。\n参考代码 #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; const int N=1000010; char s[N]; int n,sa[N],rk[N],oldrk[N\u0026lt;\u0026lt;1],id[N],px[N],cnt[N]; //px[i]=rk[id[i]]（用于排序的数组所以叫px） bool cmp(int x,int y,int w){ return oldrk[x]==oldrk[y]\u0026amp;\u0026amp;oldrk[x+w]==oldrk[y+w]; } int main() { int i,m=300,p,w; scanf(\u0026quot;%s\u0026quot;,s+1); n=strlen(s+1); for (i=1;i\u0026lt;=n;++i) ++cnt[rk[i]=s[i]]; for (i=1;i\u0026lt;=m;++i) cnt[i]+=cnt[i-1]; for (i=n;i\u0026gt;=1;--i) sa[cnt[rk[i]]--]=i; for (w=1;w\u0026lt;n;w\u0026lt;\u0026lt;=1,m=p) //m=p就是优化计数排序值域 { for (p=0,i=n;i\u0026gt;n-w;--i) id[++p]=i; for (i=1;i\u0026lt;=n;++i) if (sa[i]\u0026gt;w) id[++p]=sa[i]-w; memset(cnt,0,sizeof(cnt)); for (i=1;i\u0026lt;=n;++i) ++cnt[px[i]=rk[id[i]]]; for (i=1;i\u0026lt;=m;++i) cnt[i]+=cnt[i-1]; for (i=n;i\u0026gt;=1;--i) sa[cnt[px[i]]--]=id[i]; memcpy(oldrk,rk,sizeof(rk)); for (p=0,i=1;i\u0026lt;=n;++i) rk[sa[i]]=cmp(sa[i],sa[i-1],w)?p:++p; } for (i=1;i\u0026lt;=n;++i) printf(\u0026quot;%d \u0026quot;,sa[i]); return 0; }  这样优化之后应该不开O2都能过。\n $O(n)$ 做法 名字叫DC3，我不会\n可以参考[2009]后缀数组——处理字符串的有力工具 by.罗穗骞，里面有介绍这个算法。\n一般情况下用倍增法做足常数优化是不会被卡的..\n还有个叫“诱导排序”的东西，也是 $O(n)$ 的，听说又好写（相对于 DC3）又快。\n后缀数组无需 $height$ 数组的应用 如果用不到 $height$ 数组，一般就是利用 $rk$ 数组对字符串进行排序，有时需要对原串进行一定的加工使需要排序的字符串变成后缀，或者是只需对后缀进行排序便能对需要排序的字符串进行排序。\n[JSOI2007]字符加密 洛谷\ndark bzoj\n[USACO07DEC]Best Cow Line, Gold 洛谷\n我的题解\n$height$ 数组 后缀数组的题目往往是要用到 $height$ 数组的。\nlcp（最长公共前缀） 两个字符串 $S$ 和 $T$ 的 $lcp$ 就是最大的 $x$ 使得 $S_i=T_i$ ($\\forall 1\\le i\\le x$) 。\n下文中以 $lcp(i,j)$ 表示后缀 $i$ 和后缀 $j$ 的最长公共前缀（的长度）。\n$height$ 数组的定义 $height[i]=lcp(sa[i],sa[i-1])$，即第 $i$ 名的后缀与它前一名的后缀的最长公共前缀。\n$O(n)$ 求 $height$ 数组需要的一个引理 $height[rk[i]]\\ge height[rk[i-1]]-1$\n证明的话..感性理解\n当 $height[rk[i-1]]\\le1$ 时，上式显然成立（右边小于等于 $0$ ）。\n当 $height[rk[i-1]]\u0026gt;1$ 时：\n设后缀 $i-1$ 为 $aAD$（$A$ 是一个长度为 $height[rk[i-1]]-1$ 的字符串），那么后缀 $i$ 就是 $AD$。设后缀 $sa[rk[i-1]-1]$ 为 $aAB$ ，那么 $lcp(i-1,sa[rk[i-1]-1])=aA$。由于后缀 $sa[rk[i-1]-1]+1$ 是 $AB$，一定排在后缀 $i$ 的前面，所以后缀 $sa[rk[i]-1]$ 一定含有前缀 $A$，所以 $lcp(i,sa[rk[i]-1])$ 至少是 $height[rk[i-1]]-1$。\n简单来说：\n$i-1$：$aAD$\n$i$：$AD$\n$sa[rk[i-1]-1]$：$aAB$\n$sa[rk[i-1]-1]+1$：$AB$\n$sa[rk[i]-1]$：$A[B/C]$\n$lcp(i,sa[rk[i]-1])$：$AX$（$X$ 可能为空）\n$O(n)$ 求 $height$ 数组的代码实现 利用上面这个引理暴力求即可：\nfor (i=1,k=0;i\u0026lt;=n;++i) { if (k) --k; while (s[i+k]==s[sa[rk[i]-1]+k]) ++k; ht[rk[i]]=k; //height太长了缩写为ht }  利用摊还分析/势能分析可以发现是O(n)的，$k$ 不会超过 $n$，最多减 $n$ 次，所以最多加 $2n$ 次。\n应用 $height$ 数组需要的一个性质 $lcp(sa[i],sa[j])=\\min\\{height[i+1..j]\\}$\n感性理解：如果 $height$ 一直大于某个数，前这么多位就一直没变过；反之，由于后缀已经排好序了，不可能变了之后变回来。\n严格证明可以参考[2004]后缀数组 by.徐智磊。\n$height$ 数组的应用 $height$ 数组往往用来解决关于字符串公共部分的题目，通常需要和RMQ/单调栈等算法相结合。\n[USACO06DEC]Milk Patterns 洛谷\n我的题解\n[AHOI2013]差异 洛谷\ndark bzoj\n[HAOI2016]找相同字符 洛谷\ndark bzoj\n我的题解\n[NOI2015]品酒大会 洛谷\ndark bzoj\nSP8222 NSUBSTR - Substrings 洛谷\nSPOJ\n","date":"2019-02-17T13:53:54+08:00","permalink":"https://ouuan.github.io/post/%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","tags":["字符串","后缀数组"],"title":"后缀数组学习笔记"},{"categories":["题解"],"contents":"题目链接 洛谷\ndark bzoj\n题意简述 给你两个字符串，从中各取一个子串使这两个子串相同，求方案数。\n简要做法 以某两个位置开头的相同子串数=这两个位置开头的后缀的 $lcp$\n如果在同一个字符串中，求出 height 数组后使用单调栈求出每个位置作为最小值的贡献即可（单调栈部分与 P2659 美丽的序列，[ZJOI2007]棋盘制作 等题类似，在此就不赘述了；求两两 $lcp​$ 之和这部分与 [AHOI2013]差异 类似，故没有写那题的题解）。\n由于有两个字符串不太方便，考虑将它们拼接起来并在中间加上一个不存在的字符（如#）。这样求出拼接后的字符串的答案，减去两个原串的答案，就是最终的答案。\n参考代码 #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; const int N=400010; typedef long long ll; int sa[N],sa2[N\u0026lt;\u0026lt;1],rk[N\u0026lt;\u0026lt;1],px[N],cnt[N],sta[N],top,f[N],height[N]; struct Suffix_Array { char s[N]; ll calc() { ll out=0; int n,i,k,w,p,m=200; n=strlen(s+1); memset(sa2,0,sizeof(sa2)); memset(cnt,0,sizeof(cnt)); for (i=1;i\u0026lt;=n;++i) ++cnt[rk[i]=s[i]]; for (i=1;i\u0026lt;=m;++i) cnt[i]+=cnt[i-1]; for (i=n;i\u0026gt;=1;--i) sa[cnt[rk[i]]--]=i; for (w=1;w\u0026lt;n;w\u0026lt;\u0026lt;=1,m=p) { memset(cnt,0,sizeof(cnt)); for (p=0,i=n;i\u0026gt;n-w;--i) sa2[++p]=i; for (i=1;i\u0026lt;=n;++i) if (sa[i]\u0026gt;w) sa2[++p]=sa[i]-w; for (i=1;i\u0026lt;=n;++i) ++cnt[px[i]=rk[sa2[i]]]; for (i=1;i\u0026lt;=m;++i) cnt[i]+=cnt[i-1]; for (i=n;i\u0026gt;=1;--i) sa[cnt[px[i]]--]=sa2[i]; swap(rk,sa2); for (p=0,i=1;i\u0026lt;=n;++i) rk[sa[i]]=sa2[sa[i]]==sa2[sa[i-1]]\u0026amp;\u0026amp;sa2[sa[i]+w]==sa2[sa[i-1]+w]?p:++p; } for (i=1,k=0;i\u0026lt;=n;++i) { if (k) --k; while (s[i+k]==s[sa[rk[i]-1]+k]) ++k; height[rk[i]]=k; } for (i=1;i\u0026lt;=n;++i) { while (top\u0026amp;\u0026amp;height[sta[top]]\u0026gt;=height[i]) --top; f[i]=i-sta[top]; sta[++top]=i; } top=0; sta[++top]=n+1; height[n+1]=0; for (i=n;i\u0026gt;=1;--i) { while (top\u0026amp;\u0026amp;height[sta[top]]\u0026gt;height[i]) --top; out+=(ll)f[i]*(sta[top]-i)*height[i]; sta[++top]=i; } return out; } } a,b,ab; int main() { int n,m,i; scanf(\u0026quot;%s%s\u0026quot;,a.s+1,b.s+1); n=strlen(a.s+1); m=strlen(b.s+1); for (i=1;i\u0026lt;=n;++i) ab.s[i]=a.s[i]; ab.s[n+1]='#'; for (i=1;i\u0026lt;=m;++i) ab.s[n+1+i]=b.s[i]; cout\u0026lt;\u0026lt;ab.calc()-a.calc()-b.calc(); return 0; } ","date":"2019-02-14T11:22:18+08:00","permalink":"https://ouuan.github.io/post/bzoj4566-haoi2016-%E6%89%BE%E7%9B%B8%E5%90%8C%E5%AD%97%E7%AC%A6%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84/","tags":["字符串","后缀数组"],"title":"BZOJ4566 [HAOI2016]找相同字符（后缀数组）"},{"categories":["题解"],"contents":"题目链接 洛谷\n题意简述 给你一个字符串，求最长的出现了至少 $k$ 次的子串的长度。\n简要做法 求出 height 数组，若一个长为 $x$ 的子串在原串中出现了至少 $k$ 次，则 height 数组中一定存在至少 $k-1$ 个 连续的大于等于 $x$ 的值。所以，问题就转化成了：求 height 数组中 每连续 $k-1$ 个数的最小值 的最大值。即：$a_i=\\min\\{height_{i..i+k-2}\\}$，求 $a_i$ 的最大值。可以用RMQ/平衡树/线段树/multiset解决。\n参考代码 #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;set\u0026gt; using namespace std; const int N=40010; int n,k,a[N],sa[N],rk[N],sa2[N],px[N],cnt[1000010],height[N],ans; multiset\u0026lt;int\u0026gt; t; int main() { int i,j,w,p,m=1000000; scanf(\u0026quot;%d%d\u0026quot;,\u0026amp;n,\u0026amp;k); --k; for (i=1;i\u0026lt;=n;++i) scanf(\u0026quot;%d\u0026quot;,a+i); for (i=1;i\u0026lt;=n;++i) ++cnt[rk[i]=a[i]]; for (i=1;i\u0026lt;=m;++i) cnt[i]+=cnt[i-1]; for (i=n;i\u0026gt;=1;--i) sa[cnt[rk[i]]--]=i; for (w=1;w\u0026lt;n;w\u0026lt;\u0026lt;=1,m=p) { memset(cnt,0,sizeof(cnt)); for (p=0,i=n;i\u0026gt;n-w;--i) sa2[++p]=i; for (i=1;i\u0026lt;=n;++i) if (sa[i]\u0026gt;w) sa2[++p]=sa[i]-w; for (i=1;i\u0026lt;=n;++i) ++cnt[px[i]=rk[sa2[i]]]; for (i=1;i\u0026lt;=m;++i) cnt[i]+=cnt[i-1]; for (i=n;i\u0026gt;=1;--i) sa[cnt[px[i]]--]=sa2[i]; swap(rk,sa2); for (p=0,i=1;i\u0026lt;=n;++i) rk[sa[i]]=sa2[sa[i]]==sa2[sa[i-1]]\u0026amp;\u0026amp;sa2[sa[i]+w]==sa2[sa[i-1]+w]?p:++p; } for (i=1,j=0;i\u0026lt;=n;++i) { if (j) --j; while (a[i+j]==a[sa[rk[i]-1]+j]) ++j; height[rk[i]]=j; } for (i=1;i\u0026lt;=n;++i) { t.insert(height[i]); if (i\u0026gt;k) t.erase(t.find(height[i-k])); ans=max(ans,*t.begin()); } cout\u0026lt;\u0026lt;ans; return 0; } ","date":"2019-02-14T11:21:26+08:00","permalink":"https://ouuan.github.io/post/p2852-usaco06dec-milk-patterns%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84/","tags":["字符串","后缀数组"],"title":"P2852 [USACO06DEC]Milk Patterns（后缀数组）"},{"categories":["题解"],"contents":"题目链接 洛谷\n题意简述 给你一个字符串，每次从首或尾取一个字符组成字符串，问所有能够组成的字符串中字典序最小的一个。\n简要做法 暴力做法就是每次最坏 $O(n)$ 地判断当前应该取首还是尾，只需优化这一判断过程即可。\n将原串reverse后拼接在原串后，并在中间加上一个没出现过的字符（如 # ），求SA，即可 $O(1)$ 完成这一判断。\n参考代码 #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;cstring\u0026gt; using namespace std; const int N=1000010; char s[N]; int n,sa[N],sa2[N\u0026lt;\u0026lt;1],rk[N\u0026lt;\u0026lt;1],px[N],cnt[N]; int main() { int i,w,m=200,p,l=1,r,tot=0; cin\u0026gt;\u0026gt;n; r=n; for (i=1;i\u0026lt;=n;++i) while (!isalpha(s[i]=getchar())); for (i=1;i\u0026lt;=n;++i) rk[i]=rk[2*n+2-i]=s[i]; n=2*n+1; for (i=1;i\u0026lt;=n;++i) ++cnt[rk[i]]; for (i=1;i\u0026lt;=m;++i) cnt[i]+=cnt[i-1]; for (i=n;i\u0026gt;=1;--i) sa[cnt[rk[i]]--]=i; for (w=1;w\u0026lt;n;w\u0026lt;\u0026lt;=1,m=p) { memset(cnt,0,sizeof(cnt)); for (p=0,i=n;i\u0026gt;n-w;--i) sa2[++p]=i; for (i=1;i\u0026lt;=n;++i) if (sa[i]\u0026gt;w) sa2[++p]=sa[i]-w; for (i=1;i\u0026lt;=n;++i) ++cnt[px[i]=rk[sa2[i]]]; for (i=1;i\u0026lt;=m;++i) cnt[i]+=cnt[i-1]; for (i=n;i\u0026gt;=1;--i) sa[cnt[px[i]]--]=sa2[i]; swap(sa2,rk); for (p=0,i=1;i\u0026lt;=n;++i) rk[sa[i]]=sa2[sa[i]]==sa2[sa[i-1]]\u0026amp;\u0026amp;sa2[sa[i]+w]==sa2[sa[i-1]+w]?p:++p; } while (l\u0026lt;=r) { printf(\u0026quot;%c\u0026quot;,rk[l]\u0026lt;rk[n+1-r]?s[l++]:s[r--]); if ((++tot)%80==0) puts(\u0026quot;\u0026quot;); } return 0; } ","date":"2019-02-14T11:20:59+08:00","permalink":"https://ouuan.github.io/post/p2870-usaco07dec-best-cow-line-gold%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84/","tags":["字符串","后缀数组"],"title":"P2870 [USACO07DEC]Best Cow Line, Gold（后缀数组）"},{"categories":["题解"],"contents":"题目链接 洛谷\ndarkbzoj\n题意简述 $n$ 个入栈操作，$m$ 个出栈操作，问合法操作序列数。\n简要做法 借用一下这篇题解（的图）。\n选了 $x$ 个数，$1$ 与 $0$ 个数之差为 $y$，如下图：\n不考虑限制条件，方案数为从 $(0,0)$ 到 $(n+m,n-m)$ 的折线数，即从 $n+m$ 次操作中选择 $m$ 次向下： $\\binom{n+m}m$。考虑某一种不合法的情况，把这条折线第一次碰到 $y=-1$ 前的部分以 $y=-1$ 为轴翻折，这样就建立了 从 $(0,0)$ 到 $(n+m,n-m)$ 且碰到了 $y=-1$ 的折线 与 从 $(0,-2)$ 到 $(n+m,n-m)$ 的折线 的一一对应，所以不合法的情况个数为 $\\binom{n+m}{m-1}$，答案为 $\\binom{n+m}m-\\binom{n+m}{m-1}$。\n（上面看懂了这段可以不看，这段是废话证明）为什么这玩意是双射（一一对应）..其实很简单，每条 从 $(0,0)$ 到 $(n+m,n-m)$ 且碰到了 $y=-1$ 的折线 在第一次碰到 $y=-1$ 前的部分以 $y=-1$ 为轴翻折可以得到唯一一条 从 $(0,-2)$ 到 $(n+m,n-m)$ 的折线，而一条 从 $(0,-2)$ 到 $(n+m,n-m)$ 的折线 必然会碰到 $y=-1$，同样可以把它在第一次碰到 $y=-1$ 前的部分以 $y=-1$ 为轴翻折，就会得到唯一一条 从 $(0,0)$ 到 $(n+m,n-m)$ 且碰到了 $y=-1$ 的折线。\n最后吐槽一句。你谷完全不接受做法相同的题解，无法对已有做法进行阐述，所以并没有尝试在你谷发题解。\n代码 #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstdio\u0026gt; using namespace std; typedef long long ll; const int N=1000010; const int mod=20100403; int qpow(int x,int y); int c(int x,int y); int jc[N\u0026lt;\u0026lt;1]; int main() { int n,m; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m; jc[0]=1; for (int i=1;i\u0026lt;=n+m;++i) jc[i]=(ll)jc[i-1]*i%mod; cout\u0026lt;\u0026lt;(c(n+m,m)-c(n+m,m-1)+mod)%mod; return 0; } int qpow(int x,int y) { int out=1; while (y) { if (y\u0026amp;1) out=(ll)out*x%mod; x=(ll)x*x%mod; y\u0026gt;\u0026gt;=1; } return out; } int c(int x,int y) { return (ll)jc[x]*qpow(jc[y],mod-2)%mod*qpow(jc[x-y],mod-2)%mod; } ","date":"2019-02-12T14:56:42+08:00","permalink":"https://ouuan.github.io/post/bzoj1856-scoi2010-%E7%94%9F%E6%88%90%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/","tags":["组合数学"],"title":"BZOJ1856 [SCOI2010]生成字符串（组合数学）"},{"categories":["黑科技"],"contents":"感谢 yfz 和 mcfx 在 WC 营员交流上的分享！\n然而只看那个课件来学习指令集好像略有困难..所以我来分享一下我自学一晚上的成果。\n希望能帮助大家暴力过题，考场上再也写不出标算。\n 注：本文省略了无数个 unsigned，请自行把所有 int 视作 unsigned int，把所有 long long 视作 unsigned long long。\n 适用范围 环境 不要尝试在正式OI竞赛中使用指令集优化。\n只适用于提供资瓷的 OJ，具体列表参照营员交流ppt：\nsse2，avx 什么的都是指令集的名字。\n作用 适用于方便对连续内存空间进行批量处理的题目。大约可以视作每 $8$ 个 int 为一个分块，块内进行赋值、修改等操作常数为 $1$，也就实现了常数/=$8$。当然如果是 long long 就只能除以四。\n具体使用 define \u0026amp; pragma \u0026amp; include #define __AVX__ 1 #define __AVX2__ 1 #define __SSE__ 1 #define __SSE2__ 1 #define __SSE2_MATH__ 1 #define __SSE3__ 1 #define __SSE4_1__ 1 #define __SSE4_2__ 1 #define __SSE_MATH__ 1 #define __SSSE3__ 1 #pragma GCC optimize(\u0026quot;Ofast,no-stack-protector,unroll-loops,fast-math\u0026quot;) #pragma GCC target(\u0026quot;sse,sse2,sse3,ssse3,sse4.1,sse4.2,avx,avx2,popcnt,tune=native\u0026quot;) #include \u0026lt;immintrin.h\u0026gt; #include \u0026lt;emmintrin.h\u0026gt;  第一行是优化，如果你都用指令集了当然是能优化尽量优化。\n第二行是告诉编译器你要使用指令集。\n后面两个头文件是 C++ 将指令集封装成了函数，这样就不用在代码中内联汇编了。\n变量类型 大约有 __m256i __m256 __m256d 三种，分别存储 long long，float 和 double，实际上 __m256i 也可以用来存储 int。\n指令使用 可以在一个神奇的网站查需要的指令，左边选指令集以及指令类型，右边是指令，点开指令可以查看函数原型以及伪代码。\n这里列几条常用指令：\n__m256i _mm256_set_epi32 (int e7, int e6, int e5, int e4, int e3, int e2, int e1, int e0)：参数是八个数，也就是一个“分块”里的数，注意是逆序的。返回值是一个含这八个数的“分块”。\n__m256i _mm256_set_epi64x (__int64 e3, __int64 e2, __int64 e1, __int64 e0)：和上面一样，只不过是 $64$ 位整数，也就是 long long。\n__m256i _mm256_set1_epi32 (int a)：相当于 _mm256_set_epi32(a,a,a,a,a,a,a,a)。\n__m256i _mm256_add_epi32 (__m256i a, __m256i b)：把两个“分块”的对应位置分别相加，返回结果。\n__m256i _mm256_cmpeq_epi32 (__m256i a, __m256i b)：判断两个“分块”的对应位置是否相等，若相等则返回的“分块”对应位置是 0xffffffff，否则是 0。\n__m256i _mm256_cmpgt_epi32 (__m256i a, __m256i b)：和上面一样，只不过比较符是大于而不是相等。\n__m256i _mm256_and_si256 (__m256i a, __m256i b)：返回两个“分块”的按位与，可以配合上面两条比较指令来使用。\n访问数据 可以直接通过下标访问：\n#include \u0026lt;cstdio\u0026gt; #pragma GCC optimize(\u0026quot;Ofast,no-stack-protector,unroll-loops,fast-math\u0026quot;) #pragma GCC target(\u0026quot;sse,sse2,sse3,ssse3,sse4.1,sse4.2,avx,avx2,popcnt,tune=native\u0026quot;) #include \u0026lt;immintrin.h\u0026gt; #include \u0026lt;emmintrin.h\u0026gt; __m256i a; int main() { a=_mm256_set_epi32(1,2,3,4,5,6,7,8); printf(\u0026quot;%d\u0026quot;,a[2]); return 0; }  你们可以猜猜这个的结果是什么。\n答案是..4。\n为什么呢，首先 _mm256_set_epi32 的参数是逆序的，所以实际上存储的数顺序是 8,7,6,5,4,3,2,1。其次，__m256i 类型是存储 long long 的，所以直接通过下标访问实际上是在访问 long long，如果 cout\u0026lt;\u0026lt;a[2]就会返回 12884901892（$3\\times2^{32}+4$）。所以，这句话实际上是在 printf(\u0026quot;%d\u0026quot;,12884901892ll);。\n那么如何访问 int（甚至 short，如果题目允许这样就可以常数除以 $16$）呢？\n其实搞个指针就可以了：\na=_mm256_set_epi32(1,2,3,4,5,6,7,8); int *b=(int *)\u0026amp;a; printf(\u0026quot;%d\u0026quot;,b[2]);  这样子的输出就是 $6$ 了。\n用这种方法就可以方便地处理序列问题了：\n#include \u0026lt;cstdio\u0026gt; #pragma GCC optimize(\u0026quot;Ofast,no-stack-protector,unroll-loops,fast-math\u0026quot;) #pragma GCC target(\u0026quot;sse,sse2,sse3,ssse3,sse4.1,sse4.2,avx,avx2,popcnt,tune=native\u0026quot;) #include \u0026lt;immintrin.h\u0026gt; #include \u0026lt;emmintrin.h\u0026gt; int* b; __m256i a[10],x; int main() { int i; b=(int *)\u0026amp;a; for (i=0;i\u0026lt;80;++i) scanf(\u0026quot;%d\u0026quot;,b+i); x=_mm256_set1_epi32(233); for (i=0;i\u0026lt;10;++i) a[i]=_mm256_add_epi32(a[i],x); for (i=0;i\u0026lt;80;++i) printf(\u0026quot;%d \u0026quot;,b[i]); return 0; }  上面是一个简单的示例，读入 $80$ 个数，然后输出它们加上 $233$ 的结果。\n例题 这种东西为什么还会有例题啊。\n教主的魔法，这题比较简单（废话暴力当然简单）。\n【模板】线段树1，这题其实是最简单的，然而由于 dl 出题人把值域搞到了 long long，常数只能除以四，需要卡卡常，多提交几次才能过。\n[Ynoi2018]五彩斑斓的世界，神司怒艹lxl标算的课件例题。\nSimple Tree，这个还要树剖，只不过也还好，神司是直接内嵌汇编写的，没有测过用函数能不能过..\n然后以教主的魔法为例讲一下代码：\n#include \u0026lt;cstdio\u0026gt; #pragma GCC optimize(\u0026quot;Ofast,no-stack-protector,unroll-loops,fast-math\u0026quot;) #pragma GCC target(\u0026quot;sse,sse2,sse3,ssse3,sse4.1,sse4.2,avx,avx2,popcnt,tune=native\u0026quot;) #include \u0026lt;immintrin.h\u0026gt; #include \u0026lt;emmintrin.h\u0026gt; const int N=1000010; int n,m,tot,*a; __m256i A[N\u0026gt;\u0026gt;3]; char op[10]; void modify(int l,int r,int x) { while ((l\u0026amp;7)\u0026amp;\u0026amp;l\u0026lt;r) a[l++]+=x; //处理左边不是整块的部分，和分块的处理方法是一样的 if (l==r) return; while (r\u0026amp;7) a[--r]+=x; //处理右边不是整块的部分 if (l==r) return; __m256i t=_mm256_set1_epi32(x); //剩下的部分整块加上x for (l\u0026gt;\u0026gt;=3,r\u0026gt;\u0026gt;=3;l\u0026lt;r;++l) A[l]=_mm256_add_epi32(A[l],t); } int query(int l,int r,int x) { int out=0; while ((l\u0026amp;7)\u0026amp;\u0026amp;l\u0026lt;r) out+=int(a[l++]\u0026gt;=x); //处理左边不是整块的部分 if (l==r) return out; while (r\u0026amp;7) out+=int(a[--r]\u0026gt;=x); //处理右边不是整块的部分 if (l==r) return out; __m256i t=_mm256_set1_epi32(1); //这个1是每个大于等于x的数的贡献 __m256i ans=_mm256_set1_epi32(0); //这个ans是用来存答案的 __m256i cp=_mm256_set1_epi32(x-1); //这个是用来比较的，题目中是大于等于，所以和x-1比较 for (l\u0026gt;\u0026gt;=3,r\u0026gt;\u0026gt;=3;l\u0026lt;r;++l) ans=_mm256_add_epi32(ans,_mm256_and_si256(t,_mm256_cmpgt_epi32(A[l],cp))); //这个意会一下，作用是数当前块有几个大于x-1的数 for (int i=0;i\u0026lt;4;++i) out+=(ans[i]\u0026amp;0xffffffff)+(ans[i]\u0026gt;\u0026gt;32); //最后统计答案，因为ans[i]是一个long long，所以要前32位和后32位分别统计 return out; } int main() { int i,l,r,x,aa[8]; scanf(\u0026quot;%d%d\u0026quot;,\u0026amp;n,\u0026amp;m); a=(int*)\u0026amp;A; for (i=0;i\u0026lt;n;++i) scanf(\u0026quot;%d\u0026quot;,a+i); while (m--) { scanf(\u0026quot;%s%d%d%d\u0026quot;,op,\u0026amp;l,\u0026amp;r,\u0026amp;x); if (op[0]=='M') modify(l-1,r,x); else printf(\u0026quot;%d\\n\u0026quot;,query(l-1,r,x)); } return 0; }  ","date":"2019-02-01T14:26:52+08:00","permalink":"https://ouuan.github.io/post/n%E6%96%B9%E8%BF%87%E7%99%BE%E4%B8%87-%E6%9A%B4%E5%8A%9B%E7%A2%BE%E6%A0%87%E7%AE%97%E6%8C%87%E4%BB%A4%E9%9B%86%E4%BC%98%E5%8C%96%E7%9A%84%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/","tags":["常数优化"],"title":"n方过百万 暴力碾标算——指令集优化的基础使用"},{"categories":["游记"],"contents":"又到了 Kanon 的季节呢，快乐的冬眠生活开始了_(:з」∠)_\nDay 0/-8 Day -1 被归到广二避寒记去了..\n上午在水群的时候吐槽 Kanon 结局，然后和 yfz 稍微聊了一下，又看了看萌百，的确あゆ就是和风子、面码差不多的思念体鸭，为什么我会觉得看不懂呢..大约不止是因为あゆ的存在？\n下午只做了一道题\u0026hellip;淀粉质竟然能把 solve(rt) 写成 solve(v)\u0026hellip;退役吧\n然后不知道为什么去试了下自走棋，连续垫底了一下午，算是明示WC垫底了。\nRNG居（guo）然连跪两把，继续暗示窝WC的命运。\nDay 1/-7 上午报到的时候没能和 BlackRedRabbit 面基，只不过试机的时候发现brr就在窝左边的左边的左边，然后就愉快的面基了。\n哦对了，晚上跟 jxl 还有 hyf 住。好像是女生宿舍？被子是粉的..然而听说A栋住女生，B栋住男生，感觉不会特意反过来..\n试机题目T1（听别人说）是AC自动机上dp..本来就不会，AC自动机也几年没打过了\u0026hellip;T2是THUSC2017提答，于是没做试机题，打了个NTT，还没一遍打对..丢人。\n下午果然垫底了..T1一个简单 $12$ 分暴力打了 1h，然后 T2 的第一档 $26$ 分写了 1h 才过大（xiao）样例，交上去没过pt..然后又调了 50min，还是没过..然后花了 0.5h 重构代码，莫名其妙就过了..T3看了看感觉第一档都不会，回去看T2，T2是答对第一问有 $60%$ 的分那种，发现自己会另一档的 $27\\times60%$，然后又花了 50min 写.. 最后 30min 的时候发现 T2 还有 $43\\times 60%$ 可以用可持久化并查集写，然而时间不够了\u0026hellip;\nT2 第一次写了 6K\u0026hellip;（菜死了连 6K 都没写过..）也是第一次用 namespace 写 subtask。\nif (r\u0026lt;=10\u0026amp;\u0026amp;c\u0026lt;=10) { using namespace subtask1; }  这样写真的爽_(:з」∠)_\nT1是道期望，输出格式是最简分数，而且不约分的话数会非常大。当时我就在想为什么不取模..然后出考场听说 T1 的式子有一堆可以约分，剩下的形式特别简单\u0026hellip;\n我的游记好像经常不写题目就瞎bb..还是简单说一下吧。\nT1：给两个数列 $a_{1..n}$, $b_{1..n}$，多组询问，每次给 $c$, $d$, $e$, $f$，需要从 $a_{c..d}$ 和 $b_{e..f}$ 中各取 $d-c+1$ 个数然后两两配对，问配对的两个数相同的对数的期望，以最简分数形式输出。$n$ 和询问数好像大约是 $10^5$ ，因为只打了第一档暴力不记得了\u0026hellip;\nT2：一个网格图，有两种连边：\n 一整行/列两两连边。 一些特殊点之间两两连边。  有 $m$ 个被破坏的点，在某个时间点（每个被破坏的点独立）被修好，修好前所在行/列的整行/列连边不会连上。每个特殊点在某个时间点（每个特殊点独立）前不会和其它特殊点连边。多组询问问两个点联通的最早时间点，以及这个时间点的最短路。\n网格大小 $10^5$，询问数 $10^6$，被破坏的点数和特殊点数都是 $2\\times 10^5$。\nT3：求有多少个不同的长度不超过 $m$ 的 区间取min操作序列 使得进行最后一次操作后原序列恰好变成指定序列。值域和序列大小一样都是 $n$。$n$ 好像是一两百的样子，$m$ $10^9$。\n数据范围可能记错了，题意可能简述成看不懂了..QAQ就这样吧。\n晚上开营仪式，先是清华系主任自吹，然后是广二校长继续吹+拉拢和THU的关系，然后请一个现在在THU的NOI2017Au爷上台念了篇游记\u0026hellip;感觉那如果是篇游记还是写的挺好的，然而当众念出来..然后请了广二的一个妹子OIer 讲了一点，就结束了。\nDay 2/-6 今天是上午考试..T1是给你一棵树，每个点有 $a_i$, $b_i$，每条边有 $c_i$, $d_i$，$u$ 到 $v$ 的费用为 $\\sum\\limits_{i\\text{ on path }(u,v)}\\min(a_u+c_i,b_u+d_i)$，求每个点到其它所有点的费用之和。树大小 $5\\times 10^5$，值域 $10^5$。开场先打了个暴力，然后感觉可以枚举每条边把树分成两半，然后就可以计算 $\\sum\\limits_{c-d\u0026lt;b-a} c$ 和 $\\sum\\limits_{c-d\\ge b-a}d$ 来做，然而一开始没想到怎么做。继续去想链的部分分，发现可以主席树，然后花了 $1.5h$ 过 pt。然后发现可以用线段树合并搬到树上，又花了 $1h$ 过掉 pt。在 THUWC 过 pt 还是挺爽的..\nT2是道通过询问得到树的形态的交互，没仔细看\u0026hellip;\nT3是给平面上一些点，定义“好的多边形”为取一些点构成的没有三点共线的凸四边形，求所有“好的多边形”的面积的平均值和方差，对 $998244353$ 取模。点数 $400$ ，值域 $10^9$。有个点在坐标轴上的部分分，然而WA了两个小时..至今不知道哪错了..\n中午回寝室发现两边隔壁寝室分别有 nzhtl1984 和 yyb..然而最后和 lk 面基了。\n下午推了会儿 Kanon。\n去吃晚饭的时候碰见了 pr 和 lk。\n晚上是图像处理题：\n任务一把 $B\\times65536+A$ 看成 $A\\times65536+B$，调了 20min\u0026hellip;\n任务二任务三也写的特别慢，最后任务四没时间了..\n三场加起来没别人一场高，whkwhk\n最后离场的时候发现了这个：\n那两个红红的桌面壁纸是今天的样例\u0026hellip;\nDay 3/-5 今天应该是我来广二之后最有趣的一天了，本来拍了一堆照片，录了一堆视频，还有一堆录音，好多想说的。可是记（gu）忆（gu）是个好东西，它会帮你筛去那些不重要的，留在脑海中的便是那些真正值得写的吧。\n讲题 Day2+讲题的时候听到最多的一句话就是“然后就可以跳到”\u0026hellip;..\n讲完之后还讲了一些关于图像的其它内容，比如把图片的某些 bit 异或一下来加密：\nD1T2的讲题是带动画的，非常有意思，虽然有一些录像，然而还是放几张图片凑合一下吧：\n好像 ctr 还觉得 D1T2 可以放 NOIp T2T3 左右\u0026hellip;\n然后是什么 ”圆梦清华路上有力的援助“什么的\u0026hellip;\n反正讲题特别有意思。\n扯皮 下午是扯皮介绍THU的时间。\n能发弹幕，所以现场特别欢乐。\n先是介绍了算协，然后介绍了科协，然后是一个去年THUWC签约然后进队今年过来当工作人员的介绍自己这一年的经历，然后是一个人介绍了一下科研相关。\n反正当时感觉超有意思的..然而不太记得算协具体讲了啥了..科协讲的就记得智能体大赛..那位神仙 lzj 讲的倒记得比较清楚。大约是说他签约后写了个光线追踪的工程，然后写了个“二维屁股守望”还现场演示了，之后还去参加了智能体（注意他现在才高三..）。科研相关的讲的非常科研，可能是比较硬核而且互动/玩梗不够，当时现场也不太活跃，弹幕都没什么人刷\u0026hellip;\n结营 感觉贵系招生主任的演讲水平真的超棒..弹幕都能迅速地扯到相关话题并且立刻扯回原本的主线，衔接自然流畅，感觉可以去当主播。\n中途提了个问题，问我们为什么选择OI。\n有回答“不想上文化课”“不想高考_(:з」∠)_”的，有回答“因为兴趣（略略略”“好玩”的，有回答“希望在有生之年解决曾经无法解决的问题”的，也有回答“能结识好多厉害的同学！”的。可能大多数人都是如此吧。因为兴趣开始，时而有宏大的理想，时而又为现实所迫，最后才发现不是自己菜，而是结识了越来越多越来越强的同学们。\n约咕咕了一个小时才发，窝自然是没有的，pr签了，lk签了，yyb签了，nzhtlshadowice1984签了，joker签了，窝认识的都签了。\n一天下来那么多的感想竟然短短几行就写完了呢\u0026hellip;遗憾没有拍到的照片也只是和其它拍到了的照片一样没有被放上来。\nDay -4 今天早上一起来就是愉快的卷铺盖走人，虽然路程比去 THUWC 的时候近（从“苏元”（好像是初中部？）到“二高”），然而要搬被子床单什么的..分了两趟搬QAQ\n然后颓推了一天一会儿Kanon，魔芋的翻译真有意思：\n报到的时候有个签名墙，中午和晚上各拍了一张，晚上的比较全（废话），然而中午的拍的比较清楚，所以都放上来好了..\n看到窝写的 \u0026lt;font color=\u0026quot;grey\u0026quot;\u0026gt;ouuan\u0026lt;/font\u0026gt; 了吗qwq\n晚上是开幕式，掌声最热烈的有两个地方。\n第一个是广二的一个妹子OIer的演讲：“OI到底在学什么？班主任眼中最会修电脑的一批人，旁人眼中前途一片平坦通向美好未来的道路，同班同学眼中那个经常消失不知道去哪的神秘人”，“OI 已不只是一个竞赛，也不只是一门学科，而是存在于群聊中一句句 Orz 和三个百分号里，存在于看到十的九次方加七时的熟悉感以及看到 998244353 时的心里默默的波动中，抑或是一步步化难为简，最终得出正解的喜悦，也可能是自闭场后一个人独自惆怅的身影”。\n第二个有js风险，所以..： 当NOI科学委员会主席念到“WC性价比高”的时候（copy这行）\nDay -3~0 自闭。\n放几张图好了。\n把汐里线（推了游戏之后更喜欢这个翻译了..和香里也有姐妹的感觉）推完了。算是理解了为什么汐里的“名言”是“起きないから奇跡って言うんですよ”，这句话有好几层意思，光是看动画不会明白的吧..也稍微明白了“梦境”与“第三个愿望”是怎么回事了。虽然还是不完全懂..（都是不合理的，好像也没什么“完全懂”）\n第二场营员交流上 yfz 和 mcfx 讲的指令集真好玩。\nDay 1 打铁。\n开场先写了 $T1$ $34$ 分，一出考场就听说自己挂了 $8$ 分。\n然后去想 $T3$ 交互，发现不会做，先把强制数据分治的 $13$ 分写了，调了一会儿，继续想 $O(n^2)$。\n感觉不会，这时候已经过去 $3.5h$ 了（鬼知道前面那点分为什么写了这么久..），去玩 $T2$ 提答，前面 $60$ 分还是很好写的，然后作死的想了一会儿第四个点，发现不会，已经只剩 $0.5h$ 了。\n问题是我这个时候还在想 $T3​$ 的 $n^2​$ 怎么写\u0026hellip;最后 $15min​$ 的时候决定写个随机询问打表对照，直接随便打了个表都没有检查结果是否两两不同，本来还把原来的代码复制了一份，最后 $1min​$ 写好的时候竟然把代码复制回去编译的..随手输了个数据，一测，既不是 correct 也不是 incorrect，然后就考试结束了..估计连那 $13​$ 分一起没了，爆零了。\n写了的分：$34+60+44=138$，Cu/Ag。\n估分 at 考试结束前 $15min$ ：$34+60+13=107$，Cu。\n估分 of 考试结束前 $15min$ ：$26+60+13=99$，Fe/Cu。\n考试结束后的估分：$26+60+0=86$，Fe。\n保底估分：$18+38+0=56$，Fe。\n最高可能得分：$26+60+44=130$，Cu/Ag。\nDay 1.5 虽然只有下午+晚上，然而发生了好多事鸭。\n先是 GGF 把选手复读复测鸽到了讲题开始之后..\n然后窝去看成绩，$T3$ 竟然没挂（$13$），然而 $T2$ 的第二个点莫名挂了..仔细看了半天都是对的，问别人也是对的，群里更有趣了，$O(1)$ 的题目 $O(n)$ 做法有 $0$, $6$, $20$ 分的..然后找到了工作人员，咕了一会儿之后帮我重测过了..然后去申诉，还不知道能不能加回来。讲题没去听..听了也是自闭。\nOIer真能搞，说搞就搞出来了一个文艺汇演。\nLCA nb！Joker nb！大连24 nb！zzt nb！\n感觉这一晚上更加了解 OI 了。要变得更强，和更强的人在一起，去喜欢正确的事情，再用尽全力去喜欢自己喜欢的事情。\n完整版文艺汇演录制今晚压制出来，大约要回武汉之后才能传到b站上。\nDay 2 上午去科学中心冬眠。在车上用 zar 的热点把文艺汇演传了。\n下午听说 $T2$ 重测了，然后窝莫名 Ag 了.. 这场 WC 好像是暴力 Au，只要 $127$ 分，然而窝暴力没打满，又疯狂挂分，只好滚粗了.. 另外好像人人都有一枚铁牌。\n睡前看了两集《比宇宙更远的地方》。\nDay 3 上午看了两集《比宇宙更远的地方》，然后去火车站。发现竟然和 PinkRabbit 一辆（去火车站的）车。\n中午吃了干拌面（来火车站之前买的），然后有个卖方便面的小哥让我们帮忙把方便面看着，他去上个厕所。$20min$ 后，他从厕所出来，去问 ylh 在玩什么游戏：\n本来想对广二说 さようなら 的，想了想应该是 またね 。\n感觉 cl 中渚对朋也说的那句“离开的时候一定要是笑着离开的，不然就再也回不来了”莫名可以用在这里。\n","date":"2019-01-20T12:16:15+08:00","permalink":"https://ouuan.github.io/post/2019thuwc-wc%E5%86%AC%E7%9C%A0%E8%AE%B0/","tags":["清华营","CCF系列赛事"],"title":"2019THUWC/WC冬眠记"},{"categories":["题解"],"contents":"T1题目链接\n大意：Alice 有一个长度为 $2n$ 的 $01$ 串 $s_{1..2n}$，Bob 有 $n$ 个下标 $p_{1..n}$，Alice 和 Bob 只能用 $01$ 通信，需要在每人各 $m$ 个 bit 内使 Bob 输出 $s_{p_1..p_n}$ .\n$n=1000$, $m=1350$。\nPart 1 通信题  只是说一下我做了这道题后对通信题的理解，可能有误。\n 赛时：通信题是啥？？？ 作为一个从未做过通信题的选手，遇到这题自然是百度了一下“通信题”。如果你尝试一下，会搜到《移动通信试题库》。\n尝试搜索 “通信题 OI”——OI是什么意思? - 问通信专家；\u0026ldquo;通信题 CSDN\u0026rdquo;——通信原理考试题-CSDN下载。\nok，只能自己看样例程序了。\n于是我比赛的第一个小时就在对着样例代码懵逼中度过了\u0026hellip;..\n然后发现我sb了，忘记了一件事：标准输入是会等待输入的！可能是我 OI 题做傻了，以为输入一定要一连串不停地输入\u0026hellip;导致我一直没有理解为什么两个程序之间可以来回通信\u0026hellip;\n（上面那段话纯属我sb了，请跳过不看）\n通信题是…… 根据我的理解，通信题就是：两个程序，分别从文件读入数据，从标准输入读入另一个程序的标准输出。最后其中一个程序按要求输出到文件。\n（好像跟题面描述的差不多\u0026hellip;）\n那就说说我sb了而卡住的地方好了..一个程序 getchar() 的时候会暂停执行，直到另一个程序输出，就跟手动输入数据时等待回车一样。\n关于调试 广二机房是 win7，不太方便复制\u0026hellip;\n于是只好手动输入了，只不过感觉 copy 两个程序的输出看它们相互配合着工作，还是蛮有趣的。\nPart 2 解法 其实我 $5min$ 就想到怎么做了..（但好像做法比最短解那些神仙做法麻烦的多？）其实也不是很难写，但由于第一次写通信题不太习惯，各种细节写挂，最后写了一个小时才A\u0026hellip;\n解决问题 可以想到这样一个做法（如果想不到也没关系..看懂就好了）：选择一个区间 $[l,r]$ ，Bob 用一个长度为 $r-l+1$ 的 $01$ 串告诉 Alice 这个区间内每个位置是否是一个下标，对于每个下标 Alice 告诉 Bob 对应的值；对于不在 $[l,r]$ 内的其它部分，Alice 把所有值（不管是不是一个下标）都告诉 Bob .\n优化通信数 考虑一下，这样做需要的 bit 数是多少：\nBob 给 Alice 的：首先 Bob 要告诉 Alice $l$ 和 $r$ , 用二进制表示，需要 $22$ 个 bit；其次，Bob 要询问 $[l,r]$ ，需要 $r-l+1$ 个 bit 。\nAlice 给 Bob 的：首先 Alice 要回答 Bob 在 $[l,r]$ 内的询问，需要 “ $[l,r]$ 内下标个数” 个 bit；其次，Alice 要告诉 Bob 除了 $[l,r]$ 其它区域的所有值，需要 $n-(r-l+1)$ 个 bit 。\n那么，我们需要最小化：$\\max(r-l+23,[l,r]\\text{ 内下标个数}+n-r+l-1)$ 。\n用 $[l,l+len)$ 来表示会简洁一些，所以下文都使用这种方式，即需要最小化：$\\max(len+22,[l,l+len)\\text{ 内下标个数}+n-len)$ 。\n预处理前缀和即可快速算出 $[l,l+len)$ 内的下标个数，$O(n^2)$ 枚举区间取最小值即可。\n参考代码 Bob #include \u0026lt;iostream\u0026gt; #include \u0026lt;fstream\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; ifstream fin(\u0026quot;bob.in\u0026quot;); ofstream fout(\u0026quot;bob.out\u0026quot;); char rd() //读入一个bit { return getchar(); } void wt(int x) //输出一个bit { putchar(x+'0'); fflush(stdout); } int n,m,p[1010],rk[4010],pre[4010],minn=0x7fffffff,l,len; char ans[1010]; int main() { int i,j,t; fin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m; for (i=1;i\u0026lt;=n;++i) //读入并记录是第几个下标（便于存答案），并且复制一份拼在后面，这样如果询问的区间跨过首尾可以方便地处理 { fin\u0026gt;\u0026gt;p[i]; rk[p[i]]=rk[p[i]+2*n]=i; } for (i=1;i\u0026lt;=4*n;++i) //预处理前缀和 { pre[i]=pre[i-1]+(rk[i]\u0026gt;0); } for (i=1;i\u0026lt;=2*n;++i) //枚举找最优方案 { for (j=1;j\u0026lt;=2*n;++j) { t=max(pre[i+j-1]-pre[i-1]+2*n-j,j+22); if (t\u0026lt;minn) { minn=t; l=i; len=j; } } } for (i=10;i\u0026gt;=0;--i) //告诉Alice l和len { wt(bool((1\u0026lt;\u0026lt;i)\u0026amp;l)); } for (i=10;i\u0026gt;=0;--i) { wt(bool((1\u0026lt;\u0026lt;i)\u0026amp;len)); } for (i=l;i\u0026lt;l+len;++i) //询问区间 { if (rk[i]) { wt(1); ans[rk[i]-1]=rd(); //存答案 } else { wt(0); } } for (i=l+len;i\u0026lt;l+2*n;++i) //读取剩余部分 { if (rk[i]) { ans[rk[i]-1]=rd(); } else { rd(); } } fout\u0026lt;\u0026lt;ans; return 0; }  Alice #include \u0026lt;iostream\u0026gt; #include \u0026lt;fstream\u0026gt; #include \u0026lt;cstdio\u0026gt; using namespace std; ifstream fin(\u0026quot;alice.in\u0026quot;); int rd() //为了方便，两个程序中rd()和wt()的char/int是反的 { return getchar()-'0'; } void wt(char x) { putchar(x); fflush(stdout); } int n,m; char s[4010]; int main() { int i,l=0,len=0; fin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m\u0026gt;\u0026gt;(s+1); for (i=2*n+1;i\u0026lt;=4*n;++i) //复制一遍放在后面 { s[i]=s[i-2*n]; } for (i=0;i\u0026lt;=10;++i) //读入l和len { l=l*2+rd(); } for (i=0;i\u0026lt;=10;++i) { len=len*2+rd(); } for (i=l;i\u0026lt;l+len;++i) //回答询问 { if (rd()) { wt(s[i]); } } for (i=l+len;i\u0026lt;l+2*n;++i) //告诉Bob剩下的部分 { wt(s[i]); } return 0; }  Part 3 证明 取询问区间为 $[l,l+1318]$ ，这样的话 Bob 发给 Alice 的 bit 数就为 $1319+22=1341$ .\n区间 $[l,l+1318]$ 内下标的期望个数为 $\\frac{1319}2$ ，所以一定存在某个区间使得下标个数小于等于 $659$ ，再加上剩余部分 $681$ ，Alice 发给 Bob 的 bit 数就为 $1340$ 。\n事实上，我提交的评测记录里通信次数最多的就是 $1341+1340$ 。\nPart 4 优化 只取 $len=1325$ ，少枚举一维，可以优化到时间复杂度 $O(n)$ ；少传 $11$ 个 bit，可以优化到最大通信次数 $1336+1337$ 。证明从略。\n提交记录\n","date":"2018-12-22T23:03:25+08:00","permalink":"https://ouuan.github.io/post/uer-8-%E6%B8%B8%E8%AE%B0-%E9%80%9A%E4%BF%A1%E9%A2%98%E6%89%93%E9%9B%AA%E4%BB%97/","tags":["UOJ","通信题"],"title":"UER #8 —— 通信题：打雪仗"},{"categories":["技术"],"contents":"传送门\n源码按F12即可查看（当然也可以在 repo 里面看）\n看到一个帖子里提到了一个140字符画图比赛，看到了 Martin Büttner\u0026rsquo;s code ，然后就随便写了一个. JavaScript 都是要用啥现场百度\u0026hellip;\n已经更新了（存档？）功能，在地址栏后以 ? 开头 \u0026amp; 分隔即可输入参数。例如：https://ouuan.github.io/randpic/generator/?width=512\u0026amp;height=512\u0026amp;blocksize=75\u0026amp;qwq=2\u0026amp;minred=100\u0026amp;maxred=255\u0026amp;mingreen=100\u0026amp;maxgreen=255\u0026amp;minblue=200\u0026amp;maxblue=255\u0026amp;minalpha=0\u0026amp;maxalpha=255\n下面是一些图片（附有参数链接）：\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","date":"2018-12-20T23:12:18+08:00","permalink":"https://ouuan.github.io/post/%E9%9A%8F%E6%9C%BA%E7%94%9F%E6%88%90%E5%9B%BE%E7%89%87%E5%B1%95%E7%A4%BA/","tags":["HTML/JavaScript"],"title":"随机生成图片展示"},{"categories":["游记"],"contents":"这两天比赛是真的多..碰上了场 Chinese Legends Round / HackForces 竟然在紫名涨了点分QAQ\n看到 A，$gcd(x,x-1)=1$ ，这不是sb题吗？然后愉快地WA了\u0026hellip;互质 $\\ne$ 不为倍数鸭QAQ还有 $1$ 呢.开场-50分..\nB貌似比C难，但A的人比C多..其实当时交的时候还没想清楚 $p$ 个一样的人数是 $p$ 的倍数这个结论，就感觉好像是对的，就交了。\nC 很快就想到了结论，排列组合乘一乘随便做，而且数据范围小到可以用杨辉三角算组合数+不用快速幂。\nD 感觉要搞个MST，然后就真的先搞了个MST，然后就没有想到简单的解法..正解是MST搞完所有关键点就不搞了。一开始写挂了，然而pt特别水（好像直接输出MST最大边就可以），A完E之后看到jason的D被叉了，就仔细看了下，发现自己写挂了..然后重交，少了 $400$ 多分。\nE 贪心搞一搞就行了，据说ylh没有做出来是忘了积一定差越小和越小..\nF 看了看感觉不会，于是锁了 D 开始叉人。看到room rank1的正解感觉自己整个人都sb了..在离比赛结束 $5$ 分钟的时候看到一个感觉写挂了的，然而不敢hack，于是一直盯着看，直到离比赛结束还有 $1$ 分钟的时候才hack，然而一不小心把数据打错了..幸好格式错误不扣分，赶紧点回去重新hack，最后在离比赛结束 $4s$ 的时候提交了hack，然后绿了！喜提 $100$ 分、$50​$ 名。\n当时比赛一结束我就跟 ylh 说我感觉如果我不 fst能再涨 $100$ 名，然后最后真的又涨了 $100$ 名.. B和D一堆fst的。\nF 用奇偶性判断选择的哪边，感觉很妙。\nG 没仔细看。\nH：\n and we didn\u0026rsquo;t except anyone to pass.\n 不知道会在紫名待多久QAQ\n","date":"2018-12-17T22:47:17+08:00","permalink":"https://ouuan.github.io/post/avito-cool-challenge-2018-%E6%B8%B8%E8%AE%B0/","tags":["Codeforces"],"title":"Avito Cool Challenge 2018 游记"},{"categories":["游记"],"contents":"今天 AT 和 CF 刚好连上了，于是就都打了一下。\n关于模板 今天心血来潮把用于在线比赛的模板换了一下，加了点东西，然后发现 rep(1,l,r) 写起来非常不顺手..保留了部分比较好用的。\n测试的时候忘记开数组了（都是些什么sb错误），然后以为 ll 不能作下标，于是没有 #define long long，然后 CF 挂惨了..\nAtCoder 上一场打的 Beginner，这场难度正常多了。\nA 是个值域为 $2$ 的逆序对..\nB 用 multiset 乱搞了一下，对于每个数枚举组成的数，然后从大到小匹配，不知道是不是正解，反正过了，而且是 $log^2$ 的。\nC 感觉挺可做的..可能有细节没调出来，赶着回酒店打 CF 就没有继续调了..\nD 一开始还在想博弈论完全不会..然后仔细看了一眼，如果 A 不走，B 就会不走，就结束了；所以 A 一定能走则走。然后就随便做了。\n只不过 AT 的 rating 真的涨的好快..\nCodeforces ABC 三道 spj ？？？\n都是随便构造就能做的..\n然而 C 一开始忘开 ll 了\u0026hellip;..\nD 黑白染色一下，连通块内两种节点分别有 $a$ 个和 $b$ 个答案就是 $2^a+2^b$ ，把每个连通块的答案加起来就好了。\n由于 $O(nq)$ memset 会爆掉，不能 memset 整个数组，于是愉快地在开了 ll 的情况下 memset(\u0026hellip;sizeof(int)\u0026hellip;)；发现了之后不小心把开 int 的另一个数组也改成 memset(\u0026hellip;sizeof(long long)..) 了.. 开场 $40$ 分钟的时候这 $3$ 个关于 ll 的罚时让我排名翻了三倍\u0026hellip;\n于是，A 了 D 之后我就在板子里加上了 #define int long long。\n看了会儿 E 不会做，然后一看 standing，惊奇地发现 G 有一堆（$15$ 个，当时 E $7$ F $1$）人 A 了，然后一看，就是POJ 2926+动态RMQ\u0026hellip;\n感觉自己几年没有写过普通线段树了（最近写的全是平衡树/动态开点线段树），写了半个多小时还写错了..毕竟是 CF，应该去复制个模板才对的\u0026hellip;一交，MLE 了，woc我好不容易#define int long long了就是这个结果？？改成 int，跑了 $5.4s$，巨方，于是手动开了 O3，$4.8s$ ，但重交竟然没有罚时。应该去找个 BIT 动态求 RMQ 的模板的\u0026hellip;\n看到 halyavin 参赛了，感觉自己要 fst ，赶紧把博客写了睡觉去。\nUPD halyavin 竟然没有 hack\u0026hellip;然而 D 有一堆 memset 整个数组的，我也去 hack 了一个（edu hack $\\sqrt{}$）。\n没有 fst，第一次 A $5$ 题，上 $2k$ 了，感觉海星。\nUUPD 题解 CF1093D 【Beautiful Graph】\n题解 CF1093G 【Multidimensional Queries】\n","date":"2018-12-16T00:29:11+08:00","permalink":"https://ouuan.github.io/post/cf-edu-56-at-grand-029-%E6%B8%B8%E8%AE%B0/","tags":["AtCoder","Codeforces"],"title":"CF edu 56 \u0026 AT Grand 029 游记"},{"categories":["技术"],"contents":" 注：暂时还不知道如何制作能被引用的随机图片，只能查看图片，而不能通过类似于![](图片地址)的方式查看。\n  demo\n欢迎投稿图片：投稿地址\n 核心代码 \u0026lt;script type=\u0026quot;text/javascript\u0026quot; src=\u0026quot;imagelist.json\u0026quot;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script type=\u0026quot;text/javascript\u0026quot;\u0026gt; var r=Math.floor(Math.random()*images.length) document.write(\u0026quot;\u0026lt;img src=\u0026quot;+images[r]+\u0026quot;\u0026gt;\u0026quot;) \u0026lt;/script\u0026gt;  图片列表保存在 imagelist.json 内。\n参考示例 https://ouuan.github.io/randpic/people/index.html：\n\u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;script type=\u0026quot;text/javascript\u0026quot; src=\u0026quot;imagelist.json\u0026quot;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;title\u0026gt;随机图片-人物类\u0026lt;/title\u0026gt; \u0026lt;link rel=\u0026quot;icon\u0026quot; type=\u0026quot;image/png\u0026quot; sizes=\u0026quot;32x32\u0026quot; href=\u0026quot;/images/favicon32.png\u0026quot;\u0026gt; \u0026lt;link rel=\u0026quot;icon\u0026quot; type=\u0026quot;image/png\u0026quot; sizes=\u0026quot;16x16\u0026quot; href=\u0026quot;/images/favicon16.png\u0026quot;\u0026gt; \u0026lt;style\u0026gt; img { width: 100%; height: auto; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;script type=\u0026quot;text/javascript\u0026quot;\u0026gt; var r=Math.floor(Math.random()*images.length) document.write(\u0026quot;\u0026lt;img src=\u0026quot;+images[r]+\u0026quot;\u0026gt;\u0026quot;) \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt;  https://ouuan.github.io/randpic/people/imagelist.json：\nvar images= [ \u0026quot;https://z4a.net/images/2018/12/12/70469686_p0.png\u0026quot;, \u0026quot;https://z4a.net/images/2018/12/12/69212051_p0.jpg\u0026quot;, \u0026quot;https://z4a.net/images/2018/12/12/64660644_p0.jpg\u0026quot;, \u0026quot;https://z4a.net/images/2018/12/12/61438972_p0.jpg\u0026quot;, \u0026quot;https://z4a.net/images/2018/12/12/60141148_p0.png\u0026quot;, \u0026quot;https://z4a.net/images/2018/12/12/1200296-20170715113653118-1762611401.jpg\u0026quot;, \u0026quot;https://z4a.net/images/2018/12/12/71631241_p0.jpg\u0026quot;, \u0026quot;https://z4a.net/images/2018/12/12/f0Q5-g62pXkZ5lT3cS1hc-rs.jpg\u0026quot;, \u0026quot;https://z4a.net/images/2018/12/12/36224612_p0.jpg\u0026quot;, \u0026quot;https://z4a.net/images/2018/12/12/64702477_p0.jpg\u0026quot;, \u0026quot;https://z4a.net/images/2018/12/12/64670588_p0.jpg\u0026quot;, \u0026quot;https://z4a.net/images/2018/12/12/61815260_p0.jpg\u0026quot;, \u0026quot;https://i.loli.net/2018/12/12/5c10a02b0831b.jpg\u0026quot;, \u0026quot;https://i.loli.net/2018/12/12/5c1119665c83a.jpg\u0026quot;, \u0026quot;https://i.loli.net/2018/12/12/5c111a8bed8e8.jpg\u0026quot;, \u0026quot;https://i.loli.net/2018/12/12/5c111ab43f7cf.jpg\u0026quot;, \u0026quot;https://i.loli.net/2018/12/12/5c111ade38590.jpg\u0026quot;, \u0026quot;https://i.loli.net/2018/12/12/5c111b8240591.png\u0026quot; ]  UPD 研究了一下 js 后写了一下图片缩放：（代码很丑，毕竟是靠百度学了一个小时写出来的）（大括号不换行是因为sublime缩进写着写着就炸了，只好在网上格式化了一下）\n\u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;script type=\u0026quot;text/javascript\u0026quot; src=\u0026quot;imagelist.json\u0026quot;\u0026gt; \u0026lt;/script\u0026gt; \u0026lt;title\u0026gt; 随机图片-人物类 \u0026lt;/title\u0026gt; \u0026lt;link rel=\u0026quot;icon\u0026quot; type=\u0026quot;image/png\u0026quot; sizes=\u0026quot;32x32\u0026quot; href=\u0026quot;/images/favicon32.png\u0026quot;\u0026gt; \u0026lt;link rel=\u0026quot;icon\u0026quot; type=\u0026quot;image/png\u0026quot; sizes=\u0026quot;16x16\u0026quot; href=\u0026quot;/images/favicon16.png\u0026quot;\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body style=\u0026quot;margin: 0px; background: #0e0e0e;\u0026quot;\u0026gt; \u0026lt;script type=\u0026quot;text/javascript\u0026quot;\u0026gt; var cur = 1; var xx = 0; var yy = 0; var rx = 0; var ry = 0; var nw; var nh; var mw; var mh; var w; var h; function setSize() { if (cur == 1) { var p = document.getElementsByTagName(\u0026quot;img\u0026quot;)[0]; nw = p.naturalWidth; nh = p.naturalHeight; mw = window.innerWidth; mh = window.innerHeight; if (nw \u0026gt; mw || nh \u0026gt; mh) { p.style = \u0026quot;cursor: zoom-in\u0026quot;; } else { p.style = \u0026quot;cursor: auto\u0026quot;; } if (nw * mh \u0026gt; nh * mw) { h = nh * mw / nw; w = mw; } else { w = nw * mh / nh; h = mh; } p.style.width = w; p.style.height = h; p.style.marginTop = (mh - h) / 2; p.style.marginLeft = (mw - w) / 2; } else { if (nw \u0026gt; mw || nh \u0026gt; mh) { p.style = \u0026quot;cursor: zoom-out\u0026quot;; } else { p.style = \u0026quot;cursor: auto\u0026quot;; } } } function picLoaded() { setSize(); window.onresize = function() { setSize(); } } function BigSmall() { mw = window.innerWidth; mh = window.innerHeight; if (nw \u0026gt; mw || nh \u0026gt; mh) { if (cur == 1) { cur = 2; var p = document.getElementsByTagName(\u0026quot;img\u0026quot;)[0]; p.style = \u0026quot;cursor: zoom-out\u0026quot;; var e = event || window.event; mw = window.innerWidth; mh = window.innerHeight; if (nw * mh \u0026gt; nh * mw) { h = nh * mw / nw; w = mw; } else { w = nw * mh / nh; h = mh; } if (nw \u0026lt;= mw) { xx = (mw - nw) / 2; rx = 0; } else { xx = 0; rx = (nw - mw) * (e.clientX - (mw - w) / 2) / w; } if (nh \u0026lt;= mh) { yy = (mh - nh) / 2; ry = 0; } else { yy = 0; ry = (nh - mh) * (e.clientY - (mh - h) / 2) / h; } p.style.marginTop = yy; p.style.marginLeft = xx; document.body.scrollLeft = rx; document.body.scrollTop = ry; } else { cur = 1; setSize(); } } } var r = Math.floor(Math.random() * images.length); document.write(\u0026quot;\u0026lt;img src=\u0026quot; + images[r] + \u0026quot; onload=\\\u0026quot;picLoaded()\\\u0026quot; onclick=\\\u0026quot;BigSmall()\\\u0026quot;\u0026gt;\u0026quot;); \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt;  ","date":"2018-12-12T23:42:17+08:00","permalink":"https://ouuan.github.io/post/html%E5%AE%9E%E7%8E%B0%E9%9A%8F%E6%9C%BA%E5%9B%BE%E7%89%87/","tags":["HTML/JavaScript"],"title":"html实现随机图片"},{"categories":["游记"],"contents":" 迎风迈出的步伐更艰难，即使走的不远，但踩得更深。一代人只能做一代人的事，完成这个时代赋予的使命就是英雄，大地也会将他的脚印铭记。\n——乒乓帝国（句子迷上说是《孤杂记》..）\n 突然就得知了要去广二集训。\n然后知道了这次出去可能要一直到 WC，差不多有 $50$ 天。这样一算这个学期我在武汉的时间可能和外出的时间一样多了。\n毕竟是去广州，会暖和很多，也许看不到武汉的雪了。\nDay 0 Railway 在站台上遇到了 Dew、ylh，感觉自己活尸化严重，都是我妈先看见的\u0026hellip;\n中午吃了泡面（有汤的那种），之前出去都比较近，在火车上不用吃饭，印象中上次吃方便面还是初三的时候在学校里吃的（桶装的泡面，愣是被我当成干拌面吃的）。\n在火车上看看手机、看看《大卫·科波菲尔》，当然我现在在写博客。\n途中看到了一幅非常\u0026hellip;\u0026hellip;\u0026hellip;..ok我承认我词穷了。云很低，好像不比火车高多少，环绕在山的周围，山脚下是一些平房，在远处插入了几栋现代化的高楼大厦，有一种违和却奇妙的美感。\n赶紧掏出手机，可毕竟只是手机，拍不出云那种虚无缥缈的立体感，匆忙中也没能选好角度，没拍到那几栋高楼大厦。\n已经逝去了，经纬度也没有记下来，不能在回来的火车上再览其景，只能用粗浅的文字将其略微地记录下来罢。\nUnderground 进地铁前忘记上厕所了Orz\n和 ylh 一起体验了一次换票出站上厕所。\n然后是 huangbei 站：\n人特别多，特别热。毕竟是来避寒的\nRestaurant 和广二的教练谈了谈人生，建议我和 ylh 先系统地学知识点，不着急打套题，结果 dew 想先学知识点，我和 ylh 想在广二做题..\n然后就是住宿的事，貌似准备先住两个星期三人间，等 ylh 回去了就去教练家里住（教练一个星期只回家一天）。今晚是先各自和家长住双人间。房号 1216.\nDay 1 上午教练咕咕了，中午才来接我们。\n然后让我们不着急打比赛，给我们三个人安排了个机房做题。\n$5$ 道左偏树，派遣、罗马游戏和Joint Stacks比较轻松地做出来了；Sequence看了看题解，感觉还没完全搞懂，但A了；魔法猪学院用A*在广二的OJ和BZOJ上过了，暂时放弃可持久化左偏树，以后再学吧..\n山、河、树（不只是路边那种）（当然也不是可持久化那种），游泳池，令人联想起 Angel Beats! 的食堂，各式各样的社团活动。\nDay 2-3 把题目列表搞到了洛谷团队里.\n搞了搞平衡树、启发式合并之类的，感觉自己啥都不会..\n搞了个随机图片 。\nDay 4 一天就写了[NOI2004]郁闷的出纳员和LCT模板\u0026hellip;\n然后搞了个stylus插件：洛谷犇犇、讨论隐藏。\n果然整天待机房效率低.\nDay 5 上午听隔壁机房的讲了下回文自动机、后缀数组、后缀自动机，但由于手头上的题还没搞完就没做相关的题目。\n[NOI2005]维护数列做了好久..本来操作就多，取的子段还不能为空\u0026hellip;\n然后学了下LCT。\nDay 6-7 就做了几道 LCT 的题\u0026hellip;学了学虚树，还没做题。\n然后这几天比赛挺多的，at+cf 还有洛谷比赛。感觉洛谷比赛都挺dl的\u0026hellip;\n然后今天看了几篇vfk的博客，感觉都写的挺好的。\n里面提到了CFctr的自我修养，感觉以后出题时要牢记（虽然里面有些是只适用于CF的）：\n   准备一场CF包括：题目、比赛通知、题解。\n  你的题目必须是独一无二的。你不能从以前用过的题目中抄袭它的想法。PLEASE BE FAIR WITH THE COMMUNITY。（\n  空间限制必须是256MB，时间限制至少是出题人的java程序运行时间的两倍。\n  题面必须清晰好懂，没有语法错误。建议写得短短的……\n  题目背景中不要写数据范围，全部都要写在输入格式里。\n  请参考以前CF的题目描述的格式来写题目描述。如果你不知道怎么清晰地描述输入输出格式，请找与之类似的题目进行仿写。\n  题目描述中的数组下标最好从1开始。\n  你必须限制被你提到的所有的变量的范围。如果你提到一个字符串，你必须写明哪些字符可以出现在这个字符串内。\n  题目的tests中必须包括各种各样的数据，而且应该有各种各样的达到最小数据范围的数据和达到最大数据范围的数据。也就是说如果1 \u0026lt;= n \u0026lt;= 100000，那么数据中既应该有n = 1，也应该有n = 100000。\n  你应该写个暴力。\n  你应该拿标程与暴力对拍。\n  Div.2的题的pretests要很强，能让应该超时的程序在pretests上就TLE掉。但是你可以让这个点毫无意义。比如给n个数排序，你可以用n个1来确保选择排序不能过。\n  确保读错题的人不能过pretests。\n  建议添加极端数据，但是不必是所有极端数据。确保数组开小的人不能过pretests。\n  不要让时间复杂度很高但做了大量常数优化的人AC。\n  每道题至少2个样例。每道Div.2的题目的前两个样例必须有样例解释。\n  如果要使用long long，请确保不开long long的人不能过pretests。\n   哦对了，自定义域名总是炸，以后这个博客就用 ouuan.github.io 作为地址了。（正好避免了一年后域名到期的问题）\nDay 8 今天好像啥都没干..估计是每天都没睡好导致白天效率低下..\n好像看了好几篇淀粉质的教程，但就是不想写题..\n和 memset0 讨论关于保留几位小数与精度限制的问题..感觉其他人总是不能轻松地理解保留几位小数是卡精度的\u0026hellip;\n翻译了CF的几道题，写了写题解。\n继续yy自己口胡的题的优秀做法，依然没什么进展。\n跟 Sooke 说了说自己出 CF 的想法，Sooke 表示想一起出，然后在还没想好一道题的情况下大谈怎么出 CF..\n说实话出 div.2 的话会有些不甘，哪怕晚点也想出 div.1+div.2 的..\n第一次用洗衣机，感觉洗衣机真有趣 （好像暴露了我一周没洗衣服\u0026hellip;）\n（hexo 貌似不支持行内图片？）\nDay 9 搞了个 随机生成图片 ，感觉自己自从用了 Hexo 日益由 OIer 变成码农了。\nDay 10-11 这几天忙着搞比赛，博客可能咕咕咕了..准备比赛记大约会在比赛出来之后发QAQ.\nDay ?-? 咕咕咕咕咕咕咕\nDay 14 广二先是四楼停电，用了一上午笔记本，准备回酒店的时候门卫告诉我们电来了，然后回去一看发现四楼没电三楼有电。下午突然就又停电了，幸好我和 dew 都没有在写代码..\nylh 走了，然而住教练家被咕咕了，好像是因为又来了几个外省的。\n新酒店..发几张图感受一下吧：\n没错 p3 是 dew 在吊椅上 然而不敢对着 dew 拍\u0026hellip;\nwifi 特别神仙：\n被夹在了一个没有 wifi 的世界里..\n然后貌似明天还是什么时候开始要打比赛了，然后这篇游记就不会继续真的成“游记”了。\nDay 15 今天是集训队爷 zjt 出的 集训队互测。\nT1 一道带权带花树好题 的确是带权带花树裸题（求一般图最大权值匹配），然而不需要输出方案。\n虽然说 OI 题名无正解，然而我还是百度了一下..然后学了一个半小时带花树，没学会！\n然后再一看，$n\\le20$ 不会做？\n只好写了二分图的 $20$ 分滚粗..\n然而发现一个严重的问题，这貌似是我第一次写二分图最大权值匹配..百度了一下，发现全是KM算法，没有一篇费用流？然后仔细想了好多遍，感觉费用流应该没问题，就写了。然而一开始写挂了（连图中的边时没判哪个点是起点），幸好后来发现了。\n后来听说这题 std 是一个线代做法，由于不用输出方案码量非常小。具体可以参考2017年集训队论文。然而看不懂鸭\u0026hellip;\n这题不卡随机化乱搞.（嘤嘤嘤？）\nT2 一道拉格朗日反演好题 看到 T1 真的是一般图最大权值匹配的我真的信了题名的鬼话..\n一个 $01$ 序列，初始为空，有三种操作：\n 往末尾加个 $0$ . 删掉一个子序列，包含 $x$ 个 $0$ ，$y$ 个 $1$ ，然后往末尾加个 $1$ 。其中 $x\\in A$ 。 删掉一个子序列，只包含 $x$ 个 $0$ ，然后往末尾加个 $1$ 。其中 $x\\in B$ 。  $A$ 和 $B$ 还有操作总数 $n$ 是给你的，让你求 $n$ 次操作完成后序列长度为 $1$ 的方案数。\n一开始还以为只用管 $01$ 分别的个数，后来才发现选的子序列位置不同也算不同的方案\u0026hellip;\n数据范围：いいよ,こいよ $114514$\n不太会做，好像是转化成一个树上的 dp，然后再算一波式子，分治FFT/牛顿迭代？\n不得不说样例十分lx：\n10 10 10 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9  362880  愉快地拿到了 $|A|=|B|=n$ 这档部分分。\nT3 一道 Top cactus 好题 仙人掌上 $q$ 次询问求经过某个点的路径贡献之和。模 $998244353$。“不在简单环上的边数”为 $x$ 的路径贡献为 $v_x$ 。\n部分分第一档，树，$n\\le2000$ 。\nwoc我只会 $O(n^3)$ ..\n冷静了一下，发现可以枚举路径树上差分..\n愉快地拿到了这 $10$ 分。\n正解好像是淀粉质+NTT。然后搬到圆方树上去。\n总结 队爷出的题就是神仙..之前一直感觉多项式看起来没啥用？请julao们看到这句话别打我..感觉很有必要早点去学多项式全家桶了。\n另外题名里的算法真的 $99%$ 不可信。\n另外由于打比赛换了个机房，貌似机房里都是一些外省的？\n OIer居然是可以有npy的！\n Day 16 yww咕咕了，myh出的题。这场题面太赞了！据说题意不清被吐槽的很厉害，但我貌似还是第一次碰见YNOI型题面，背景是自己看过的番，题意瞬间理解。\n这场还有个有趣的地方，T1 和 T3 的 subtask 一开始放反了，而且 T3 的变量 T1 都有，于是我比赛开始 $2h$ 才发现..（当然我发现的时候已经改回来了）\nT1 青春野狼不做理性小魔女的梦 题意简述，题目背景太棒了，所以我要题面简述。\n在咖啡厅，双叶不说话，只是推给了你一张纸，上面写着一个不定方程： $A_1x_1+A_2x_2+\\cdots+A_kx_k\\equiv1\\mod m$，然而其中的一些 $A_i$ 被咖啡打湿了，需要给被打湿的 $A_i$ 们赋值（$A_i\\in[0,m)$），使得不定方程有整数解；同时，双叶也不记得 $m$ 是多少了，所以要求 $m\\in[1,n]$ 的方案数之和。$1\\le k\\le50,1\\le n \\le10^9$。\n大约想到怎么做了，然而感觉无法实现（事实是正解要用杜教筛），会写的特别麻烦复杂度还不对，于是就只打了 $k\\le5$, $n\\le10$ 的暴力和没有数字被打湿的分。然而后面那档挂了，因为求区间内与某个数互质的数个数时没有容斥，最神奇的是拍半个多小时没拍出来\u0026hellip;\nT2 青春野狼不做姐控偶像的梦 和花给麻衣的信很有规律，她写的信是一个 $1$ ~ $n$ 的排列，一段连续的信能给麻衣鼓励，当且仅当它的值也连续（noi.ac的whzzt邀请赛里把这玩意定义为“广义排列”，意思就是一个区间， $max-min=r-l$ 且没有重复的数），麻衣想知道如果只保留一段连续的信，她能收到多少鼓励（就是多组区间询问）。\n其实..就是 CF997E Good Subsegments..\n千古神犇wxh log碾标算！lxctr myh n^2 送温暖！嗯，我拿了 $O(n^2)$ 的 $20$ 分\u0026hellip;\n做法参考 zzq的评论\nT3 青春野狼不做小恶魔学妹的梦 这道题题面写的最好！（貌似也被吐槽的最惨）\n 对学长的思念，深埋于心底。\n难以表达。\n与学长的记忆分为 $n$ 个部分，两个不同的部分间可能会有一种关系，也可能没有。\n可是我知道，它们藕断丝连，注定联通。\n想忘掉，可是却越来越难忘，$m$ 种关系会带给我 $m^k$ 的思念。\n我不知道我有多思念学长，能告诉我如果关系随意出现，思念的和吗？\n我不想看到太大的数，只要告诉我它模 $998244353$ 的结果就好了。\n 题意简述：$n$ 个点组成联通无向图，求不同的方案边数的 $k$ 次方之和。\n斯特林展开+大力推式子+NTT.\n再见。\n其它 myh 问班上的女生：你怎么3.5k写完仙人掌剖分的。\n嗯，女生就是昨天的总结里的女生。yqyry\nDay 17 今天没有比赛。\nDay 16 ~ Day 17 的这晚貌似是来广二之后睡的最长的一次（$6$ 小时 $40$ 分），然后效率果然略高了一些（一天只搞了FFT/NTT/多项式求逆，高个鬼），比起之前整天几乎啥都不干还是好多了..（有种如果睡8小时能一天搞完多项式全家桶的错觉）\n希望这周能把多项式常见的一些东西搞完吧..到时候应该会写一篇博客。\nDay 18 颓颓颓。\nT1 题意大约是求 $l_i\\le ki+b\\le r_i$ 的 $k,b$ 方案数。\n最低档暴力在考试结束前 $10min$ 才想出来一个特别麻烦的解法..然后爆零了。\n正解半平面交。\nT2 线性同余找循环节海星。\nT3 给几个团，团内点连相同权值边，问点之间两两距离之和。\n以团内边权为点权求出团之间的最短路，然后 $dist(i,j)=\\min\\{d(x,y)|x\\in S_i,y\\in S_j\\}$（$S_i$ 表示 $i$ 所在团的集合）。\n具体实现要用到 FMT 里的一个小 trick ，然而题解里一笔带过，我看了一下午题解都没看明白\u0026hellip;\n其它 那位女生 $rank1$ 了\u0026hellip;\n然后今天才发现广二 OJ 外网是能上的..（当然注册不了账号QAQ）\nDay 19 今天搬的 ACM 原题？CF 权限 gym Orz\n题解给吉老师视频，太灵性了..\nzjt 25（$rank$ $8$），myh 赛后五分钟提交 $15$ 快乐赛。\nT1 dp，好像没啥不会的知识点，然而没做出来。\nT2 把排列当成坐标放在平面上，分类讨论求上升块？表示完全没听懂，讲的时候 myh 在不停地提问。\n黑科技听不懂，而这道题除了黑科技还要牛顿迭代\u0026hellip;每场必有多项式的flag还是没倒.\nT3 没听懂嘤嘤嘤。\nDay 20 颓颓颓。\n今天没比赛，然而只搞了多项式除法和任意模数NTT。\n多项式除法一开始 $B(x)$ 模了 $x^m$ ，然而应该模 $x^{n-m+1}$ ，然后挂了半天。\n任意模数NTT因为数组开小挂了半天\u0026hellip;\n看到洛咕有绘板，就把晚上的at咕咕了，搞了个py脚本。一开始妄想手动把图片转成数据，差点一晚没睡，后来main包发了个脚本，转的效果还挺不错的。\nDay 21-23 基本上都在搞绘板，比赛记应该是永久咕咕了，绘板记这几天会写出来。\n有一个小插曲，9102年第一个梗被我骗了点赞。\nDay gugugu 绘板记咕咕了，这两天的比赛记咕咕了，今晚的CF不咕咕！猝死！！\nDay 27 今天的T1非常有意思，$8$ 个 int 进行编码，编码长度至少是 $1000$ 个 int，随机打乱之后给你解码。标算是一个不确定性算法，所以这题是达到一定正确率就过，（然后我赛时第一次提交30，第二次提交20，脸黑选手zjt赛时90，赛后AC），然而有神仙想出了多点求值、快速插值的确定算法。\nT2一看是几何题我就跳了..然而这题不怎么需要计算几何，而且有 $30$ 分挺好写的\u0026hellip;..\nT3是个树上dp，部分分有个“与一条蛇同构”，然后：\nxswl\n尝试着按myh的提交记录刷题，第一题是个字符串哈希，第一眼还以为是AC自动机..然后一发mapT飞，unordered就过了。第二题是个裸的单点、子树加，单点询问，竟然写错了3遍\u0026hellip;..第三题是个数位dp，愉快地卡住了\u0026hellip;.再不好好学数位dp感觉会出事_(:з」∠)_\nDay 28 T1是树上在线多组多路径询问颜色种类数和mex，一开始看到部分分还在想为什么没给树上莫队分，然后一想多条路径莫队复杂度肯定不对，看题解才知道正解树分块\u0026hellip;bitset能在线搞定的事，为什么要离线排序呢？然后成功在赛后A掉了（广二膜你赛赛后首A_(:з」∠)_）大约就是预处理关键点之间的bitset，块内暴力跳，关键点之间已经预处理了。\nT2是道神仙题..好像从某外国比赛搬的，赛时0A，通过分治时判断左右一样来保证复杂度，没太听懂。\nT3：“点分治然后建虚树再点分治就好了！”（mdzz）“听说fzy有两个log做法？treap/Splay合并就行了！”（mdzz）\n然后用bitset\u0026lt;0\u0026gt;水了点contribution，达成成就：contribution比friends多。\npolygon真有意思！试着把一道题搞上去了。\nDay 29-30 稍微学了下莫比乌斯反演和杜教筛，感觉挺有意思的QAQ。\n比赛全场就我不会马拉车，然而三题暴力排名还不错\u0026hellip;貌似只要打了点非无脑的暴力就能考的还行。（A题就jxd了\nDay 31 今天比赛是zzq出的，上场 **Chinese round ** 既视感严重..\nT1 树上有一些特殊点。\n两两匹配特殊点使得距离之和最大。正解没听懂，然而直接扫一遍存为 $rk_{1..k}$ 然后输出 $(rk_i,rk_{i+\\frac k 2})$ 就能过\u0026hellip;\nT2 “这是一道交互题”。\n加了一些限制条件，不同排名的人在某些情况下可能不回答询问，对其排序。\n并不是很难然而赛时没想到..\nT3 QuickSort伪代码。\n求 $cnt$ 次操作后排序成啥样了。又是只需要大小时转化为 $0/1$,$0/\\pm1$ 的 trick.\n然后，今天写了 $5$ 道莫比乌斯反演，100+600，感觉海星。\nDay 32 改题日→出题日\nDay 33 比赛的时候OJ挂了海星，最后修好了。\n感受一下刚修好时的提交。这次题目时限又大，当时卡了好几页。\nT1一开始时限是 $2s$，后来开成 $4s$ 了，然后一排人 $3.9s$\u0026hellip;\nT3一开始时限是 $6s$，myh NTT被卡常，赛后给自己开到 $12s$ 重测，$9s$ 过了\u0026hellip;然后他成功 $rank1$。\nDay 34 这个是我们刚来时就在画的，最近画好了，趁着迟到没人拍了一下。\n上午被告知学校有考试，机房被占用了，让我们下午不要去机房，在打比赛的体育馆待着。于是很多人都提前跑了..我也下午就走了，走的时候看到一堆小学生模样的孩子和家长，听到了“XX考试的第二场和XX时间一样，不让考完第一场就跑”之类的话，听到了“二火”之类曾经熟悉的名词。我是为什么放弃了华一寄来到外初的呢..早就忘得一干二净了，只记得来外高是因为wqs的寥寥几句话：\n还听到一个孩子说：“二中环境真好。”我以为他也会感叹二中有山有水，没想到他说的是——“二中有专门的清洁工”。\nDay 35 改题日颓颓颓\nDay 36 OrangeRabbit tql!!!\n去机房的路上发现这个：\n我们刚来的时候就看到有人在画井盖了，然而才发现这个QAQ\nT2对自己 $20$ 分暴力过于自信，打了一个半小时表找不到规律后写了下 $20$ 分才发现是错的\u0026hellip;\nT1写了一个半小时比暴力跑的还慢的树剖..稍微想想就可以发现复杂度完全不比暴力优的，然而想到就打了..\n最后没时间写T3暴力了，赛后听说T3数据特别水，随便写都能六七十分..\n于是炸的特别惨。\n晚上学了下淀粉质（讲题的时候myh认为机房里没人不会动态点分树\u0026hellip;），看题解怎么都看不懂，只不过自己yy很快就写出来了，然而第一次交的时候前向星存边数组没开两倍..？\nDay 37 今天又是zzq出的题，T1T2都是构造，其中T1没有输入..T1 rand跑了一个小时跑出来 $60$ 分（存种子提交），T2最低档爆搜不会..两个特殊性质subtask写了 $30$ 分。\nT3 也是道思维好题，写了个 $O(n^3)$ 暴力 $30$ 分。\nDay 38 好像是最后一个改题日..又颓过去了没什么好说的。\nDay 39 Sooke跟我说他昨天做了这套题\u0026hellip;然后告诉我不要看T3，会很惨。然而..\n这次好像是我拿到 $80$ 分最快的一次，打完T1T2拍了一下就开始玩提答了。看了一会儿大约看懂了一点，然后试着百度了一下“lambda”，啥都没查到，然后继续搜“lambda 邱奇”，发现“邱奇数 百度百科”，然后继续搜“邱奇数”，搜到了这个。于是开始研究..前面 $6$ 个点有的是自己想的，有的是看懂之后写的，78是直接抄的。最后混到个15名..lx特别ba\u0026hellip;只不过今天又来了几个人，感觉不抄的话二三十名好像也有，也海星啦\u0026hellip;\nDay 40 最后一天了呢..已经在布置THUWC了。\n今天的题暴力档特别少..又是1h拿到了 $48$ 然后肝不出了\u0026hellip;T3有很多人A，和之前D16T2有点像，是给一个排列问划分成若干个连续段的方案数，做法也比较类似，然而没想起来，也不会做\u0026hellip;\n这 $40$ 天好多想补的知识点也没补完..题也没怎么改..总体来说挺颓的\u0026hellip;最后两天再稍微补一补，调整一下状态吧，考出应有的成绩就好。这篇博客大概就这样完结了，下次就是THUWC/WC游记了。\nDay 41 本来应该结束了的..今天没去学校，10点的时候dew突然告诉我今天有场比赛？？一看是THUSCH2017原题，然后T1 dl线段树写了2h没调出来\u0026hellip;只不过好像并不是膜你赛，广二OJ很早就有这几题了，今天的standing也只有6个人\u0026hellip;\n然后..窝竟然真的在WC前把kanon补完了..\n","date":"2018-12-09T15:31:27+08:00","permalink":"https://ouuan.github.io/post/2018-2019%E5%86%AC-%E5%B9%BF%E4%BA%8C%E9%81%BF%E5%AF%92%E8%AE%B0/","tags":["集训"],"title":"2018~2019冬 广二避寒记"},{"categories":["游记"],"contents":"之前听教练安利，就来打了场 AtCoder。\n-5h 比赛地址\n一开始看到 \u0026ldquo;Beginner\u0026quot;的时候我还迟疑了一下，看了下上一场 Beginner 的题目，又在网上搜了一下，想着可以熟悉一下 AtCoder ，就准备打了。\n0min 咕咕咕\n5min 咕咕咕咕咕咕\n只不过幸好咕咕了，我的模板还没搞好..赶紧新建文件夹 atcoder\\AtCoder Beginner Contest 115 ，把 $4$ 个用于 CF 的模板扔进去。\n10min 开始了！\n用了 $0.1s$ 决定用 switch 而不是 if else 。\n用了不知道多久敲完。\n没测样例（废话）直接交了。\n其实我现在还在想，如果 WJ 的时候我去写 T2 而不是刷新看结果会不会涨个一两名\u0026hellip;\n12min 看了下 $10\\times10000\u0026lt;10^9$ 。\n用了不知道多久敲完。\n测了样例交了。\n其实我现在还在想，如果没测样例我会不会再涨个一两名\u0026hellip;\n14min 想了想还是用了快读，毕竟模板里有。\n测样例，没写cout\u0026lt;\u0026lt;ans; 。\n其实我现在还在想，其实我现在还在想，如果没测样例我会不会掉个十几名。\n16min 数据范围看起来好小。\n等等，$x$ 的范围？\n预处理汉堡的大小。\n哦，爆 int 了。\n其实我现在还在想，如果模板里有#define int long long我会不会再涨个一两名\u0026hellip;\n写个函数 work(int a) 处理大小为 $a$ 的汉堡，分类讨论乱搞一下应该就行了。\n测样例，#3 看起来好大。\n终于可以安心地看 judging 不用担心浪费时间了。\n130min Beginner 定级貌似最高 400 点 rating..\n","date":"2018-12-08T21:50:43+08:00","permalink":"https://ouuan.github.io/post/atcoder-beginner-contest-115/","tags":["AtCoder"],"title":"AtCoder Beginner Contest 115 游记"},{"categories":["题解"],"contents":"又只会写T1\u0026hellip;\n题目链接\n题意简述 给你一个排列 $p_{1..n}$，$a_{1..n}$ 为任意的一个排列，定义 $b[a_i]=a[p_i]$，求总共有多少个不同的 $b_{1..n}$ 。\n做法 首先，对 $(i,p_i)$ 连边，会得到若干个环。\n环上旋转一下（$\\forall i\\text{ on the cycle : }i\\rightarrow p_i$）得到的置换是本质相同的。节点个数相同的环互换一下是本质相同的。\n先计算把 $n​$ 个节点分成若干个环的方案数：（用 $siz[i]​$ 表示第 $i​$ 个环的大小，$k​$ 表示环的个数，$sum[i]​$ 表示 $\\sum\\limits_{j=i}^ksiz[j]​$）\n$$S_1=\\prod\\limits_{i=1}^kC_{sum[i]}^{siz[i]}$$\n然后去掉节点个数相同的环互相交换：（用 $num[i]$ 表示节点个数为 $i$ 的环的个数）\n$$S_2=\\frac{S_1}{\\prod\\limits_{i=1}^nnum[i]!}$$\n然后乘上每个环旋转（旋转造成的不同方案数即固定某个数后剩下的数的排列个数）：\n$$S_3=S_2\\times\\prod\\limits_{i=1}^k(siz[i]-1)!$$\n$S_3$ 就是最终的答案了。\n参考代码 noi.ac 上最短解（其实计算方式和我是一样的..）：\n#include\u0026lt;bits/stdc++.h\u0026gt; #define mn 1111111 using namespace std; long long n,i=1,s=1,j,x,p=998244353,a[mn],f[mn],v[mn],t[mn]; int main() { scanf(\u0026quot;%lld\u0026quot;,\u0026amp;n); f[0]=f[1]=1; for (;i\u0026lt;=n;i++) scanf(\u0026quot;%lld\u0026quot;,a+i); for (i=2;i\u0026lt;=n;i++) f[i]=f[p%i]*(p-p/i)%p,(s*=i)%=p; for (i=1;i\u0026lt;=n;i++) if (!v[i]) { for (j=i,x=0;!v[j];x++,j=a[j]) v[j]=1; (s*=f[x]*f[++t[x]]%p)%=p; } printf(\u0026quot;%lld\u0026quot;,s); }  我自己赛时的辣鸡写法：\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;cctype\u0026gt; using namespace std; int read() { int out=0; char c; while (!isdigit(c=getchar())); for (;isdigit(c);c=getchar()) { out=out*10+c-'0'; } return out; } const int N=1000010; const int M=998244353; void dfs(int u); int c(int a,int b); int n,p[N],dfn[N],low[N],sta[N],dfncnt,top,siz[N],tot,num[N]; int x,y,jc[N],inv[N],ans=1,sum; bool ins[N]; int main() { int i; n=sum=read(); for (i=1;i\u0026lt;=n;++i) { p[i]=read(); } for (i=1;i\u0026lt;=n;++i) { if (dfn[i]==0) { dfs(i); } } jc[0]=jc[1]=inv[0]=inv[1]=1; for (i=2;i\u0026lt;=n;++i) { inv[i]=(1ll*M*M-1ll*(M/i)*inv[M%i])%M; } for (i=2;i\u0026lt;=n;++i) { jc[i]=(1ll*jc[i-1]*i)%M; inv[i]=(1ll*inv[i-1]*inv[i])%M; } for (i=1;i\u0026lt;=tot;++i) { ans=1ll*ans*c(sum,siz[i])%M; sum-=siz[i]; } for (i=1;i\u0026lt;=n;++i) { ans=1ll*ans*inv[num[i]]%M; } for (i=1;i\u0026lt;=tot;++i) { ans=1ll*ans*jc[siz[i]-1]%M; } cout\u0026lt;\u0026lt;ans; return 0; } int c(int a,int b) { if (a==b||b==0) { return 1; } return 1ll*(1ll*jc[a]*inv[b]%M)*inv[a-b]%M; } void dfs(int u) { dfn[u]=low[u]=++dfncnt; sta[++top]=u; ins[u]=true; if (dfn[p[u]]==0) { dfs(p[u]); low[u]=min(low[u],low[p[u]]); } else if (ins[p[u]]) { low[u]=min(low[u],dfn[p[u]]); } if (low[u]==dfn[u]) { siz[++tot]=1; while (sta[top]!=u) { ++siz[tot]; ins[sta[top--]]=false; } ins[sta[top--]]=false; ++num[siz[tot]]; } }  所以说不要看到环就 tarjan\u0026hellip;\n","date":"2018-12-08T12:04:29+08:00","permalink":"https://ouuan.github.io/post/wc2019-%E5%85%A8%E5%9B%BD%E6%A8%A1%E6%8B%9F%E8%B5%9B%E7%AC%AC%E4%BA%8C%E5%9C%BA-t1-%E9%A2%98%E8%A7%A3/","tags":["组合数学","noi.ac"],"title":"WC2019 全国模拟赛第二场 T1 题解"},{"categories":["技术"],"contents":"折腾了 $3$ 天终于把博客搭建好了\u0026hellip;本文会简单介绍一下 hexo 博客的搭建，并选取一些我自己在配置博客的过程中遇到的问题，说明一下我的解决方案。\n实际上，hexo 博客的搭建并不难，难搞的是美化，我在这个过程中遇到了很多问题，不可能在这篇博客中全部陈述出来，最重要的还是勤于百度。\nwarning\n本博客已从 hexo 迁移至 hugo，详见 从 hexo 到 hugo 。\n 博客的搭建 先推荐两篇比较好的教程：搭建个人博客-hexo+github详细完整步骤，使用github+Hexo人人都能拥有一个美美的博客。\n这部分网上讲的已经比较好了，我在这就简单说一下。\n安装软件 需要安装的软件有：git，Node.js。\n下载安装即可\u0026hellip;\n本地设置 装好之后，在本地创建一个文件夹，下文中称其为“根目录”。\n 下文中“输入命令”均指在命令行中输入命令（并回车废话），既可以使用 git bash，也可以使用 cmd 或 powershell 。输入命令时若无特别说明都需要 cd 到根目录下。\n 输入命令 npm install -g hexo 来安装 hexo 。\n输入命令 hexo init 来初始化 hexo 。\n输入命令 npm install  来安装一些需要的包。\n输入命令 hexo s，并在浏览器打开 localhost:4000，在本地预览博客；如果上文步骤进行正确，应该看到一个类似于这样的页面：\n 注：命令可以缩写，条件是没有开头几个字母相同的其它命令。hexo s 实际上是 hexo server 的缩写；下文中 hexo d 是 hexo deploy 的缩写，hexo g 是 hexo generate 的缩写；hexo clean 不能缩写为 hexo c，因为存在命令 hexo config ，但是可以缩写为 hexo cl 。\n 按 Ctrl+C 关闭 server 以继续操作。（若出现类似于 终止批处理操作吗(Y/N)? 的提示，输入 y 即可。）\n接着安装博客的主题，可以在 hexo 官网 选择主题下载，本篇教程推荐使用 NexT 主题。\n在 hexo 官网 点击图片下方蓝色的文字即可打开主题的 GitHub 主页，一般来说，一个主题的 GitHub 主页上是有用于安装的命令以及配置博客的教程的。\n如果没有的话（或者即使有也一样），你应该输入命令 git clone 主题的Github主页地址 themes/主题名  。例如：git clone https://github.com/theme-next/hexo-theme-next themes/next 。\n当然，你也可以使用默认的 landscape 主题，从而不用额外下载主题。\n下载好主题后，用任何一款文本编辑器（记事本也可以），打开根目录下的 _config.yml ，将 theme: landscape 修改为 theme: 你想用的主题名 即可。\n配置 GitHub 仓库 首先你需要有一个 GitHub 账号。\n然后点击右上角你的头像，打开“Your repositories”，点击绿色的按钮“New”。\n在\u0026quot;Repository name”一栏填入 yourname.github.io （“yourname”指你的 GitHub ID，比如我就填 ouuan.github.io），\u0026ldquo;Description\u0026quot;可以随便填也可以不填，然后点绿色的按钮“Create repository”。\n将博客上传至 GitHub 输入命令 ssh-keygen 来生成 SSH，让你输入东西你就空着，按回车（应该要按三次回车）。\n然后用任意的文本编辑器打开 C:\\Users\\电脑用户名\\.ssh\\id_rsa.pub（如果装了 vim 可以直接输入命令 vim ~/.ssh/id_rsa.pub），复制里面的内容。\n打开 GitHub，点击右上角的头像，打开“Settings”，选择左边的“SSH and GPG keys”，点绿色的按钮“New SSH key”，Title 随便填，下面的 Key 把刚才复制的东西粘贴进去，然后点绿色的按钮“Add SSH key”。过程中可能需要输入密码。\n输入命令 ssh -T git@github.com ，若出现 Hi yourname! You've successfully authenticated, but GitHub does not provide shell access. 表示 SSH 配置成功。\n输入命令 npm install hexo-deployer-git --save 安装 deployer 。\n打开根目录下的 _config.yml ，将最后几行改为：\ndeploy: type: git repository: https://github.com/yourname/yourname.github.io.git branch: master  当然\u0026quot;yourname\u0026quot;要改成你的 GitHub ID 。\n依次输入命令：\nhexo clean hexo g hexo d  这一步可能要输入密码。\n等几分钟，再用浏览器打开 yourname.github.io ，应该就可以看到你的博客了。（此时别人也可以通过这个网址看到你的博客。）\n博客的配置与美化 根目录下的 _config.yml 这部分参考官网教程即可。\n建议不要像我一样 permalink 设成 title/\u0026hellip;博客写多了之后，如果博客全放在根目录，就会非常自闭。（试想一下你哪天写到了 1000 篇博客，然后打开博客 repo，显示 Sorry, we had to truncate this directory to 1,000 files.，整个页面都是乱七八糟的博文名称）。可以设成 blog/title 之类的，总之不要全放根目录。\n可以在 highlight.tab_replace 设置将缩进替换为什么，默认是长度为八空格的制表符。例如：\nhighlight: enable: true line_number: true auto_detect: false tab_replace: ' '  主题目录下的 _config.yml 主题目录下的 _config.yml 指 \\themes\\主题名\\_config.yml。\n这里以 NexT 主题（本文基于 NexT 6.6，其它版本可能有些区别）为例，这个主题的 _config.yml 非常完备，修改配置基本上只需删除/添加注释符号 # 以及改变 true/false 即可。\n选择 NexT 主题的四种之一 # Schemes scheme: Muse #scheme: Mist #scheme: Pisces #scheme: Gemini  将想用的主题前的 # 删掉，在 scheme: Muse 前加上 # 即可。\n例如：\n# Schemes #scheme: Muse #scheme: Mist #scheme: Pisces scheme: Gemini  四种主题的预览在 NexT 主题的官网有。\n改变网站图标 favicon: small: /images/favicon-16x16-next.png medium: /images/favicon-32x32-next.png apple_touch_icon: /images/apple-touch-icon-next.png safari_pinned_tab: /images/logo.svg  将你想用的图标放在 \\themes\\next\\source\\images 里，然后修改上面的文件名即可。\n例如：\nfavicon: small: /images/favicon16.png medium: /images/favicon32.png  页脚设置 footer: # Specify the date when the site was setup. # If not defined, current year will be used. #since: 2015 # Icon between year and copyright info. icon: # Icon name in fontawesome, see: https://fontawesome.com/v4.7.0/icons # `heart` is recommended with animation in red (#ff0000). name: battery-full # If you want to animate the icon, set it to true. animated: false # Change the color of icon, using Hex Code. color: \u0026quot;#808080\u0026quot; # If not defined, will be used `author` from Hexo main config. copyright: # ------------------------------------------------------------- powered: # Hexo link (Powered by Hexo). enable: false # Version info of Hexo after Hexo link (vX.X.X). version: true theme: # Theme \u0026amp; scheme info link (Theme - NexT.scheme). enable: true # Version info of NexT after scheme info (vX.X.X). version: true # ------------------------------------------------------------- # Beian icp information for Chinese users. In China, every legal website should have a beian icp in website footer. # http://www.miitbeian.gov.cn beian: enable: false icp:  icon： © 2019 与用户名之间的图标。（图中 $1$）\n图标名称为 Font Awesome 上的图标名称。\npowered.enable：为 true 则会显示“由 Hexo 强力驱动”。（图中 $2$）\npowered.version：为 true 则会显示 Hexo 的版本。（图中 $3$）\ntheme.enable：为 true 则会显示“主题 – NexT.XX”。（图中 $4$）\ntheme.version：为 true 则会显示主题的版本。（图中 $5$）\n注：根据 NexT 主题的 LICENSE，footer 中必须开启 theme.enable 选项。\n“关于”\u0026amp;\u0026ldquo;标签\u0026rdquo; menu: home: / || home about: /about/ || user tags: /tags/ || tags #categories: /categories/ || th archives: /archives/ || archive #schedule: /schedule/ || calendar #sitemap: /sitemap.xml || sitemap #commonweal: /404/ || heartbeat  将需要的项目取消注释即可在侧边栏显示。\n如果需要使用“关于”页面，输入命令 hexo new page \u0026quot;about\u0026quot;。\n然后在 \\source\\about\\index.md 中就可以编辑“关于”页面了。\n可以修改 \\source\\about\\index.md 中的 title 项来显示“关于”而非“about”。\n如果需要使用“标签”功能，需要在博文中添加选项 tags ：\n如果有多个标签，每行一个，以 -  开头：\ntags: - 标签1 - 标签2 - 标签3  如果需要使用“标签”页面，输入命令 hexo new page \u0026quot;tags\u0026quot;。\n然后向 source\\tags\\index.md 中添加一行：\ntype: \u0026quot;tags\u0026quot;  “分类”与“标签”类似。\n站内搜索 输入命令 npm install hexo-generator-searchdb --save 安装所需的库。\n在根目录下的 _config.yml 的结尾加入：\nsearch: path: search.xml field: post format: html limit: 10000  然后在 \\themes\\next\\_config.yml 中，打开 local_search：\nlocal_search: enable: true  社交网站 # Social Links. # Usage: `Key: permalink || icon` # Key is the link label showing to end users. # Value before `||` delimeter is the target permalink. # Value after `||` delimeter is the name of FontAwesome icon. If icon (with or without delimeter) is not specified, globe icon will be loaded. social: GitHub: https://github.com/ouuan || github 洛谷: https://www.luogu.org/space/show?uid=49742 || code Codeforces: https://www.codeforces.com/profile/ouuan || code b站: https://space.bilibili.com/11067182 || tv social_icons: enable: true icons_only: false transition: false  在 social 下每行一个，格式为：名称: 地址 || 图标。\n其中，“图标”为 Font Awesome 图标名称，但有些图标是不可用的，而且图标也不全，使用的时候要尝试一下图标是否可用。\nsocial_icons: enable: false  这样设置可以只显示名称不显示图标。\n友情链接（或其它链接） # Blog rolls links_icon: globe links_title: 友情链接 # links_layout: block links_layout: inline links: Dew: https://www.cnblogs.com/ppprseter/ wjyyy: https://www.wjyyy.top/ Sooke: https://www.luogu.org/blog/Sooke/ huyufeifei: https://www.cnblogs.com/huyufeifei/ Rye_Catcher: https://rye-catcher.github.io/ 额冻豆腐: http://www.mayflyyh.com/  links_icon：显示在标题前的图标。\nlinks_title：标题。\nlinks_layout：block 一行一个，inline 一行多个。\nlinks：要显示的链接以及名称。\n头像 # Sidebar Avatar avatar: # in theme directory(source/images): /images/avatar.gif # in site directory(source/uploads): /uploads/avatar.gif # You can also use other linking images. url: /images/avatar.jpg # If true, the avatar would be dispalyed in circle. rounded: true # The value of opacity should be choose from 0 to 1 to set the opacity of the avatar. opacity: 1 # If true, the avatar would be rotated with the cursor. rotated: false  url：头像地址，留空则不显示头像。\nrounded：圆/方头像。\nopacity：不透明度。\nrotated：随光标旋转。\n回到顶部按钮/阅读百分比  # Back to top in sidebar (only for Pisces | Gemini). b2t: true # Scroll percent label in b2t button. scrollpercent: true  博客首页不显示全文 在博文里可以用 \u0026lt;!-- more --\u0026gt; 来标识在首页显示到哪为止。\n可以在 \\themes\\next\\_config.yml 里设置到一定字数自动不显示全文：\n# Automatically Excerpt. Not recommend. # Please use \u0026lt;!-- more --\u0026gt; in the post to control excerpt accurately. auto_excerpt: enable: true length: 150 # Read more button # If true, the read more button would be displayed in excerpt section read_more_btn: true  length：不显示全文的字数上限。\nread_more_btn：代码块复制按钮 codeblock: # Manual define the border radius in codeblock # Leave it empty for the default 1 border_radius: # Add copy button on codeblock copy_button: enable: true # Show text copy result show_result: true  enable：启用复制按钮。\nshow_result：$\\LaTeX$ # Math Equations Render Support math: enable: true # Default(true) will load mathjax/katex script on demand # That is it only render those page who has 'mathjax: true' in Front Matter. # If you set it to false, it will load mathjax/katex srcipt EVERY PAGE. per_page: false engine: mathjax #engine: katex  enable：启用 $\\LaTeX$ 。\nper_page：为 true 则只有博文中有 mathjax: true 才会启用 $\\LaTeX$，否则每篇博客都会启用 $\\LaTeX$ 。\nengine：推荐使用 mathjax 。\nhexo 博客的 mathjax 和 Markdown 有一些冲突，将在后文专门讲解如何解决冲突。\n访客统计 busuanzi_count: enable: true  书签 书签的功能是关闭页面/手动点击书签按钮时，保存这篇博客看到的位置，下次点进这篇博客时继续从这个位置开始。\n安装插件：git clone https://github.com/theme-next/theme-next-bookmark.git source/lib/bookmark\n更改 \\themes\\next\\_config.yml：\n# Bookmark Support # Dependencies: https://github.com/theme-next/theme-next-bookmark bookmark: enable: true # if auto # - save the reading position when closing the page # - or clicking the bookmark-icon # if manual, only save it by clicking the bookmark-icon save: manual  其它配置 博客背景 打开 \\themes\\next\\source\\css\\_custom\\custom.styl，输入：\nbody { background-image:url(/images/background.jpg); background-size: cover; }  把背景图片重命名为 background.jpg，放入 \\themes\\source\\images（当然也可以更改background-image:url()）。\nbackground-size: cover; 表示宽度缩放至页面大小。\nbody { background-image:url(/images/background.jpg); background-repeat: no-repeat; background-attachment:fixed; background-size: cover; }  如果修改成这样的话背景图片就不会滚动。\n如果不想让博客内容挡住背景，可以设置博客内容的透明度，在 \\themes\\next\\source\\css\\_custom\\custom.styl 中加入下面的代码即可：\n.main-inner { opacity: 0.9; }  评论功能 由于 Gitalk 存在一些安全性的问题（OAuth App 的 client_id 和 client_secret 是可见的、访客需要授予读写自己的 repo 的权限），并且稳定性较差，推荐使用 utterances。\n在 https://utteranc.es/ 中进行设置，将配置代码放到 \\themes\\next\\layout\\_partials\\comments.swig 中即可，如：\n{% if page.comments %} \u0026lt;div class=\u0026quot;comments\u0026quot;\u0026gt; \u0026lt;script src=\u0026quot;https://utteranc.es/client.js\u0026quot; repo=\u0026quot;ouuan/blog-comments\u0026quot; issue-term=\u0026quot;title\u0026quot; label=\u0026quot;utterances\u0026quot; theme=\u0026quot;github-light\u0026quot; crossorigin=\u0026quot;anonymous\u0026quot; async\u0026gt; \u0026lt;/script\u0026gt; \u0026lt;/div\u0026gt; {% if theme.facebook_sdk.enable and theme.facebook_comments_plugin.enable %} ...  其实也可以安装 hexo-next-utteranc 插件，但没必要。\n另外，用于存放 issue 的 repo 需要安装 utterances app。\n博文自定义排序 打开 \\node_modules\\hexo-generator-index\\lib\\generator.js 。\n在末尾添加如下代码：\n posts.data = posts.data.sort(function(a, b) { if(a.top \u0026amp;\u0026amp; b.top) { if(a.top == b.top) return b.date - a.date; else return b.top - a.top; } else if(a.top \u0026amp;\u0026amp; !b.top) { return -1; } else if(!a.top \u0026amp;\u0026amp; b.top) { return 1; } else return b.date - a.date; });  在博文设置中加入 top: x 即可，会以 top 为第一关键字，时间为第二关键字排序。若 top 为空则视作 -INF 。\n折叠块 怎么搞？ 标题链接的这篇博文写的够清楚了..\n需要注意的是这个折叠块标题的字体被设置了..如果想和博文用同样的字体，需要删去 font-family: \u0026quot;Microsoft Yahei\u0026quot;;。\n README.md 如果想在 https://github.com/yourname/yourname.github.io 让别人看到你的博客的简介，就需要写一个 README.md 放在根目录下的 source 文件夹内。\n然而，只是这样的话， README.md 会被渲染成 html，所以需要更改根目录下 _config.yml 的设置：\nskip_render: README.md  自定义404页面 首先写一个 \\source\\404.html 。\n至于怎么写html..这里地方太小写不下。\n**需要注意的是，一个真正的 404 页面应当在访问时返回 404 代码。**在 HTML 中，可以使用 \u0026lt;meta http-equiv=\u0026quot;Content-Security-Policy\u0026quot; content=\u0026quot;connect-src 'self'\u0026quot;\u0026gt; 实现。（似乎不加这个也会返回 404？不是特别清楚。）\n可以参考一下我的：\n\u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta http-equiv=\u0026quot;Content-type\u0026quot; content=\u0026quot;text/html; charset=utf-8\u0026quot;\u0026gt; \u0026lt;meta http-equiv=\u0026quot;Content-Security-Policy\u0026quot; content=\u0026quot;connect-src 'self'\u0026quot;\u0026gt; \u0026lt;title\u0026gt;404 Error | ouuan的博客\u0026lt;/title\u0026gt; \u0026lt;link rel=\u0026quot;icon\u0026quot; type=\u0026quot;image/png\u0026quot; sizes=\u0026quot;32x32\u0026quot; href=\u0026quot;/favicon-32x32.png\u0026quot;\u0026gt; \u0026lt;link rel=\u0026quot;icon\u0026quot; type=\u0026quot;image/png\u0026quot; sizes=\u0026quot;16x16\u0026quot; href=\u0026quot;/favicon-16x16.png\u0026quot;\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div\u0026gt; \u0026lt;p style=\u0026quot;text-align: center;\u0026quot;\u0026gt;\u0026lt;strong\u0026gt;您可能访问了错误的网址\u0026lt;/strong\u0026gt;\u0026lt;img src=\u0026quot;/images/5bd4705dd844f.jpg\u0026quot;\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;br\u0026gt;\u0026lt;br\u0026gt; \u0026lt;p style=\u0026quot;text-align: center;\u0026quot;\u0026gt;\u0026lt;strong\u0026gt;您现在可以：\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;p style=\u0026quot;text-align: center;\u0026quot;\u0026gt;\u0026lt;a href=\u0026quot;/\u0026quot;\u0026gt;\u0026lt;strong\u0026gt;回到博客主页\u0026lt;/strong\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;p style=\u0026quot;text-align: center;\u0026quot;\u0026gt;\u0026lt;a href=\u0026quot;javascript:history.go(-1);\u0026quot;\u0026gt;\u0026lt;strong\u0026gt;返回上一页\u0026lt;/strong\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;br\u0026gt;\u0026lt;br\u0026gt; \u0026lt;p style=\u0026quot;text-align: center;\u0026quot;\u0026gt;\u0026lt;strong\u0026gt;如果您在登录 Gitalk 时遇到此问题，请尝试\u0026lt;a href=\u0026quot;/%E5%A5%BD%E7%94%A8%E7%9A%84%E7%BD%91%E7%AB%99/\u0026quot;\u0026gt;换一篇博客\u0026lt;/a\u0026gt;登录\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt;  然后，如果直接这样发布，html 会被渲染，就跟一个自定义页面（hexo new page）一样了。\n所以要修改根目录下的 _config.yml，在 skip_render: 后添加 404.html，如果有多项用 -  隔开：\nskip_render: - README.md - 404.html  发布完成后，访问一个错误的网址，比如 你的域名/qaq 就可以查看效果了。\n一言（ヒトコト） 大约是这个。\n网上没找到教程，自己随便瞎研究了一波，所以方法比较丑陋，仅供参考..\n本来想稍微写一下自己研究的经过，想了想自己也没完全搞清楚，就来一波授人以鱼吧\u0026hellip;\n\\themes\\next\\layout\\_macro\\sidebar.swig:\n…… \u0026lt;aside id=\u0026quot;sidebar\u0026quot; class=\u0026quot;sidebar\u0026quot;\u0026gt; \u0026lt;div class=\u0026quot;sidebar-inner\u0026quot;\u0026gt; \u0026lt;div class=\u0026quot;hitokoto-block\u0026quot;\u0026gt; \u0026lt;div class=\u0026quot;hitokoto-inner hitokoto-comma hitokoto-left-comma\u0026quot;\u0026gt;“\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026quot;hitokoto-inner hitokoto-content\u0026quot;\u0026gt;\u0026lt;b\u0026gt;\u0026lt;span\u0026gt;\u0026lt;span id=\u0026quot;hitokoto-content\u0026quot;\u0026gt;\u0026lt;/span\u0026gt;\u0026lt;/span\u0026gt;\u0026lt;/b\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026quot;hitokoto-inner hitokoto-comma hitokoto-right-comma\u0026quot;\u0026gt;”\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div id=\u0026quot;hitokoto-from\u0026quot;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026quot;hitokoto-bottom\u0026quot;\u0026gt; \u0026lt;a id=\u0026quot;hitokoto-link\u0026quot; href=\u0026quot;https://hitokoto.cn/\u0026quot;\u0026gt;Hitokoto\u0026lt;/a\u0026gt;\u0026amp;nbsp;\u0026amp;nbsp;\u0026amp;nbsp; \u0026lt;button id=\u0026quot;hitokoto-like\u0026quot; title=\u0026quot;通过给句子点赞可以增加其出现概率，由于技术原因并不能在博客中显示赞数与点赞是否成功的信息（红心表示成功发送点赞请求，但如果同 IP 重复点赞就会失败），如需查看可以点击左边的“Hitokoto”链接。\u0026quot;\u0026gt;\u0026lt;i class=\u0026quot;menu-item-icon fa fa-fw fa-heart\u0026quot;\u0026gt;\u0026lt;/i\u0026gt;\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div style=\u0026quot;height: 15px\u0026quot;\u0026gt;\u0026lt;/div\u0026gt; {% if theme.sidebar.onmobile %} ……  \\themes\\next\\layout\\_scripts\\commons.swig:\n…… \u0026lt;script type=\u0026quot;text/javascript\u0026quot;\u0026gt; function hitokotoLike(x, y) { $.ajax({ url: \u0026quot;https://hitokoto.cn/Like\u0026quot;, type: \u0026quot;GET\u0026quot;, data: \u0026quot;ID=\u0026quot; + x, dataType: \u0026quot;jsonp\u0026quot;, success: function(data) { alert(data.message); $(y).css('color', 'red'); }, error: function() { console.log('Hitokoto Like Request Error.'); $(y).css('color', 'red'); } }); } $.get('https://v1.hitokoto.cn/?c=a', function(data) { $('#hitokoto-content').css('display', '').text(data.hitokoto); $('#hitokoto-from').css('display', '').text('——' + data.from); $('#hitokoto-from').attr('title', '上传者: ' + data.creator); $('#hitokoto-link').attr('href', 'https://hitokoto.cn/?id=' + data.id); document.getElementById('hitokoto-like').onclick = function() { hitokotoLike(data.id, '#hitokoto-like'); } }); \u0026lt;/script\u0026gt;  \\themes\\next\\source\\css\\_custom\\custom.styl:\n…… .sidebar { background: rgba(0, 0, 0, 0); } .hitokoto-block { width: 200px; display: table; padding: 0 10px; } .hitokoto-inner { text-align: left; display: table-cell; } .hitokoto-comma { color: #B2B7F2; font-size: 24px; font-weight: bold; font-family: 'Times New Roman', serif; } .hitokoto-left-comma { vertical-align: top; } .hitokoto-right-comma { vertical-align: bottom; } .hitokoto-content { width: 176px; color: burlywood; text-indent: 2em; vertical-align: middle; padding: 0.8em 0.2em 1em 0.2em; } #hitokoto-from { text-align: right; font-size: 0.8em; color: black; } .hitokoto-bottom { margin-top: 15px; font-size: 0.8em; color: black; }  大约就这样，省略号表示文件中本来就有的其它部分。不保证在其他人电脑上可以用。大致思路就是搞个空 div 指定一个 id，用 js 往里面塞东西。所以即使我这个“鱼”不能直接用大约也是可以稍微研究研究来用的。\n博文复制提醒 在 \\themes\\next\\layout\\_scripts\\commons.swig 中加入：\n\u0026lt;script type=\u0026quot;text/javascript\u0026quot;\u0026gt; $('.post-body').bind('copy', function() { alert('本博客内容欢迎分享（将本博客的原文地址分享到其它网站），允许部分摘录并在醒目位置附上原文链接，未经许可禁止任何形式的全文转载。'); }); \u0026lt;/script\u0026gt;  更改 CSS 大概按照 谢益辉博客 魔改了一下。\nCSS Files。\nEmoji 详见 crimx/hexo-filter-github-emojis 🤔 。\n安装的时候遇到了一些问题，具体来说执行 npm install hexo-filter-github-emojis --save 不会安装 peer dependencies，需要手动安装（从警告信息就可以看出需要安装哪些）。而在安装 canvas 时出现错误，更新 node-pre-gyp 后得到了解决。\n大约是为了保证用户能够看到，很多显示 emoji 的库（如 emojione）都是使用 cdn 加载图片，然而我还是觉得 Win 10 本身的 emoji 样式比较好看，Linux 的也不错，所以又稍微魔改了一下，改成了显示 Unicode 字符而非图片。具体来说，将 \\node_modules\\hexo-filter-github-emojis\\index.js 中的 renderEmoji 函数中的全部内容替换成了 return emojis[name].codepoints ? emojis[name].codepoints.map(c =\u0026gt; `\u0026amp;#x${c};`).join('') : ' '; 。\n博客的写作 Markdown 的使用 网上有很多 Markdown 的学习资源，我自己是在洛谷剪贴板学会的。\n我以前一般都用洛谷剪贴板编辑 Markdown，但 hexo 博客需要在本地编辑 .md 文件，这时普通的文本编辑器就不太方便了。我推荐 Typora 这款软件，还是挺方便的。\n撰写博客前的准备 打开根目录下的 _config.yml ，将 post_asset_folder 设为 true。\n这样就可以把图片放到博客里而不用其它图床了。\n然后把 \\source\\_posts\\hello-world.md 删除。\n博文的撰写 新建一篇博客：hexo new \u0026quot;博文标题\u0026quot;。\n然后等几秒钟，在 \\source\\_posts 文件夹下，就会生成 博客名 这个文件夹（如果你把 post_asset_folder 设为 true 了）以及 博客名.md。\n撰写博客就是编辑 博客名.md。\n这个文件的开头是博客的一些设置，可以在 \\scaffolds\\posts.md 中修改默认设置，我的默认设置是：\n--- title: {{ title }} date: {{ date }} tags: top: ---  然后就可以写 Markdown 格式的文章了。（top 是自定义文章排序，上文中介绍过）\n需要注意的是，在洛谷代码块可以不加\u0026quot;cpp\u0026rdquo;，但在 hexo 上，一定要加上\u0026quot;cpp\u0026rdquo;：\n#include \u0026lt;iostream\u0026gt; int main() { cout\u0026lt;\u0026lt;\u0026quot;hello world!\u0026quot; }  #include \u0026lt;iostream\u0026gt; int main() { cout\u0026lt;\u0026lt;\u0026quot;hello world!\u0026quot; }  更多博文模板 在 \\scaffolds 文件夹中可以增加更多的模板，比如我就搞了一个 \\scaffolds\\tutorial.md，这样的话，新建一篇题解的时候输入命令 hexo new tutorial \u0026quot;博文标题\u0026quot; 就可以使用模板了。\n引用本地图片 引用链接/网络上的图片格式与普通 Markdown 相同（[链接名称](链接地址) 和 ![图片描述](图片地址)），引用本地图片需要把 post_asset_folder 设为 true ，然后把图片放在与博客同名的文件夹中，然后只用 ![图片描述](图片文件名) 就可以引用了。\n在编辑器里显示不出图片是正常的。\n还有另一种方式引用图片，![refpic](/post_img/hexo博客搭建指北/refpic.jpg 这是一张用这种方式引用的图片)\n用这种方式引用图片的话，把鼠标放在上面会显示图片描述（上面这张图就是用这种方式引用的）。\n只有这种方式引用图片才能在博客首页正常显示图片，否则只能点进博客才能看到图片。\n$\\LaTeX$ 的使用 $\\LaTeX$ 概述 $\\LaTeX$ 主要用于编辑数学公式，十分方便，网上也有很多学习资源，比如：LaTeX数学公式大全。\n在支持 $\\LaTeX$ 的 Markdown 文档里，使用两个美元符号将 $\\LaTeX$ 公式括起来，例如：\n~~QAQ$f_i=\\sum\\limits_{j=1}^ia_j$f_i=\\sum\\limits_{j=1}^ia_j~~  QAQ$f_i=\\sum\\limits_{j=1}^ia_j$f_i=\\sum\\limits_{j=1}^ia_j\n也可以用一对双美元符号使公式居中显示在单行，例如：\n$f_i=1$ $$f_i=1$$  $f_i=1$\n$$f_i=1$$\n在 Typora 中使用 $\\LaTeX$ 需要将设置中的\u0026quot;Markdown 扩展语法\u0026quot;全部勾选。\n P.S. $\\LaTeX$：\\LaTeX\n 启用 $\\LaTeX$ 在 \\themes\\next\\_config.yml 中将 mathjax 设为 true，然后将 per_page 设为 false 或者在需要启用 \\LaTeX 的博文开头加上 mathjax: true 。\n解决冲突 由于hexo博客中即使是 $$ 内的字符也会被当成 Markdown 渲染，类似于 $f_{f_i}$、$a*b*c$、$[x,y](1\u0026lt;x\u0026lt;y\u0026lt;2)$ 之类的，都会被错误地渲染。\n对于下划线，新版本的 marked 已经修复这一 bug（新版本的 hexo 或许已经不需要手动升级了），所以可以通过执行 npm install --save marked 和 npm install --save hexo-renderer-marked 解决。但同时，新版本的 marked 会将 \\ 用作转义，所以 \\\\ 、 \\{ 之类的要改成 \\\\\\\\ 、 \\\\{ 。\n对于 *，建议使用 $\\cdot$ ($a\\cdot b$，一般用于表示乘积) 或 $\\times$ （$n\\times m$ 的矩阵，一般用于表示维度或者笛卡尔积）或 $\\ast$ （$\\mathbb{N}^\\ast$，一般用于上标或表示卷积） 代替。其实也可以使用 $\\*$ 来代替 $\\ast$ 。\n对于 $[x,y](1\u0026lt;x\u0026lt;y\u0026lt;2)$，在它们之间加上空格，即 $[x,y] (1\u0026lt;x\u0026lt;y\u0026lt;2)$ 就好了。\n博客的发布 其实前文提到过，依次输入以下三条命令即可：\nhexo cl hexo g hexo d  hexo cl 是可选的。加上不会有坏处..而且有时候必须加上。\n发布之前还可以执行 hexo s 并在本地使用浏览器打开 localhost:4000 进行预览。\n当然也可以使用 hexo g -d 命令。\n","date":"2018-12-06T16:00:37+08:00","permalink":"https://ouuan.github.io/post/hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E6%8C%87%E5%8C%97/","tags":["博客"],"title":"hexo博客搭建指北"},{"categories":null,"contents":" 在本博客，推荐安装 思源宋体 以获得更好的阅读体验。\n本博客中还有少量含有中文的 LaTeX 公式，所以推荐安装 MathJax 的 Unicode 字体 Arial Unicode MS 。\n Q: 博客里的 XX 功能是怎么做到的啊？\nA: 本博客所有代码 开源，并提供一个可以制作自己博客的 模板。请先自己找，还可以参考 从 Hexo 到 Hugo，找不到可以在评论区问。\nQ: 为什么大部分题解里的题意简述数据范围不全，甚至不太看得懂？\nA: 因为这是题解不是题面，题意简述的目的是让人尽快知道题目大意，而不是确保能够让人读懂、能够据此写出 AC 代码。如果看不懂/想知道详细的数据范围，可以去 OJ 上看。\n 头像不是我自己画的。\n  HB OIer，已退役。 Arch Linux / KDE / yakuake / Oh My Zsh / VS Code / Firefox GitHub: CP Editor, OI Wiki 等。 最喜欢的番剧/漫画是 3月のライオン，同时还是 μ\u0026rsquo;ser，CLer，海子姐单推，偶尔做做视频。 十六型人格测试 中的 “逻辑学家” 人格。 GPG key: 863A0F9FA8127FA4   初三：\nNOIP2017 普及组一等 $230$（HB $rank$ $4$）\nNOIP2017 提高组二等 $160$（HB $rank$ $43$）\nHBSX2018 非正式选手 $180$（HB $rank$ $4$）\n高一：\nNOIP2018 提高组一等 $489$（CN $rank$ $329$）\nTHUWC2019 没约 invisible（CN 垫底）\nWC2019 Ag $99$（CN $rank$ $119$）\nHBSX2019 被爆踩 $247$（HB $rank$ $4$）\nCTS2019 Ag $156$（CN $rank$ $126$）\nAPIO2019 Cu $113$（CN $rank$ $256$）\nTHUSC2019 三等 invisible（CN $rank$ $?$）\nCodeforces Round #564 出题人之一 \u0026amp; 主要组织者\n2019.6.13 CF Contribution 134（CN $rank$ $1$）\nNOI2019 Cu $376$（CN $rank$ $178$）\n高二：\nCSP-S2019 一等 $433$ (CN $rank$ $238$)\nTHUWC2019-2 一等 invisible (一等里垫底)\nNOI Online Round 1 $180$ （垫底）\nNOI Online Round 2 $300$\nNOI Online Round 3 $200$ （垫底）\nHBSX2020 $295$ （HB $rank$ $7$）\nWC2020 Ag $75$ (CN $rank$ $130$)\nAPIO2020 Ag $119$ (CN $rank$ $171$)\nNOI2020 Ag $322$ (CN $rank$ $153$)\n 这个赞赏码的 SHA256 校验和为 003dc4bb97e94296a35666aedfa599c5cdce81f762cad8647df48787548e6545。\n你还可以用 GPG key 863A0F9FA8127FA4 和 GPG signature 来验证这个赞赏码：\n 下载 赞赏码图片 和 签名文件。 在以上两个文件都存在的目录下，运行 gpg --verify wechat-sponsor.jpg.sig。   ","date":"2018-12-05T13:40:21+08:00","permalink":"https://ouuan.github.io/about/","tags":null,"title":"关于"},{"categories":["题解"],"contents":"由于只会T1，没法写游记，只好来写题解了\u0026hellip;\n题目链接\n题目大意 给你一个数列，每次可以任取两个不相交的区间，取一次的贡献是这两个区间里所有数的最小值，求所有取法的贡献和，对 $10^9+7$ 取模。\n数列长度 $2\\times 10^5$ ，值域 $1$ ~ $10^9$ 。\n$O(n^4)$ 做法 预处理区间最小值，枚举选的两个区间。\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; const int M=1000000007; int n,a[60][60],ans; int main() { int i,j,k,l; cin\u0026gt;\u0026gt;n; for (i=1;i\u0026lt;=n;++i) { cin\u0026gt;\u0026gt;a[i][i]; } for (i=1;i\u0026lt;n;++i) { for (j=i+1;j\u0026lt;=n;++j) { a[i][j]=min(a[i][j-1],a[j][j]); } } for (i=1;i\u0026lt;n;++i) { for (j=i;j\u0026lt;n;++j) { for (k=j+1;k\u0026lt;=n;++k) { for (l=k;l\u0026lt;=n;++l) { ans=(ans+min(a[i][j],a[k][l]))%M; } } } } cout\u0026lt;\u0026lt;ans; return 0; }  $O(nlogn)$ 做法  warning：接下来的文章里“的”字嵌套情况非常严重，文字叙述比较繁杂，看不懂十分正常，建议看懂一小部分然后自己推。\n 考虑每个元素作为贡献的区间是哪些，为了把每个区间分给唯一的元素，规定一个区间的贡献是最小值里最靠左的（ e.g. 4 3 2 4 2 2 的贡献是 $3$ 号元素，即最左边的 $2$ ）。所以，可以利用栈在 $O(n)$ 的时间内预处理出每个元素作为贡献的区间的左端点和右端点的范围：\nfor (i=1;i\u0026lt;=n;++i) { while (top\u0026amp;\u0026amp;a[sta[top]].w\u0026gt;a[i].w) { a[sta[top--]].r=i-1; } sta[++top]=i; } while (top) { a[sta[top--]].r=n; } for (i=n;i\u0026gt;=1;--i) { while (top\u0026amp;\u0026amp;a[sta[top]].w\u0026gt;=a[i].w) { a[sta[top--]].l=i+1; } sta[++top]=i; } while (top) { a[sta[top--]].l=1; }  每个元素作为贡献的区间就是 $[x,y] (l_i\\le x\\le i\\le y\\le r_i)$，每个元素作为贡献的区间数就是 $t_i=(i-l_i+1)\\times(r_i-i+1)$ 。\n然后，将元素按值从大到小排序，就能计算出区间数的后缀和 $suf[i]$，但一个元素的总贡献并不是 $t_i\\times suf[i+1]$，因为这些区间可能与当前元素作为贡献的区间相交。\n注意到，要想和当前元素作为贡献的区间相交，必须 $[x,y] (l_i\\le x\\le y\\le r_i)$ ，而这样的区间除了当前元素作为贡献的区间，贡献都排在当前元素之后（值比当前元素大或值相等但位置靠后），所以这样的区间除了当前元素作为贡献的区间，都是我们要找的与当前元素作为贡献的区间相交的贡献更靠后的区间。\n 注：下面这段话中“相交的区间对”指（与当前元素作为贡献的区间相交的贡献更靠后的区间，当前元素作为贡献的区间）这样的一对区间；“相交的区间”指与当前元素作为贡献的区间相交的贡献更靠后的区间。\n 接下来就要计算相交的区间有多少对。首先，相交的区间不可能跨过当前元素，否则就是当前元素作为贡献的区间；所以，相交的区间要么是 $[x,y] (l_i\\le x\\le y\u0026lt;i)$ ，要么是 $[x,y] (i\u0026lt;x\\le y\\le r_i)$。先计算 $[x,y] (l_i\\le x\\le y\u0026lt;i)$ 与当前元素作为贡献的区间相交的对数，先考虑 $y$ 固定时，个数为 $(r_i-i+1)\\times(y-l_i+1)^2$ ，其中：$y-l_i+1$ 既是相交的区间左端点的个数，也是与相交的区间相交的当前元素作为贡献的区间的左端点的个数；$r_i-i+1$ 是与相交的区间相交的当前元素作为贡献的区间的右端点的个数。所以，总数是 $(r_i-i+1)\\times\\sum\\limits_{y=l_i}^{i-1}(y-l_i+1)^2$ ，乘号右边是自然数平方和，可以用公式计算，所以就是 $(r_i-i+1)\\times\\frac{(i-l_i)\\times(i-l_i+1)\\times(2i-2l_i+1)}6$ 。$[x,y] (i\u0026lt;x\\le y\\le r_i)$ 同理，总数为 $(i-l_i+1)\\times\\frac{(r_i-i)\\times(r_i-i+1)\\times(2r_i-2i+1)}6$ 。\n所以，把相交的总对数减掉就可以了。\n参考代码：\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;cctype\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; int read() { int out=0; char c; while (!isdigit(c=getchar())); for (;isdigit(c);c=getchar()) { out=out*10+c-'0'; } return out; } const int N=200010; const int M=1000000007; const int SIX=166666668; //6模1e9+7的逆元 struct Node { long long id,w,l,r,t; bool operator\u0026lt;(const Node\u0026amp; b) const { return w\u0026lt;b.w; } } a[N]; long long n,suf[N],sta[N],top,ans; int main() { int i; n=read(); for (i=1;i\u0026lt;=n;++i) { a[i].w=read(); a[i].id=i; } for (i=1;i\u0026lt;=n;++i) { while (top\u0026amp;\u0026amp;a[sta[top]].w\u0026gt;a[i].w) { a[sta[top--]].r=i-1; } sta[++top]=i; } while (top) { a[sta[top--]].r=n; } for (i=n;i\u0026gt;=1;--i) { while (top\u0026amp;\u0026amp;a[sta[top]].w\u0026gt;=a[i].w) { a[sta[top--]].l=i+1; } sta[++top]=i; } while (top) { a[sta[top--]].l=1; } for (i=1;i\u0026lt;=n;++i) { a[i].t=(i-a[i].l+1)*(a[i].r-i+1)%M; } sort(a+1,a+n+1); for (i=n;i\u0026gt;=1;--i) { suf[i]=(suf[i+1]+a[i].t)%M; } for (i=1;i\u0026lt;=n;++i) { ans=(ans+(a[i].w*suf[i+1]%M)*a[i].t)%M; ans=(ans-(a[i].id-a[i].l)*(a[i].id-a[i].l+1)%M*(2*a[i].id-2*a[i].l+1)%M*SIX%M*(a[i].r-a[i].id+1)%M*a[i].w%M+M)%M; //重复区间在左 ans=(ans-(a[i].r-a[i].id)*(a[i].r-a[i].id+1)%M*(2*a[i].r-2*a[i].id+1)%M*SIX%M*(a[i].id-a[i].l+1)%M*a[i].w%M+M)%M; //重复区间在右 } cout\u0026lt;\u0026lt;ans; return 0; }  ","date":"2018-12-04T20:29:47+08:00","permalink":"https://ouuan.github.io/post/wc2019-%E5%85%A8%E5%9B%BD%E6%A8%A1%E6%8B%9F%E8%B5%9B%E7%AC%AC%E4%B8%80%E5%9C%BA-t1-%E9%A2%98%E8%A7%A3/","tags":["noi.ac"],"title":"WC2019 全国模拟赛第一场 T1 题解"},{"categories":["知识点"],"contents":"最近做了几道树上背包的题目，很多题目的数据范围都很小，但实际上树上背包有多种方式可以优化到 $O(nm)$ （$n$ 为节点数，$m$ 为体积的值域），比如先序遍历优化（何森《先序遍历用于优化树形背包问题》），求泛化物品的并（徐持衡《浅谈几类背包题》）……经过一番学习，觉得还是上下界优化理解起来最简单，也比较好写，适用范围广，唯一比其它做法复杂的地方就是复杂度分析。\n例题讲解 这里以一道经典的树上背包作为例题：【数据加强版】选课\n直接把我出的数据加强版放上来了..反正题面里有原题链接QAQ\n 注：本文中用 $a_i$ 代指题面中的 $s_i$ 。\n $O(nm^2)$ 做法 用 $f_{u,i}$ 表示以 $u$ 为根的子树中选 $i$ 门课的最大得分，那么 $f_{u,i}=\\min\\limits_{\\forall fa[v_j]=u,\\sum k_j=i-1}(\\sum f[v_j][k_j])+a_u$，而这个转移可以通过背包实现，依次合并每棵子树，每次合并时枚举 $i$ 和 $k_j$ ，$f_{u,i}=\\max(f_{u,i},f_{u,i-k_j}+f_{v_j,k_j})$ 。\n需要倒序枚举 $i$ 防止状态在转移前被覆盖。否则的话dp数组要多一维。\n由于可能是森林，所有没有直接先修课的节点，父亲视为节点 $0$，实际上就要选 $m+1$ 个节点。\n参考代码：\nvoid dfs(int u) { f[u][1]=a[u]; int i,j,k,v; for (i=head[u];i;i=nxt[i]) { v=to[i]; dfs(v); for (j=m+1;j\u0026gt;=1;--j) { for (k=1;k\u0026lt;j;++k) { f[u][j]=max(f[u][j],f[u][j-k]+f[v][k]); } } } }  上下界优化 注意背包转移的这部分：\nfor (j=m+1;j\u0026gt;=1;--j) { for (k=1;k\u0026lt;j;++k) { f[u][j]=max(f[u][j],f[u][k]+f[v][j-k]); } }  实际上，这里面有很多状态都是没有意义的：\n  转移时已经合并了大小之和为 $s$ 的一些子树，那么 $f_{u,i}(i\u0026gt;s)$ 实际上是没有意义的。\n  $f_{v,i}(i\u0026gt;siz[v])$ 也是没有意义的。\n  $f_{u,i}(i\u0026gt;m)$ 是没有作用的。\n  所以，可以对 $j$ 和 $k$ 的枚举范围进行优化：\nvoid dfs(int u) { siz[u]=1; f[u][1]=a[u]; int i,j,k,v; for (i=head[u];i;i=nxt[i]) { v=to[i]; dfs(v); for (j=min(m+1,siz[u]+siz[v]);j\u0026gt;=1;--j) { for (k=max(1,j-siz[u]);k\u0026lt;=siz[v]\u0026amp;\u0026amp;k\u0026lt;j;++k) { f[u][j]=max(f[u][j],f[u][j-k]+f[v][k]); } } siz[u]+=siz[v]; } }  复杂度分析 可以参考这篇博客。\n形象的解释 每个点对都只会在 $lca$ 处合并一次，所以总的复杂度是 $O(n^2)$ 的。\n这个解释很简洁，需要自己意会一下..\n粗略计算 令 $T_u$ 为处理子树 $u$ 的总用时，那么：\n$$\\begin{aligned}T_u\u0026amp;=\\left(\\sum\\limits_{\\forall fa[v_i]=u}T_{v_i}\\right)+t_u\\\\t_u\u0026amp;=1+(1+siz[v_1])\\times siz[v_1]+(1+siz[v_1]+siz[v_2])\\times siz[v_2]+\\cdots+siz[u]\\times siz[v_k]\\\\\u0026amp;=1+\\sum\\limits_{\\forall fa[v_i]=u}siz[v_i]\\times(siz[u]+1)\\\\\u0026amp;=siz[u]^2\\end{aligned}$$\n对于叶子节点 $u$ ，$T(u)=1$ ，是 $O(siz[u]^2)$ 的。\n对于儿子都是叶子节点的节点 $u$，由于平方和小于和平方，$\\sum\\limits_{\\forall fa[v_i]=u}T_{v_i}$ 也是 $O(siz[u]^2)$ 的。\n可以这样递归地说明，对于任意节点 $u$ ，$\\sum\\limits_{\\forall fa[v_i]=u}T_{v_i}$ 都是 $O(siz[u]^2)$ 的。\n又因为 $t(u)$ 是 $O(siz[u]^2)$ 的，$T(u)$ 就是 $O(siz[u]^2)$ 的。\n所以解决整个问题就是 $O(n^2)$ 的。\n考虑值域的计算 枚举过程中还要对 $m$ 取 min ，所以应该是这样的：\n$$\\begin{aligned}t_u\u0026amp;=1+\\min(m,1+siz[v_1])\\times \\min(m,siz[v_1])+\\min(m,1+siz[v_1]+siz[v_2])\\times \\min(m,siz[v_2])+\\cdots+\\min(m,siz[u])\\times \\min(m,siz[v_k])\\\\\u0026amp;\\le m\\times siz[u]\\end{aligned}$$\n所以，$t(u)$ 是 $O(\\min(siz[u],m)\\times siz[u])$ 的。\n对于 $siz[u]\\le m$，$T(u)$ 是 $O(siz[u]^2)$ 的。\n对于 $siz[u]\u0026gt;m$，$\\sum\\limits_{\\forall fa[v_i]=u,siz[v_i]\\le m}T_{v_i}$ 是 $O\\left(\\left(\\sum\\limits_{\\forall fa[v_i]=u,siz[v_i]\\le m}siz[v_i]\\right)^2\\right)$ 的；$\\sum\\limits_{\\forall fa[v_i]=u,siz[v_i]\u0026gt;m}T_{v_i}$ 是 $O\\left(m\\times\\sum\\limits_{\\forall fa[v_i]=u,siz[v_i]\u0026gt;m}siz[v_i]\\right)$ 的；所以，$T(u)$ 是 $O(m\\times siz[u])$ 的。\n所以，解决整个问题是 $O(nm)$ 的。\n其它例题 【数据加强版】道路重建\ndl代码 我出的那两道数据加强版略有些毒瘤..（$n\\times m\\le 10^8$）\n大约需要这样写：\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; void dfs(int u); void add(int u,int v); const int N=100010; int head[N],nxt[N],to[N],cnt; int n,m,a[N],f[100000010],siz[N]; int main() { int i,k; scanf(\u0026quot;%d%d\u0026quot;,\u0026amp;n,\u0026amp;m); for (i=1;i\u0026lt;=n;++i) { scanf(\u0026quot;%d%d\u0026quot;,\u0026amp;k,a+i); add(k,i); } dfs(0); printf(\u0026quot;%d\u0026quot;,f[m+1]); return 0; } void add(int u,int v) { nxt[++cnt]=head[u]; head[u]=cnt; to[cnt]=v; } void dfs(int u) { siz[u]=1; f[u*(m+2)+1]=a[u]; int i,j,k,v; for (i=head[u];i;i=nxt[i]) { v=to[i]; dfs(v); for (j=min(m+1,siz[u]+siz[v]);j\u0026gt;=1;--j) { for (k=max(1,j-siz[u]);k\u0026lt;=siz[v]\u0026amp;\u0026amp;k\u0026lt;j;++k) { f[u*(m+2)+j]=max(f[u*(m+2)+j],f[u*(m+2)+j-k]+f[v*(m+2)+k]); } } siz[u]+=siz[v]; } }  关于另一种 $O(nm)$ 做法 一开始我在洛谷发了篇选课的题解，然后没过\u0026hellip;\n那篇题解 用的是求泛化物品的并（徐持衡《浅谈几类背包题》）\n虽然说洛谷好像还没有上下界优化的题解..但最近好几篇题解没过审，都不太想在洛谷发题解了\u0026hellip;\n","date":"2018-11-28T17:16:35+08:00","permalink":"https://ouuan.github.io/post/%E6%A0%91%E4%B8%8A%E8%83%8C%E5%8C%85%E7%9A%84%E4%B8%8A%E4%B8%8B%E7%95%8C%E4%BC%98%E5%8C%96/","tags":["树形dp"],"title":"树上背包的上下界优化"},{"categories":["知识点"],"contents":"浅谈邻项交换排序的应用以及需要注意的问题.pdf\n 邻项交换排序是一种常见的贪心算法，通过比较两个相邻元素交换前后的优劣对整个序列进行排序，从而使得这个序列成为题目所求的最优解。然而，邻项交换排序的应用有一些需要注意的地方，稍有不慎便会成为一个错误的算法。\n 算法简介 例题引入 题目来源 NOIP2012提高组D1T2 国王游戏\n题目描述 恰逢 $H$ 国国庆，国王邀请 $n$ 位大臣来玩一个有奖游戏。首先，他让每个大臣在左、右手上面分别写下一个整数，国王自己也在左、右手上各写一个整数。然后，让这 $n $位大臣排成一排，国王站在队伍的最前面。排好队后，所有的大臣都会获得国王奖赏的若干金币，每位大臣获得的金币数分别是：排在该大臣前面的所有人的左手上的数的乘积除以他自己右手上的数，然后向下取整得到的结果。\n国王不希望某一个大臣获得特别多的奖赏，所以他想请你帮他重新安排一下队伍的顺序，使得获得奖赏最多的大臣，所获奖赏尽可能的少。注意，国王的位置始终在队伍的最前面。\n输入格式 第一行包含一个整数 $n$ ，表示大臣的人数。\n第二行包含两个整数 $a$ 和 $b$ ，之间用一个空格隔开，分别表示国王左手和右手上的整数。\n接下来 $n$ 行，每行包含两个整数 $a$ 和 $b$ ，之间用一个空格隔开，分别表示每个大臣左手和右手上的整数。\n输出格式 一个整数，表示重新排列后的队伍中获奖赏最多的大臣所获得的金币数。\n数据范围 对于 $20%$ 的数据，有 $1\\le n\\le 10,0\u0026lt;a,b\u0026lt;8$；\n对于 $40%$ 的数据，有 $1\\le n\\le 20,0\u0026lt;a,b\u0026lt;8$；\n对于 $60%$ 的数据，有 $1\\le n\\le 100$；\n对于 $60%$ 的数据，保证答案不超过 $10^9$；\n对于 $100%$ 的数据，有 $1\\le n\\le 1000,0\u0026lt;a,b\u0026lt;10000$ 。\n使用邻项交换排序解决问题 选取相邻的两个大臣 $i$ 和 $j$ （$j$ 此时在 $i$ 后一个），分别用 $a_i,b_i,a_j,b_j$ 表示这两位大臣左手上和右手上的数字，设这两位大臣前面的所有大臣左手上的数乘积为 $k$ 。\n此时，若调整这两名大臣的顺序，对前面和后面的大臣都不会造成影响，因此我们只要使得这两位大臣中获得较多奖赏的那位获得的奖赏尽量少即可。\n当 $i$ 在前 $j$ 在后时，这个值为 $\\max(\\frac k{b_i},\\frac {k a_i}{b_j})$ 。\n当 $j$ 在前 $i$ 在后时，这个值为 $\\max(\\frac k{b_j},\\frac {k a_j}{b_i})$ 。\n因此，若 $\\max(\\frac k{b_i},\\frac {k a_i}{b_j})\u0026gt;\\max(\\frac k{b_j},\\frac {k a_j}{b_i})$ ，就需要交换 $i$ 和 $j$ 。\n实际上，由于 $\\frac {k a_i}{b_j}\\ge\\frac k{b_j},\\frac {k a_j}{b_i}\\ge\\frac k{b_i}$ ，只需比较 $\\frac {k a_i}{b_j}$ 和 $\\frac {k a_j}{b_i}$ ，也就只需比较 $\\frac {a_i}{b_j}$ 和 $\\frac {a_j}{b_i}$ ，即：若 $a_i b_i\u0026gt;a_j b_j$，就要交换 $i$ 和 $j$ 。\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; const int N=1010; struct Node { int a,b; bool operator\u0026lt;(Node\u0026amp; y) { return a*b\u0026lt;y.a*y.b; } } dc[N]; long long n,ans,k; int main() { cin\u0026gt;\u0026gt;n; for (int i=0;i\u0026lt;=n;++i) { cin\u0026gt;\u0026gt;dc[i].a\u0026gt;\u0026gt;dc[i].b; } sort(dc+1,dc+n+1); k=dc[0].a; for (int i=1;i\u0026lt;=n;++i) { ans=max(ans,k/dc[i].b); k*=dc[i].a; } cout\u0026lt;\u0026lt;ans; return 0; }  使用以上代码即可得到60分，而AC此题需要使用高精度乘除法，不在本文讨论范围内。\n使用邻项交换排序需要注意的问题 另一道例题 题目来源 洛谷P2123 皇后游戏\n题目描述 皇后有 $n$ 位大臣，每位大臣的左右手上面分别写上了一个正整数。恰逢国庆节来临，皇后决定为 $n$ 位大臣颁发奖金，其中第 $i$ 位大臣所获得的奖金数目为第 $i－1$ 位大臣所获得奖金数目与前 $i$ 位大臣左手上的数的和的较大值再加上第 $i$ 位大臣右手上的数。\n形式化地讲：我们设第 $i$ 位大臣左手上的正整数为 $a_i$ ，右手上的正整数为 $b_i$ ，\n则第 $i$ 位大臣获得的奖金数目为 $c_i$ 可以表达为：\n$$c_i=\\begin{cases}a_1+b_1 \u0026amp; i=1\\\\\\max(c_{i-1},\\sum\\limits_{j=1}^ia_j)+b_i \u0026amp; 2\\le i\\le n\\end{cases}$$\n当然，吝啬的皇后并不希望太多的奖金被发给大臣，所以她想请你来重新安排一下队伍的顺序，使得获得奖金最多的大臣，所获奖金数目尽可能的少。\n注意：重新安排队伍并不意味着一定要打乱顺序，我们允许不改变任何一位大臣的位置。\n输入格式 第一行包含一个正整数 $T$ ，表示测试数据的组数。\n接下来 $T$ 个部分，每个部分的第一行包含一个正整数 $n$ ，表示大臣的数目。\n每个部分接下来 $n$ 行中，每行两个正整数，分别为 $a_i$ 和 $b_i$ ，含义如上文所述。\n输出格式 共 $T$ 行，每行包含一个整数，表示获得奖金最多的大臣所获得的奖金数目。\n数据范围 对于全部测试数据满足：$T\\le10,1\\le n\\le20000,1\\le a_i,b_i\\le10^9$ 。\n尝试用邻项交换排序解决问题 还是选取相邻的两个大臣 $i$ 和 $j$ （$j$ 此时在 $i$ 后一个），交换 $i$ 和 $j$ 对前面的大臣无影响，对后面的大臣的影响在于排在后面的那个大臣获得的奖金，需要使之尽量小。\n设这两个大臣前面的所有大臣左手上的数之和为 $\\rm sum$ ，这两个大臣的再往前一个大臣得到的奖金是 $\\rm pre$ 。\n当 $i$ 在前 $j$ 在后时，这个值为 $\\max(\\max(\\mathrm{pre},\\mathrm{sum}+a_i)+b_i,\\mathrm{sum}+a_i+a_j)+b_j$ 。\n当 $j$ 在前 $i$ 在后时，这个值为 $\\max(\\max(\\mathrm{pre},\\mathrm{sum}+a_j)+b_j,\\mathrm{sum}+a_j+a_i)+b_i$ 。\n由于 $\\max(x,y)+z=\\max(x+z,y+z)$ ，需要比较的就是 $\\max(\\mathrm{pre}+b_i+b_j,\\mathrm{sum}+a_i+b_i+b_j,\\mathrm{sum}+a_i+a_j+b_j)$ 和 $\\max(\\mathrm{pre}+b_j+b_i,\\mathrm{sum}+a_j+b_j+b_i,\\mathrm{sum}+a_j+a_i+b_i)$ ，其中 $\\mathrm{pre}+b_i+b_j=\\mathrm{pre}+b_j+b_i$ ，需要比较的就是 $\\max(\\mathrm{sum}+a_i+b_i+b_j,\\mathrm{sum}+a_i+a_j+b_j)$ 和 $\\max(\\mathrm{sum}+a_j+b_j+b_i,\\mathrm{sum}+a_j+a_i+b_i)$ ，再用 $\\mathrm{sum}+a_i+b_i+a_j+b_j$ 减去两边并变号，即：当 $\\min(a_i,b_j)\u0026gt;\\min(a_j,b_i)$ 时，需要交换 $i$ 和 $j$。\n于是，可以写出以下代码，并在洛谷上AC此题：\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; const int N=20010; struct Node { int a,b; bool operator\u0026lt;(Node\u0026amp; y) { return min(a,y.b)\u0026lt;min(b,y.a); } } dc[N]; long long ans,sum,t,n; int main() { cin\u0026gt;\u0026gt;t; while (t--) { cin\u0026gt;\u0026gt;n; for (int i=1;i\u0026lt;=n;++i) { cin\u0026gt;\u0026gt;dc[i].a\u0026gt;\u0026gt;dc[i].b; } sort(dc+1,dc+n+1); ans=sum=0; for (int i=1;i\u0026lt;=n;++i) { sum+=dc[i].a; ans=max(ans,sum)+dc[i].b; } cout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl; } return 0; }  hack数据 事实上，上面的做法是错误的，无法通过下面这组数据：\n2 4 1 1 1 1 3 5 2 7 4 1 1 3 5 1 1 2 7  这两组数据只有大臣给出的顺序不同，但上面的代码输出为：\n16 17  输出中间结果，可以发现，排列后的最终结果分别为：\n1 1 1 1 2 7 3 5  和\n1 1 3 5 1 1 2 7  这两种排列方式都满足 $\\forall i\\in [1,n),\\min(a_i,b_{i+1})\\le\\min(a_{i+1},b_i)$，但第二种方式并不是最优解。具体原因将在下文分析。\n严格弱序 严格弱序简介 要知道为什么这种做法是错误的，首先需要了解严格弱序（strict weak ordering）。\n对于一个比较运算符（用“$\u0026lt;$”表示此运算符，用“$\\not\u0026lt;$”表示不满足此运算符），若满足以下四个条件，则称其是满足严格弱序的：\n $x\\not\u0026lt;x$ （非自反性） 若 $x\u0026lt;y$，则 $y\\not\u0026lt;x$ （非对称性） 若 $x\u0026lt;y,y\u0026lt;z$，则 $x\u0026lt;z$ （传递性） 若 $x\\not\u0026lt;y,y\\not\u0026lt;x,y\\not\u0026lt;z,z\\not\u0026lt;y$，则 $x\\not\u0026lt;z,z\\not\u0026lt;x$ （不可比性的传递性）  而 C++ 标准库要求用于排序的运算符必须满足严格弱序：\n  It has to be antisymmetric.\nThis means that for operator $\u0026lt;$: If $x \u0026lt; y$ is true, then $y \u0026lt; x$ is false.\nThis means that for a predicate op(): If op(x,y) is true, then op(y,x) is false.\n  It has to be transitive.\nThis means that for operator $\u0026lt;$: If $x \u0026lt; y$ is true and $y \u0026lt; z$ is true, then $x \u0026lt; z$ is true.\nThis means that for a predicate op(): If op(x,y) is true and op(y,z) is true, then op(x,z)\nis true.\n  It has to be irreflexive.\nThis means that for operator $\u0026lt;$: $x \u0026lt; x$ is always false.\nThis means that for a predicate op(): op(x,x) is always false.\n  It has to have transitivity of equivalence, which means roughly: If a is equivalent to b and b is\nequivalent to c, then a is equivalent to c.\nThis means that for operator $\u0026lt;$: If $!(a\u0026lt;b) \\\u0026amp;\\\u0026amp; !(b\u0026lt;a)$ is true and $!(b\u0026lt;c) \\\u0026amp;\\\u0026amp; !(c\u0026lt;b)$ is true\nthen $!(a\u0026lt;c) \\\u0026amp;\\\u0026amp; !(c\u0026lt;a)$ is true.\nThis means that for a predicate op(): If op(a,b), op(b,a), op(b,c), and op(c,b) all yield\nfalse, then op(a,c) and op(c,a) yield false.\n  上述做法的判断条件满足传递性，但不满足不可比性的传递性。\n满足传递性的证明 命题：$\\forall \\begin{cases}\\min(a_i,b_j)\u0026lt;\\min(a_j,b_i)\\\\\\min(a_j,b_k)\u0026lt;\\min(a_k,b_j)\\end{cases}$，有 $\\min(a_i,b_k)\u0026lt;\\min(a_k,b_i)$。\n将上式拆解成逻辑式，即证：\n$\\forall \\begin{cases}(a_i\u0026lt;a_j\\lor b_j\u0026lt;a_j)\\land(a_i\u0026lt;b_i\\lor b_j\u0026lt;b_i) \\\\(a_j\u0026lt;a_k\\lor b_k\u0026lt;a_k)\\land(a_j\u0026lt;b_j\\lor b_k\u0026lt;b_j)\\end{cases}$，有 $(a_i\u0026lt;a_k\\lor b_k\u0026lt;a_k)\\land(a_i\u0026lt;b_i\\lor b_k\u0026lt;b_i)$。\n假设原命题不成立，即 $\\exists\\begin{cases}(a_i\u0026lt;a_j\\lor b_j\u0026lt;a_j)\\land(a_i\u0026lt;b_i\\lor b_j\u0026lt;b_i)\u0026amp;(1) \\\\(a_j\u0026lt;a_k\\lor b_k\u0026lt;a_k)\\land(a_j\u0026lt;b_j\\lor b_k\u0026lt;b_j)\u0026amp;(2) \\\\(a_i\\ge a_k\\land b_k\\ge a_k)\\lor(a_i\\ge b_i\\land b_k\\ge b_i)\u0026amp;(3)\\end{cases}$\n分别讨论 $(3)$ 式成立的两种情况：\n若 $a_i\\ge a_k\\land b_k\\ge a_k$，由 $(2)$ 式得 $a_j\u0026lt;a_k$，进而推出 $a_j\u0026lt;a_i$，再由 $(1)$ 式得 $b_j\u0026lt;a_j$，再由 $(2)$ 式得到 $b_k\u0026lt;b_j$，所以 $b_k\u0026lt;b_j\u0026lt;a_j\u0026lt;a_k$，与 $b_k\\ge a_k$ 矛盾，不成立。\n若 $a_i\\ge b_i\\land b_k\\ge b_i$，与上面类似，由 $(1)$ 式得 $b_j\u0026lt;b_i$，进而推出 $b_j\u0026lt;b_k$，再由 $(2)$ 式得到 $a_j\u0026lt;b_j$，再由 $(1)$ 式得到 $a_i\u0026lt;a_j$，所以 $a_i\u0026lt;a_j\u0026lt;b_j\u0026lt;b_i$，与 $a_i\\ge b_i$ 矛盾，不成立。\n综上所述，假设不成立。\n所以，$P_{i,j}=\\min(a_i,b_j)\u0026lt;\\min(a_j,b_i)$ 具有传递性。\n不具有不可比性的传递性的证明 命题：$\\forall \\begin{cases}\\min(a_i,b_j)=\\min(a_j,b_i)\\\\\\min(a_j,b_k)=\\min(a_k,b_j)\\end{cases}$，有 $\\min(a_i,b_k)=\\min(a_k,b_i)$。\n很明显，当 $a_j=b_j$ 且都很小时存在反例，如：\n$$\\begin{array}{c|c|c}\u0026amp;a\u0026amp;b\\\\i\u0026amp;3\u0026amp;5\\\\j\u0026amp;1\u0026amp;1\\\\k\u0026amp;2\u0026amp;7\\end{array}$$\n$\\begin{cases}\\min(3,1)=\\min(1,5)\\\\\\min(1,7)=\\min(2,1)\\end{cases}$，但 $\\min(3,7)\\ne \\min(2,5)$。\n这样的反例还有很多，所以，$P_{i,j}=\\min(a_i,b_j)\u0026lt;\\min(a_j,b_i)$ 不具有不可比性的传递性。\n为何会错 简单地说，$P_{i,j}=\\min(a_i,b_j)\u0026lt;\\min(a_j,b_i)$ 不满足严格弱序，不能作为 std::sort 的比较函数。\n究其原因，“不具有不可比性的传递性”意味着：将序列中若干个不可比的相邻元素对（在这种比较方式下即 $\\min(a_i,b_{i+1})=\\min(a_{i+1},b_i)$ 的 $i$ 和 $i+1$）互换后，可能会出现前面的元素“大于”后面的元素（在这种比较方式下即出现 $\\min(a_i,b_{i+1})\u0026gt;\\min(a_{i+1},b_i)$），从而使得原先的排列方式不是最优的。\n正确解法 更加完善的贪心解法 比较相邻两项时，若 $\\min(a_i,b_j)=\\min(a_j,b_i)$ ，从全局来看，由于 $a$ 的前缀和对答案有一定的影响，把 $a$ 更小的放前面是更优的。从而可以得到这样一个解法：\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; const int N=20010; struct Node { int a,b; bool operator\u0026lt;(Node\u0026amp; y) { return min(a,y.b)==min(b,y.a)?a\u0026lt;y.a:min(a,y.b)\u0026lt;min(b,y.a); } } dc[N]; long long ans,sum,t,n; int main() { cin\u0026gt;\u0026gt;t; while (t--) { cin\u0026gt;\u0026gt;n; for (int i=1;i\u0026lt;=n;++i) { cin\u0026gt;\u0026gt;dc[i].a\u0026gt;\u0026gt;dc[i].b; } sort(dc+1,dc+n+1); ans=sum=0; for (int i=1;i\u0026lt;=n;++i) { sum+=dc[i].a; ans=max(ans,sum)+dc[i].b; } cout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl; } return 0; }  这个解法的正确性将在下文证明。\n一个解法是否正确的判断方式 由上文的讨论可以得知，一个排序方式 $P_{i,j}$ 要是正解，需要满足两个条件：\n  满足严格弱序。\n  $\\forall P_{i,j}=true$，$\\min(a_i,b_j)\\le\\min(a_j,b_i)$ 。\n  即，可以作为比较函数，且排序完成后任意交换相邻元素均不会使答案更优。\n从而可以写出下面的正解判断器：\n#include \u0026lt;cstdio\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; bool cmp(int i,int j); int a[10],b[10]; int main() { for (a[0]=1;a[0]\u0026lt;=6;++a[0]) { for (b[0]=1;b[0]\u0026lt;=6;++b[0]) { if (cmp(0,0)) { printf(\u0026quot;No irreflexivity:%d %d\\n\u0026quot;,a[0],b[0]); } for (a[1]=1;a[1]\u0026lt;=6;++a[1]) { for (b[1]=1;b[1]\u0026lt;=6;++b[1]) { if (cmp(0,1)\u0026amp;\u0026amp;min(a[0],b[1])\u0026gt;min(a[1],b[0])) { printf(\u0026quot;Not the best:%d %d %d %d\\n\u0026quot;,a[0],b[0],a[1],b[1]); } for (a[2]=1;a[2]\u0026lt;=6;++a[2]) { for (b[2]=1;b[2]\u0026lt;=6;++b[2]) { if (cmp(0,1)\u0026amp;\u0026amp;cmp(1,2)\u0026amp;\u0026amp;!cmp(0,2)) { printf(\u0026quot;No transitivity:%d %d %d %d %d %d\\n\u0026quot;,a[0],b[0],a[1],b[1],a[2],b[2]); } if (!cmp(0,1)\u0026amp;\u0026amp;!cmp(1,0)\u0026amp;\u0026amp;!cmp(1,2)\u0026amp;\u0026amp;!cmp(2,1)\u0026amp;\u0026amp;(cmp(0,2)||cmp(2,0))) { printf(\u0026quot;No transitivity of incomparability:%d %d %d %d %d %d\\n\u0026quot;,a[0],b[0],a[1],b[1],a[2],b[2]); } } } } } } } return 0; } bool cmp(int i,int j) { return min(a[i],b[j])==min(a[j],b[i])?a[i]\u0026lt;a[j]:min(a[i],b[j])\u0026lt;min(a[j],b[i]); }  运行程序，没有任何输出，说明上文所述的排序方式是一个正解。\n用其它排序方式替换 cmp，若没有任何输出即可作为本题的正确排序方式。\n下面是几种排序方式的例子：\nbool cmp(int i,int j) { return min(a[i],b[j])==min(a[j],b[i])?b[i]\u0026gt;b[j]:min(a[i],b[j])\u0026lt;min(a[j],b[i]); }  输出为空，是正解。\nbool cmp(int i,int j) { return min(a[i],b[j])\u0026lt;min(a[j],b[i]); }  共输出1694行，前10行如下：\nNo transitivity of incomparability:1 2 1 1 2 1 No transitivity of incomparability:1 2 1 1 2 2 No transitivity of incomparability:1 2 1 1 2 3 No transitivity of incomparability:1 2 1 1 2 4 No transitivity of incomparability:1 2 1 1 2 5 No transitivity of incomparability:1 2 1 1 2 6 No transitivity of incomparability:1 2 1 1 3 1 No transitivity of incomparability:1 2 1 1 3 2 No transitivity of incomparability:1 2 1 1 3 3 No transitivity of incomparability:1 2 1 1 3 4  bool cmp(int i,int j) { return min(a[i],b[j])==min(a[j],b[i])?a[i]\u0026gt;a[j]:min(a[i],b[j])\u0026lt;min(a[j],b[i]); }  共输出280行，前10行如下：\nNo transitivity:1 2 2 1 1 1 No transitivity:1 2 2 2 1 1 No transitivity:1 2 2 3 1 1 No transitivity:1 2 2 4 1 1 No transitivity:1 2 2 5 1 1 No transitivity:1 2 2 6 1 1 No transitivity:1 2 3 1 1 1 No transitivity:1 2 3 2 1 1 No transitivity:1 2 3 3 1 1 No transitivity:1 2 3 4 1 1  bool cmp(int i,int j) { return min(a[i],b[j])\u0026lt;=min(a[j],b[i]); }  共输出883行，前10行如下：\nNo irreflexivity:1 1 No irreflexivity:1 2 No irreflexivity:1 3 No irreflexivity:1 4 No irreflexivity:1 5 No irreflexivity:1 6 No irreflexivity:2 1 No transitivity:2 1 1 1 1 2 No transitivity:2 1 1 1 1 3 No transitivity:2 1 1 1 1 4  总结 在可以通过比较相邻两项得出交换或不交换一定不会更差时，可以通过邻项交换排序的方式来得到最优解。\n邻项交换排序的比较函数需要满足严格弱序，并且排序完成后任意交换相邻元素都不会更优。\n使用这种算法时，一定要注意以上两点，才能得到真正正确的算法。\n 最后再把我去雅礼集训的时候水题选讲的 slide 放上来好了..（还附赠一道由乃题）\n水题选讲_ouuan.pdf\n","date":"2018-11-18T08:05:50+08:00","permalink":"https://ouuan.github.io/post/%E6%B5%85%E8%B0%88%E9%82%BB%E9%A1%B9%E4%BA%A4%E6%8D%A2%E6%8E%92%E5%BA%8F%E7%9A%84%E5%BA%94%E7%94%A8%E4%BB%A5%E5%8F%8A%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84%E9%97%AE%E9%A2%98/","tags":["贪心","序理论"],"title":"浅谈邻项交换排序的应用以及需要注意的问题"},{"categories":["游记"],"contents":"Day1 T1 积木大赛 NOIp2013D2T1\u0026hellip;..看到的时候我还以为我记错了，以为原题是一次可以随便加，这题只能加一，出考场后查了下发现一模一样。\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;cstdio\u0026gt; using namespace std; const int N=100010; int n,d[N],ans; int main() { int i; scanf(\u0026quot;%d\u0026quot;,\u0026amp;n); for (i=1;i\u0026lt;=n;++i) { scanf(\u0026quot;%d\u0026quot;,d+i); if (d[i]\u0026gt;d[i-1]) { ans+=d[i]-d[i-1]; } } cout\u0026lt;\u0026lt;ans; return 0; }  T2 货币系统 去掉可以由其它货币拼成的货币，这个结论倒是很快猜到了。但由于xkdyh留下的阴影，一开始我还写了个exgcd\u0026hellip;幸好大样例比较良心，有一组数据是三种货币拼成另一种。然后再仔细一看，发现是个完全背包\u0026hellip;\n简单证明一下：\n结论：对于一个没有任何一种货币可以由系统内其它货币拼成的货币系统 $(n,A)$，与其等价的货币系统 $(m,B)$ 只能是 $(n,A)$ 自身或者加上一些能由 $(n,A)$ 表示的数。\n若 $A\\not\\subseteq B$，任取 $t\\in (A-B)$，那么在 $B$ 中必然有一些元素能够拼成 $t$，而这些元素在 $A$ 中必然有不能表示的（否则与 $A$ 中没有任何一种货币可以由系统内其它货币拼成矛盾），而存在 $(m,B)$ 能表示而 $(n,A)$ 不能表示的数与 $(n,A),(m,B)$ 等价矛盾，不成立。\n若 $B$ 中有 $(n,A)$ 所不能表示的元素，依然与 $(n,A),(m,B)$ 等价矛盾，不成立。\n所以命题得证。\n排个序然后完全背包去掉能被系统内其它货币表示的货币即可。\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; int t,n,a[110],maxx; bool f[25010]; int main() { int i,j,ans; scanf(\u0026quot;%d\u0026quot;,\u0026amp;t); while (t--) { scanf(\u0026quot;%d\u0026quot;,\u0026amp;n); ans=n; maxx=0; for (i=1;i\u0026lt;=n;++i) { scanf(\u0026quot;%d\u0026quot;,a+i); maxx=max(maxx,a[i]); } sort(a+1,a+n+1); memset(f,false,sizeof(f)); f[0]=true; for (i=1;i\u0026lt;=n;++i) { if (f[a[i]]) { --ans; continue; } for (j=0;j+a[i]\u0026lt;=maxx;++j) { if (f[j]) { f[j+a[i]]=true; } } } printf(\u0026quot;%d\\n\u0026quot;,ans); } return 0; }  T3 赛道修建 看到这题就想起了ylh当时跟我一个房间的时候切掉的 CF div.2 E，但赛后发现不一样\u0026hellip;\n出考场得知dew、ylh都切掉了这题，然而我只写了直径、链和菊花图的 $55$ 分\u0026hellip;凉凉凉\nDay2 T1 旅行 一开始看错题了，以为是最小字典序生成树，还在想为什么 $m$ 这么小..然后仔细一看题，发现一条边只能回溯时重复经过，也就是最后得到的序列只能是个dfs序\u0026hellip;数据范围很小，所以就枚举断边写了个 $O(n^2)$ 的，预处理边排序。然后出考场听一堆dalao在那说各种 $O(nlogn)$，$O(n)$ 做法\u0026hellip;都不会QAQ\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;cstring\u0026gt; using namespace std; const int N=5010; void dfs(int u); int n,m,cut,a[N][N],tot,e[N][2]; bool vis[N],used[N]; //used用于对m个字典序取min，若used[i]=true说明断开第 i 条边时一定不是答案 vector\u0026lt;int\u0026gt; g[N]; int main() { int i,j,u,v,minn; scanf(\u0026quot;%d%d\u0026quot;,\u0026amp;n,\u0026amp;m); for (i=0;i\u0026lt;m;++i) { scanf(\u0026quot;%d%d\u0026quot;,\u0026amp;u,\u0026amp;v); e[i][0]=u; e[i][1]=v; g[u].push_back(v); g[v].push_back(u); } for (i=1;i\u0026lt;=n;++i) { sort(g[i].begin(),g[i].end()); } if (n==m) { for (cut=0;cut\u0026lt;m;++cut) { memset(vis,false,sizeof(vis)); tot=0; dfs(1); if (tot\u0026lt;n) { used[cut]=true; } } for (i=1;i\u0026lt;=n;++i) { minn=n; for (j=0;j\u0026lt;m;++j) { if (!used[j]\u0026amp;\u0026amp;a[j][i]\u0026lt;minn) { minn=a[j][i]; } } for (j=0;j\u0026lt;m;++j) { if (a[j][i]\u0026gt;minn) { used[j]=true; } } printf(\u0026quot;%d\u0026quot;,minn); if (i\u0026lt;n) { putchar(' '); } } } else { cut=m; dfs(1); for (i=1;i\u0026lt;=n;++i) { printf(\u0026quot;%d\u0026quot;,a[m][i]); if (i\u0026lt;n) { putchar(' '); } } } return 0; } void dfs(int u) { if (vis[u]) { return; } vis[u]=true; a[cut][++tot]=u; int v,i; for (i=0;i\u0026lt;g[u].size();++i) { v=g[u][i]; if ((u!=e[cut][0]||v!=e[cut][1])\u0026amp;\u0026amp;(u!=e[cut][1]||v!=e[cut][0])) { dfs(v); } } }  T2 填数游戏 要是数据范围给到 $10^9$ 我就不会在考场上推半天了\u0026hellip;一开始想了好久怎么 $O(nm)$ dp，虽然没想出来怎么做，但发现了暴力怎么写：一种方案合法等价于：对于每个点，它右边的点先往下再往右的路径小于它下面的点先往右再往下的路径。因为这两条路径分别是一个点向右走后最大的路径和向下走后最小的路径。然后打了个表，发现 $(n,m)=(n,n+1)\\times 3^{m-n-1} (n\\ge 2,m\\ge n+1)$。于是开始跑 $(8,9)$ ，跑到11:50 还没跑出来\u0026hellip;幸好发现了 $(n,n)$ 和 $(n,n+1)$ 之间也有一定的规律，把 $(8,9)$ 算出来了\u0026hellip;\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; const long long Ans[9][10]={{0,0,0,0,0,0,0,0,0,0}, {0,0,0,0,0,0,0,0,0,0}, {0,4,12,36,0,0,0,0,0,0}, {0,8,36,112,336,0,0,0,0,0}, {0,16,108,336,912,2688,0,0,0,0}, {0,32,324,1008,2688,7136,21312,0,0,0}, {0,64,972,3024,8064,21312,56768,170112,0,0}, {0,128,2916,9072,24192,63936,170112,453504,1360128,0}, {0,256,8748,27216,72576,191808,510336,1360128,3626752,10879488}}; //其实有一部分表是不必要（没有意义）的... const long long M=1000000007; long long n,m,ans=1; int main() { int i; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m; if (n\u0026gt;m) { swap(n,m); } if (n==1) { for (i=30;i\u0026gt;=0;--i) { ans=ans*ans%M; if (m\u0026amp;(1\u0026lt;\u0026lt;i)) { ans=ans*2%M; } } cout\u0026lt;\u0026lt;ans; } else { if (m\u0026lt;=n+1) { cout\u0026lt;\u0026lt;Ans[n][m]; return 0; } else { for (i=30;i\u0026gt;=0;--i) { ans=ans*ans%M; if ((m-n-1)\u0026amp;(1\u0026lt;\u0026lt;i)) { ans=ans*3%M; } } cout\u0026lt;\u0026lt;ans*Ans[n][n+1]%M; } } return 0; }  T3 保卫王国 据说是ddp\u0026hellip;考场上先10min写了44分（一开始还以为是55分Orz），然后看了下，觉得B1挺可写的，更新向上的链貌似就可以了，但最后没调出来..\n Day7 上（tui）了一个星期的whk..个鬼啊，三天在考期中，就上了两天whk。感觉从零开始的whk没有想象中那么恐怖\u0026hellip;\n一周不让去机房，一到家就在洛谷上测了一下公布的代码.其它题都和预估的一样，D2T1可能会被卡常，洛谷上开了O2最慢点 $0.9s$ ，而且不用vector好像也过不了，不知道是不是洛谷上内存开小了的原因\u0026hellip;\nD1T3大众AC题我爆菊（花图）了\u0026hellip; 幸好菊花图的数据分治放在了最后面，还有 $40$ 分。发现自己傻了，不知道为什么会认为只有最短的两条边可以拼在一起，其它边都只能自成一条道\u0026hellip;\u0026hellip;.\n听说D2T3不用ddp，还是我太菜了\u0026hellip;\n估分：$100+100+40+88/100+100+44=472/484$\n Day10 GGF咕咕咕，然而我把两个T3写了一下..\nD1T3真的好简单\u0026hellip;二分答案，check的时候dfs处理每棵子树并返回块数最多时最大剩余，具体就是把子树返回值排个序，双指针配对得到最多块数，然后从最后一个配对的左指针开始往前这么多个依次配对，最后看剩下的没配对的里面最大的是多少。（第二天换成CCF数据发现做法挂了）处理子树的时候二分返回值不影响复杂度但能保证正确性。\nD2T3做法挺有趣的..倍增题做少了，估计做多了就比较套路了\u0026hellip;预处理出 $f[u][1],f[u][0],g[u][1],g[u][0]$，分别代表选/不选 $u$ 时 子树 $u$ 答案，选/不选 $u$ 时 $u$ 往上（整颗树减去子树 $u$）的答案。倍增处理出祖先 $fa[u][i]$ 表示 $u$ 的 $2^i$ 祖先，用 $bz[u][i][0/1][0/1]$ 表示子树 $fa[u][i]$ 除去子树 $u$ ，其中 $u$ 选/不选，$fa[u][i]$ 选/不选的答案，可以在dfs预处理 f 和 g 的同时算出 $bz[u][0][0/1][0/1]$ ，然后：\n$$bz[u][i][a][b]=\\min(bz[u][i-1][a][0]+bz[fa[u][i-1]][i-1][0][b],bz[u][i-1][a][1]+bz[fa[u][i-1]][i-1][1][b])$$\n计算答案的时候如果是祖先关系直接倍增计算链上答案，再加上子树的 f 和 祖先上方的 g；否则倍增到 $lca$ 计算路径上的答案，两棵子树以及 $lca$ 上方的答案就是对应的 $f$ 和 $g$ 。然后写到 $22:15$，交上去 $68$ 分，回寝室\u0026hellip;ab相邻的 $16$ 分真的好简单，不用倍增，考场上应该写出来的\u0026hellip;\n Day11 刚到学校听说自己 $480$ ，还在想8700k这么强，能把我的 travel 卡成 $96$ \u0026hellip;\n中午一看是 $489$，数据真有趣\u0026hellip;D1T3 隔壁原 $95$ 变成 $80$，我昨天A的变成 $90$ 了，考场写的还骗到了 $5$ 分（$45$）\u0026hellip;8700k天下第一！\n Day25 咕咕咕咕咕，$\\mathrm{CN}$ $329$。\n","date":"2018-11-11T14:52:37+08:00","permalink":"https://ouuan.github.io/post/noip2018%E6%8F%90%E9%AB%98%E7%BB%84%E6%B8%B8%E8%AE%B0/","tags":["CCF系列赛事"],"title":"NOIp2018提高组游记"},{"categories":["题解"],"contents":"我写的莫队教程\n其实这是一道bzoj上的题（bzoj2639，貌似是权限题，反正我看不了），在YALI做模拟赛的时候遇到了.\n然后在网上查到了几篇关于这道题的博客，都和我的做法略有不同\u0026hellip;\n题目大意 给你一个 $r*c$ 的矩阵，每个点有一个颜色， $m$ 个询问，每次询问一个子矩阵内，每种颜色出现次数的平方和。\n$r,c\\le 200,m\\le 100000$\n做法简述 首先我们要明白，莫队究竟在干什么。\n莫队其实就是几个指针在那跳来跳去，每跳一步都需要一定的时间，通过对询问排序使得指针跳的总次数尽量小。\n所以，这题中询问为 $(x_1,y_1,x_2,y_2)$ ，也就是四个指针在那跳，分别分块再排序就可以了，即：\n//为避免和cmath库中的y0y1重名，下文中代码内的x1,y1,x2,y2都用x,y,xx,yy代替 struct Query { int x,y,xx,yy,id; bool operator\u0026lt;(Query\u0026amp; b) { return x/B==b.x/B?(y/B==b.y/B?(xx/B==b.xx/B?yy\u0026lt;b.yy:xx\u0026lt;b.xx):y\u0026lt;b.y):x\u0026lt;b.x; //B为分块大小 } } q[M];  答案更新 一般的莫队都是 $O(1)$ 更新答案的，然而这题是 $O(n)$ （用 $n$ 代表 $r,c$ ） 更新。\n移动指针的时候，把一排一起修改。\n需要注意的是，8个while的顺序如果排列不当在某些情况下会导致答案出错，所以最好是将所有add都放在del前面（实际上有多种排列顺序都可以在不进行“反操作”的情况下保证答案正确，所有add放在del前面只是其中一种），或者是对“反区间”进行“反操作”。\n所谓“反区间”，如：修改 $x_1$ 指针时，本应进行add操作，而此时$y_1\u0026gt;y_2+1$，那么就要将 $(y_2,y_1)$ 这个开区间内的所有点进行del。\nwhile的排列顺序得当可以使“反区间”不可能出现。\n“反操作”参考代码：\nwhile (x\u0026lt;q[i].x) { for (j=y;j\u0026lt;=yy;++j) { del(a[x][j]); } for (j=yy+1;j\u0026lt;y;++j) { add(a[x][j]); } ++x; } while (y\u0026lt;q[i].y) { for (j=x;j\u0026lt;=xx;++j) { del(a[j][y]); } for (j=xx+1;j\u0026lt;x;++j) { add(a[j][y]); } ++y; } while (xx\u0026gt;q[i].xx) { for (j=y;j\u0026lt;=yy;++j) { del(a[xx][j]); } for (j=yy+1;j\u0026lt;y;++j) { add(a[xx][j]); } --xx; } while (yy\u0026gt;q[i].yy) { for (j=x;j\u0026lt;=xx;++j) { del(a[j][yy]); } for (j=xx+1;j\u0026lt;x;++j) { add(a[j][yy]); } --yy; } while (x\u0026gt;q[i].x) { --x; for (j=y;j\u0026lt;=yy;++j) { add(a[x][j]); } for (j=yy+1;j\u0026lt;y;++j) { del(a[x][j]); } } while (y\u0026gt;q[i].y) { --y; for (j=x;j\u0026lt;=xx;++j) { add(a[j][y]); } for (j=xx+1;j\u0026lt;x;++j) { del(a[j][y]); } } while (xx\u0026lt;q[i].xx) { ++xx; for (j=y;j\u0026lt;=yy;++j) { add(a[xx][j]); } for (j=yy+1;j\u0026lt;y;++j) { del(a[xx][j]); } } while (yy\u0026lt;q[i].yy) { ++yy; for (j=x;j\u0026lt;=xx;++j) { add(a[j][yy]); } for (j=xx+1;j\u0026lt;x;++j) { del(a[j][yy]); } } out[q[i].id]=ans;  分块大小 具体计算清楚非常复杂，这里只是估算一下.\n$x_1$ 指针的移动次数为 $O(mB)$，$y_2$ 指针的移动次数渐进复杂度中含有 $O\\left(\\frac{n^4}{B^3}\\right)$，取 $mB=\\frac{n^4}{B^3}$，得到 $B=nm^{-\\frac{1}{4}}$\n总时间复杂度为 $O(mlogm+n^2m^{\\frac{3}{4}})$\n反正这样的分块大小实测比 $\\sqrt{n}$ 优秀\u0026hellip;有兴趣的话可以严谨地算一算（如果发现我这个估算有问题可以直接在这篇博客下评论）\n初始子矩阵 任意一个空矩阵就可以了，如 $x_1=y_1=1,x_2=y_2=0$\n参考代码 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;cmath\u0026gt; using namespace std; const int N=210; const int M=100010; void add(int x); void del(int x); int r,c,m,B,a[N][N],lsh[N*N],tot,cnt[N*N],ans,out[M]; struct Query { int x,y,xx,yy,id; bool operator\u0026lt;(Query\u0026amp; b) { return x/B==b.x/B?(y/B==b.y/B?(xx/B==b.xx/B?yy\u0026lt;b.yy:xx\u0026lt;b.xx):y\u0026lt;b.y):x\u0026lt;b.x; } } q[M]; int main() { int i,j,x=1,y=1,xx=0,yy=0; cin\u0026gt;\u0026gt;r\u0026gt;\u0026gt;c\u0026gt;\u0026gt;m; B=pow(r*c,0.5)/pow(m,0.25)+1.0; for (i=1;i\u0026lt;=r;++i) { for (j=1;j\u0026lt;=c;++j) { cin\u0026gt;\u0026gt;a[i][j]; lsh[tot++]=a[i][j]; //这题要离散化 } } sort(lsh,lsh+tot); tot=unique(lsh,lsh+tot)-lsh; for (i=1;i\u0026lt;=r;++i) { for (j=1;j\u0026lt;=c;++j) { a[i][j]=lower_bound(lsh,lsh+tot,a[i][j])-lsh; } } for (i=0;i\u0026lt;m;++i) { cin\u0026gt;\u0026gt;q[i].x\u0026gt;\u0026gt;q[i].y\u0026gt;\u0026gt;q[i].xx\u0026gt;\u0026gt;q[i].yy; q[i].id=i; } sort(q,q+m); for (i=0;i\u0026lt;m;++i) { while (x\u0026gt;q[i].x) { --x; for (j=y;j\u0026lt;=yy;++j) { add(a[x][j]); } } while (xx\u0026lt;q[i].xx) { ++xx; for (j=y;j\u0026lt;=yy;++j) { add(a[xx][j]); } } while (y\u0026gt;q[i].y) { --y; for (j=x;j\u0026lt;=xx;++j) { add(a[j][y]); } } while (yy\u0026lt;q[i].yy) { ++yy; for (j=x;j\u0026lt;=xx;++j) { add(a[j][yy]); } } while (x\u0026lt;q[i].x) { for (j=y;j\u0026lt;=yy;++j) { del(a[x][j]); } ++x; } while (xx\u0026gt;q[i].xx) { for (j=y;j\u0026lt;=yy;++j) { del(a[xx][j]); } --xx; } while (y\u0026lt;q[i].y) { for (j=x;j\u0026lt;=xx;++j) { del(a[j][y]); } ++y; } while (yy\u0026gt;q[i].yy) { for (j=x;j\u0026lt;=xx;++j) { del(a[j][yy]); } --yy; } out[q[i].id]=ans; } for (i=0;i\u0026lt;m;++i) { cout\u0026lt;\u0026lt;out[i]\u0026lt;\u0026lt;endl; } return 0; } void add(int x) { ans=ans+2*cnt[x]+1; ++cnt[x]; } void del(int x) { ans=ans-2*cnt[x]+1; --cnt[x]; }  ","date":"2018-10-02T18:23:00+08:00","permalink":"https://ouuan.github.io/post/%E4%BA%8C%E7%BB%B4%E8%8E%AB%E9%98%9F%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/","tags":["莫队"],"title":"二维莫队解题报告"},{"categories":["游记"],"contents":"想了想，像之前那样简略地叙述题意和做法，根本没讲清楚，没有任何意义，还不如写写自己的感受。\n感觉YALI真的是一所挺不错的学校吧。总是能有一机房的julao轮番吊打你，总是能有集训队的奆佬来给你出dltm、给你讲题。每天放学回酒店的路上还能看到操场上一群目测是田径队之类的同学在努力地训练着。到处都洋溢着「青春」的氛围，反倒是老师见得很少（或许是国庆的缘故吧..）。YALI在我心中已经不止是那个在OIerDb的“全国信息学竞赛学校排名2018”上排名第一的学校了。\n这几天去掉失误基本上都能排在前 $20$，但其他julao也会失误，所以是不存在“如果没有失误”的\u0026hellip;\n既然生在了弱省，就更要把眼光放在省外。OIerDb学校排行榜$rank1\\sqrt{}$，OIerDb学校排行榜$rank5\\sqrt{}​$。\n虽然写的很短，还是比之前几乎什么都没写好吧.\n———————————————以上于7号上午———————————————\n到了YALI的学生们返校的下午，YALI变得和外高没什么两样了\u0026hellip;或许是那些国庆还在学校的人们让我看到了YALI不同的一面吧.\n","date":"2018-10-01T19:27:01+08:00","permalink":"https://ouuan.github.io/post/2018%E5%9B%BD%E5%BA%86yali%E9%9B%86%E8%AE%AD%E6%B8%B8%E8%AE%B0/","tags":["集训"],"title":"2018国庆YALI集训游记"},{"categories":["知识点"],"contents":"这几天学习了莫队算法，试着写一篇比较详细的莫队教程吧\u0026hellip;\n普通莫队 简介 莫队是一种基于分块思想的离线算法，用于解决区间问题，适用范围如下：\n  只有询问没有修改。\n  允许离线。\n  在已知询问 $[l,r]$ 答案的情况下可以 $O(1)$ 得到 $[l,r-1],[l,r+1],[l-1,r],[l+1,r]$ 的答案。\n  满足以上三个条件就可以在 $O(n\\sqrt{m}+m\\log m)​$ 的时间复杂度下得到每个询问的解。\n算法思想 莫队的精髓就在于通过对询问进行排序，并把询问的结果作为下一个询问求解的基础，使得暴力求解的复杂度得到保证。\n上文中“适用范围”的第三点“在已知询问 $[l,r]$ 答案的情况下可以 $O(1)$ 得到 $[l,r-1],[l,r+1],[l-1,r],[l+1,r]$ 的答案”即是“把询问的结果作为下一个询问求解的基础”的方法。\n例题解析 例：[国家集训队]小Z的袜子\n在这题中，用 $cnt_i$ 表示当前处理的区间内颜色为i的袜子出现的次数，用 $\\mathrm{len}$ 表示当前处理的区间的长度，用 $x$ 表示新增的那只袜子的颜色。\n以已知区间 $[l,r]$ 的答案求解区间 $[l,r+1]$ 为例。分别处理分子和分母：\n 分母为任选两只袜子的组合总数，原先是 $\\frac{\\mathrm{len}(\\mathrm{len}-1)}{2}$，现在是 $\\frac{\\mathrm{len}(\\mathrm{len}+1)}{2}$，增加了 $\\mathrm{len}$ 。 分子为两只袜子颜色相同的组合总数，比原来增加了 $cnt_x$，即新增的这只袜子和原本就在当前区间内的相同颜色的袜子的组合。  因此，将一只颜色为x的袜子计入答案的函数就可以写出来了：\n//fz代表分子，fm代表分母 void add(int x) { fz+=cnt[x]; ++cnt[x]; fm+=len; ++len; }  同理可以写出将一只颜色为x的袜子移出答案的函数：\nvoid del(int x) { --cnt[x]; fz-=cnt[x]; --len; fm-=len; }  于是，我们就可以得到一个暴力的算法：用 $l$ 和 $r$ 分别记录当前区间的两个端点，然后用下面这段代码来更新答案（q[i].l,q[i].r代表正在处理的询问的两个端点，col[p]代表第 $p$ 只袜子的颜色）：\nwhile (l\u0026gt;q[i].l) { add(col[--l]); } while (r\u0026lt;q[i].r) { add(col[++r]); } while (l\u0026lt;q[i].l) { del(col[l++]); } while (r\u0026gt;q[i].r) { del(col[r--]); }  然而，这个算法的时间复杂度是 $O(nm)$ 的（因为最坏情况下每次 $l$ 和 $r$ 两个指针都要走 $O(n)$ 的距离，而一共有 $m$ 次询问），和暴力完全一样甚至跑的更慢。\n优化复杂度 别忘了，之前我说过，莫队的精髓就在于通过对询问进行排序，使得暴力求解的复杂度得到保证。\n我们的目的是使 $l$ 和 $r$ 两个指针走过的总距离尽量的小，这时候就要用到分块的思想了。\n把整个区间 $[1,n]$ 分成若干块，以询问的左端点所在块为第一关键字，以询问的右端点大小为第二关键字，对询问进行排序，那么：\n 对于同一块的询问，$l$ 指针每次最多移动块的大小，$r$ 指针的移动则是单调的，总共移动最多 $n$ 。 对于不同块的询问，$l$ 每次换块时最多移动两倍块的大小， $r$ 每次换块时最多移动 $n$ 。  总结：（用 $B$ 表示块的大小）$l$ 指针每次移动 $O(B)$，$r$ 指针每块移动 $O(n)​$ 。\n所以：\n $l$ 的移动次数最多为询问数 $\\times$ 块的大小，即 $O(mB)$ 。 $r$ 的移动次数最多为块的个数 $\\times$ 总区间大小，即 $O(n^2/B)$ 。  因此，总移动次数为 $O(mB+n^2/B)$ 。\n 实际上，“换块”这一事件发生的次数并不多，因此即便换块复杂度达到 $\\mathcal O(n)$ 也是不会影响复杂度的。只不过一般情况下块是相邻的，换块复杂度就比较小。\n—— update on 2019.7.27\n 没错，这就是个双勾函数，所以当 $B=\\sqrt{\\frac{n^2}{m}}$ 即 $\\frac{n}{\\sqrt{m}}$ 时复杂度最小，为 $O(n\\sqrt{m})$ 。\n剩下的最后一个问题：初始的当前区间是什么？\n只要任意指定一个空区间就好了，如 $l=1,r=0$ 。\n所以，整个莫队算法就可以概括为：\n  将询问记录下来。\n  以 $\\frac{n}{\\sqrt{m}}$ 为块的大小，以询问的左端点所在块为第一关键字，以询问的右端点大小为第二关键字，对询问进行排序。\n  暴力处理每个询问。\n  输出答案。\n  总的复杂度为 $O(n\\sqrt{m}+m\\log m)$ 。\nP.S. 网上很多教程说分块大小取 $\\sqrt{n}$ 最优，复杂度为 $O(n\\sqrt{n})$，这是不严谨的，当n、m差别较大时使用 $\\sqrt{n}$ 作为分块大小效率会明显偏低。\n例题代码 [国家集训队]小Z的袜子 AC代码：\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;cmath\u0026gt; using namespace std; const int N=50010; void add(int x); void del(int x); int gcd(int a,int b); int n,m,B,fz,fm,len,col[N],cnt[N],ans[N][2]; struct Query { int l,r,id; bool operator\u0026lt;(Query\u0026amp; b) { return l/B==b.l/B?r\u0026lt;b.r:l\u0026lt;b.l; } } q[N]; int main() { int i,l=1,r=0,g; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m; B=n/sqrt(m); for (i=1;i\u0026lt;=n;++i) { cin\u0026gt;\u0026gt;col[i]; } for (i=0;i\u0026lt;m;++i) { cin\u0026gt;\u0026gt;q[i].l\u0026gt;\u0026gt;q[i].r; q[i].id=i; } sort(q,q+m); for (i=0;i\u0026lt;m;++i) { if (q[i].l==q[i].r) { ans[q[i].id][0]=0; ans[q[i].id][1]=1; continue; } while (l\u0026gt;q[i].l) { add(col[--l]); } while (r\u0026lt;q[i].r) { add(col[++r]); } while (l\u0026lt;q[i].l) { del(col[l++]); } while (r\u0026gt;q[i].r) { del(col[r--]); } g=gcd(fz,fm); ans[q[i].id][0]=fz/g; ans[q[i].id][1]=fm/g; } for (i=0;i\u0026lt;m;++i) { printf(\u0026quot;%d/%d\\n\u0026quot;,ans[i][0],ans[i][1]); } return 0; } void add(int x) { fz+=cnt[x]; ++cnt[x]; fm+=len; ++len; } void del(int x) { --cnt[x]; fz-=cnt[x]; --len; fm-=len; } int gcd(int a,int b) { return b==0?a:gcd(b,a%b); }  其它例题 小B的询问\n带修莫队 前面说过，普通的莫队只能解决没有修改的问题，那么带修改的问题怎么解决呢？带修莫队就是一种支持单点修改的莫队算法。\n算法简介 还是对询问进行排序，每个询问除了左端点和右端点还要记录这次询问是在第几次修改之后（时间），以左端点所在块为第一关键字，以右端点所在块为第二关键字，以时间为第三关键字进行排序。\n暴力查询时，如果当前修改数比询问的修改数少就把没修改的进行修改，反之回退。\n需要注意的是，修改分为两部分：\n  若修改的位置在当前区间内，需要更新答案（del原颜色，add修改后的颜色）。\n  无论修改的位置是否在当前区间内，都要进行修改（以供add和del函数在以后更新答案）。\n  分块大小的选择以及复杂度证明 （用 $B$ 表示分块大小，$c$ 表示修改个数，$q$ 表示询问个数，l块表示以 $l/B$ 分的块，r块表示以 $r/B$ 分的块，每个l块包含 $n/B$ 个r块）\n  对于时间指针 $now$：对于每个r块，最坏情况下会移动 $c$，共有 $\\left(\\frac{n}{B}\\right)^2$ 个r块，所以总移动次数为 $\\frac{cn^2}{B^2}$ 。\n  对于左端点指针 $l$ ：l块内移动每次最多 $B$，换l块每次最多 $2B$，所以总移动次数为 $O(qB)$ 。\n  对于右端点指针 $r​$：r块内移动每次最多 $B​$，换r块每次最多 $2B​$，所有l块内移动次数之和为 $O(qB)​$；换l块时最多移动 $n​$，总的换l块时移动次数为 $O\\left(\\frac{n^2}{B}\\right)​$；所以总的移动次数为 $O\\left(qB+\\frac{n^2}{B}\\right)​$ 。\n  所以：总移动次数为 $O\\left(\\frac{cn^2}{B^2}+qB+\\frac{n^2}{B}\\right)$ 。\n 实际上，“换块”这一事件发生的次数并不多，因此即便换块复杂度达到 $\\mathcal O(n)​$ 也是不会影响复杂度的。只不过一般情况下块是相邻的，换块复杂度就比较小。\n—— update on 2019.7.27\n 由于一般的题目都不会告诉你修改和询问分别的个数，所以统一用 $m​$ 表示，即 $O\\left(\\frac{mn^2}{B^2}+mB+\\frac{n^2}{B}\\right)​$ 。\n那么 $B$ 取多少呢\u0026hellip;Mathematica告诉我大约是这个： 所以还是不要纠结带修莫队的最佳分块大小好了\u0026hellip;视作 $n=m​$ 的话，就可以得到总移动次数为 $O\\left(\\frac{n^3}{B^2}+nB+\\frac{n^2}{B}\\right)​$，那么 $B=n^{\\frac{2}{3}}​$ 时取最小值 $O\\left(n^{\\frac{5}{3}}\\right)​$ 。\n所以：带修莫队的渐进时间复杂度为 $O\\left(n\\log n+n^{\\frac{5}{3}}\\right)$ （视作 $n=m$）。\n例题代码 这次就不详细分析例题了，直接上代码。\n[国家集训队]数颜色 AC代码：\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;cmath\u0026gt; using namespace std; void add(int x); void del(int x); void modify(int x,int ti); //这个函数会执行或回退修改ti（执行还是回退取决于是否执行过，具体通过swap实现），x表明当前的询问是x，即若修改了区间[q[x].l,q[x].r]便要更新答案 int n,m,B,cnt[1000010],a[50010],ans,ccnt,qcnt,now,out[50010]; struct Change { int p,col; } c[50010]; struct Query { int l,r,t,id; bool operator\u0026lt;(Query\u0026amp; b) { return l/B==b.l/B?(r/B==b.r/B?t\u0026lt;b.t:r\u0026lt;b.r):l\u0026lt;b.l; } } q[50010]; int main() { int i,l=2,r=1; char type[10]; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m; B=pow(n,0.66666); for (i=1;i\u0026lt;=n;++i) { cin\u0026gt;\u0026gt;a[i]; } for (i=1;i\u0026lt;=m;++i) { scanf(\u0026quot;%s\u0026quot;,type); if (type[0]=='Q') { ++qcnt; cin\u0026gt;\u0026gt;q[qcnt].l\u0026gt;\u0026gt;q[qcnt].r; q[qcnt].t=ccnt; q[qcnt].id=qcnt; } else { ++ccnt; cin\u0026gt;\u0026gt;c[ccnt].p\u0026gt;\u0026gt;c[ccnt].col; } } sort(q+1,q+qcnt+1); for (i=1;i\u0026lt;=qcnt;++i) { while (l\u0026gt;q[i].l) { add(a[--l]); } while (r\u0026lt;q[i].r) { add(a[++r]); } while (l\u0026lt;q[i].l) { del(a[l++]); } while (r\u0026gt;q[i].r) { del(a[r--]); } while (now\u0026lt;q[i].t) { modify(i,++now); } while (now\u0026gt;q[i].t) { modify(i,now--); } out[q[i].id]=ans; } for (i=1;i\u0026lt;=qcnt;++i) { cout\u0026lt;\u0026lt;out[i]\u0026lt;\u0026lt;endl; } return 0; } void add(int x) { if (cnt[x]++==0) { ++ans; } } void del(int x) { if (--cnt[x]==0) { --ans; } } void modify(int x,int ti) { if (c[ti].p\u0026gt;=q[x].l\u0026amp;\u0026amp;c[ti].p\u0026lt;=q[x].r) { del(a[c[ti].p]); add(c[ti].col); } swap(a[c[ti].p],c[ti].col); //下次执行时必定是回退这次操作，直接互换就可以了 }  其它例题 CF940F Machine Learning\n树上莫队 其实，莫队算法除了序列还可以用于树。复杂度同序列上的莫队（不带修 $O(n\\sqrt{m}+m\\log m)​$，带修 $O\\left(n\\log n+n^{\\frac{5}{3}}\\right)$）。\n例题：[WC2013]糖果公园\n分块方式 这里需要看一道专门为树上莫队设计的题目 [SCOI2005]王室联邦。\n用这道题所要求的方式进行分块，并用后文的方式更新答案，就能保证复杂度（复杂度分析见后文）。\n那么如何满足每块大小在 $[B,3B]$，块内每个点到核心点路径上的所有点都在块内呢？\n这里先提供一种构造方式，再予以证明：\ndfs，并创建一个栈，dfs一个点时先记录初始栈顶高度，每dfs完当前节点的一棵子树就判断栈内（相对于刚开始dfs时）新增节点的数量是否≥B，是则将栈内所有新增点分为同一块，核心点为当前dfs的点，当前节点结束dfs时将当前节点入栈，整个dfs结束后将栈内所有剩余节点归入已经分好的最后一个块。\n参考代码：\nvoid dfs(int u,int fa) { int t=top; for (int i=head[u];i;i=nxt[i]) { int v=to[i]; if (v!=fa) { dfs(v,u); if (top-t\u0026gt;=B) { key[++tot]=u; while (top\u0026gt;t) bl[stk[top--]]=tot; } } } stk[++top]=u; } int main() { //....... dfs(1,0); if (!tot) ++tot; key[tot]=1; while (top) bl[stk[top--]]=tot; }  如果你看懂了这个方法的话，每块大小≥B是显然的，下面证明为何每块大小≤3B：\n对于当前节点的每一棵子树：\n  若未被分块的节点数\u0026gt;B，那么在dfs这棵子树的根节点时就一定会把这棵子树的一部分分为一块直至这棵子树的剩余节点数≤B，所以这种情况不存在。\n  若未被分块的节点数=B，这些节点一定会和栈中所有节点分为一块，栈中之前还剩 $[0,B-1]$ 个节点，那么这一块的大小为 $[B,2B-1]$ 。\n  若未被分块的节点数\u0026lt;B，当未被分块的节点数+栈中剩余节点数≥B时，这一块的大小为 $[B,2B-1)$，否则继续进行下一棵子树。\n  对于dfs结束后栈内剩余节点，数量一定在 $[1,B]​$ 内，而已经分好的每一块的大小为 $[B,2B-1]​$，所以每块的大小都在 $[B,3B)​$ 内。\n修改方式 所谓“修改”，就是由询问 $(cu,cv)$ 更新至询问 $(tu,tv)$ 。\n如果把两条路径上的点全部修改复杂度是和暴力一样的，所以需要做一些处理。\n（下文中 $T(u,v)​$ 表示 $u​$ 到 $v​$ 的路径上除 $lca(u,v)​$ 外的所有点构成的集合，$S(u,v)​$ 代表u到v的路径，$xor​$ 表示集合对称差（就跟异或差不多））\n 两个指针 $cu,cv​$ （相当于序列莫队的 $l,r​$ 两个指针）， $ans​$记录$T(cu,cv)​$ 的答案，$vis​$ 数组记录每个节点是否在 $T(cu,cv)​$ 内； 由 $T(cu,cv)​$ 更新至 $T(tu,tv)​$ 时，将 $T(cu,tu)​$ 和 $T(cv,tv)​$ 的 $vis​$ 分别取反，并相应地更新答案； 将答案记录到 $out​$ 数组（离线后用于输出那个）时对 $lca(cu,cv)​$ （此时的 $cu,cv​$ 已更新为上一步中的 $tu,tv​$） 的 $vis​$ 取反并更新答案，记录完再改回来（因为 $lca​$ 处理比较麻烦，这样搞比较方便）。  第二步证明如下：\n$$ \\begin{aligned} \u0026amp;T(cu, cv)\\operatorname{xor}T(tu, tv)\\\\\n=\u0026amp;(S(cu, root)\\operatorname{xor}S(cv, root))\\operatorname{xor}(S(tu, root)\\operatorname{xor}S(tv, root))\\\\\n=\u0026amp;(S(cu, root)\\operatorname{xor}S(tu, root))\\operatorname{xor}(S(cv, root)\\operatorname{xor}S(tv, root))\\\\\n=\u0026amp;T(cu, tu)\\operatorname{xor}T(cv, tv) \\end{aligned} $$\n之所以要把 $T(cu,cv)\\operatorname{xor}T(tu,tv)$ 转化成 $T(cu,tu)\\operatorname{xor}T(cv,tv)$，是因为这样的话就能通过对询问排序来保证复杂度。排序方式就是以 $u$ 所在块编号为第一关键字，$v​$ 的编号为第二关键字排序。如果是带修莫队，就还要以时间为第三关键字。\n关于单点修改 树上莫队的单点修改和序列莫队类似，唯一不同就是，修改后是否更新答案通过 $vis$ 数组判断。\n复杂度分析 每块大小在 $[B,3B)​$，所以两点间路径长度也在 $[B,3B)​$，块内移动就是 $\\mathcal O(B)​$ 的，然后就和序列莫队的复杂度分析类似了\u0026hellip;\n例题代码 [WC2013]糖果公园\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;cmath\u0026gt; using namespace std; const int N=100010; void pathmodify(int u,int v); //将T(u,v)取反并更新答案 void opp(int x); //将节点x取反并更新答案 void modify(int ti); //进行或回退修改ti int lca(int u,int v); void dfs(int u); //进行分块并记录dep数组、f数组（用于求lca、两点间路径） void add(int u,int v); int head[N],nxt[N\u0026lt;\u0026lt;1],to[N\u0026lt;\u0026lt;1],cnt; int n,m,Q,B,bl[N],tot,V[N],W[N],a[N],stk[N],top,qcnt,ccnt,dep[N],f[20][N],num[N],now; long long ans,out[N]; bool vis[N]; struct Query { int u,v,t,id; bool operator\u0026lt;(Query\u0026amp; y) { return bl[u]==bl[y.u]?(bl[v]==bl[y.v]?t\u0026lt;y.t:bl[v]\u0026lt;bl[y.v]):bl[u]\u0026lt;bl[y.u]; } } q[N]; struct Change { int p,x; } c[N]; int main() { int i,j,u,v,lc,type; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m\u0026gt;\u0026gt;Q; B=pow(n,0.666); for (i=1;i\u0026lt;=m;++i) cin\u0026gt;\u0026gt;V[i]; for (i=1;i\u0026lt;=n;++i) cin\u0026gt;\u0026gt;W[i]; for (i=1;i\u0026lt;n;++i) { cin\u0026gt;\u0026gt;u\u0026gt;\u0026gt;v; add(u,v); add(v,u); } dfs(1); for (i=1;i\u0026lt;=16;++i) { for (j=1;j\u0026lt;=n;++j) { f[i][j]=f[i-1][f[i-1][j]]; } } while (top) bl[stk[top--]]=tot; for (i=1;i\u0026lt;=n;++i) cin\u0026gt;\u0026gt;a[i]; for (i=0;i\u0026lt;Q;++i) { cin\u0026gt;\u0026gt;type; if (type==0) { ++ccnt; cin\u0026gt;\u0026gt;c[ccnt].p\u0026gt;\u0026gt;c[ccnt].x; } else { cin\u0026gt;\u0026gt;q[qcnt].u\u0026gt;\u0026gt;q[qcnt].v; q[qcnt].t=ccnt; q[qcnt].id=qcnt; ++qcnt; } } sort(q,q+qcnt); u=v=1; for (i=0;i\u0026lt;qcnt;++i) { pathmodify(u,q[i].u); pathmodify(v,q[i].v); u=q[i].u; v=q[i].v; while (now\u0026lt;q[i].t) modify(++now); while (now\u0026gt;q[i].t) modify(now--); lc=lca(u,v); opp(lc); out[q[i].id]=ans; opp(lc); } for (i=0;i\u0026lt;qcnt;++i) cout\u0026lt;\u0026lt;out[i]\u0026lt;\u0026lt;endl; return 0; } void pathmodify(int u,int v) { if (dep[u]\u0026lt;dep[v]) swap(u,v); while (dep[u]\u0026gt;dep[v]) { opp(u); u=f[0][u]; } while (u!=v) { opp(u); opp(v); u=f[0][u]; v=f[0][v]; } } void opp(int x) { if (vis[x]) ans-=1ll*V[a[x]]*W[num[a[x]]--]; else ans+=1ll*V[a[x]]*W[++num[a[x]]]; vis[x]^=1; } void modify(int ti) { if (vis[c[ti].p]) { opp(c[ti].p); swap(a[c[ti].p],c[ti].x); opp(c[ti].p); } else swap(a[c[ti].p],c[ti].x); } int lca(int u,int v) { if (dep[u]\u0026lt;dep[v]) { swap(u,v); } int i; for (i=0;i\u0026lt;=16;++i) { if ((dep[u]-dep[v])\u0026amp;(1\u0026lt;\u0026lt;i)) { u=f[i][u]; } } if (u==v) return u; for (i=16;i\u0026gt;=0;--i) { if (f[i][u]!=f[i][v]) { u=f[i][u]; v=f[i][v]; } } return f[0][u]; } void dfs(int u) { int t=top; for (int i=head[u];i;i=nxt[i]) { int v=to[i]; if (v!=f[0][u]) { f[0][v]=u; dep[v]=dep[u]+1; dfs(v); if (top-t\u0026gt;=B) { ++tot; while (top\u0026gt;t) bl[stk[top--]]=tot; } } } stk[++top]=u; } void add(int u,int v) { nxt[++cnt]=head[u]; head[u]=cnt; to[cnt]=v; }  回滚莫队（只增莫队） 适用范围  删除时不方便统计答案。 可以方便地回滚单次操作，即修改造成的影响要么能够在 $\\mathcal O(\\sqrt n)$ 内保存下来，要么可以 $\\mathcal O(1)​$ 地回滚单次增加。  算法流程  对于左右端点在同一块的暴力计算。 跟普通莫队一样排序，左端点换块时清空答案，把左指针设为左端点所在块的下一块的开头，把右指针设为左端点所在块的最后一位。这样右指针是单调递增的，每处理一个询问时，先记录一些信息（比如答案），再左移左指针并更新答案，然后把左指针移回左端点所在块的下一块的开头，过程中回滚除记录下的信息以外的其它影响，最后把记录下的信息恢复。如：先右移右指针，再记录 ans，然后左移左指针时增加 cnt 并更新 ans，回滚时把增加的 cnt 减掉，最后把 ans 回滚为记录的值。  例题 \u0026amp; 代码 BZOJ4241 历史研究\n参考代码 #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;cctype\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; typedef long long ll; const int N = 100010; const int B = 333; int read() { int out = 0; char c; while (!isdigit(c = getchar())); for (; isdigit(c); c = getchar()) out = out * 10 + c - '0'; return out; } struct Query { int l, r, id; bool operator\u0026lt;(const Query \u0026amp; y) const { return l / B == y.l / B ? r \u0026lt; y.r : l \u0026lt; y.l; } } q[N]; void add(int x); int n, m, a[N], lsh[N], tot, cnt[N]; ll ans, bk, out[N]; int main() { int i, j, l, r, bl = -1; n = read(); m = read(); for (i = 1; i \u0026lt;= n; ++i) a[i] = lsh[++tot] = read(); sort(lsh + 1, lsh + tot + 1); tot = unique(lsh + 1, lsh + tot + 1) - lsh; for (i = 1; i \u0026lt;= n; ++i) a[i] = lower_bound(lsh + 1, lsh + tot, a[i]) - lsh; for (i = 1; i \u0026lt;= m; ++i) { q[i].l = read(); q[i].r = read(); q[i].id = i; if (q[i].l / B == q[i].r / B) // 暴力处理左右端点在同一块的询问 { for (j = q[i].l; j \u0026lt;= q[i].r; ++j) { ++cnt[a[j]]; out[i] = max(out[i], (ll) cnt[a[j]] * lsh[a[j]]); } for (j = q[i].l; j \u0026lt;= q[i].r; ++j) --cnt[a[j]]; } } sort(q + 1, q + m + 1); for (i = 1; i \u0026lt;= m; ++i) { if (q[i].l / B == q[i].r / B) continue; if (i == 1 || q[i].l / B != bl) // 左端点换块 { ans = 0; bl = q[i].l / B; memset(cnt, 0, sizeof(cnt)); l = (bl + 1) * B; r = (bl + 1) * B - 1; } while (r \u0026lt; q[i].r) add(a[++r]); // 右移右指针 bk = ans; // 记录 ans while (l \u0026gt; q[i].l) add(a[--l]); // 左移左指针并更新答案 out[q[i].id] = ans; while (l \u0026lt; (bl + 1) * B) --cnt[a[l++]]; // 回滚 ans = bk; // 把 ans 修改回来 } for (i = 1; i \u0026lt;= m; ++i) printf(\u0026quot;%lld\\n\u0026quot;, out[i]); return 0; } void add(int x) { ++cnt[x]; ans = max(ans, (ll) cnt[x] * lsh[x]); }   莫队的扩展 其实莫队可以扩展到高维，参见二维莫队解题报告。\n更一般地，若 $Q(x_1,x_2,\\cdots,x_k)​$ 为一个询问，$\\forall i\\in[1,k]​$，$x_i​$ 的规模都为 $n​$，可以在时间 $\\mathrm{T}​$ 内求解 $Q(x_1,x_2,\\cdots,x_i\\pm 1,\\cdots,x_n)​$，共有 $m​$ 个询问，那么就可以在 $O\\left(km\\log m+nTm^\\frac{k-1}{k}\\right)​$ 的时间复杂度下离线求解。\n（蒟蒻的大胆猜想而已..并没有严格证明）\n","date":"2018-09-30T17:19:58+08:00","permalink":"https://ouuan.github.io/post/%E8%8E%AB%E9%98%9F%E5%B8%A6%E4%BF%AE%E8%8E%AB%E9%98%9F%E6%A0%91%E4%B8%8A%E8%8E%AB%E9%98%9F%E8%AF%A6%E8%A7%A3/","tags":["离线算法","莫队"],"title":"莫队、带修莫队、树上莫队详解"}]