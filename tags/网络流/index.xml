<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>网络流 on ouuan的博客</title>
    <link>https://ouuan.github.io/tags/%E7%BD%91%E7%BB%9C%E6%B5%81/</link>
    <description>Recent content in 网络流 on ouuan的博客</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Sat, 26 Oct 2019 19:50:25 +0800</lastBuildDate>
    
	<atom:link href="https://ouuan.github.io/tags/%E7%BD%91%E7%BB%9C%E6%B5%81/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>基于 Capacity Scaling 的弱多项式复杂度最小费用流算法</title>
      <link>https://ouuan.github.io/post/%E5%9F%BA%E4%BA%8E-capacity-scaling-%E7%9A%84%E5%BC%B1%E5%A4%9A%E9%A1%B9%E5%BC%8F%E5%A4%8D%E6%9D%82%E5%BA%A6%E6%9C%80%E5%B0%8F%E8%B4%B9%E7%94%A8%E6%B5%81%E7%AE%97%E6%B3%95/</link>
      <pubDate>Sat, 26 Oct 2019 19:50:25 +0800</pubDate>
      
      <guid>https://ouuan.github.io/post/%E5%9F%BA%E4%BA%8E-capacity-scaling-%E7%9A%84%E5%BC%B1%E5%A4%9A%E9%A1%B9%E5%BC%8F%E5%A4%8D%E6%9D%82%E5%BA%A6%E6%9C%80%E5%B0%8F%E8%B4%B9%E7%94%A8%E6%B5%81%E7%AE%97%E6%B3%95/</guid>
      <description>&lt;p&gt;大多数人所使用的费用流算法，即每次求出残量网络中 $s$ 到 $t$ 关于费用的最短路进行增广（将 Dinic 最大流算法中的 BFS 改为 SPFA），是伪多项式复杂度的，最坏情况下复杂度为 $O(nmf)$，其中 $f$ 为最大流。已知有一种在点数为 $n$，边数为 $O(n^2)$，值域为 $O(2^{n/2})$ 时将其用时卡成关于 $n$ 的指数级复杂度的构造方法。&lt;/p&gt;
&lt;p&gt;本文将介绍一种复杂度为进行 $O(m\log U)$ 次（$U$ 表示边的最大容量）无负权边单源最短路（使用 &lt;code&gt;priority_queue&lt;/code&gt; 实现 Dijkstra 算法，总复杂度即为 $O(m^2\log U\log m)$）的弱多项式复杂度算法。&lt;/p&gt;
&lt;p&gt;其实这个算法并不是很复杂（只是相关资料比较少，会对学习造成一定困难，这也是我写这篇博客的原因），最小费用最大流的模板也只需要 $2.5KB$，并不比常见的伪多项式复杂度算法长很多。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>CF512C Fox And Dinner（二分图，最大流）</title>
      <link>https://ouuan.github.io/post/cf512c-fox-and-dinner%E4%BA%8C%E5%88%86%E5%9B%BE%E6%9C%80%E5%A4%A7%E6%B5%81/</link>
      <pubDate>Tue, 15 Oct 2019 19:50:54 +0800</pubDate>
      
      <guid>https://ouuan.github.io/post/cf512c-fox-and-dinner%E4%BA%8C%E5%88%86%E5%9B%BE%E6%9C%80%E5%A4%A7%E6%B5%81/</guid>
      <description>&lt;h2 id=&#34;题目链接&#34;&gt;题目链接&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://codeforces.com/contest/512/problem/C&#34; target=&#34;_blank&#34;&gt;CF&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;题意简述&#34;&gt;题意简述&lt;/h2&gt;
&lt;p&gt;给你 $n$ 个整数，需要将它们分成任意个至少包含 $3$ 个数的环，使得每相邻两个数加起来是一个质数。&lt;/p&gt;
&lt;p&gt;判断是否有解，若有解输出任意一组解。&lt;/p&gt;
&lt;p&gt;$3\le n\le 200$, 数的范围是 $[2,10^4]$。&lt;/p&gt;</description>
    </item>
    
  </channel>
</rss>