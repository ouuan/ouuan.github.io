<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>网络流 on ouuan的博客</title><link>https://ouuan.github.io/tags/%E7%BD%91%E7%BB%9C%E6%B5%81/</link><description>Recent content in 网络流 on ouuan的博客</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Sat, 26 Oct 2019 19:50:25 +0800</lastBuildDate><atom:link href="https://ouuan.github.io/tags/%E7%BD%91%E7%BB%9C%E6%B5%81/index.xml" rel="self" type="application/rss+xml"/><item><title>基于 Capacity Scaling 的弱多项式复杂度最小费用流算法</title><link>https://ouuan.github.io/post/%E5%9F%BA%E4%BA%8E-capacity-scaling-%E7%9A%84%E5%BC%B1%E5%A4%9A%E9%A1%B9%E5%BC%8F%E5%A4%8D%E6%9D%82%E5%BA%A6%E6%9C%80%E5%B0%8F%E8%B4%B9%E7%94%A8%E6%B5%81%E7%AE%97%E6%B3%95/</link><pubDate>Sat, 26 Oct 2019 19:50:25 +0800</pubDate><guid>https://ouuan.github.io/post/%E5%9F%BA%E4%BA%8E-capacity-scaling-%E7%9A%84%E5%BC%B1%E5%A4%9A%E9%A1%B9%E5%BC%8F%E5%A4%8D%E6%9D%82%E5%BA%A6%E6%9C%80%E5%B0%8F%E8%B4%B9%E7%94%A8%E6%B5%81%E7%AE%97%E6%B3%95/</guid><description>&lt;p>大多数人所使用的费用流算法，即每次求出残量网络中 $s$ 到 $t$ 关于费用的最短路进行增广（将 Dinic 最大流算法中的 BFS 改为 SPFA），是伪多项式复杂度的，最坏情况下复杂度为 $O(nmf)$，其中 $f$ 为最大流。已知有一种在点数为 $n$，边数为 $O(n^2)$，值域为 $O(2^{n/2})$ 时将其用时卡成关于 $n$ 的指数级复杂度的构造方法。&lt;/p>
&lt;p>本文将介绍一种复杂度为进行 $O(m\log U)$ 次（$U$ 表示边的最大容量）无负权边单源最短路（使用 &lt;code>priority_queue&lt;/code> 实现 Dijkstra 算法，总复杂度即为 $O(m^2\log U\log m)$）的弱多项式复杂度算法。&lt;/p>
&lt;p>其实这个算法并不是很复杂（只是相关资料比较少，会对学习造成一定困难，这也是我写这篇博客的原因），最小费用最大流的模板也只需要 $2.5KB$，并不比常见的伪多项式复杂度算法长很多。&lt;/p></description></item><item><title>CF512C Fox And Dinner（二分图，最大流）</title><link>https://ouuan.github.io/post/cf512c-fox-and-dinner%E4%BA%8C%E5%88%86%E5%9B%BE%E6%9C%80%E5%A4%A7%E6%B5%81/</link><pubDate>Tue, 15 Oct 2019 19:50:54 +0800</pubDate><guid>https://ouuan.github.io/post/cf512c-fox-and-dinner%E4%BA%8C%E5%88%86%E5%9B%BE%E6%9C%80%E5%A4%A7%E6%B5%81/</guid><description>&lt;h2 id="题目链接">题目链接&lt;/h2>
&lt;p>&lt;a href="https://codeforces.com/contest/512/problem/C">CF&lt;/a>&lt;/p>
&lt;h2 id="题意简述">题意简述&lt;/h2>
&lt;p>给你 $n$ 个整数，需要将它们分成任意个至少包含 $3$ 个数的环，使得每相邻两个数加起来是一个质数。&lt;/p>
&lt;p>判断是否有解，若有解输出任意一组解。&lt;/p>
&lt;p>$3\le n\le 200$, 数的范围是 $[2,10^4]$。&lt;/p></description></item></channel></rss>