<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>图论 on ouuan的博客</title><link>https://ouuan.github.io/tags/%E5%9B%BE%E8%AE%BA/</link><description>Recent content in 图论 on ouuan的博客</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Tue, 18 Feb 2020 11:45:02 +0800</lastBuildDate><atom:link href="https://ouuan.github.io/tags/%E5%9B%BE%E8%AE%BA/index.xml" rel="self" type="application/rss+xml"/><item><title>CF603E Pastoral Oddities（结论，LCT/分治+并查集）</title><link>https://ouuan.github.io/post/cf603e/</link><pubDate>Tue, 18 Feb 2020 11:45:02 +0800</pubDate><guid>https://ouuan.github.io/post/cf603e/</guid><description>&lt;p>&lt;a href="https://codeforces.com/contest/603/problem/E">题目链接&lt;/a>&lt;/p>
&lt;div class="admonition question">
&lt;p class="admonition-title">题意简述&lt;/p>
&lt;p>给你一张边带权且边从 $1$ 到 $m$ 编号的无向图 $G$，称一张图 $H$ 是“好的”，当且仅当存在一个 $H$ 的生成子图 $F$ 使得 $F$ 中每个点的度数都是奇数。现在，你需要回答 $m$ 个问题，第 $i$ 个问题是：求最小的 $x$，使得仅保留 $G$ 中编号不超过 $i$ 且边权不超过 $x$ 的边时，得到的生成子图是“好的”，或者指出不存在这样的 $x$。&lt;/p>
&lt;p>$2\le n\le 10^5$, $1\le m\le 3\cdot 10^5$, TL 4s。&lt;/p>
&lt;/div></description></item><item><title>基于 Capacity Scaling 的弱多项式复杂度最小费用流算法</title><link>https://ouuan.github.io/post/%E5%9F%BA%E4%BA%8E-capacity-scaling-%E7%9A%84%E5%BC%B1%E5%A4%9A%E9%A1%B9%E5%BC%8F%E5%A4%8D%E6%9D%82%E5%BA%A6%E6%9C%80%E5%B0%8F%E8%B4%B9%E7%94%A8%E6%B5%81%E7%AE%97%E6%B3%95/</link><pubDate>Sat, 26 Oct 2019 19:50:25 +0800</pubDate><guid>https://ouuan.github.io/post/%E5%9F%BA%E4%BA%8E-capacity-scaling-%E7%9A%84%E5%BC%B1%E5%A4%9A%E9%A1%B9%E5%BC%8F%E5%A4%8D%E6%9D%82%E5%BA%A6%E6%9C%80%E5%B0%8F%E8%B4%B9%E7%94%A8%E6%B5%81%E7%AE%97%E6%B3%95/</guid><description>&lt;p>大多数人所使用的费用流算法，即每次求出残量网络中 $s$ 到 $t$ 关于费用的最短路进行增广（将 Dinic 最大流算法中的 BFS 改为 SPFA），是伪多项式复杂度的，最坏情况下复杂度为 $O(nmf)$，其中 $f$ 为最大流。已知有一种在点数为 $n$，边数为 $O(n^2)$，值域为 $O(2^{n/2})$ 时将其用时卡成关于 $n$ 的指数级复杂度的构造方法。&lt;/p>
&lt;p>本文将介绍一种复杂度为进行 $O(m\log U)$ 次（$U$ 表示边的最大容量）无负权边单源最短路（使用 &lt;code>priority_queue&lt;/code> 实现 Dijkstra 算法，总复杂度即为 $O(m^2\log U\log m)$）的弱多项式复杂度算法。&lt;/p>
&lt;p>其实这个算法并不是很复杂（只是相关资料比较少，会对学习造成一定困难，这也是我写这篇博客的原因），最小费用最大流的模板也只需要 $2.5KB$，并不比常见的伪多项式复杂度算法长很多。&lt;/p></description></item><item><title>CF512C Fox And Dinner（二分图，最大流）</title><link>https://ouuan.github.io/post/cf512c-fox-and-dinner%E4%BA%8C%E5%88%86%E5%9B%BE%E6%9C%80%E5%A4%A7%E6%B5%81/</link><pubDate>Tue, 15 Oct 2019 19:50:54 +0800</pubDate><guid>https://ouuan.github.io/post/cf512c-fox-and-dinner%E4%BA%8C%E5%88%86%E5%9B%BE%E6%9C%80%E5%A4%A7%E6%B5%81/</guid><description>&lt;h2 id="题目链接">题目链接&lt;/h2>
&lt;p>&lt;a href="https://codeforces.com/contest/512/problem/C">CF&lt;/a>&lt;/p>
&lt;h2 id="题意简述">题意简述&lt;/h2>
&lt;p>给你 $n$ 个整数，需要将它们分成任意个至少包含 $3$ 个数的环，使得每相邻两个数加起来是一个质数。&lt;/p>
&lt;p>判断是否有解，若有解输出任意一组解。&lt;/p>
&lt;p>$3\le n\le 200$, 数的范围是 $[2,10^4]$。&lt;/p></description></item><item><title>CF508D Tanya and Password（欧拉路径）</title><link>https://ouuan.github.io/post/cf508d-tanya-and-password%E6%AC%A7%E6%8B%89%E8%B7%AF%E5%BE%84/</link><pubDate>Tue, 15 Oct 2019 15:01:00 +0800</pubDate><guid>https://ouuan.github.io/post/cf508d-tanya-and-password%E6%AC%A7%E6%8B%89%E8%B7%AF%E5%BE%84/</guid><description>&lt;h2 id="题目链接">题目链接&lt;/h2>
&lt;p>&lt;a href="https://codeforces.com/contest/508/problem/D">CF&lt;/a>&lt;/p>
&lt;h2 id="题意简述">题意简述&lt;/h2>
&lt;p>有一个字符串 $S[1..n+2]$，告诉你 $\forall 1\le i\le n, S[i..i+2]$（所有长为 $3$ 的子串），求任意一个满足条件的 $S$。&lt;/p>
&lt;p>$1\le n\le 2\cdot 10^5$，字符集为大小写字母 + 数字。&lt;/p></description></item><item><title>gym102268D Dates（贪心，二分图匹配，线段树）</title><link>https://ouuan.github.io/post/gym102268d-dates%E8%B4%AA%E5%BF%83%E4%BA%8C%E5%88%86%E5%9B%BE%E5%8C%B9%E9%85%8D%E7%BA%BF%E6%AE%B5%E6%A0%91/</link><pubDate>Fri, 11 Oct 2019 11:30:32 +0800</pubDate><guid>https://ouuan.github.io/post/gym102268d-dates%E8%B4%AA%E5%BF%83%E4%BA%8C%E5%88%86%E5%9B%BE%E5%8C%B9%E9%85%8D%E7%BA%BF%E6%AE%B5%E6%A0%91/</guid><description>&lt;h2 id="题目链接">题目链接&lt;/h2>
&lt;p>&lt;a href="https://codeforces.com/gym/102268/problem/D">CF&lt;/a>&lt;/p>
&lt;h2 id="题意简述">题意简述&lt;/h2>
&lt;p>给你一张二分图：左边 $t$ 个位置，第 $i$ 个位置上有 $a_i$ 个点；右边 $n$ 个带权的点，第 $i$ 个点与位置在 $[l_i, r_i]$ 之间的所有左边的点有连边；匹配权值为匹配中右边点的权值之和；求最大权匹配。&lt;/p>
&lt;p>$1\le n,t\le 3\cdot 10^5$，保证 $l_i\le l_{i+1}$, $r_i\le r_{i+1}$。&lt;/p></description></item><item><title>CF1209F Koala and Notebook（BFS，最短路）</title><link>https://ouuan.github.io/post/cf1209f-koala-and-notebookbfs%E6%9C%80%E7%9F%AD%E8%B7%AF/</link><pubDate>Mon, 16 Sep 2019 08:58:32 +0800</pubDate><guid>https://ouuan.github.io/post/cf1209f-koala-and-notebookbfs%E6%9C%80%E7%9F%AD%E8%B7%AF/</guid><description>&lt;h2 id="题目链接">题目链接&lt;/h2>
&lt;p>&lt;a href="http://codeforces.com/contest/1209/problem/F">CF&lt;/a>&lt;/p>
&lt;h2 id="题意简述">题意简述&lt;/h2>
&lt;p>给你一张 $n$ 个点 $m$ 条边的无向连通图，一条路径的权值是路径上的边的编号（十进制）顺次连接而成的数字。求 $1$ 到每个点的最短路，&lt;strong>输出&lt;/strong> 对 $10^9+7$ 取模。&lt;/p>
&lt;p>$2\le n\le10^5$, $n-1\le m\le10^5$。&lt;/p></description></item><item><title>LGV 引理学习笔记</title><link>https://ouuan.github.io/post/lgv-%E5%BC%95%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</link><pubDate>Tue, 03 Sep 2019 21:54:43 +0800</pubDate><guid>https://ouuan.github.io/post/lgv-%E5%BC%95%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</guid><description>&lt;p>Lindström–Gessel–Viennot lemma，即 LGV 引理，可以用来处理有向无环图上不相交路径计数等问题。&lt;/p></description></item><item><title>BZOJ2115 [WC2011]最大XOR和路径（线性基，图论）</title><link>https://ouuan.github.io/post/bzoj2115-wc2011-%E6%9C%80%E5%A4%A7xor%E5%92%8C%E8%B7%AF%E5%BE%84%E7%BA%BF%E6%80%A7%E5%9F%BA%E5%9B%BE%E8%AE%BA/</link><pubDate>Sun, 16 Jun 2019 20:46:02 +0800</pubDate><guid>https://ouuan.github.io/post/bzoj2115-wc2011-%E6%9C%80%E5%A4%A7xor%E5%92%8C%E8%B7%AF%E5%BE%84%E7%BA%BF%E6%80%A7%E5%9F%BA%E5%9B%BE%E8%AE%BA/</guid><description>&lt;h2 id="题目链接">题目链接&lt;/h2>
&lt;p>&lt;a href="https://www.luogu.org/problemnew/show/P4151">洛谷&lt;/a>&lt;/p>
&lt;p>&lt;a href="https://darkbzoj.tk/problem/2115">darkbzoj&lt;/a>&lt;/p>
&lt;h2 id="题意简述">题意简述&lt;/h2>
&lt;p>给你一张带边权的无向图，求 $1$ 到 $n$ 的边权异或和最大的路径。&lt;/p>
&lt;p>点数 $5\times 10^4$，边数 $10^5$。&lt;/p></description></item><item><title>[NOI2010]航空管制（建反图，拓扑排序，优先队列）</title><link>https://ouuan.github.io/post/noi2010-%E8%88%AA%E7%A9%BA%E7%AE%A1%E5%88%B6%E5%BB%BA%E5%8F%8D%E5%9B%BE%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/</link><pubDate>Fri, 19 Apr 2019 13:00:29 +0800</pubDate><guid>https://ouuan.github.io/post/noi2010-%E8%88%AA%E7%A9%BA%E7%AE%A1%E5%88%B6%E5%BB%BA%E5%8F%8D%E5%9B%BE%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/</guid><description>&lt;h2 id="题目链接">题目链接&lt;/h2>
&lt;p>&lt;a href="https://www.luogu.org/problemnew/show/P1954">洛谷&lt;/a>&lt;/p>
&lt;h2 id="题意简述">题意简述&lt;/h2>
&lt;p>给你一个 DAG，每个点有个值 $k_i$。&lt;/p>
&lt;p>第一问：求一个拓扑排序，使每个点出现的位置不超过 $k_i$。&lt;/p>
&lt;p>第二问：在满足第一问的拓扑排序中，求每个点分别的最早出现位置。&lt;/p></description></item></channel></rss>