<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[「HNOI2016」最小公倍数（回滚莫队，并查集）]]></title>
    <url>%2F%E3%80%8CHNOI2016%E3%80%8D%E6%9C%80%E5%B0%8F%E5%85%AC%E5%80%8D%E6%95%B0%EF%BC%88%E5%9B%9E%E6%BB%9A%E8%8E%AB%E9%98%9F%EF%BC%8C%E5%B9%B6%E6%9F%A5%E9%9B%86%EF%BC%89%2F</url>
    <content type="text"><![CDATA[题目链接LOJ 洛谷 题意简述给你一张带边权的无向图，边权都形如 $2^a3^b$ ，若干询问，每次问是否存在 $u$ 到 $v$ 且边权的最小公倍数为 $2^a3^b$ 的途径（可以不是简单路径）。 点数 $5\cdot 10^4$，边数 $10^5$，询问数 $5\cdot 10^4$ 。 简要做法首先转化问题：仅保留图中 $2$ 的指数不超过 $a$ 且 $3$ 的指数不超过 $b$ 的边，是否满足“$u$ 和 $v$ 连通，且连通块内 $2$ 的最高指数为 $a$，$3$ 的最高指数为 $b$”？ 发现 $a$ 和 $b$ 在增大/减小时会导致边加入图中/从图中删去，这和莫队的左右指针很像。事实上这题的确可以看作一种长得比较奇怪的莫队。 具体来说，维护 $a$ 指针和 $b$ 指针，由于每条边要么先被 $a$ 指针扫到，要么先被 $b$ 指针扫到，增大其中一个指针时判一下是否满足另一个指针的要求，若满足则加入图中即可。 由于删边不好维护，可以使用类似 回滚莫队 的方法处理，但由于本题的特殊性，不存在“左右端点在同一块的暴力计算”这种情况。 具体实现可以参考代码（ 坑形如 u u 0 0 的询问若不存在 $(u, v)$ 的边权为 $1$ 则答案为 No，所以连通块内 $2$ 和 $3$ 指数的初值要赋为 $-1$ 。 个人觉得 u u 0 0 答案不为 Yes 很蠢.. 参考代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cmath&gt;#include &lt;stack&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;int B;struct Edge&#123; int u, v, a, b; Edge(int _a = 0, int _b = 0): a(_a), b(_b) &#123;&#125;&#125;;vector&lt;Edge&gt; a, b;struct Query&#123; int u, v, a, b, ra, rb, id; Query(int _u, int _v, int _a, int _b, int _ra, int _rb, int _id): u(_u), v(_v), a(_a), b(_b), ra(_ra), rb(_rb), id(_id) &#123;&#125; bool operator&lt;(const Query&amp; y) const &#123; return b &lt; y.b; &#125;&#125;;vector&lt;vector&lt;Query&gt; &gt; q;int n, m, k, qa, qb;vector&lt;bool&gt; ans;struct UnionFindSet&#123; int tim; vector&lt;int&gt; f, siz, two, three; struct Change &#123; int x, y, x2, x3; Change(int _x, int _y, int _x2, int _x3): x(_x), y(_y), x2(_x2), x3(_x3) &#123;&#125; &#125;; stack&lt;Change&gt; c; int find(int x) &#123; return x == f[x] ? x : find(f[x]); &#125; void merge(int x, int y, int tw, int th) &#123; x = find(x); y = find(y); if (x == y) &#123; c.emplace(x, -1, two[x], three[x]); two[x] = max(two[x], tw); three[x] = max(three[x], th); return; &#125; if (siz[x] &lt; siz[y]) swap(x, y); c.emplace(x, y, two[x], three[x]); siz[x] += siz[y]; f[y] = x; two[x] = max(tw, max(two[x], two[y])); three[x] = max(th, max(three[x], three[y])); &#125; void record() &#123; tim = c.size(); &#125; void rollback() &#123; while (c.size() &gt; tim) &#123; auto t = c.top(); c.pop(); if (~t.y) &#123; f[t.y] = t.y; siz[t.x] -= siz[t.y]; two[t.x] = t.x2; three[t.x] = t.x3; &#125; else &#123; two[t.x] = t.x2; three[t.x] = t.x3; &#125; &#125; &#125; void reset() &#123; f.resize(n + 1); siz.assign(n + 1, 1); two.assign(n + 1, -1); three = two; for (int i = 1; i &lt;= n; ++i) f[i] = i; tim = 0; while (!c.empty()) c.pop(); &#125; void check(Query t) &#123; int u = find(t.u); int v = find(t.v); ans[t.id] = u == v &amp;&amp; two[u] == t.ra &amp;&amp; three[u] == t.rb; &#125;&#125; ufs;bool cmpa(const Edge&amp; x, const Edge&amp; y)&#123; return x.a &lt; y.a;&#125;bool cmpb(const Edge&amp; x, const Edge&amp; y)&#123; return x.b &lt; y.b;&#125;void adda(int x)&#123; if (~qb &amp;&amp; a[x].b &lt;= b[qb].b) &#123; ufs.merge(a[x].u, a[x].v, a[x].a, a[x].b); &#125;&#125;void addb(int x)&#123; if (~qa &amp;&amp; b[x].a &lt;= a[qa].a) &#123; ufs.merge(b[x].u, b[x].v, b[x].a, b[x].b); &#125;&#125;int main()&#123; scanf("%d%d", &amp;n, &amp;m); a.resize(m); for (int i = 0; i &lt; m; ++i) scanf("%d%d%d%d", &amp;a[i].u, &amp;a[i].v, &amp;a[i].a, &amp;a[i].b); b = a; sort(a.begin(), a.end(), cmpa); sort(b.begin(), b.end(), cmpb); scanf("%d", &amp;k); B = m / sqrt(k) + 1; q.resize(m / B + 1); ans.resize(k); for (int i = 0; i &lt; k; ++i) &#123; int u, v, ra, rb; scanf("%d%d%d%d", &amp;u, &amp;v, &amp;ra, &amp;rb); int aa = upper_bound(a.begin(), a.end(), Edge(ra, rb), cmpa) - a.begin() - 1; int bb = upper_bound(b.begin(), b.end(), Edge(ra, rb), cmpb) - b.begin() - 1; if (~aa &amp;&amp; ~bb) q[aa / B].emplace_back(u, v, aa, bb, ra, rb, i); else ans[i] = false; &#125; for (int i = 0; i &lt; q.size(); ++i) &#123; sort(q[i].begin(), q[i].end()); ufs.reset(); qb = -1; qa = i * B; for (auto t : q[i]) &#123; while (qb &lt; t.b) addb(++qb); ufs.record(); while (qa &lt; t.a) adda(++qa); ufs.check(t); ufs.rollback(); qa = i * B; &#125; &#125; for (auto x : ans) puts(x ? "Yes" : "No"); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>并查集</tag>
        <tag>莫队</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「NOI2018」你的名字（SAM，线段树合并）]]></title>
    <url>%2F%E3%80%8CNOI2018%E3%80%8D%E4%BD%A0%E7%9A%84%E5%90%8D%E5%AD%97%EF%BC%88SAM%EF%BC%8C%E7%BA%BF%E6%AE%B5%E6%A0%91%E5%90%88%E5%B9%B6%EF%BC%89%2F</url>
    <content type="text"><![CDATA[题目链接UOJ LOJ 洛谷 题意简述给你一个字符串 $S$，有 $q$ 次询问，每次给你询问串 $T$ 以及左右端点 $l$, $r$，询问 $T$ 有多少个 本质不同 的子串 不是 $S[l..r]$ 的子串。 $|S|\le 5\cdot 10^5$, $\sum|T|\le 10^6$, $q\le 10^5$ 。 简要做法不需要本质不同、l=1、r=|S|枚举 $T$ 的前缀，找到这个前缀的最长后缀使其是 $S$ 的子串，就可以求出答案了。 换句话说，对于每个 $i$，求出最小的 $j$ ($1\le j\le i+1$) 使得 $T[j..i]$ 是 $S$ 的子串，那么 $\sum j-1$ 就是答案。 可以对 $S$ 建 SAM，维护一个指针指向 $T[j..i]$ 在 SAM 上对应的顶点，如果拓展一个字符后不是 $S$ 的子串就把 $j$ 加一，如果低于当前 SAM 上节点的长度限制就跳 parent 边，也就是 从首部删去字符 。 需要本质不同、l=1、r=|S|由本质不同可以想到用 SAM 去重。具体来说，对 $T$ 建 SAM，对每个 $T[j..i]$ 在 SAM 上打个标记，表示 $T[j..i]$ 及其所有后缀（即对应顶点及其在 parent 树上的祖先）都是 $S$ 的子串，最后 DFS 一遍即可求出答案。 原问题如果询问的不是整个 $S$ 而是其一个子串，关键在于如何判断 $T[j..i]$ 是不是 $S[l..r]$ 的子串。 可以使用线段树合并维护 $S$ 的 SAM 上的每个点的 right 集合，$T[j..i]$ 是 $S[l..r]$ 的子串等价于 $T[j..i]$ 在 $S$ 中的 right 集合含有某个区间内的元素，区间求和即可查询。 还有一个细节，在 $T$ 的 SAM 上打标记时，可能出现 SAM 上的一个节点对应的较短的那些串是 $S[l..r]$ 的子串，但较长的串不是。所以标记还需要记录不是 $S[l..r]$ 子串所需的长度。 参考代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;using namespace std;typedef long long ll;struct SAM&#123; struct Node &#123; int len, pa, tag; vector&lt;int&gt; ch; Node(int _len = 0, int _pa = -1, vector&lt;int&gt; _ch = vector&lt;int&gt;(26, 0)): len(_len), pa(_pa), tag(0), ch(_ch) &#123;&#125; &#125;; vector&lt;Node&gt; t; int p; vector&lt;int&gt; endp; vector&lt;vector&lt;int&gt; &gt; g; void extend(int x) &#123; int np = t.size(); t.emplace_back(t[p].len + 1); while (~p &amp;&amp; !t[p].ch[x]) &#123; t[p].ch[x] = np; p = t[p].pa; &#125; if (p == -1) t[np].pa = 0; else &#123; int q = t[p].ch[x]; if (t[q].len == t[p].len + 1) t[np].pa = q; else &#123; int nq = t.size(); t.emplace_back(t[p].len + 1, t[q].pa, t[q].ch); t[q].pa = t[np].pa = nq; while (~p &amp;&amp; t[p].ch[x] == q) &#123; t[p].ch[x] = nq; p = t[p].pa; &#125; &#125; &#125; p = np; &#125; SAM(const string&amp; s): t(1), p(0) &#123; t.reserve(s.size() * 2); endp.resize(s.size()); for (int i = 0; i &lt; s.size(); ++i) &#123; extend(s[i] - 'a'); endp[i] = p; &#125; g.resize(t.size()); for (int i = 1; i &lt; t.size(); ++i) g[t[i].pa].push_back(i); &#125; ll dfs(int u = 0) &#123; ll out = 0; for (auto v : g[u]) &#123; if (!v) continue; out += dfs(v); t[u].tag = max(t[u].tag, t[v].tag); &#125; if (u) out += max(0, t[u].len - max(t[u].tag, t[t[u].pa].len)); return out; &#125;&#125;;struct SegmentTree&#123;#define mid ((l + r) &gt;&gt; 1) struct Node &#123; int sum, ls, rs; Node(int _sum = 0, int _ls = 0, int _rs = 0): sum(_sum), ls(_ls), rs(_rs) &#123;&#125; &#125;; vector&lt;Node&gt; t; int add(int x, int p, int l, int r) &#123; int cur = t.size(); t.push_back(t[x]); ++t[cur].sum; if (l == r - 1) return cur; if (p &lt; mid) t[cur].ls = add(t[x].ls, p, l, mid); else t[cur].rs = add(t[x].rs, p, mid, r); return cur; &#125; int merge(int x, int y) &#123; if (!x || !y) return x | y; t.emplace_back(t[x].sum + t[y].sum, merge(t[x].ls, t[y].ls), merge(t[x].rs, t[y].rs)); return t.size() - 1; &#125; int query(int x, int L, int R, int l, int r) &#123; if (L &gt;= r || R &lt;= l) return 0; if (L &lt;= l &amp;&amp; r &lt;= R) return t[x].sum; return query(t[x].ls, L, R, l, mid) + query(t[x].rs, L, R, mid, r); &#125;#undef mid&#125; seg;vector&lt;int&gt; rt;void dfs(const vector&lt;vector&lt;int&gt; &gt;&amp; g, int u = 0)&#123; for (auto v : g[u]) &#123; dfs(g, v); rt[u] = seg.merge(rt[u], rt[v]); &#125;&#125;int main()&#123; ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0); string s; cin &gt;&gt; s; SAM sams(s); seg.t.resize(1); seg.t.reserve(s.size() &lt;&lt; 5); rt.resize(sams.t.size(), 0); for (int i = 0; i &lt; s.size(); ++i) rt[sams.endp[i]] = seg.add(rt[sams.endp[i]], i, 0, s.size()); dfs(sams.g); int q; cin &gt;&gt; q; while (q--) &#123; int l, r; string t; cin &gt;&gt; t &gt;&gt; l &gt;&gt; r; SAM samt(t); for (int i = 0, u = 0, v = 0, p = 0; i &lt; t.size(); ++i) &#123; while (p &lt; i &amp;&amp; !sams.t[u].ch[t[i] - 'a']) &#123; ++p; if (u &amp;&amp; i - p &lt;= sams.t[sams.t[u].pa].len) u = sams.t[u].pa; if (v &amp;&amp; i - p &lt;= samt.t[samt.t[v].pa].len) v = samt.t[v].pa; &#125; if (!sams.t[u].ch[t[i] - 'a']) &#123; p = i + 1; u = v = 0; continue; &#125; u = sams.t[u].ch[t[i] - 'a']; v = samt.t[v].ch[t[i] - 'a']; while (p &lt;= i &amp;&amp; seg.query(rt[u], l + i - p - 1, r, 0, s.size()) == 0) &#123; ++p; if (u &amp;&amp; i - p + 1 &lt;= sams.t[sams.t[u].pa].len) u = sams.t[u].pa; if (v &amp;&amp; i - p + 1 &lt;= samt.t[samt.t[v].pa].len) v = samt.t[v].pa; &#125; samt.t[v].tag = max(samt.t[v].tag, i - p + 1); &#125; cout &lt;&lt; samt.dfs() &lt;&lt; '\n'; &#125; return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>字符串</tag>
        <tag>数据结构</tag>
        <tag>SAM</tag>
        <tag>线段树合并</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[THUWC2019 第二轮冬眠]]></title>
    <url>%2FTHUWC2019-%E7%AC%AC%E4%BA%8C%E8%BD%AE%E5%86%AC%E7%9C%A0%2F</url>
    <content type="text"><![CDATA[非常荣幸能够参加这场跨度 300+ 天的比赛。 上接 2019THUWC/WC冬眠记 。 Day 333收到通知比赛环境的邮件。 今年环境怎么啥额外软件都没有（没有 GIMP 也没有 WireShark 什么的）。也没看到题型/赛制说明什么的..没法押 Day2+ 了 T_T 上午把前一天晚上（其实是当天凌晨）海子姐（@七海Nana7mi）的相簿分享会补了（幸好没顶着强行看直播，不然人没了.png）。 下午和晚上把远古巨坑填了：chen_zhe的号哭 。 全部做好之后渲染，2min 后电脑卡了..重启之后重新渲染，这个时候海子姐已经开播了（ 因为电脑在渲染，所以就只能一边用手机看直播一边渲染（ 最后在显示还剩 2min 渲染完毕的时候又卡住了..正当我长按关机键还不到 10s 时，电脑突然活过来了..赶紧松开关机键，差点人没了。 然后就一边看直播一边传视频，成功掉进海子姐发 8 给 9 投票的陷阱..还第一次被海子姐读弹幕了（在大家投票时发了一句“第一步下角第二步必须下 5”，然后大家投的 9，最后还平了..）。 总结：因为 SC 考了 WireShark，所以来看鲨鱼直播准备 Day2+。 Day 334一天大部分时间（？其实算一算并没有）都在高铁上。 大概是 BEASTARS + 海子姐录播 + 三狮漫画。 高铁还是一如既往的吵，一直戴着耳机，到了北京之后人都晕了。 然后晚上不是去宾馆，而是住一个亲戚家。 由于亲戚家孩子刚开始时在旁边看着，于是就佯装看自己博客里的题解。之后就顺势看下去了..赛前看看自己写的题解或许的确不错.. 说起来，不到 18 点的时候路过天津，20:39 收到天津文旅局短信是什么操作（ Day 335赛前自然醒好评（ 试机 10 点多才去，T1 照例 A+B，T2 是之前看游记见到过的 THUWC2018 签到题，然而一开始想了个假做法，半个多小时才过掉..过掉的时候大家都跑路了，所以我也没去看剩下两题，但记得题目名，回来一查果然是 THUWC2018 的另外两题。 开营式比 SC 短了接近 1h，所以比赛没咕，好评（ 简要题意T1给你 $n$ 个在长为 $k$ 的数列 $a_1,a_2,\ldots,a_n$ 上进行的操作，第 $i$ 个操作形如 “$p(i)$, $b(i)_1, b(i)_2, \ldots, b(i)_k$”，表示“若 $a_{p_i}&lt; b(i)_{p_i}$，则将 $a$ 修改为 $b(i)$”。再给你 $m$ 个初始序列 $a$，求依次进行这 $n$ 个操作后会得到什么数列。 $1\le n, m\le 10^5$ , $1\le k\le 20$ ，时限 $\mathtt{3s}$。 T2给你一张带非负边权的有向图，你需要在上面移动棋子。棋子的移动规则：选择 权值 非零的出边中 编号 最小的一条移动，然后将这条边的 权值 减一。每次操作会给你棋子的初始位置以及移动步数上限，棋子会在无法移动或移动步数达到上限时停止移动，你需要求出每次操作的棋子停下来的位置。前面的操作会对后面的操作产生影响。 点数、询问数 $10^5$ ，边数 $1.5\cdot 10^5$ ，时限 $\mathtt{8s}$ 。 T3给你一张所有边长度都为 $1$ 的树 $G=(V, E)$ 以及常量 $k$ ，记 $G$ 中两点 $u$ 和 $v$ 之间的距离为 $dis(u, v)$ ，构造无向图 $H=(V, \{(u, v)|dis(u, v)\le k\})$ ，$q$ 次询问，每次给出 $l$ 和 $r$ ，求 $H$ 在 $[l, r]$ 上的导出子图（即仅保留 $[l, r]$ 内的点以及它们之间的所有连边得到的子图）的连通块数量。 点数 $3\cdot 10^5$ ，边数 $6\cdot 10^5$ ，时限 $\mathtt{6s}$ 。 比赛登录用户名竟然是 “THUWC2020” 开头，明明是 2019 年的比赛（ T1 看了一小会儿就会了，写完之后把编译错误改完就 pp 了。 过了之后去把 lower_bound 改成了 upper_bound ，然后 并不愉快地 又 pp 了..说好的实质 IOI 赛制呢 QAQ。于是跑去写了个对拍，upper_bound 很快拍出错了，一开始的版本几万组没出错，极限数据不开 O2 过不了，开 O2 $\mathtt{1.5s}$ 。于是 T1 就搞了 1h+… 一开始的题面还没写值域，结果提问发出去的 20s 前发了个公告补充了值域，然后就得到了“请仔细阅读公告”的回复… 看了眼 T2 和 T3，发现都不太会做。 T3 不知道为什么，第一眼我就把它转化成了“求每个点编号左右编号最靠近它的距离不超过 $k$ 的点，然后莫队”，对着这个想了好久，然后发现这是个明显的假转化，然后发现自己连 $k=1$ 的数普通连通块都不会做了，然后发现链并不保证编号是顺着来的所以链也不会了，就滚去看 T2 了.. T2 的“数据随机”那档部分分给的很迷，说什么“每条边出现概率为 $\dfrac{1}{n^2}$”，听起来像是期望只有一条边的感觉，然后我交上去测了一下，发现不止 $10$ 条边，怀疑是笔误..只不过这档大概是给暴力的吧，我暴力也过了这档，就没提问了.. 然而问题在于，暴力甚至可以过环套树加上不超过 $50$ 条额外边的那档..（过不了环套树那档。） 然后去写不需要考虑删边那档，一开始我去写了个拓扑排序找环，快写完的时候突然发现自己没有处理步数上限既没到链的末尾也没到环上的情况，立刻想到可以用倍增处理，紧接着想到这档除了倍增啥都不用写，然后就把写了半天的拓扑排序全删了.. 然后去写树的部分分，一开始一个地方想错写自闭了，然后去写 T3 的 $8$ 分，写完回来发现自己 sb 了，然后写完了树的部分分，结果调了 1h..然后就考试结束了。 感觉少想一会儿正解，部分分打快点，环套树就可以写出来了.. PT 是 $165$ 分，但环套树加上不超过 $50$ 条额外边显然过不了，所以大概是 $100+49+8=157$ 分。看起来就很大众分的样子，然而持续两天的比赛第一天结束当然是不能去看别人多少分的。 Day 336简要题意T1给你一个数以及 $n$ 个对一个数进行的操作，其中第 $i$ 个操作是将 $x$ 变成 $a_i|x|+b_ix+c_i$ ，你可以改变操作进行的顺序，求最后得到的数的最大值。 $1\le n\le 15$ ，$-15\le a_i, b_i, c_i\le 15$ ，时限 $\mathtt{1s}$ 。 T2给你一张有向无环图 $G$ ，令 $G$ 的 DFS 树为 $T$（以 $1$ 为根，优先访问编号小的点），多组询问，每次给出 $a$ 和 $b$ ，保证 $a$ 在 $T$ 上是 $b$ 的祖先，询问“在 $G$ 中删去 $T$ 上 $a$ 到 $b$ 的简单路径上的边之后，$T$ 中以 $b$ 为根的子树内的点有多少个在 $G$ 中是从 $1$ 出发不可达的”。 点数、询问数 $10^5$ ，边数 $1.5\cdot 10^5$ ，时限 $\mathtt{1s}$ 。 T3给你一棵点权是一个排列的树，多组询问，每次给出两个点和一个非负整数 $k$ ，求这两点间路径上的点权构成的序列可以由多少个不同的序列由恰好 $k$ 轮 冒泡排序得到。 点数、询问数 $5\cdot 10^5$ ，时限 $\mathtt{4s}$ 。 比赛今天 T1 怎么不会做..今天 T2 和 T3 依然不会做.. 把 T1 暴力打了。 把 T2 暴力打了。 把 T3 暴力打了。怎么 T 掉了.. T3 打个表，啥规律都没有。 把 T1 部分分打全了。 我好像会 T2 所有部分分？ 写完 subtask2，假了。 写完 subtask4，假了。 写完 subtask3，还剩不到 1h 了。 卡了下 T3 暴力常数，暴力过了。 我自闭了。 今天 pt 好像更弱（？），好像 T1 随便写都能过若干 subtask，subtask1 没过剩下都过、subtask2 没过剩下都过之类的。反正我的部分分都对拍了，应该没啥问题.. 好像是比大众分低但是并不知道的 $55+31+8=94$ 。 下午下午好短啊..我怎么写个游记就快要吃饭了 QAQ 本来还想学一下 Python 二进制文件读写的.. Day 336+这次不用二进制文件读写了，任务是模拟 Cache。 开场前一直在想：“APIO 上到底讲了啥…” 开场先读了 10min 学习手册，发现不对劲，回想一下自己平时写工程时的流程（需要什么 → 搜什么 → 发现哪看不懂 → DFS 前置知识）以及前两次工程题的教训，于是就先去看了看题，直接去找学习手册中对应的部分，然后发现题目名称和学习手册标题顺序是相反的（ 5min 后发现 T1 需要用到的只有倒数第二页的一张表格..然后非常愉快地 OOP 实现了一发，然后因为语文问题没过样例，过样例之后交上去只过了 subtask1，仔细阅读之后发现还是语文问题，改了之后就过了。此时 1:20 左右。 T2 好像差不多就是 APIO 上讲的那个东西，写着写着就只剩半小时了.. 然后把 T3 的 subtask1 写完就只剩不到 10min 了.. T3 剩下的 subtask 差不多就是把 T2 封装一下用上去，感觉 20min 就可以写完.. 最后是大众分 $40+56+16=112$ 。 Day 337面试听说 0 点半的时候教练收到了面试通知.. 依然是按字典序排序，又等到了接近 12 点，但这次没有要求关手机，于是可以愉快地水群。 面试的时候说了一下之前颓 OI Wiki 时学的时间复杂性理论，还有 capacity scaling 什么的，然后果然被问了“什么是 NP 问题？什么是 NPC 问题？”。 英语阅读是一篇图论基础概念（点和边的定义之类的），之前写 OI Wiki 的时候也查过很多图论相关的 en Wikipedia，所以感觉很稳，然后读完之后，用英语问了我“你知道图论在生活中有哪些运用吗？”，突然不按剧本，然后就随便说了个导航，然后阅读部分竟然就结束了..这和图论基础概念到底有什么关系啊.. 然后是“还有一分钟，要不问你个数学题吧”。上次没问数学题，但看很多人游记都有提到，而且据说很简单。问的是“一支铅笔折三次，组成三角形的概率是多大”。题面非常迷惑，我向考官确认了一下，意思就是“将一条线段均匀随机地分成三段，这三段能够组成三角形的概率是多大”。然而我从小不擅长当面回答问题，当时半分钟脑子一片空白，考官问我有什么思路，我说了个“最长那段要小于二分之一”，被回了个“显然”，然后时间就到了。 出考场后瞬间会做，感觉自己没救了。 宣讲感觉这次宣讲是今年 WC 第一轮（指 2019 年 1 月那次）和今年 SC 的结合，总体效果感觉和 WC 第一轮差不多，没有 SC 那么无聊（ 然而这次完全没有讲题，连 Day336+ T6（期待你的声音）的分享都没有（ 发奖今年没进面试都有奖（ 为啥线这么低啊.. 我好像压线 1= 了。]]></content>
      <categories>
        <category>游记</category>
      </categories>
      <tags>
        <tag>清华营</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CF786C Till I Collapse（根号分治，二分答案 / 主席树，调和级数）]]></title>
    <url>%2FCF786C-Till-I-Collapse%EF%BC%88%E6%A0%B9%E5%8F%B7%E5%88%86%E6%B2%BB%EF%BC%8C%E4%BA%8C%E5%88%86%E7%AD%94%E6%A1%88-%E4%B8%BB%E5%B8%AD%E6%A0%91%EF%BC%8C%E8%B0%83%E5%92%8C%E7%BA%A7%E6%95%B0%EF%BC%89%2F</url>
    <content type="text"><![CDATA[题目链接CF 题意简述给你一个长为 $n$ 的数列，对于 $1\le k\le n$ 的所有整数 $k$，求出这个问题的答案：将数列划分成若干连续段，每段内最多有 $k$ 个 不同 的数，至少要划分成几段？ $n\le 10^5$ 。 简要做法首先是一个显而易见的贪心：分段时在一段内放更多的数一定不劣。这个结论在下面两个做法都会用到。 根号分治根据上面的那个结论，可以得到一个 $k$ 固定时复杂度为 $O(n)$ 的做法。需要使用时间戳清空访问数组。 然后就可以进行根号分治： 取一个合适的值 $B$ 。 对于 $1\le k\le B$ ，直接做，时间复杂度为 $O(nB)$ 。 对于 $B+1\le k\le n$ ，答案不超过 $n/B$ ，可以对于每个答案二分求出 $k$ 的最小值和最大值，时间复杂度为 $O(n^2\log n/B)$ 。 取 $B=\sqrt{n\log n}$，总时间复杂度为 $O(n\sqrt{n\log n})$，可以通过本题。 主席树每个 $k$ 的答案不超过 $n/k$，根据调和级数，可以得到总答案的级别为 $O(n\log n)$ ，所以只要能够快速求出一次分段的右端点，就能够快速求出总答案了。 这题依然可以沿用 「SDOI2009」HH 的项链 的树状数组做法，但由于要不断地求分段的右端点，需要使用主席树，再加上线段树二分，就可以 $O(\log n)$ 求出一段的右端点，总时间复杂度即为 $O(n\log^2n)$ 。 具体来说，$f_{l, i}\in\{0, 1\}$ ，$f_{l, i}=1$ 当且仅当 $i$ 是 $l$ 及其右侧第一个为 $a_i$ 的数，即 $i\ge l$ 且不存在 $j$ 使得 $l\le j\le i-1, a_j=a_i$ 。那么，$[l, r]$ 的颜色数就是 $f_{l, r}$ 。使用 $n$ 棵主席树分别维护 $f_{1..n, i}$ 即可。 参考代码根号分治 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899 #ifndef OUUAN #pragma GCC optimize("Ofast,no-stack-protector,unroll-loops,fast-math") #endif #include&lt;bits/stdc++.h&gt; //#define int LoveLive//#define FAST_IOSTREAM 1 #define For(i,l,r)for(int i=(l),i##end=(r);i&lt;=i##end;++i) #define FOR(i,r,l)for(int i=(r),i##end=(l);i&gt;=i##end;--i) #define SON(i,u)for(int i=head[u];i;i=nxt[i]) #define ms(a,x)memset(a,x,sizeof(a)) #define fi first #define se second #define pb emplace_back #define pq priority_queue #define isinf(x)(x&gt;=INF?-1:x) #define y1 why_is_there_a_function_called_y1 using namespace std;typedef long long LoveLive;typedef pair&lt;int,int&gt;pii;typedef vector&lt;int&gt;vi;typedef long double ld;const double inf=1e121;const double eps=1e-10;mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());int randint(int l,int r)&#123;int out=rng()%(r-l+1)+l;return out&gt;=l?out:out+r-l+1;&#125;template&lt;typename A,typename B&gt;string to_string(pair&lt;A,B&gt;p);template&lt;typename A,typename B,typename C&gt;string to_string(tuple&lt;A,B,C&gt;p);template&lt;typename A,typename B,typename C,typename D&gt;string to_string(tuple&lt;A,B,C,D&gt;p);string to_string(const string&amp;s)&#123;return '"'+s+'"';&#125;string to_string(const char*s)&#123;return to_string((string)s);&#125;string to_string(bool b)&#123;return(b?"true":"false");&#125;string to_string(vector&lt;bool&gt;v)&#123;bool first=true;string res="&#123;";for(int i=0;i&lt;static_cast&lt;int&gt;(v.size());i++)&#123;if(!first)&#123;res+=",";&#125;first=false;res+=to_string(v[i]);&#125;res+="&#125;";return res;&#125;template&lt;size_t N&gt;string to_string(bitset&lt;N&gt;v)&#123;string res="";for(size_t i=0;i&lt;N;i++)&#123;res+=static_cast&lt;char&gt;('0'+v[i]);&#125;return res;&#125;template&lt;typename A&gt;string to_string(A v)&#123;bool first=true;string res="&#123;";for(const auto&amp;x:v)&#123;if(!first)&#123;res+=",";&#125;first=false;res+=to_string(x);&#125;res+="&#125;";return res;&#125;template&lt;typename A,typename B&gt;string to_string(pair&lt;A,B&gt;p)&#123;return "("+to_string(p.first)+","+to_string(p.second)+")";&#125;template&lt;typename A,typename B,typename C&gt;string to_string(tuple&lt;A,B,C&gt;p)&#123;return "("+to_string(get&lt;0&gt;(p))+","+to_string(get&lt;1&gt;(p))+","+to_string(get&lt;2&gt;(p))+")";&#125;template&lt;typename A,typename B,typename C,typename D&gt;string to_string(tuple&lt;A,B,C,D&gt;p)&#123;return "("+to_string(get&lt;0&gt;(p))+","+to_string(get&lt;1&gt;(p))+","+to_string(get&lt;2&gt;(p))+","+to_string(get&lt;3&gt;(p))+")";&#125;template&lt;typename A,typename B,typename C,typename D,typename E&gt;string to_string(tuple&lt;A,B,C,D,E&gt;p)&#123;return "("+to_string(get&lt;0&gt;(p))+","+to_string(get&lt;1&gt;(p))+","+to_string(get&lt;2&gt;(p))+","+to_string(get&lt;3&gt;(p))+","+to_string(get&lt;4&gt;(p))+")";&#125;void debug_out()&#123;cerr&lt;&lt;endl;&#125;template&lt;typename Head,typename...Tail&gt;void debug_out(Head H,Tail...T)&#123;cerr&lt;&lt;" "&lt;&lt;to_string(H);debug_out(T...);&#125; #ifdef OUUAN #define debug(...)cerr&lt;&lt;"["&lt;&lt;#__VA_ARGS__&lt;&lt;"]:",debug_out(__VA_ARGS__) #else #define debug(...)42 #endif #ifdef int const int INF=0x3f3f3f3f3f3f3f3fll; #else const int INF=0x3f3f3f3f;typedef long long ll; #endif #ifdef FAST_IOSTREAM #define br cout&lt;&lt;'\n' #define sp cout&lt;&lt;' ' long long read()&#123;long long x;cin&gt;&gt;x;return x;&#125;template&lt;typename T&gt;void read(T&amp;x)&#123;cin&gt;&gt;x;&#125;template&lt;typename T&gt;void write(const T&amp;x)&#123;cout&lt;&lt;x;&#125; #else #define br putchar('\n') #define sp putchar(' ') template&lt;typename T&gt;typename enable_if&lt;!is_integral&lt;T&gt;::value,void&gt;::type read(T&amp;x)&#123;cin&gt;&gt;x;&#125;long long read()&#123;char c;long long out=0,f=1;for(c=getchar();!isdigit(c)&amp;&amp;c!='-';c=getchar());if(c=='-')&#123;f=-1;c=getchar();&#125;for(;isdigit(c);c=getchar())out=(out&lt;&lt;3)+(out&lt;&lt;1)+c-'0';return out*f;&#125;template&lt;typename T&gt;typename enable_if&lt;is_integral&lt;T&gt;::value,T&gt;::type read(T&amp;x)&#123;char c;T f=1;x=0;for(c=getchar();!isdigit(c)&amp;&amp;c!='-';c=getchar());if(c=='-')&#123;f=-1;c=getchar();&#125;for(;isdigit(c);c=getchar())x=(x&lt;&lt;3)+(x&lt;&lt;1)+c-'0';return x*=f;&#125;char read(char&amp;x)&#123;for(x=getchar();isspace(x);x=getchar());return x;&#125;double read(double&amp;x)&#123;scanf("%lf",&amp;x);return x;&#125;ld read(ld&amp;x)&#123;scanf("%Lf",&amp;x);return x;&#125;template&lt;typename T&gt;typename enable_if&lt;!is_integral&lt;T&gt;::value,void&gt;::type write(const T&amp;x)&#123;cout&lt;&lt;x;&#125;template&lt;typename T&gt;typename enable_if&lt;is_integral&lt;T&gt;::value,void&gt;::type write(const T&amp;x)&#123;if(x&lt;0)&#123;putchar('-');write(-x);return;&#125;if(x&gt;9)write(x/10);putchar(x%10+'0');&#125;void write(const char&amp;x)&#123;putchar(x);&#125;void write(const double&amp;x)&#123;printf("%.10lf",x);&#125;void write(const ld&amp;x)&#123;printf("%.10Lf",x);&#125; #endif template&lt;typename T,typename...Args&gt;void read(T&amp;x,Args&amp;...args)&#123;read(x);read(args...);&#125;template&lt;typename OutputIt,typename=typename enable_if&lt;is_same&lt;output_iterator_tag,typename iterator_traits&lt;OutputIt&gt;::iterator_category&gt;::value||(is_base_of&lt;forward_iterator_tag,typename iterator_traits&lt;OutputIt&gt;::iterator_category&gt;::value&amp;&amp;!is_const&lt;OutputIt&gt;::value)&gt;::type&gt;void read(OutputIt __first,OutputIt __last)&#123;for(;__first!=__last;++__first)read(*__first);&#125;template&lt;typename InputIt,typename=typename enable_if&lt;is_base_of&lt;input_iterator_tag,typename iterator_traits&lt;InputIt&gt;::iterator_category&gt;::value&gt;::type&gt;void wts(InputIt __first,InputIt __last)&#123;bool isFirst=true;for(;__first!=__last;++__first)&#123;if(isFirst)isFirst=false;else sp;write(*__first);&#125;br;&#125;template&lt;typename InputIt,typename=typename enable_if&lt;is_base_of&lt;input_iterator_tag,typename iterator_traits&lt;InputIt&gt;::iterator_category&gt;::value&gt;::type&gt;void wtb(InputIt __first,InputIt __last)&#123;for(;__first!=__last;++__first)&#123;write(*__first);br;&#125;&#125;template&lt;typename T&gt;void wts(const T&amp;x)&#123;write(x);sp;&#125;template&lt;typename T&gt;void wtb(const T&amp;x)&#123;write(x);br;&#125;template&lt;typename T&gt;void wte(const T&amp;x)&#123;write(x);exit(0);&#125;template&lt;typename T,typename...Args&gt;void wts(const T&amp;x,Args...args)&#123;wts(x);wts(args...);&#125;template&lt;typename T,typename...Args&gt;void wtb(const T&amp;x,Args...args)&#123;wts(x);wtb(args...);&#125;template&lt;typename T,typename...Args&gt;void wte(const T&amp;x,Args...args)&#123;wts(x);wte(args...);&#125;template&lt;typename T&gt;inline bool up(T&amp;x,const T&amp;y)&#123;return x&lt;y?x=y,1:0;&#125;template&lt;typename T&gt;inline bool dn(T&amp;x,const T&amp;y)&#123;return y&lt;x?x=y,1:0;&#125;template&lt;typename T&gt;inline bool inRange(const T&amp;x,const T&amp;l,const T&amp;r)&#123;return!(x&lt;l)&amp;&amp;!(r&lt;x);&#125;template&lt;typename valueType,typename tagType&gt;class segmentTreeNode&#123;public:int id,left,right;valueType val;tagType tag;&#125;;template&lt;typename valueType, typename tagType, valueType(*merge)(valueType,valueType), void(*update)(segmentTreeNode&lt;valueType,tagType&gt;&amp;,tagType)&gt;class segmentTree&#123;private:std::vector&lt;segmentTreeNode&lt;valueType,tagType&gt;&gt;nodes;int leftRange,rightRange;valueType valueZero;tagType tagZero;void pushup(int cur)&#123;nodes[cur].val=merge(nodes[cur&lt;&lt;1].val,nodes[cur&lt;&lt;1|1].val);&#125;void pushdown(int cur)&#123;update(nodes[cur&lt;&lt;1],nodes[cur].tag);update(nodes[cur&lt;&lt;1|1],nodes[cur].tag);nodes[cur].tag=tagZero;&#125;void build(int cur,int l,int r,const std::vector&lt;valueType&gt;&amp;initValue)&#123;nodes[cur].id=cur;nodes[cur].left=l;nodes[cur].right=r;nodes[cur].tag=tagZero;if(l==r-1)nodes[cur].val=initValue[l-leftRange];else&#123;build(cur&lt;&lt;1,l,(l+r)&gt;&gt;1,initValue);build(cur&lt;&lt;1|1,(l+r)&gt;&gt;1,r,initValue);pushup(cur);&#125;&#125;void init(const std::vector&lt;valueType&gt;&amp;_initValue,const valueType&amp;_valueZero,const tagType&amp;_tagZero)&#123;valueZero=_valueZero;tagZero=_tagZero;nodes.resize((rightRange-leftRange)&lt;&lt;2);build(1,leftRange,rightRange,_initValue);&#125;void modify(int cur,int l,int r,int L,int R,const tagType&amp;tag)&#123;if(l&gt;=R||r&lt;=L)return;if(L&lt;=l&amp;&amp;r&lt;=R)update(nodes[cur],tag);else&#123;pushdown(cur);modify(cur&lt;&lt;1,l,(l+r)&gt;&gt;1,L,R,tag);modify(cur&lt;&lt;1|1,(l+r)&gt;&gt;1,r,L,R,tag);pushup(cur);&#125;&#125;valueType query(int cur,int l,int r,int L,int R)&#123;if(l&gt;=R||r&lt;=L)return valueZero;if(L&lt;=l&amp;&amp;r&lt;=R)return nodes[cur].val;pushdown(cur);return merge(query(cur&lt;&lt;1,l,(l+r)&gt;&gt;1,L,R), query(cur&lt;&lt;1|1,(l+r)&gt;&gt;1,r,L,R));&#125;public:segmentTree()&#123;&#125;segmentTree(int _leftRange,int _rightRange,const std::vector&lt;valueType&gt;&amp;_initValue,const valueType&amp;_valueZero,const tagType&amp;_tagZero)&#123;leftRange=_leftRange;rightRange=_rightRange;init(_initValue,_valueZero,_tagZero);&#125;segmentTree(int size,const std::vector&lt;valueType&gt;&amp;_initValue,const valueType&amp;_valueZero,const tagType&amp;_tagZero)&#123;leftRange=1;rightRange=size+1;init(_initValue,_valueZero,_tagZero);&#125;void modify(int l,int r,const tagType&amp;tag)&#123;modify(1,leftRange,rightRange,l,r,tag);&#125;void modify(int p,const tagType&amp;tag)&#123;modify(p,p+1,tag);&#125;valueType query(int l,int r)&#123;return query(1,leftRange,rightRange,l,r);&#125;valueType query(int p)&#123;return query(p,p+1);&#125;&#125;;class maxFlow&#123;private:typedef long long ll;std::queue&lt;int&gt;q;std::vector&lt;int&gt;head,cur,nxt,to,dep;std::vector&lt;ll&gt;cap;public:maxFlow(int _n=0)&#123;init(_n);&#125;void init(int _n)&#123;head.clear();head.resize(_n+1,0);nxt.resize(2);to.resize(2);cap.resize(2);&#125;void init()&#123;init(head.size()-1);&#125;void add(int u,int v,ll w)&#123;nxt.push_back(head[u]);head[u]=to.size();to.push_back(v);cap.push_back(w);&#125;void Add(int u,int v,ll w)&#123;add(u,v,w);add(v,u,0);&#125;void del(int x)&#123;cap[x&lt;&lt;1]=cap[x&lt;&lt;1|1]=0;&#125;bool bfs(int s,int t)&#123;dep.clear();dep.resize(head.size(),-1);dep[s]=0;q.push(s);while(!q.empty())&#123;int u=q.front();q.pop();for(int i=head[u];i;i=nxt[i])&#123;int v=to[i];ll w=cap[i];if(w&gt;0&amp;&amp;dep[v]==-1)&#123;dep[v]=dep[u]+1;q.push(v);&#125;&#125;&#125;return ~dep[t];&#125;ll dfs(int u,ll flow,int t)&#123;if(dep[u]==dep[t])return u==t?flow:0;ll out=0;for(int&amp;i=cur[u];i;i=nxt[i])&#123;int v=to[i];ll w=cap[i];if(w&gt;0&amp;&amp;dep[v]==dep[u]+1)&#123;ll f=dfs(v,std::min(w,flow-out),t);cap[i]-=f;cap[i ^ 1]+=f;out+=f;if(out==flow)return out;&#125;&#125;return out;&#125;ll maxflow(int s,int t)&#123;ll out=0;while(bfs(s,t))&#123;cur=head;out+=dfs(s,0x7fffffffffffffffll,t);&#125;return out;&#125;ll getflow(int x)const&#123;return cap[x&lt;&lt;1|1];&#125;&#125;;struct customHash&#123;static uint64_t splitmix64(uint64_t x)&#123;x+=0x9e3779b97f4a7c15;x=(x ^(x&gt;&gt;30))*0xbf58476d1ce4e5b9;x=(x ^(x&gt;&gt;27))*0x94d049bb133111eb;return x ^(x&gt;&gt;31);&#125;size_t operator()(uint64_t x)const&#123;static const uint64_t FIXED_RANDOM=rng();return splitmix64(x+FIXED_RANDOM);&#125;&#125;; const int B = 1400;int n, tim;vi a, vis;int solve(int k)&#123; int out = 0, p = 0; do &#123; int cnt = 0; ++tim; ++out; while (p &lt; n) &#123; if (vis[a[p]] != tim) &#123; if (++cnt &gt; k) break; vis[a[p]] = tim; &#125; ++p; &#125; &#125; while (p &lt; n); return out;&#125;signed main()&#123;#ifdef FAST_IOSTREAM cin.sync_with_stdio(false); cin.tie(0);#endif read(n); a.resize(n); vis.resize(n + 1, 0); read(a.begin(), a.end()); For (i, 1, min(B, n)) wts(solve(i)); int p = min(B, n) + 1; FOR (i, n / B + 1, 1) &#123; int l = p - 1; int r = n; while (l &lt; r) &#123; int mid = (l + r + 1) &gt;&gt; 1; if (solve(mid) &lt; i) r = mid - 1; else l = mid; &#125; for (; p &lt;= l; ++p) wts(i); &#125; return 0;&#125; 主席树 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125 #ifndef OUUAN #pragma GCC optimize("Ofast,no-stack-protector,unroll-loops,fast-math") #endif #include&lt;bits/stdc++.h&gt; //#define int LoveLive//#define FAST_IOSTREAM 1 #define For(i,l,r)for(int i=(l),i##end=(r);i&lt;=i##end;++i) #define FOR(i,r,l)for(int i=(r),i##end=(l);i&gt;=i##end;--i) #define SON(i,u)for(int i=head[u];i;i=nxt[i]) #define ms(a,x)memset(a,x,sizeof(a)) #define fi first #define se second #define pb emplace_back #define pq priority_queue #define isinf(x)(x&gt;=INF?-1:x) #define y1 why_is_there_a_function_called_y1 using namespace std;typedef long long LoveLive;typedef pair&lt;int,int&gt;pii;typedef vector&lt;int&gt;vi;typedef long double ld;const double inf=1e121;const double eps=1e-10;mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());int randint(int l,int r)&#123;int out=rng()%(r-l+1)+l;return out&gt;=l?out:out+r-l+1;&#125;template&lt;typename A,typename B&gt;string to_string(pair&lt;A,B&gt;p);template&lt;typename A,typename B,typename C&gt;string to_string(tuple&lt;A,B,C&gt;p);template&lt;typename A,typename B,typename C,typename D&gt;string to_string(tuple&lt;A,B,C,D&gt;p);string to_string(const string&amp;s)&#123;return '"'+s+'"';&#125;string to_string(const char*s)&#123;return to_string((string)s);&#125;string to_string(bool b)&#123;return(b?"true":"false");&#125;string to_string(vector&lt;bool&gt;v)&#123;bool first=true;string res="&#123;";for(int i=0;i&lt;static_cast&lt;int&gt;(v.size());i++)&#123;if(!first)&#123;res+=",";&#125;first=false;res+=to_string(v[i]);&#125;res+="&#125;";return res;&#125;template&lt;size_t N&gt;string to_string(bitset&lt;N&gt;v)&#123;string res="";for(size_t i=0;i&lt;N;i++)&#123;res+=static_cast&lt;char&gt;('0'+v[i]);&#125;return res;&#125;template&lt;typename A&gt;string to_string(A v)&#123;bool first=true;string res="&#123;";for(const auto&amp;x:v)&#123;if(!first)&#123;res+=",";&#125;first=false;res+=to_string(x);&#125;res+="&#125;";return res;&#125;template&lt;typename A,typename B&gt;string to_string(pair&lt;A,B&gt;p)&#123;return "("+to_string(p.first)+","+to_string(p.second)+")";&#125;template&lt;typename A,typename B,typename C&gt;string to_string(tuple&lt;A,B,C&gt;p)&#123;return "("+to_string(get&lt;0&gt;(p))+","+to_string(get&lt;1&gt;(p))+","+to_string(get&lt;2&gt;(p))+")";&#125;template&lt;typename A,typename B,typename C,typename D&gt;string to_string(tuple&lt;A,B,C,D&gt;p)&#123;return "("+to_string(get&lt;0&gt;(p))+","+to_string(get&lt;1&gt;(p))+","+to_string(get&lt;2&gt;(p))+","+to_string(get&lt;3&gt;(p))+")";&#125;template&lt;typename A,typename B,typename C,typename D,typename E&gt;string to_string(tuple&lt;A,B,C,D,E&gt;p)&#123;return "("+to_string(get&lt;0&gt;(p))+","+to_string(get&lt;1&gt;(p))+","+to_string(get&lt;2&gt;(p))+","+to_string(get&lt;3&gt;(p))+","+to_string(get&lt;4&gt;(p))+")";&#125;void debug_out()&#123;cerr&lt;&lt;endl;&#125;template&lt;typename Head,typename...Tail&gt;void debug_out(Head H,Tail...T)&#123;cerr&lt;&lt;" "&lt;&lt;to_string(H);debug_out(T...);&#125; #ifdef OUUAN #define debug(...)cerr&lt;&lt;"["&lt;&lt;#__VA_ARGS__&lt;&lt;"]:",debug_out(__VA_ARGS__) #else #define debug(...)42 #endif #ifdef int const int INF=0x3f3f3f3f3f3f3f3fll; #else const int INF=0x3f3f3f3f;typedef long long ll; #endif #ifdef FAST_IOSTREAM #define br cout&lt;&lt;'\n' #define sp cout&lt;&lt;' ' long long read()&#123;long long x;cin&gt;&gt;x;return x;&#125;template&lt;typename T&gt;void read(T&amp;x)&#123;cin&gt;&gt;x;&#125;template&lt;typename T&gt;void write(const T&amp;x)&#123;cout&lt;&lt;x;&#125; #else #define br putchar('\n') #define sp putchar(' ') template&lt;typename T&gt;typename enable_if&lt;!is_integral&lt;T&gt;::value,void&gt;::type read(T&amp;x)&#123;cin&gt;&gt;x;&#125;long long read()&#123;char c;long long out=0,f=1;for(c=getchar();!isdigit(c)&amp;&amp;c!='-';c=getchar());if(c=='-')&#123;f=-1;c=getchar();&#125;for(;isdigit(c);c=getchar())out=(out&lt;&lt;3)+(out&lt;&lt;1)+c-'0';return out*f;&#125;template&lt;typename T&gt;typename enable_if&lt;is_integral&lt;T&gt;::value,T&gt;::type read(T&amp;x)&#123;char c;T f=1;x=0;for(c=getchar();!isdigit(c)&amp;&amp;c!='-';c=getchar());if(c=='-')&#123;f=-1;c=getchar();&#125;for(;isdigit(c);c=getchar())x=(x&lt;&lt;3)+(x&lt;&lt;1)+c-'0';return x*=f;&#125;char read(char&amp;x)&#123;for(x=getchar();isspace(x);x=getchar());return x;&#125;double read(double&amp;x)&#123;scanf("%lf",&amp;x);return x;&#125;ld read(ld&amp;x)&#123;scanf("%Lf",&amp;x);return x;&#125;template&lt;typename T&gt;typename enable_if&lt;!is_integral&lt;T&gt;::value,void&gt;::type write(const T&amp;x)&#123;cout&lt;&lt;x;&#125;template&lt;typename T&gt;typename enable_if&lt;is_integral&lt;T&gt;::value,void&gt;::type write(const T&amp;x)&#123;if(x&lt;0)&#123;putchar('-');write(-x);return;&#125;if(x&gt;9)write(x/10);putchar(x%10+'0');&#125;void write(const char&amp;x)&#123;putchar(x);&#125;void write(const double&amp;x)&#123;printf("%.10lf",x);&#125;void write(const ld&amp;x)&#123;printf("%.10Lf",x);&#125; #endif template&lt;typename T,typename...Args&gt;void read(T&amp;x,Args&amp;...args)&#123;read(x);read(args...);&#125;template&lt;typename OutputIt,typename=typename enable_if&lt;is_same&lt;output_iterator_tag,typename iterator_traits&lt;OutputIt&gt;::iterator_category&gt;::value||(is_base_of&lt;forward_iterator_tag,typename iterator_traits&lt;OutputIt&gt;::iterator_category&gt;::value&amp;&amp;!is_const&lt;OutputIt&gt;::value)&gt;::type&gt;void read(OutputIt __first,OutputIt __last)&#123;for(;__first!=__last;++__first)read(*__first);&#125;template&lt;typename InputIt,typename=typename enable_if&lt;is_base_of&lt;input_iterator_tag,typename iterator_traits&lt;InputIt&gt;::iterator_category&gt;::value&gt;::type&gt;void wts(InputIt __first,InputIt __last)&#123;bool isFirst=true;for(;__first!=__last;++__first)&#123;if(isFirst)isFirst=false;else sp;write(*__first);&#125;br;&#125;template&lt;typename InputIt,typename=typename enable_if&lt;is_base_of&lt;input_iterator_tag,typename iterator_traits&lt;InputIt&gt;::iterator_category&gt;::value&gt;::type&gt;void wtb(InputIt __first,InputIt __last)&#123;for(;__first!=__last;++__first)&#123;write(*__first);br;&#125;&#125;template&lt;typename T&gt;void wts(const T&amp;x)&#123;write(x);sp;&#125;template&lt;typename T&gt;void wtb(const T&amp;x)&#123;write(x);br;&#125;template&lt;typename T&gt;void wte(const T&amp;x)&#123;write(x);exit(0);&#125;template&lt;typename T,typename...Args&gt;void wts(const T&amp;x,Args...args)&#123;wts(x);wts(args...);&#125;template&lt;typename T,typename...Args&gt;void wtb(const T&amp;x,Args...args)&#123;wts(x);wtb(args...);&#125;template&lt;typename T,typename...Args&gt;void wte(const T&amp;x,Args...args)&#123;wts(x);wte(args...);&#125;template&lt;typename T&gt;inline bool up(T&amp;x,const T&amp;y)&#123;return x&lt;y?x=y,1:0;&#125;template&lt;typename T&gt;inline bool dn(T&amp;x,const T&amp;y)&#123;return y&lt;x?x=y,1:0;&#125;template&lt;typename T&gt;inline bool inRange(const T&amp;x,const T&amp;l,const T&amp;r)&#123;return!(x&lt;l)&amp;&amp;!(r&lt;x);&#125;template&lt;typename valueType,typename tagType&gt;class segmentTreeNode&#123;public:int id,left,right;valueType val;tagType tag;&#125;;template&lt;typename valueType, typename tagType, valueType(*merge)(valueType,valueType), void(*update)(segmentTreeNode&lt;valueType,tagType&gt;&amp;,tagType)&gt;class segmentTree&#123;private:std::vector&lt;segmentTreeNode&lt;valueType,tagType&gt;&gt;nodes;int leftRange,rightRange;valueType valueZero;tagType tagZero;void pushup(int cur)&#123;nodes[cur].val=merge(nodes[cur&lt;&lt;1].val,nodes[cur&lt;&lt;1|1].val);&#125;void pushdown(int cur)&#123;update(nodes[cur&lt;&lt;1],nodes[cur].tag);update(nodes[cur&lt;&lt;1|1],nodes[cur].tag);nodes[cur].tag=tagZero;&#125;void build(int cur,int l,int r,const std::vector&lt;valueType&gt;&amp;initValue)&#123;nodes[cur].id=cur;nodes[cur].left=l;nodes[cur].right=r;nodes[cur].tag=tagZero;if(l==r-1)nodes[cur].val=initValue[l-leftRange];else&#123;build(cur&lt;&lt;1,l,(l+r)&gt;&gt;1,initValue);build(cur&lt;&lt;1|1,(l+r)&gt;&gt;1,r,initValue);pushup(cur);&#125;&#125;void init(const std::vector&lt;valueType&gt;&amp;_initValue,const valueType&amp;_valueZero,const tagType&amp;_tagZero)&#123;valueZero=_valueZero;tagZero=_tagZero;nodes.resize((rightRange-leftRange)&lt;&lt;2);build(1,leftRange,rightRange,_initValue);&#125;void modify(int cur,int l,int r,int L,int R,const tagType&amp;tag)&#123;if(l&gt;=R||r&lt;=L)return;if(L&lt;=l&amp;&amp;r&lt;=R)update(nodes[cur],tag);else&#123;pushdown(cur);modify(cur&lt;&lt;1,l,(l+r)&gt;&gt;1,L,R,tag);modify(cur&lt;&lt;1|1,(l+r)&gt;&gt;1,r,L,R,tag);pushup(cur);&#125;&#125;valueType query(int cur,int l,int r,int L,int R)&#123;if(l&gt;=R||r&lt;=L)return valueZero;if(L&lt;=l&amp;&amp;r&lt;=R)return nodes[cur].val;pushdown(cur);return merge(query(cur&lt;&lt;1,l,(l+r)&gt;&gt;1,L,R), query(cur&lt;&lt;1|1,(l+r)&gt;&gt;1,r,L,R));&#125;public:segmentTree()&#123;&#125;segmentTree(int _leftRange,int _rightRange,const std::vector&lt;valueType&gt;&amp;_initValue,const valueType&amp;_valueZero,const tagType&amp;_tagZero)&#123;leftRange=_leftRange;rightRange=_rightRange;init(_initValue,_valueZero,_tagZero);&#125;segmentTree(int size,const std::vector&lt;valueType&gt;&amp;_initValue,const valueType&amp;_valueZero,const tagType&amp;_tagZero)&#123;leftRange=1;rightRange=size+1;init(_initValue,_valueZero,_tagZero);&#125;void modify(int l,int r,const tagType&amp;tag)&#123;modify(1,leftRange,rightRange,l,r,tag);&#125;void modify(int p,const tagType&amp;tag)&#123;modify(p,p+1,tag);&#125;valueType query(int l,int r)&#123;return query(1,leftRange,rightRange,l,r);&#125;valueType query(int p)&#123;return query(p,p+1);&#125;&#125;;class maxFlow&#123;private:typedef long long ll;std::queue&lt;int&gt;q;std::vector&lt;int&gt;head,cur,nxt,to,dep;std::vector&lt;ll&gt;cap;public:maxFlow(int _n=0)&#123;init(_n);&#125;void init(int _n)&#123;head.clear();head.resize(_n+1,0);nxt.resize(2);to.resize(2);cap.resize(2);&#125;void init()&#123;init(head.size()-1);&#125;void add(int u,int v,ll w)&#123;nxt.push_back(head[u]);head[u]=to.size();to.push_back(v);cap.push_back(w);&#125;void Add(int u,int v,ll w)&#123;add(u,v,w);add(v,u,0);&#125;void del(int x)&#123;cap[x&lt;&lt;1]=cap[x&lt;&lt;1|1]=0;&#125;bool bfs(int s,int t)&#123;dep.clear();dep.resize(head.size(),-1);dep[s]=0;q.push(s);while(!q.empty())&#123;int u=q.front();q.pop();for(int i=head[u];i;i=nxt[i])&#123;int v=to[i];ll w=cap[i];if(w&gt;0&amp;&amp;dep[v]==-1)&#123;dep[v]=dep[u]+1;q.push(v);&#125;&#125;&#125;return ~dep[t];&#125;ll dfs(int u,ll flow,int t)&#123;if(dep[u]==dep[t])return u==t?flow:0;ll out=0;for(int&amp;i=cur[u];i;i=nxt[i])&#123;int v=to[i];ll w=cap[i];if(w&gt;0&amp;&amp;dep[v]==dep[u]+1)&#123;ll f=dfs(v,std::min(w,flow-out),t);cap[i]-=f;cap[i ^ 1]+=f;out+=f;if(out==flow)return out;&#125;&#125;return out;&#125;ll maxflow(int s,int t)&#123;ll out=0;while(bfs(s,t))&#123;cur=head;out+=dfs(s,0x7fffffffffffffffll,t);&#125;return out;&#125;ll getflow(int x)const&#123;return cap[x&lt;&lt;1|1];&#125;&#125;;struct customHash&#123;static uint64_t splitmix64(uint64_t x)&#123;x+=0x9e3779b97f4a7c15;x=(x ^(x&gt;&gt;30))*0xbf58476d1ce4e5b9;x=(x ^(x&gt;&gt;27))*0x94d049bb133111eb;return x ^(x&gt;&gt;31);&#125;size_t operator()(uint64_t x)const&#123;static const uint64_t FIXED_RANDOM=rng();return splitmix64(x+FIXED_RANDOM);&#125;&#125;; #define mid ((l + r) &gt;&gt; 1) struct Node&#123; int val, ls, rs; bool l1; Node() &#123; val = ls = rs = 0; l1 = false; &#125;&#125;;vector&lt;Node&gt; t;int modify(int u, int l, int r, int p, int x)&#123; int cur = t.size(); t.push_back(t[u]); t[cur].val += x; if (p == l) t[cur].l1 = x == 1; if (l == r - 1) return cur; if (p &lt; mid) &#123; int ls = modify(t[u].ls, l, mid, p, x); t[cur].ls = ls; &#125; else &#123; int rs = modify(t[u].rs, mid, r, p, x); t[cur].rs = rs; &#125; return cur;&#125;int query(int u, int l, int r, int k)&#123; if (l == r - 1) return l; if (t[t[u].ls].val &lt; k || (t[t[u].ls].val == k &amp;&amp; !t[t[u].rs].l1)) return query(t[u].rs, mid, r, k - t[t[u].ls].val); else return query(t[u].ls, l, mid, k);&#125;int n;vi a, rt, pre;int solve(int k)&#123; int p = 0, out = 0; while (p &lt; n) &#123; ++out; p = query(rt[p], 0, n, k) + 1; &#125; return out;&#125;signed main()&#123;#ifdef FAST_IOSTREAM cin.sync_with_stdio(false); cin.tie(0);#endif read(n); a.resize(n); rt.resize(n + 1, 0); pre.resize(n + 1, -1); read(a.begin(), a.end()); t.resize(1); FOR (i, n - 1, 0) &#123; rt[i] = modify(rt[i + 1], 0, n, i, 1); if (~pre[a[i]]) rt[i] = modify(rt[i], 0, n, pre[a[i]], -1); pre[a[i]] = i; &#125; For (i, 1, n) wts(solve(i)); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>贪心</tag>
        <tag>数据结构</tag>
        <tag>二分答案</tag>
        <tag>根号分治</tag>
        <tag>主席树</tag>
        <tag>数颜色</tag>
        <tag>调和级数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CF594D REQ（数颜色，莫队，树状数组，数论）]]></title>
    <url>%2FCF594D-REQ%EF%BC%88%E6%95%B0%E9%A2%9C%E8%89%B2%EF%BC%8C%E8%8E%AB%E9%98%9F%EF%BC%8C%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%EF%BC%8C%E6%95%B0%E8%AE%BA%EF%BC%89%2F</url>
    <content type="text"><![CDATA[题目链接CF 题意简述给你一个正整数序列，多次询问给定区间内每个数之积的欧拉函数 ($\varphi$)，对 $10^9+7$ 取模。 数列长度、询问个数不超过 $2\cdot 10^5$，数的大小不超过 $10^6$ 。 简要做法其实这题和 「SDOI2009」HH 的项链 本质是一样的。 由计算欧拉函数的公式得： $$\varphi\left(\prod\limits_{i=l}^ra_i\right)=\left(\prod\limits_{i=l}^ra_i\right)\cdot\left(\prod\limits_{p\text{ is a prime factor of }a_{l..r}}\frac{p-1}p\right)$$ 即，区间积乘上每个在这个区间中出现了的质因数减一除以本身。 区间积可以通过计算前缀积线性解决，关键在于求出分母。 如果每个质因数的贡献不是 $(p-1)/p$ 而是 $1$，并且贡献不是相乘而是相加，这就是一个区间数颜色问题了。事实上，区间数颜色问题的解法的确可以套用过来。 （下文中复杂度里的 $w$ 均指值域，$\omega(w)$ 指值域内一个数不可重质因子个数的最大值，即 A111972 ，$m$ 指模数，即 $10^9+7$ 。） 莫队做法感觉 $O(w+w\log m/\log w+n\sqrt q\log w+q\log q)$ 做法没啥好讲的，会莫队就会了吧..但这个复杂度我写的过不了。 数论相关的莫队题经常可以根号分治去掉一个 log 。 具体来说，大小超过 $\sqrt w$ 的质因数在一个数中最多出现一次，所以可以把这些“大质数”用莫队处理，其它“小质数”用前缀和预处理，然后时间复杂度就是 $O(w+w\log m/\log w+n\sqrt q+q\log q)$ 了（$O(w\log m/\log w)$ 是计算 $(p-1)/p$ 以及 $p/(p-1)$ 的复杂度，当然，可以通过线性求逆元去掉这个 $\log m$）（空间复杂度为 $O(w+n\sqrt w + m)$）。 这样优化之后可以通过本题。 还有另外一种方式：不枚举重复的质因数，可以优化到 $O(w+w\log p/\log w+n\sqrt q\omega(w)+q\log q)$，也可以通过本题。 树状数组做法这也是区间数颜色的经典做法。 记 $pre(p, r)$ 表示质因数 $p$ 在 $[1, r]$ 中最后一次出现的位置，即： $$pre(p, r)=\max\left(\{x|x\in\mathbb{N}, x\in[1, r], p|a_x\}\bigcup\{0\}\right)$$ 那么，$ans(l, r)=\left(\prod_{pre(p, r)\ge l}(p-1)/p\right)\cdot\left(\prod_{i=l}^ra_i\right)$ 。 将询问离线下来，按右端点排序，从左往右遍历每个点作为 $r$，使用数据结构（如树状数组）维护 $pre(1..r, r)$ 并查询答案，就好了。 如果不枚举重复的质因数，复杂度为 $O(w+w\log p/\log w+n\omega(w)\log n+q(\log n+\log m))$ 。 参考代码瓶颈不带 log 的莫队做法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;cctype&gt;#include &lt;algorithm&gt;using namespace std;typedef long long ll;int read()&#123; int out = 0; char c; while (!isdigit(c = getchar())); for (; isdigit(c); c = getchar()) out = out * 10 + c - '0'; return out;&#125;const int B = 168;const int W = 1e6;const int BLOCK = 500;const int mod = 1e9 + 7;int qpow(int x, int y)&#123; int out = 1; while (y) &#123; if (y &amp; 1) out = (ll) out * x % mod; x = (ll) x * x % mod; y &gt;&gt;= 1; &#125; return out;&#125;vector&lt;bool&gt; np;int n, m, ans = 1;vector&lt;vector&lt;int&gt; &gt; tot;vector&lt;int&gt; a, p, k, invk, maxp, mul, cnt, out;struct Query&#123; int l, r, id; Query(int _l, int _r, int _id) &#123; l = _l; r = _r; id = _id; &#125; bool operator&lt;(const Query&amp; y) const &#123; return l / BLOCK == y.l / BLOCK ? ((l / BLOCK) &amp; 1 ? r &gt; y.r : r &lt; y.r) : l &lt; y.l; &#125;&#125;;vector&lt;Query&gt; q;void add(int x)&#123; if (maxp[x] &gt;= B) &#123; if (++cnt[maxp[x]] == 1) &#123; ans = (ll) ans * k[maxp[x]] % mod; &#125; &#125;&#125;void del(int x)&#123; if (maxp[x] &gt;= B) &#123; if (--cnt[maxp[x]] == 0) &#123; ans = (ll) ans * invk[maxp[x]] % mod; &#125; &#125;&#125;int main()&#123; n = read(); np.resize(W + 1, false); maxp.resize(W + 1); for (int i = 2; i &lt;= W; ++i) &#123; if (!np[i]) &#123; maxp[i] = p.size(); p.push_back(i); k.push_back((ll) (i - 1) * qpow(i, mod - 2) % mod); invk.push_back(qpow(k.back(), mod - 2)); &#125; for (int j = 0; j &lt; p.size() &amp;&amp; i * p[j] &lt;= W; ++j) &#123; int x = i * p[j]; np[x] = true; maxp[x] = max(j, maxp[i]); if (i % p[j] == 0) break; &#125; &#125; a.resize(n + 1); mul.resize(n + 1, 1); cnt.resize(p.size(), 0); tot.resize(B, vector&lt;int&gt;(n + 1, 0)); for (int i = 1; i &lt;= n; ++i) &#123; a[i] = read(); mul[i] = (ll) mul[i - 1] * a[i] % mod; for (int j = 0; j &lt; B; ++j) tot[j][i] = tot[j][i - 1]; for (int x = a[i]; x &gt; 1; x /= p[maxp[x]]) if (maxp[x] &lt; B) ++tot[maxp[x]][i]; &#125; m = read(); out.resize(m); int l, r; for (int i = 0; i &lt; m; ++i) &#123; l = read(); r = read(); q.push_back(Query(l, r, i)); &#125; sort(q.begin(), q.end()); l = 1, r = 0; for (int i = 0; i &lt; m; ++i) &#123; while (l &gt; q[i].l) add(a[--l]); while (r &lt; q[i].r) add(a[++r]); while (l &lt; q[i].l) del(a[l++]); while (r &gt; q[i].r) del(a[r--]); int tmp = (ll) ans * mul[q[i].r] % mod * qpow(mul[q[i].l - 1], mod - 2) % mod; for (int j = 0; j &lt; B; ++j) if (tot[j][q[i].r] - tot[j][q[i].l - 1]) tmp = (ll) tmp * k[j] % mod; out[q[i].id] = tmp; &#125; for (int i = 0; i &lt; m; ++i) printf("%d\n", out[i]); return 0;&#125; 树状数组做法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;cctype&gt;#include &lt;algorithm&gt;using namespace std;typedef long long ll;typedef pair&lt;int, int&gt; pii;int read()&#123; int out = 0; char c; while (!isdigit(c = getchar())); for (; isdigit(c); c = getchar()) out = out * 10 + c - '0'; return out;&#125;const int mod = 1e9 + 7;const int W = 1e6;int qpow(int x, int y)&#123; int out = 1; while (y) &#123; if (y &amp; 1) out = (ll) out * x % mod; x = (ll) x * x % mod; y &gt;&gt;= 1; &#125; return out;&#125;struct BIT&#123; vector&lt;int&gt; A; void resize(int size) &#123; A.resize(size + 1, 1); &#125; void add(int p, int x) &#123; for (; p &lt; A.size(); p += (p &amp; -p)) &#123; A[p] = (ll) A[p] * x % mod; &#125; &#125; int query(int p) &#123; int out = 1; for (; p; p -= (p &amp; -p)) out = (ll) out * A[p] % mod; return out; &#125;&#125; bit;vector&lt;vector&lt;pii&gt; &gt; q;int n, m;vector&lt;bool&gt; np;vector&lt;int&gt; a, mul, p, minp, nxt, k, invk, pre, out;int main()&#123; np.resize(W + 1); nxt.resize(W + 1); minp.resize(W + 1); for (int i = 2; i &lt;= W; ++i) &#123; if (!np[i]) &#123; nxt[i] = 1; minp[i] = p.size(); p.push_back(i); k.push_back((ll) (i - 1) * qpow(i, mod - 2) % mod); invk.push_back(qpow(k.back(), mod - 2)); &#125; for (int j = 0; j &lt; p.size() &amp;&amp; i * p[j] &lt;= W; ++j) &#123; int x = i * p[j]; np[x] = true; minp[x] = j; if (i % p[j]) nxt[x] = i; else &#123; nxt[x] = nxt[i]; break; &#125; &#125; &#125; n = read(); a.resize(n + 1); mul.resize(n + 1, 1); for (int i = 1; i &lt;= n; ++i) &#123; a[i] = read(); mul[i] = (ll) mul[i - 1] * a[i] % mod; &#125; m = read(); q.resize(n + 1); for (int i = 0; i &lt; m; ++i) &#123; int l = read(); int r = read(); q[r].push_back(pii(l, i)); &#125; pre.resize(p.size(), 0); out.resize(m); bit.resize(n); for (int i = 1; i &lt;= n; ++i) &#123; for (int x = a[i]; x &gt; 1; x = nxt[x]) &#123; if (pre[minp[x]]) bit.add(pre[minp[x]], invk[minp[x]]); bit.add(pre[minp[x]] = i, k[minp[x]]); &#125; int tmp = (ll) bit.query(i) * mul[i] % mod; for (auto x : q[i]) out[x.second] = (ll) tmp * qpow((ll) bit.query(x.first - 1) * mul[x.first - 1] % mod, mod - 2) % mod; &#125; for (int i = 0; i &lt; m; ++i) printf("%d\n", out[i]); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>树状数组</tag>
        <tag>数论</tag>
        <tag>数颜色</tag>
        <tag>莫队</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CF455D Serega and Fun（分块 / 平衡树）]]></title>
    <url>%2FCF455D-Serega-and-Fun%EF%BC%88%E5%88%86%E5%9D%97-%E5%B9%B3%E8%A1%A1%E6%A0%91%EF%BC%89%2F</url>
    <content type="text"><![CDATA[题目链接CF 题意简述给你一个序列，在线地支持两个操作： 将一个区间循环移位。 查询一个区间中某个数出现的次数。 序列长度、查询个数都不超过 $10^5$，时限 $\texttt{4s}$ 。 O((n+m)sqrtn) 做法大致思路：分成若干块，每块维护块内每个数的出现次数（这导致空间复杂度是 $O(n\sqrt n)$），以及这一块对应的序列（相当于块状链表）。 具体来说，有至少四种大同小异的做法： 算法： 每次循环移位时只将给定区间的末尾移至给定区间的开头，这样的话每块的大小会经常改变，每根号次循环移位需要重构一次。 每次循环移位时除了将给定区间的末尾移至给定区间的开头，还将区间内每一块的末尾移至下一块的开头，这样的话每块的大小总是不变的。 数据结构： 使用链表维护每一块，找到需要插入、删除的位置可以做到 $O(\sqrt n)$，插入、删除可以做到 $O(1)$ ，换块（末尾删除、头部插入）可以做到 $O(1)$ 。 使用双端队列维护每一块，找到需要插入、删除的位置可以做到 $O(1)$，插入、删除可以做到 $O(\sqrt n)$ ，换块（末尾删除、头部插入）可以做到 $O(1)$ 。 O(n+mlog^2n) 做法使用一棵平衡树维护整个序列，再使用 $n$ 棵平衡树分别维护值为 $i$ 的数之间的相对位置。 即，$t_0$ 中的元素是序列中的每个数，$t_i$ ($1\le i\le n$) 中的元素是所有大小为 $i$ 的数，用于比较的键值是这个数在序列中的位置。 $t_0$ 的维护是经典问题，而维护 $t_i$ 时需要查找位置不超过/不小于给定值的最靠右/最靠左元素，找这个的时候需要利用 $t_0$ 来查询一个数在序列中的位置，具体实现时需要记录 $t_i$ 的每个节点在 $t_0$ 中对应的节点。 由于在 $t_i$ 中调用了 $t_0$，复杂度就是 $O(n+m\log^2 n)$ 。 有点难写，我写了 5KB，调了一年..CF 上有 2.3KB 的提交（没仔细看，但应该是一样的做法..）。 然后这题还成功劝退结构体数组选手，让我改用指针了..最后内存占用比分块还大。 参考代码nsqrtn 做法（链表，每次换块） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;list&gt;#include &lt;algorithm&gt;using namespace std;const int N = 1e5 + 5;const int B = 1000;int n, m, a[N], bl[N], bll[N], blr[N], cnt[N / B + 5][N];list&lt;int&gt; lst[N / B + 5];int main()&#123; scanf("%d", &amp;n); for (int i = 1; i &lt;= n; ++i) scanf("%d", a + i); for (int i = 1, l = 1, r; l &lt;= n; l = r + 1, ++i) &#123; r = min(n, l + B - 1); bll[i] = l; blr[i] = r; for (int j = l; j &lt;= r; ++j) &#123; bl[j] = i; ++cnt[i][a[j]]; lst[i].push_back(a[j]); &#125; &#125; scanf("%d", &amp;m); int ans = 0; while (m--) &#123; int type, l, r; scanf("%d%d%d", &amp;type, &amp;l, &amp;r); l = (l + ans - 1) % n + 1; r = (r + ans - 1) % n + 1; if (l &gt; r) swap(l, r); if (type == 1) &#123; auto it = lst[bl[r]].begin(); for (int i = bll[bl[r]]; i &lt; r; ++i) ++it; int tmp = *it; --cnt[bl[r]][tmp]; ++cnt[bl[l]][tmp]; lst[bl[r]].erase(it); it = lst[bl[l]].begin(); for (int i = bll[bl[l]]; i &lt; l; ++i) ++it; lst[bl[l]].insert(it, tmp); for (int i = bl[l]; i &lt; bl[r]; ++i) &#123; int t = lst[i].back(); lst[i].pop_back(); lst[i + 1].push_front(t); --cnt[i][t]; ++cnt[i + 1][t]; &#125; &#125; else &#123; int k; scanf("%d", &amp;k); k = (k + ans - 1) % n + 1; ans = 0; if (bl[l] == bl[r]) &#123; auto it = lst[bl[l]].begin(); for (int i = bll[bl[l]]; i &lt;= r; ++i) &#123; if (i &gt;= l) ans += *it == k; ++it; &#125; &#125; else &#123; auto it = lst[bl[l]].begin(); for (int i = bll[bl[l]]; i &lt;= blr[bl[l]]; ++i) &#123; if (i &gt;= l) ans += *it == k; ++it; &#125; it = lst[bl[r]].begin(); for (int i = bll[bl[r]]; i &lt;= r; ++i) &#123; ans += *it == k; ++it; &#125; for (int i = bl[l] + 1; i &lt; bl[r]; ++i) ans += cnt[i][k]; &#125; printf("%d\n", ans); &#125; &#125; return 0;&#125; nlog^2n 做法（Splay） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;algorithm&gt;using namespace std;struct Node;int n, m;vector&lt;int&gt; a;vector&lt;Node *&gt; rt;vector&lt;queue&lt;Node *&gt; &gt; q; // q[i] 存的是值为 i 的数在 t_0 中对应的节点Node *empty, *lsen, *rsen;struct Node&#123; int val, siz; Node *pa, *mir; // mir 是在 t_0 中对应的节点 vector&lt;Node *&gt; ch; Node(Node *_pa = empty, int _val = 0, Node *_mir = empty) &#123; siz = 1; pa = _pa; mir = _mir; val = _val; ch.resize(2, empty); &#125;&#125;;void pushup(Node *x)&#123; x-&gt;siz = x-&gt;ch[0]-&gt;siz + x-&gt;ch[1]-&gt;siz + 1;&#125;void rotate(Node *x)&#123; Node *y = x-&gt;pa; Node *z = y-&gt;pa; int k = x == y-&gt;ch[1]; z-&gt;ch[y == z-&gt;ch[1]] = x; x-&gt;pa = z; y-&gt;ch[k] = x-&gt;ch[k ^ 1]; x-&gt;ch[k ^ 1]-&gt;pa = y; x-&gt;ch[k ^ 1] = y; y-&gt;pa = x; pushup(y); pushup(x);&#125;void Splay(Node *x, Node *goal)&#123; while (x-&gt;pa != goal) &#123; Node *y = x-&gt;pa; Node *z = y-&gt;pa; if (z != goal) rotate((x == y-&gt;ch[1]) ^ (y == z-&gt;ch[1]) ? x : y); rotate(x); &#125;&#125;void makeroot(Node *&amp; root, Node *x)&#123; Splay(x, empty); root = x;&#125;Node* kth(Node *root, int x)&#123; Node *u = root; while (1) &#123; if (u-&gt;ch[0]-&gt;siz &gt;= x) u = u-&gt;ch[0]; else if (u-&gt;ch[0]-&gt;siz + 1 == x) return u; else &#123; x -= u-&gt;ch[0]-&gt;siz + 1; u = u-&gt;ch[1]; &#125; &#125;&#125;int rk(Node *&amp; root, Node *x)&#123; makeroot(root, x); return x-&gt;ch[0]-&gt;siz + 1;&#125;void link(Node *&amp; root, Node *x, Node *y, int type = 0)&#123; makeroot(root, y); if (root-&gt;ch[type] != empty) &#123; Node *u = kth(y-&gt;ch[0], y-&gt;ch[0]-&gt;siz); makeroot(root, u); &#125; y-&gt;ch[type] = x; x-&gt;pa = y; pushup(y); if (y-&gt;pa != empty) pushup(y-&gt;pa);&#125;void cut(Node *&amp; root, Node *x)&#123; makeroot(root, x); Node *u = kth(x-&gt;ch[0], x-&gt;ch[0]-&gt;siz); makeroot(root, u); u-&gt;ch[1] = x-&gt;ch[1]; x-&gt;ch[1]-&gt;pa = u; x-&gt;ch[0] = x-&gt;ch[1] = x-&gt;pa = empty; x-&gt;siz = 1; pushup(u);&#125;Node* rkle(Node *root, int x)&#123; Node *u = root; while (1) &#123; if (u-&gt;ch[1] != empty &amp;&amp; rk(rt[0], kth(u-&gt;ch[1], 1)-&gt;mir) &lt;= x) u = u-&gt;ch[1]; else if (rk(rt[0], u-&gt;mir) &lt;= x) return u; else u = u-&gt;ch[0]; &#125;&#125;Node* rkge(Node *root, int x)&#123; Node *u = root; while (1) &#123; if (u-&gt;ch[0] != empty &amp;&amp; rk(rt[0], kth(u-&gt;ch[0], u-&gt;ch[0]-&gt;siz)-&gt;mir) &gt;= x) u = u-&gt;ch[0]; else if (rk(rt[0], u-&gt;mir) &gt;= x) return u; else u = u-&gt;ch[1]; &#125;&#125;Node* split(Node *&amp; root, int l, int r)&#123; Node *x = kth(root, l); Node *y = kth(root, r + 2); makeroot(root, x); Splay(y, x); return y-&gt;ch[0];&#125;Node* get(Node *&amp; root, int p)&#123; Node *x = rkle(root, p); Node *y = rkge(root, p + 2); makeroot(root, x); Splay(y, x); return y-&gt;ch[0];&#125;Node* build1(vector&lt;int&gt;::iterator l, vector&lt;int&gt;::iterator r, Node *pa)&#123; if (l == r) return empty; auto mid = l + (r - l) / 2; Node *cur = new Node(pa, *mid); cur-&gt;ch[0] = build1(l, mid, cur); q[*mid].push(cur); cur-&gt;ch[1] = build1(mid + 1, r, cur); pushup(cur); return cur;&#125;void build1(Node *&amp; root, vector&lt;int&gt;&amp; a)&#123; root = build1(a.begin(), a.end(), empty); lsen = new Node(); link(root, lsen, kth(root, 1)); rsen = new Node(); link(root, rsen, kth(root, root-&gt;siz), 1);&#125;Node* build2(int l, int r, int val, Node *pa)&#123; if (l == r) return empty; int mid = (l + r) &gt;&gt; 1; Node *cur = new Node(pa, val); cur-&gt;ch[0] = build2(l, mid, val, cur); cur-&gt;mir = q[val].front(); q[val].pop(); cur-&gt;ch[1] = build2(mid + 1, r, val, cur); pushup(cur); return cur;&#125;void build2(Node *&amp; root, int size, int val)&#123; if (size == 0) return; root = build2(0, size, val, empty); Node *lsentry = new Node(empty, 0, lsen); link(root, lsentry, kth(root, 1)); Node *rsentry = new Node(empty, 0, rsen); link(root, rsentry, kth(root, root-&gt;siz), 1);&#125;int main()&#123; empty = new Node(); empty-&gt;siz = 0; empty-&gt;ch[0] = empty-&gt;ch[1] = empty-&gt;pa = empty-&gt;mir = empty; scanf("%d", &amp;n); a.resize(n, 0); for (int i = 0; i &lt; n; ++i) scanf("%d", &amp;a[i]); rt.resize(n + 1); q.resize(n + 1); build1(rt[0], a); for (int i = 1; i &lt;= n; ++i) build2(rt[i], q[i].size(), i); scanf("%d", &amp;m); int ans = 0; while (m--) &#123; int type, l, r; scanf("%d%d%d", &amp;type, &amp;l, &amp;r); l = (l + ans - 1) % n + 1; r = (r + ans - 1) % n + 1; if (l &gt; r) swap(l, r); if (type == 1) &#123; if (l == r) continue; Node *x = split(rt[0], l, r); Node *y = kth(x, 1); Node *z = kth(x, x-&gt;siz); int k = z-&gt;val; x = get(rt[k], r); cut(rt[k], x); Node *qaq = rkle(rt[k], l); Node *qwq = rkge(rt[k], l + 1); makeroot(rt[k], qaq); Splay(qwq, qaq); link(rt[k], x, qwq); cut(rt[0], z); link(rt[0], z, y); &#125; else &#123; int k; scanf("%d", &amp;k); k = (k + ans - 1) % n + 1; if (rt[k] == 0) &#123; ans = 0; puts("0"); continue; &#125; Node *x = rkle(rt[k], l); Node *y = rkge(rt[k], r + 2); makeroot(rt[k], x); Splay(y, x); ans = y-&gt;ch[0]-&gt;siz; printf("%d\n", ans); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>分块</tag>
        <tag>平衡树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CF901C Bipartite Segments（二分图）]]></title>
    <url>%2FCF901C-Bipartite-Segments%EF%BC%88%E4%BA%8C%E5%88%86%E5%9B%BE%EF%BC%89%2F</url>
    <content type="text"><![CDATA[题目链接CF 题意简述定义一个“偶环”为边数为偶数的回路（回路又被称作“边简单环”，即不经过重复边且首尾点相同的途径）。 给你一张不含“偶环”的无向图。称一个区间是“好的”，当且仅当编号在这个区间中的点的导出子图是一张二分图。 多组询问，每次询问一个给定区间有多少个子区间是“好的”。 点数、边数、询问数均不超过 $3\cdot 10^5$ 。 简要做法由于图中没有偶环，容易想到一个子图是二分图等价于没有环（因为二分图等价于没有奇环）。 但“没有偶环”的用处远不止此：没有偶环还意味着每个点最多处于一个环内（否则取两个包含同一个点的奇环，把重复的边去掉，就可以得到一个偶环）。 那么，找出图中的每个环的最小节点编号和最大节点编号，以最小值和最大值作为左右端点，就可以得到若干条线段。而一个区间合法就等价于其不包含这些线段中的任意一条。 现在问题已经转化成了：给你 $k$ 条线段 $\{[c_i, d_i]\}_{i=1}^k$，$q$ 次询问，第 $i$ 次询问给你一个区间 $[l_i, r_i]$，求 $[l_i, r_i]$ 有多少个子区间不包含这 $k$ 条线段中的任意一条。 首先，可以观察到，若有一条线段被另一条线段完全包含，包含它的这条线段就可以被无视了。 去除掉上述无用线段后，剩下的线段两两互不包含，那么将它们按左端点排序，会满足：$\forall 1\le i&lt; k, c_i&lt; c_{i+1}, d_i&lt; d_{i+1}$ （不取等号是因为 $1\sim n$ 中的每个数在 $c_{1..n}$ 和 $d_{1..n}$ 中最多只出现一次，而这是因为在原题意中每个点最多处于一个环内）。 如果不管 $r_i$ 的限制，对于每个左端点求答案，画个图手玩一下可以发现，以 $p$ 为左端点时，合法区间的右端点最多到 $\min\left(\{d_j-1|c_j\ge p\}\bigcup\{n\}\right)$ ，即 $p$ “右边”的第一条线段的右端点减一（不存在则为 $n$）。每个左端点无视右端点限制的合法区间数可以求个前缀和，而 $p$ “右边”的第一条线段可以二分求得，也可以线性预处理后 $O(1)$ 求得。那么，我们就会做 $r_i=n$ 的情况了。 然后考虑如何处理 $r_i$ 的限制。对称地（指这个式子和上面那个式子几乎是对称的），令 $t=\max\left(\{c_j|d_j\le r_i\}\bigcup\{0\}\right)$，即 $r_i$ “左边”的第一条线段的左端点（不存在则为 $0$），那么对于不小于 $t$ 的左端点，$r_i$ 这个限制是无用的，而对于大于 $t$ 的左端点，右端点最多可以取到 $r_i$ 。 $t$ 同样可以二分求得或者线性预处理后 $O(1)$ 求得，将左端点分成 $[l_i, t]$ 和 $[t+1, r_i]$ 两部分，前半部分用前缀和计算，后半部分即为 $[t+1, r_i]$ 的子区间数，然后就做完了。实现时注意特判 $t&lt; l_i$ 的情况。 参考代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;algorithm&gt; using namespace std; typedef long long ll;typedef pair&lt;int, int&gt; pii; vector&lt;int&gt; pa, dfn, rt, uncut;vector&lt;vector&lt;int&gt; &gt; g;int n, m, q, dfntot;vector&lt;ll&gt; pre;vector&lt;pii&gt; s; void dfs(int u)&#123; dfn[u] = ++dfntot; for (auto v : g[u]) &#123; if (v == pa[u]) continue; if (!dfn[v]) &#123; pa[v] = u; dfs(v); &#125; else if (dfn[v] &lt; dfn[u]) &#123; int mn = u, mx = u, x = u; while (x != v) &#123; x = pa[x]; mn = min(mn, x); mx = max(mx, x); &#125; rt[mn] = mx; &#125; &#125;&#125; int main()&#123; scanf("%d%d", &amp;n, &amp;m); g.resize(n + 1); pa.resize(n + 1, 0); pre.resize(n + 1, 0); dfn.resize(n + 1, 0); uncut.resize(n + 1, 0); rt.resize(n + 1, n + 1); for (int i = 1; i &lt;= m; ++i) &#123; int u, v; scanf("%d%d", &amp;u, &amp;v); g[u].push_back(v); g[v].push_back(u); &#125; for (int i = 1; i &lt;= n; ++i) if (!dfn[i]) dfs(i); int mn = n; for (int i = n; i &gt;= 1; --i) &#123; mn = min(mn, rt[i]); if (rt[i] &lt;= mn) s.push_back(pii(i, rt[i])); &#125; reverse(s.begin(), s.end()); s.push_back(pii(n + 1, n + 1)); int p = 0, ban = s[0].second; for (int i = 1; i &lt;= n; ++i) &#123; if (i &gt; s[p].first) ban = s[++p].second; pre[i] = pre[i - 1] + ban - i; uncut[i] = uncut[i - 1] + (i == s[uncut[i - 1]].second); &#125; scanf("%d", &amp;q); while (q--) &#123; int l, r; scanf("%d%d", &amp;l, &amp;r); int k = uncut[r]; if (k == 0 || s[k - 1].first &lt; l) printf("%I64d\n", (ll) (r - l + 1) * (r - l + 2) / 2); else printf("%I64d\n", pre[s[k - 1].first] - pre[l - 1] + (ll) (r - s[k - 1].first) * (r - s[k - 1].first + 1) / 2); &#125; return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>二分图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CF1260F Colored Tree（点分治，差分，基数排序）]]></title>
    <url>%2FCF1260F-Colored-Tree%EF%BC%88%E7%82%B9%E5%88%86%E6%B2%BB%EF%BC%8C%E5%B7%AE%E5%88%86%EF%BC%8C%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F%EF%BC%89%2F</url>
    <content type="text"><![CDATA[题目链接CF 题意简述给你一棵树，每个点的颜色为一个区间内的整数，一种染色方案的权值是所有同色无序点对的距离之和，求所有不同染色方案的权值之和。 点数、颜色数均不超过 $10^5$ 。 简要做法首先是 $O(n^2)$ 做法：把计算总和转化为计算期望，然后就可以枚举点对，计算同色概率，乘上距离，最后把期望乘上方案数就是答案。进行 $n$ 次 DFS 而不是每次求 LCA 就可以做到 $O(n^2)$ 。 然后是 $O(n\log n\log c)$（$c$ 为颜色数）做法：点分治，令 $f(u, v)=\max(0, \min(r_u, r_v)-\max(l_u, l_v)+1)$, 点 $u$ 的贡献是 $\sum_{v}f(u, v)(dep_u+dep_v)(r_u-l_u+1)^{-1}(r_v-l_v+1)^{-1}$，即 $\left(dep_u\cdot(r_u-l_u+1)^{-1}\right)\cdot\left(\sum_{v}f(u, v)(r_v-l_v+1)^{-1}\right)+(r_u-l_u+1)^{-1}\cdot\left(\sum_{v}f(u, v)dep_v(r_v-l_v+1)^{-1}\right)$ ，用以颜色为下标、支持区间加/查询区间和的线段树维护 $\sum_{v}(r_v-l_v+1)^{-1}$ 以及 $\sum_{v}dep_v(r_v-l_v+1)^{-1}$ 即可。 如果你写的是其它 $O(n\log n\log c)$ 做法，如链分治（dsu on tree），或者你的常数比较小（比如使用树状数组而不是线段树），你可能就过了。 否则，你可能 TLE on 6 或者 TLE on 14 之类的。 但是，大常数选手并不是没有活路的，因为这题有 $O(n\log n)$ 做法。 其中一种，是使用差分代替上述做法中的线段树。但如果在点分治内进行比较排序，复杂度是 $O(n\log^2 n)$（尽管瓶颈部分的常数很小），解决方法是在点分治的外部进行一次排序，然后在内部就可以线性地将每棵子树的修改与询问划分开来。 “划分”本质上是一个双关键字排序，第一关键字为所在子树的编号，第二关键字为修改/询问原本的排序方式，利用基数排序的思想，由于第二关键字已经有序，对第一关键字进行稳定排序即可。使用计数排序可以做到线性复杂度，总复杂度就是 $O(n\log n)$ 。 参考代码nlognlogc 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178 #ifndef OUUAN #pragma GCC optimize("Ofast,no-stack-protector,unroll-loops,fast-math") #endif #include&lt;bits/stdc++.h&gt; //#define int LoveLive//#define FAST_IOSTREAM 1 #define For(i,l,r)for(int i=(l),i##end=(r);i&lt;=i##end;++i) #define FOR(i,r,l)for(int i=(r),i##end=(l);i&gt;=i##end;--i) #define SON(i,u)for(int i=head[u];i;i=nxt[i]) #define ms(a,x)memset(a,x,sizeof(a)) #define fi first #define se second #define pb emplace_back #define pq priority_queue #define isinf(x)(x&gt;=INF?-1:x) #define y1 why_is_there_a_function_called_y1 #define DEBUG(x)cerr&lt;&lt;(#x)&lt;&lt;":"&lt;&lt;x&lt;&lt;endl using namespace std;typedef long long LoveLive;typedef pair&lt;int,int&gt;pii;typedef vector&lt;int&gt;vi;typedef long double ld;const double inf=1e121;const double eps=1e-10;mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());int randint(int l,int r)&#123;int out=rng()%(r-l+1)+l;return out&gt;=l?out:out+r-l+1;&#125; #ifdef int const int INF=0x3f3f3f3f3f3f3f3fll; #else const int INF=0x3f3f3f3f;typedef long long ll; #endif #ifdef FAST_IOSTREAM #define br cout&lt;&lt;'\n' #define sp cout&lt;&lt;' ' long long read()&#123;long long x;cin&gt;&gt;x;return x;&#125;template&lt;typename T&gt;void read(T&amp;x)&#123;cin&gt;&gt;x;&#125;template&lt;typename T&gt;void write(const T&amp;x)&#123;cout&lt;&lt;x;&#125; #else #define br putchar('\n') #define sp putchar(' ') template&lt;typename T&gt;typename enable_if&lt;!is_integral&lt;T&gt;::value,void&gt;::type read(T&amp;x)&#123;cin&gt;&gt;x;&#125;long long read()&#123;char c;long long out=0,f=1;for(c=getchar();!isdigit(c)&amp;&amp;c!='-';c=getchar());if(c=='-')&#123;f=-1;c=getchar();&#125;for(;isdigit(c);c=getchar())out=(out&lt;&lt;3)+(out&lt;&lt;1)+c-'0';return out*f;&#125;template&lt;typename T&gt;typename enable_if&lt;is_integral&lt;T&gt;::value,T&gt;::type read(T&amp;x)&#123;char c;T f=1;x=0;for(c=getchar();!isdigit(c)&amp;&amp;c!='-';c=getchar());if(c=='-')&#123;f=-1;c=getchar();&#125;for(;isdigit(c);c=getchar())x=(x&lt;&lt;3)+(x&lt;&lt;1)+c-'0';return x*=f;&#125;char read(char&amp;x)&#123;for(x=getchar();isspace(x);x=getchar());return x;&#125;double read(double&amp;x)&#123;scanf("%lf",&amp;x);return x;&#125;ld read(ld&amp;x)&#123;scanf("%Lf",&amp;x);return x;&#125;template&lt;typename T&gt;typename enable_if&lt;!is_integral&lt;T&gt;::value,void&gt;::type write(const T&amp;x)&#123;cout&lt;&lt;x;&#125;template&lt;typename T&gt;typename enable_if&lt;is_integral&lt;T&gt;::value,void&gt;::type write(const T&amp;x)&#123;if(x&lt;0)&#123;putchar('-');write(-x);return;&#125;if(x&gt;9)write(x/10);putchar(x%10+'0');&#125;void write(const char&amp;x)&#123;putchar(x);&#125;void write(const double&amp;x)&#123;printf("%.10lf",x);&#125;void write(const ld&amp;x)&#123;printf("%.10Lf",x);&#125; #endif template&lt;typename T,typename...Args&gt;void read(T&amp;x,Args&amp;...args)&#123;read(x);read(args...);&#125;template&lt;typename OutputIt,typename=typename enable_if&lt;is_same&lt;output_iterator_tag,typename iterator_traits&lt;OutputIt&gt;::iterator_category&gt;::value||(is_base_of&lt;forward_iterator_tag,typename iterator_traits&lt;OutputIt&gt;::iterator_category&gt;::value&amp;&amp;!is_const&lt;OutputIt&gt;::value)&gt;::type&gt;void read(OutputIt __first,OutputIt __last)&#123;for(;__first!=__last;++__first)read(*__first);&#125;template&lt;typename InputIt,typename=typename enable_if&lt;is_base_of&lt;input_iterator_tag,typename iterator_traits&lt;InputIt&gt;::iterator_category&gt;::value&gt;::type&gt;void wts(InputIt __first,InputIt __last)&#123;bool isFirst=true;for(;__first!=__last;++__first)&#123;if(isFirst)isFirst=false;else sp;write(*__first);&#125;br;&#125;template&lt;typename InputIt,typename=typename enable_if&lt;is_base_of&lt;input_iterator_tag,typename iterator_traits&lt;InputIt&gt;::iterator_category&gt;::value&gt;::type&gt;void wtb(InputIt __first,InputIt __last)&#123;for(;__first!=__last;++__first)&#123;write(*__first);br;&#125;&#125;template&lt;typename T&gt;void wts(const T&amp;x)&#123;write(x);sp;&#125;template&lt;typename T&gt;void wtb(const T&amp;x)&#123;write(x);br;&#125;template&lt;typename T&gt;void wte(const T&amp;x)&#123;write(x);exit(0);&#125;template&lt;typename T,typename...Args&gt;void wts(const T&amp;x,Args...args)&#123;wts(x);wts(args...);&#125;template&lt;typename T,typename...Args&gt;void wtb(const T&amp;x,Args...args)&#123;wts(x);wtb(args...);&#125;template&lt;typename T,typename...Args&gt;void wte(const T&amp;x,Args...args)&#123;wts(x);wte(args...);&#125;template&lt;typename T&gt;inline bool up(T&amp;x,const T&amp;y)&#123;return x&lt;y?x=y,1:0;&#125;template&lt;typename T&gt;inline bool dn(T&amp;x,const T&amp;y)&#123;return y&lt;x?x=y,1:0;&#125;template&lt;typename T&gt;inline bool inRange(const T&amp;x,const T&amp;l,const T&amp;r)&#123;return!(x&lt;l)&amp;&amp;!(r&lt;x);&#125;template&lt;typename valueType,typename tagType&gt;class segmentTreeNode&#123;public:int id,left,right;valueType val;tagType tag;&#125;;template&lt;typename valueType, typename tagType, valueType(*merge)(valueType,valueType), void(*update)(segmentTreeNode&lt;valueType,tagType&gt;&amp;,tagType)&gt;class segmentTree&#123;private:std::vector&lt;segmentTreeNode&lt;valueType,tagType&gt;&gt;nodes;int leftRange,rightRange;valueType valueZero;tagType tagZero;void pushup(int cur)&#123;nodes[cur].val=merge(nodes[cur&lt;&lt;1].val,nodes[cur&lt;&lt;1|1].val);&#125;void pushdown(int cur)&#123;update(nodes[cur&lt;&lt;1],nodes[cur].tag);update(nodes[cur&lt;&lt;1|1],nodes[cur].tag);nodes[cur].tag=tagZero;&#125;void build(int cur,int l,int r,const std::vector&lt;valueType&gt;&amp;initValue)&#123;nodes[cur].id=cur;nodes[cur].left=l;nodes[cur].right=r;nodes[cur].tag=tagZero;if(l==r-1)nodes[cur].val=initValue[l-leftRange];else&#123;build(cur&lt;&lt;1,l,(l+r)&gt;&gt;1,initValue);build(cur&lt;&lt;1|1,(l+r)&gt;&gt;1,r,initValue);pushup(cur);&#125;&#125;void init(const std::vector&lt;valueType&gt;&amp;_initValue,const valueType&amp;_valueZero,const tagType&amp;_tagZero)&#123;valueZero=_valueZero;tagZero=_tagZero;nodes.resize((rightRange-leftRange)&lt;&lt;2);build(1,leftRange,rightRange,_initValue);&#125;void modify(int cur,int l,int r,int L,int R,const tagType&amp;tag)&#123;if(l&gt;=R||r&lt;=L)return;if(L&lt;=l&amp;&amp;r&lt;=R)update(nodes[cur],tag);else&#123;pushdown(cur);modify(cur&lt;&lt;1,l,(l+r)&gt;&gt;1,L,R,tag);modify(cur&lt;&lt;1|1,(l+r)&gt;&gt;1,r,L,R,tag);pushup(cur);&#125;&#125;valueType query(int cur,int l,int r,int L,int R)&#123;if(l&gt;=R||r&lt;=L)return valueZero;if(L&lt;=l&amp;&amp;r&lt;=R)return nodes[cur].val;pushdown(cur);return merge(query(cur&lt;&lt;1,l,(l+r)&gt;&gt;1,L,R), query(cur&lt;&lt;1|1,(l+r)&gt;&gt;1,r,L,R));&#125;public:segmentTree()&#123;&#125;segmentTree(int _leftRange,int _rightRange,const std::vector&lt;valueType&gt;&amp;_initValue,const valueType&amp;_valueZero,const tagType&amp;_tagZero)&#123;leftRange=_leftRange;rightRange=_rightRange;init(_initValue,_valueZero,_tagZero);&#125;segmentTree(int size,const std::vector&lt;valueType&gt;&amp;_initValue,const valueType&amp;_valueZero,const tagType&amp;_tagZero)&#123;leftRange=1;rightRange=size+1;init(_initValue,_valueZero,_tagZero);&#125;void modify(int l,int r,const tagType&amp;tag)&#123;modify(1,leftRange,rightRange,l,r,tag);&#125;void modify(int p,const tagType&amp;tag)&#123;modify(p,p+1,tag);&#125;valueType query(int l,int r)&#123;return query(1,leftRange,rightRange,l,r);&#125;valueType query(int p)&#123;return query(p,p+1);&#125;&#125;;class maxFlow&#123;private:typedef long long ll;std::queue&lt;int&gt;q;std::vector&lt;int&gt;head,cur,nxt,to,dep;std::vector&lt;ll&gt;cap;public:maxFlow(int _n=0)&#123;init(_n);&#125;void init(int _n)&#123;head.clear();head.resize(_n+1,0);nxt.resize(2);to.resize(2);cap.resize(2);&#125;void init()&#123;init(head.size()-1);&#125;void add(int u,int v,ll w)&#123;nxt.push_back(head[u]);head[u]=to.size();to.push_back(v);cap.push_back(w);&#125;void Add(int u,int v,ll w)&#123;add(u,v,w);add(v,u,0);&#125;void del(int x)&#123;cap[x&lt;&lt;1]=cap[x&lt;&lt;1|1]=0;&#125;bool bfs(int s,int t)&#123;dep.clear();dep.resize(head.size(),-1);dep[s]=0;q.push(s);while(!q.empty())&#123;int u=q.front();q.pop();for(int i=head[u];i;i=nxt[i])&#123;int v=to[i];ll w=cap[i];if(w&gt;0&amp;&amp;dep[v]==-1)&#123;dep[v]=dep[u]+1;q.push(v);&#125;&#125;&#125;return ~dep[t];&#125;ll dfs(int u,ll flow,int t)&#123;if(dep[u]==dep[t])return u==t?flow:0;ll out=0;for(int&amp;i=cur[u];i;i=nxt[i])&#123;int v=to[i];ll w=cap[i];if(w&gt;0&amp;&amp;dep[v]==dep[u]+1)&#123;ll f=dfs(v,std::min(w,flow-out),t);cap[i]-=f;cap[i ^ 1]+=f;out+=f;if(out==flow)return out;&#125;&#125;return out;&#125;ll maxflow(int s,int t)&#123;ll out=0;while(bfs(s,t))&#123;cur=head;out+=dfs(s,0x7fffffffffffffffll,t);&#125;return out;&#125;ll getflow(int x)const&#123;return cap[x&lt;&lt;1|1];&#125;&#125;;struct customHash&#123;static uint64_t splitmix64(uint64_t x)&#123;x+=0x9e3779b97f4a7c15;x=(x ^(x&gt;&gt;30))*0xbf58476d1ce4e5b9;x=(x ^(x&gt;&gt;27))*0x94d049bb133111eb;return x ^(x&gt;&gt;31);&#125;size_t operator()(uint64_t x)const&#123;static const uint64_t FIXED_RANDOM=rng();return splitmix64(x+FIXED_RANDOM);&#125;&#125;; typedef pair&lt;bool, pii&gt; pbii;const int W = 100000;const int mod = (1e9 + 7//, 998244353);vector&lt;vi&gt; g;vector&lt;bool&gt; vis;int n, tsiz, rt, ans;vi l, r, siz, wt, inv;int qpow(int x, int y)&#123; int out = 1; while (y) &#123; if (y &amp; 1) out = (ll) out * x % mod; x = (ll) x * x % mod; y &gt;&gt;= 1; &#125; return out;&#125;int modadd(int x, int y)&#123; return (x += y) &gt;= mod ? x - mod : x;&#125;pii merge(pii x, pii y)&#123; return pii(modadd(x.fi, y.fi), modadd(x.se, y.se));&#125;void update(segmentTreeNode&lt;pii, pbii&gt;&amp; u, pbii x)&#123; if (x.first) &#123; u.tag = pbii(true, pii(0, 0)); u.val = pii(0, 0); &#125; else if (x.se == pii(0, 0)) return; u.tag.se = merge(u.tag.se, x.se); u.val.fi = (u.val.fi + (ll) x.se.fi * (u.right - u.left)) % mod; u.val.se = (u.val.se + (ll) x.se.se * (u.right - u.left)) % mod;&#125;segmentTree&lt;pii, pbii, merge, update&gt; t(W, vector&lt;pii&gt;(W, pii(0, 0)), pii(0, 0), pbii(false, pii(0, 0)));void getroot(int u, int pa)&#123; siz[u] = wt[u] = 1; for (auto v : g[u]) &#123; if (v == pa || vis[v]) continue; getroot(v, u); siz[u] += siz[v]; up(wt[u], siz[v]); &#125; up(wt[u], tsiz - siz[u]); if (!rt || wt[u] &lt; wt[rt]) rt = u;&#125;void calc(int u, int pa, int dep)&#123; auto res = t.query(l[u], r[u] + 1); ans = (ans + (ll) inv[u] * dep % mod * res.fi + (ll) inv[u] * res.se) % mod; for (auto v : g[u]) &#123; if (v == pa || vis[v]) continue; calc(v, u, dep + 1); &#125;&#125;void insert(int u, int pa, int dep)&#123; t.modify(l[u], r[u] + 1, pbii(false, pii(inv[u], (ll) inv[u] * dep % mod))); for (auto v : g[u]) &#123; if (v == pa || vis[v]) continue; insert(v, u, dep + 1); &#125;&#125;void solve(int u)&#123; vis[u] = true; t.modify(1, W + 1, pbii(true, pii(0, 0))); t.modify(l[u], r[u] + 1, pbii(false, pii(inv[u], 0))); for (auto v : g[u]) &#123; if (vis[v]) continue; calc(v, u, 1); insert(v, u, 1); &#125; for (auto v : g[u]) &#123; if (vis[v]) continue; rt = 0; tsiz = siz[v]; getroot(v, u); solve(rt); &#125;&#125;signed main()&#123; #ifdef FAST_IOSTREAM cin.sync_with_stdio(false); cin.tie(0); #endif read(n); l.resize(n + 1); g.resize(n + 1); vis.resize(n + 1, false); r = wt = siz = inv = l; For (i, 1, n) &#123; read(l[i], r[i]); inv[i] = qpow(r[i] - l[i] + 1, mod - 2); &#125; For (i, 2, n) &#123; int u, v; read(u, v); g[u].pb(v); g[v].pb(u); &#125; tsiz = n; getroot(1, 0); solve(rt); for (int i = 1; i &lt;= n; ++i) ans = (ll) ans * (r[i] - l[i] + 1) % mod; cout &lt;&lt; ans; return 0;&#125; nlogn#1 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;typedef long long ll;const int mod = 1e9 + 7;int qpow(int x, int y)&#123; int out = 1; while (y) &#123; if (y &amp; 1) out = (ll) out * x % mod; x = (ll) x * x % mod; y &gt;&gt;= 1; &#125; return out;&#125;vector&lt;bool&gt; vis;int n, tsiz, rt, ans;vector&lt;vector&lt;int&gt; &gt; g;vector&lt;int&gt; siz, wt, bel, dep, inv;struct Modification&#123; int id, p, inv, l; Modification(int _id, int _p, int _inv, int _l): id(_id), p(_p), inv(_inv), l(_l) &#123;&#125; bool operator&lt;(const Modification&amp; b) const &#123; return p &lt; b.p; &#125; int k1() const &#123; return inv; &#125; int b1() const &#123; return p == l ? (ll) (1 - l + mod) * k1() % mod : (ll) (mod - p + 1) * k1() % mod; &#125; int k2() const &#123; return (ll) inv * dep[id] % mod; &#125; int b2() const &#123; return p == l ? (ll) (1 - l + mod) * k2() % mod : (ll) (mod - p + 1) * k2() % mod; &#125;&#125;;struct Query&#123; int id, p, inv; Query(int _id, int _p, int _inv): id(_id), p(_p), inv(_inv) &#123;&#125; bool operator&lt;(const Query&amp; b) const &#123; return p &lt; b.p; &#125; void calc(int x1, int x2, int type) const &#123; ans = (ans + (ll) type * inv * ((ll) dep[id] * x1 % mod + x2) % mod + mod) % mod; &#125;&#125;;void getroot(int u, int pa)&#123; siz[u] = wt[u] = 1; for (auto v : g[u]) &#123; if (v == pa || vis[v]) continue; getroot(v, u); siz[u] += siz[v]; wt[u] = max(wt[u], siz[v]); &#125; wt[u] = max(wt[u], tsiz - siz[u]); if (!rt || wt[u] &lt; wt[rt]) rt = u;&#125;void calc(const vector&lt;Modification&gt;&amp; ms, const vector&lt;Query&gt;&amp; qs, int type)&#123; int k1 = 0, b1 = 0, k2 = 0, b2 = 0, i = 0; for (auto q : qs) &#123; while (i &lt; ms.size() &amp;&amp; ms[i].p &lt;= q.p) &#123; k1 = (k1 + ms[i].k1()) % mod; b1 = (b1 + ms[i].b1()) % mod; k2 = (k2 + ms[i].k2()) % mod; b2 = (b2 + ms[i].b2()) % mod; ++i; &#125; q.calc(((ll) k1 * q.p + b1) % mod, ((ll) k2 * q.p + b2) % mod, type); &#125;&#125;void dfs(int u, int pa)&#123; for (auto v : g[u]) &#123; if (v == pa || vis[v]) continue; dep[v] = dep[u] + 1; bel[v] = bel[u]; dfs(v, u); &#125;&#125;void solve(int u, vector&lt;Modification&gt;&amp; ms, vector&lt;Query&gt;&amp; qs)&#123; vis[u] = true; vector&lt;vector&lt;Query&gt; &gt; qson(1, vector&lt;Query&gt;()); vector&lt;vector&lt;Modification&gt; &gt; mson(1, vector&lt;Modification&gt;()); for (auto v : g[u]) &#123; if (vis[v]) continue; mson.push_back(vector&lt;Modification&gt;()); qson.push_back(vector&lt;Query&gt;()); bel[v] = mson.size() - 1; dep[v] = 1; dfs(v, u); &#125; bel[u] = dep[u] = 0; calc(ms, qs, 1); for (auto m : ms) mson[bel[m.id]].push_back(m); for (auto q : qs) qson[bel[q.id]].push_back(q); vector&lt;Modification&gt;().swap(ms); // free memory, the memory complexity is O(n) instead of O(nlogn) because of these two lines vector&lt;Query&gt;().swap(qs); for (auto v : g[u]) &#123; if (vis[v]) continue; calc(mson[bel[v]], qson[bel[v]], -1); tsiz = siz[v]; rt = 0; getroot(v, u); solve(rt, mson[bel[v]], qson[bel[v]]); &#125;&#125;int main()&#123; scanf("%d", &amp;n); g.resize(n + 1); siz.resize(n + 1, 0); vis.resize(n + 1, false); wt = bel = dep = inv = siz; vector&lt;Modification&gt; ms; vector&lt;Query&gt; qs; int mul = (mod + 1) / 2; for (int i = 1; i &lt;= n; ++i) &#123; int l, r; scanf("%d%d", &amp;l, &amp;r); mul = (ll) mul * (r - l + 1) % mod; inv[i] = qpow(r - l + 1, mod - 2); ms.push_back(Modification(i, l, inv[i], l)); ms.push_back(Modification(i, r + 1, mod - inv[i], l)); qs.push_back(Query(i, l - 1, mod - inv[i])); qs.push_back(Query(i, r, inv[i])); &#125; for (int i = 1; i &lt; n; ++i) &#123; int u, v; scanf("%d%d", &amp;u, &amp;v); g[u].push_back(v); g[v].push_back(u); &#125; sort(ms.begin(), ms.end()); sort(qs.begin(), qs.end()); tsiz = n; getroot(1, 0); solve(rt, ms, qs); cout &lt;&lt; (ll) ans * mul % mod; return 0;&#125; nlogn#2 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;typedef long long ll;const int mod = 1e9 + 7;static unsigned fast_mod(uint64_t x)&#123;#if !defined(_WIN32) || defined(_WIN64) return x % mod;#endif // Optimized mod for Codeforces 32-bit machines. // x must be less than 2^32 * m for this to work, so that x / m fits in a 32-bit integer. unsigned x_high = x &gt;&gt; 32, x_low = (unsigned) x; unsigned quot, rem; asm("divl %4\n" : "=a" (quot), "=d" (rem) : "d" (x_high), "a" (x_low), "r" (mod)); return rem;&#125;int modadd(int x, int y)&#123; return (x += y) &gt;= mod ? x - mod : x;&#125;int qpow(int x, int y)&#123; int out = 1; while (y) &#123; if (y &amp; 1) out = fast_mod((ll) out * x); x = fast_mod((ll) x * x); y &gt;&gt;= 1; &#125; return out;&#125;vector&lt;bool&gt; vis;int n, tsiz, rt, ans;vector&lt;vector&lt;int&gt; &gt; g;vector&lt;int&gt; siz, wt, bel, dep, inv, cnt, ma, mb, qa, qb;struct Modification&#123; int id, p, inv, l; Modification(int _id, int _p, int _inv, int _l): id(_id), p(_p), inv(_inv), l(_l) &#123;&#125; bool operator&lt;(const Modification&amp; b) const &#123; return p &lt; b.p; &#125; int k1() const &#123; return inv; &#125; int b1() const &#123; return p == l ? fast_mod((ll) (1 - l + mod) * k1()) : fast_mod((ll) (mod - p + 1) * k1()); &#125; int k2() const &#123; return (ll) inv * dep[id] % mod; &#125; int b2() const &#123; return p == l ? fast_mod((ll) (1 - l + mod) * k2()) : fast_mod((ll) (mod - p + 1) * k2()); &#125;&#125;;vector&lt;Modification&gt; ms;struct Query&#123; int id, p, inv; Query(int _id, int _p, int _inv): id(_id), p(_p), inv(_inv) &#123;&#125; bool operator&lt;(const Query&amp; b) const &#123; return p &lt; b.p; &#125; void calc(int x1, int x2, int type) const &#123; ans = fast_mod(ans + type * fast_mod((ll) inv * (fast_mod((ll) dep[id] * x1 + x2))) + mod); &#125;&#125;;vector&lt;Query&gt; qs;void getroot(int u, int pa)&#123; siz[u] = wt[u] = 1; for (auto v : g[u]) &#123; if (v == pa || vis[v]) continue; getroot(v, u); siz[u] += siz[v]; wt[u] = max(wt[u], siz[v]); &#125; wt[u] = max(wt[u], tsiz - siz[u]); if (!rt || wt[u] &lt; wt[rt]) rt = u;&#125;void calc(int l, int r, int type)&#123; int k1 = 0, b1 = 0, k2 = 0, b2 = 0, i = l; for (int j = l; j &lt;= r; ++j) &#123; Query&amp; q = qs[qa[j]]; while (i &lt;= r) &#123; Modification&amp; m = ms[ma[i]]; if (m.p &gt; q.p) break; k1 = modadd(k1, m.k1()); b1 = modadd(b1, m.b1()); k2 = modadd(k2, m.k2()); b2 = modadd(b2, m.b2()); ++i; &#125; q.calc(fast_mod((ll) k1 * q.p + b1), fast_mod((ll) k2 * q.p + b2), type); &#125;&#125;void dfs(int u, int pa)&#123; cnt[bel[u]] += 2; for (auto v : g[u]) &#123; if (v == pa || vis[v]) continue; dep[v] = dep[u] + 1; bel[v] = bel[u]; dfs(v, u); &#125;&#125;void solve(int u, int l, int r)&#123; vis[u] = true; int soncnt = bel[u] = dep[u] = 0; cnt[0] = l + 1; for (auto v : g[u]) &#123; if (vis[v]) continue; bel[v] = ++soncnt; cnt[bel[v]] = cnt[bel[v] - 1]; dep[v] = 1; dfs(v, u); &#125; calc(l, r, 1); vector&lt;int&gt; cnt2(cnt.begin(), cnt.begin() + soncnt + 1); for (int i = r; i &gt;= l; --i) mb[cnt2[bel[ms[ma[i]].id]]--] = ma[i]; for (int i = l; i &lt;= r; ++i) ma[i] = mb[i]; for (int i = 0; i &lt;= soncnt; ++i) cnt2[i] = cnt[i]; for (int i = r; i &gt;= l; --i) qb[cnt2[bel[qs[qa[i]].id]]--] = qa[i]; for (int i = l; i &lt;= r; ++i) qa[i] = qb[i]; for (int i = 0; i &lt;= soncnt; ++i) cnt2[i] = cnt[i]; for (auto v : g[u]) &#123; if (vis[v]) continue; calc(cnt2[bel[v] - 1] + 1, cnt2[bel[v]], -1); tsiz = siz[v]; rt = 0; getroot(v, u); solve(rt, cnt2[bel[v] - 1] + 1, cnt2[bel[v]]); &#125;&#125;int main()&#123; scanf("%d", &amp;n); g.resize(n + 1); siz.resize(n + 1, 0); vis.resize(n + 1, false); wt = bel = dep = inv = cnt = siz; int mul = (mod + 1) / 2; for (int i = 1; i &lt;= n; ++i) &#123; int l, r; scanf("%d%d", &amp;l, &amp;r); mul = fast_mod((ll) mul * (r - l + 1)); inv[i] = qpow(r - l + 1, mod - 2); ms.push_back(Modification(i, l, inv[i], l)); ms.push_back(Modification(i, r + 1, mod - inv[i], l)); qs.push_back(Query(i, l - 1, mod - inv[i])); qs.push_back(Query(i, r, inv[i])); &#125; for (int i = 1; i &lt; n; ++i) &#123; int u, v; scanf("%d%d", &amp;u, &amp;v); g[u].push_back(v); g[v].push_back(u); &#125; ma.resize(n * 2); mb = qa = qb = ma; for (int i = 0; i &lt; n * 2; ++i) ma[i] = qa[i] = i; sort(ma.begin(), ma.end(), [](int x, int y) &#123; return ms[x] &lt; ms[y]; &#125;); sort(qa.begin(), qa.end(), [](int x, int y) &#123; return qs[x] &lt; qs[y]; &#125;); tsiz = n; getroot(1, 0); solve(rt, 0, 2 * n - 1); cout &lt;&lt; fast_mod((ll) ans * mul); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>点分治</tag>
        <tag>差分</tag>
        <tag>基数排序</tag>
        <tag>概率期望</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UOJ 无限 waiting 的解决方法]]></title>
    <url>%2FUOJ-%E6%97%A0%E9%99%90-waiting-%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[本文讲的是自己搭建的 UOJ 如何解决无限 waiting，而不是 http://uoj.ac 如何解决无限 waiting（后者大概要联系 vfk..反正我是没遇到过）。 这个问题困扰了我很久.. 然后在若干次数据回滚后，我发现每次都是使用 git 后出现无限 waiting。进而发现是在 git reset --hard 后发生这种情况。 最后，我发现了问题的真正原因：git 把某些文件的权限改了，导致 docker 启动时无法运行 judger。 解决方法： 123docker exec -it uoj chmod +x /opt/uoj/judger/judge_clientdocker exec -it uoj chown local_main_judger: /opt/uoj/judger/log/judger.logdocker restart uoj （当然，如果你改了 docker 容器名 / judger 用户名，甚至网页和 judger 不是同一个 docker，就不能照搬上面的命令了。）]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「NOI2014」购票（斜率优化，点分治）]]></title>
    <url>%2F%E3%80%8CNOI2014%E3%80%8D%E8%B4%AD%E7%A5%A8%EF%BC%88%E6%96%9C%E7%8E%87%E4%BC%98%E5%8C%96%EF%BC%8C%E7%82%B9%E5%88%86%E6%B2%BB%EF%BC%89%2F</url>
    <content type="text"><![CDATA[题目链接UOJ 洛谷 题意简述给你一棵树，$i$ 号点有 $p_i$、$q_i$ 和 $l_i$ 三个属性，每条边有给定的长度。 从一个点出发可以到达其祖先中与其距离不超过 $l_i$ 的点，费用为 $p_i\cdot dis+q_i$，求每个点到根的最小费用。 点数不超过 $2\cdot 10^5$ 。 简要做法用 $dis[i]$ 表示$i$ 到根的距离，$f_i$ 表示点 $i$ 的答案，那么：$$f_i=\min\limits_{\begin{array}{cc}j\text{ is an ancestor of }i\\dis[j]\ge dis[i]-l_i\end{array}}\{f_j-p_i dis[j]+p_i dis[i]+q[i]\}$$这个东西可以用斜率优化，然而有三个不太友好的地方： 这是棵树； 有 $dis[j]\ge dis[i]-l_i$ 这个限制； $p_i$ 不是单调的。 类似于 「NOI2007」货币兑换 ，可以用类似于 CDQ 分治的点分治来解决上述三个问题。（然而我不仅没做过货币兑换，而且想到这个做法的时候都没意识到它是 CDQ 分治，只是在 四色的 NOI 中听说了这题可以点分治然后就 yy 出来了..） 具体来说，每个转移都可以看成一条路径，但只有竖直向上的路径是合法的，所以“向上”的那个子树需要特殊处理。类似于 CDQ 分治先处理左半部分再计算左半部分对右半部分的贡献，这题每次分治时先处理“向上”的那个子树，然后用分治中心到根的链除了分治中心本身外在当前分治树上的部分来更新分治中心的 DP 值，再用分治中心到根的链在当前分治树上的部分来更新除了“向上”的那个外的其它子树的 DP 值，最后再分治下去处理除了“向上”的那个外的其它子树。 更新除了“向上”的那个外的其它子树的 DP 值时，需要把这些子树里的点按 $dis[i]-l_i$ 排序，然后从下往上把分治中心到根的链在当前分治树上的部分在可行时加入凸包。 由于 $p_i$ 不是单调的，并不是用单调队列/单调栈维护凸包，而是保留整个凸包，查询的时候二分。 用叉积判斜率会爆 long long，可以用 __int128 / double 解决。 总复杂度 $O(n\log^2 n)$ 。 参考代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;typedef long long ll;const ll INF = 1e18;vector&lt;bool&gt; vis;int n, type, tsiz, rt;vector&lt;vector&lt;int&gt; &gt; g;vector&lt;ll&gt; dis, p, q, k, f;vector&lt;int&gt; siz, wt, dep, pa;void getroot(int u, int fa)&#123; siz[u] = wt[u] = 1; for (int i = 0; i &lt; g[u].size(); ++i) &#123; int v = g[u][i]; if (v == fa || vis[v]) continue; getroot(v, u); siz[u] += siz[v]; wt[u] = max(wt[u], siz[v]); &#125; wt[u] = max(wt[u], tsiz - siz[u]); if (!rt || wt[u] &lt; wt[rt]) rt = u;&#125;void getchildren(int u, vector&lt;int&gt;&amp; children)&#123; for (int i = 0; i &lt; g[u].size(); ++i) &#123; int v = g[u][i]; if (v == pa[u] || vis[v]) continue; children.push_back(v); getchildren(v, children); &#125;&#125;bool cmp(int x, int y)&#123; return dis[x] - k[x] &gt; dis[y] - k[y];&#125;bool check(int x, int y, int z)&#123; return 1.0 * (f[x] - f[y]) / (dis[x] - dis[y]) &lt; 1.0 * (f[y] - f[z]) / (dis[y] - dis[z]);&#125;ll calc(int i, int j)&#123; return f[j] + p[i] * (dis[i] - dis[j]) + q[i];&#125;void solve(int u)&#123; vis[u] = true; vector&lt;int&gt; anc(1, u); while (pa[anc.back()] &amp;&amp; !vis[pa[anc.back()]]) anc.push_back(pa[anc.back()]); if (anc.size() &gt; 1) &#123; rt = 0; tsiz = siz[pa[u]]; getroot(pa[u], u); solve(rt); for (int i = 1; i &lt; anc.size() &amp;&amp; dis[anc[i]] &gt;= dis[u] - k[u]; ++i) f[u] = min(f[u], calc(u, anc[i])); &#125; vector&lt;int&gt; children; getchildren(u, children); sort(children.begin(), children.end(), cmp); vector&lt;int&gt; convex; int t = 0; for (int i = 0; i &lt; children.size(); ++i) &#123; int v = children[i]; while (t &lt; anc.size() &amp;&amp; dis[anc[t]] &gt;= dis[v] - k[v]) &#123; while (convex.size() &gt;= 2 &amp;&amp; check(convex[convex.size() - 2], convex.back(), anc[t])) convex.pop_back(); convex.push_back(anc[t++]); &#125; if (convex.empty()) continue; int l = 0, r = convex.size() - 1; while (l &lt; r) &#123; int mid = (l + r + 1) &gt;&gt; 1; if (mid &amp;&amp; calc(v, convex[mid - 1]) &lt; calc(v, convex[mid])) r = mid - 1; else l = mid; &#125; f[v] = min(f[v], calc(v, convex[l])); &#125; for (int i = 0; i &lt; children.size(); ++i) &#123; int v = children[i]; if (v == pa[u] || vis[v]) continue; rt = 0; tsiz = siz[v]; getroot(v, u); solve(v); &#125;&#125;int main()&#123; scanf("%d%d", &amp;n, &amp;type); vis.resize(n + 1, false); f.resize(n + 1, INF); dis.resize(n + 1, 0); dep.resize(n + 1, 0); siz.resize(n + 1, 0); wt.resize(n + 1, 0); pa.resize(n + 1, 0); g.resize(n + 1); p.resize(n + 1); q.resize(n + 1); k.resize(n + 1); for (int i = 2; i &lt;= n; ++i) &#123; scanf("%d%lld%lld%lld%lld", &amp;pa[i], &amp;dis[i], &amp;p[i], &amp;q[i], &amp;k[i]); g[pa[i]].push_back(i); g[i].push_back(pa[i]); dis[i] += dis[pa[i]]; &#125; f[1] = 0; tsiz = n; getroot(1, 0); solve(rt); for (int i = 2; i &lt;= n; ++i) printf("%lld\n", f[i]); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>点分治</tag>
        <tag>cdq分治</tag>
        <tag>斜率优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019，以及毕业之前]]></title>
    <url>%2F2019%EF%BC%8C%E4%BB%A5%E5%8F%8A%E6%AF%95%E4%B8%9A%E4%B9%8B%E5%89%8D%2F</url>
    <content type="text"><![CDATA[怀着伤感的心情写下这段文字，然后开始一段新的征程。 Starting point 看到左边那几排灰色的方格了吗。 第一个绿色的方格是 2018 年 12 月 4 日。 那是什么日子呢？ 要说的话，那是我开始使用 hexo 博客的日子。 那还是我得知自己在 NOIP2018 中夺得 HB rk1 后不久。 在那之后没过几天，我坐上高铁，第一次长期（大于一周）在外参加集训。 也就是那时，我谋生了办一场 CF 的想法。 使用 hexo 博客，也让我从一个 Github 的旁观者，变成了使用者。 究竟是其中的哪一个，改变了故事的主人公，我们不得而知。 但那天，就这样成了故事的起点。 Problem Setting故事的第一站，叫做 Problem Setting 。 这一站很长，可以说从故事开始前——2018 年 8 月——就开始了。那是两场洛谷公开赛，非酋yyf的sif之旅 与 蒟蒻们的补番之旅 。它们并不完善，所以这两场旅途并没有被纳入本文所讲的这个故事之中。 这一站的故事我也曾经讲述过，题目叫做 「bad round 与出题人的坚守」 。 这其中的过程其实并不重要，但就像 后记 中所说的，这一站改变了故事的主人公。 他会对有漏洞的题面感到愤怒——无论是自己过去出的题，还是在哪看到的题目。 Codeforces Round #564，在 CF 上留下的只是八道题目与若干 rating 的变化，但它让故事的主人公对事物的看法有了变化： 我讨厌不用心的出题人，讨厌不严谨甚至误导人的博客，因为，我认为出题给别人做、写博客给别人看是应当对别人负责的。如果没有精力、不想负责的话，出题给自己做，博客保存在本地就好了，发出来干什么？即使是能力不够，也得有认真负责的态度才行。如果没有，别人骂你，只当骂醒好了。如果骂不醒，那着实该骂。 当我指出其他人题目里的种种不足，当我抛开他人博客中不严谨的话语而豁然开朗大叫原文之漏洞满篇时，有没有想过他人付出的心血呢？当然有，只是我认为尊重不是基于付出，而是基于负责的态度，基于真正做了什么的。就好比你追一个女孩子，辛辛苦苦付出了那么多，如果不提升自己，如果不付出真心，别人凭什么喜欢你？ 说到底，对写给别人的东西负责，是我自己的一种坚守，我自己并不是总能做到，也不是生来就能做到。但我会努力去做，无论在怎样的大环境下，我想尽我所能创造一片小小的净土。 很快，他将发现，他不止学会了出题。 GithubGithub 是什么？ 它不只是一个 “代码托管平台”，更是一个 “开源社区”。 在这里，你可以参与他人的项目，也可以让自己的项目被更多人发现，让他人也能够参与其中。 在这个故事中，我们的主人公也写过一些小东西，虽然都不是什么大工程，但也列在这了，有兴趣的读者不妨翻一翻，看看有没有什么能够用得上的：一些有趣的小工程 。 这一站只是故事的一个小插曲，让我们接着往下。 OI WikiOI Wiki 又是什么呢？ 它也是托管在 Github 上的一个开源项目，可它和上面刚刚说过的那些小东西不同，OI Wiki 是一个有着 3.5k stars 和 700+ forks (截至 2019.11.23) 的大项目。 那是一个崇尚知识自由的 OI 学习资源整合站点，可它，很不完善。 信步在 OI Wiki 中的主人公，发现了满眼的空白与漏洞。 他意识到这是怎样的一个平台——它不像出题，只是昙花一现，若题目不够优美，还不知是否有人从中有所收获；它不像写博客，在这个平台上，会有人和你一起协作，也有更多的目光，聚焦在你敲打出的文字之上。 这一站究竟发生了什么？时至今日，我也说不清楚，留下的只有数字：59 pull requests，182 commits，7966 additions ，4675 delections ，100 pull requests reviewed。 伴随着这些数字的，还有一个谜一样的 OIer，他从不在机房打游戏，但他的提交记录却总是寥寥无几。 Value这个故事，好像不是很长，那我们来讲一讲故事之外的一些内容，有关一个看似失败的 OIer 背后的故事。 一切得追溯到一本叫做 从零开始学理财 的书，书中的内容我都不太记得了，故事的主人公现在也对经济不是很感兴趣，那是他小学一二年级时看的，现在只记得其中的一个片段： 有次李嘉诚结束酒会，出酒店刚要上车，一枚一元硬币掉落，滚向下水道，李嘉诚便紧走几步要赶上去捡取。 旁边酒店门童眼疾手快，从地上捡起硬币，交给李嘉诚。李嘉诚很高兴，当即给了门童 100 元小费。 据说李嘉诚是这样说的：“如果我不捡，这一元就从市面消失，毫无价值，而门童捡起来给了我，我的一元没有丢失；门童为我保住一元，值得奖励，100 元他花出去可以吃好的，可以给家人买东西，很有意义，谁都没有损失。” 这个故事的真假暂且不论，丢失一元硬币在经济学意义上究竟带来了什么也不重要，但这个故事给他展示了一个新的视角，一个从全局看问题的视角。 在小学四年级的奥数课上，他又学习了“统筹与规划”，知道了人们排队打水时应当如何安排顺序。 在听说了囚徒困境，并在生活中找到了无数个实例后，他发现，合作博弈的平衡点与非合作博弈截然不同。 vfk 所写的 美在这里 点醒了他，让他看到了 「美就在人与人的相互帮助，相互信任中」，明白了 UOJ 精神之源流究竟在何处。 在 OI 的学习中，一个又一个的最优化问题，让他明白了，看问题不能片面。 在 CF contribution 机制的激励下，他登上了中国 contribution 榜的顶峰。 经过上面那个故事，contribute 已经成了他生活的一部分。 三月のライオン 中 ひなた 喊出的 「後悔なんてしないっっ しちゃダメだっ だって 私のした事は ぜったい まちがってなんか ない！」，让他坚定了自己的决心。 他给自己的价值观下了定义：以最大化社会全体成员的利益总和为目标。 这不是利他主义：自己是社会全体的一部分，他人的利益不比自己的利益重要，但多数人的利益往往更加重要。 这一价值观也不会让他帮助恶人，因为这会间接地使他人利益受损。这也使他明白，惩治恶人的目的不是报复，而是使其改过自新，不再作恶。 这一价值观还让他相信，竞争是以共同进步为目的的，正如他在博客的「关于」一栏中所写，「我不想和他人争抢保送的名额，但我现阶段的梦想，是提高国家集训队第 50 名的水平」，他相信竞争的受益者不会是少数人，而是全体。 他不能做到像雷锋一样总是帮助身边的人，他不懂如何安慰他人，如何鼓励他人，如何在恰当的时候给身边的人以帮助，他也不愿花费比受益人所受之益更大的代价来帮助他人。所以，他选择了 contribute ，选择了在排队时等在最后，选择了在车厢上有空位时若没有其他人站着便坐下。 Future但他在 contribute 这条路上渐行渐远，回头望去时，他发现，自己无法像 ひなた 一样，坚信自己所做是没有错的。 感觉 NOIP 时期自己还是有点智商的，从去广二集训起智商严重下滑。 自从搭了 hexo 博客经常沉迷开发、写工程。然而到现在 Python、JS 什么的还严重依赖搜索引擎。 自从在 CF 出了题，经常沉迷喷出题人、帮出题人改题面、写出题规范，甚至不切实际地希望洛谷公开赛能有所改善。 CF contribution 还挺高的，但 rating 已经大半年停滞不前了。 总之最近一年学了别人一个月就能学完的知识点，但智商下滑，导致水平没有提高。倒是学习了各种各样 contribute 的姿势。感觉要退役。 他意识到，自己的视角虽然够广，但还不够长远。 他想起了自己的梦想，想起了曾经立下的誓言。 是时候把手头的事情放下了，变得更像一名 OIer。 直到 2021 年的夏日，无论是一路在 OI 之路上前行，还是走上高考这条道路。 他在心里暗暗发誓，到那时，他还要回归 contribute 这条不归路，继续走下去。 一句话题意我直到高中毕业大概都不会再参与出题 / 写 OI Wiki 等 contribute 性质的活动了。]]></content>
      <categories>
        <category>其它</category>
      </categories>
      <tags>
        <tag>contribute</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[悬崖边的踟蹰 —— CSP-S 2019]]></title>
    <url>%2F%E6%82%AC%E5%B4%96%E8%BE%B9%E7%9A%84%E8%B8%9F%E8%B9%B0-%E2%80%94%E2%80%94-CSP-S-2019%2F</url>
    <content type="text"><![CDATA[标题来自 三月のライオン Chapter.64 銀の羽根 ： 答案只在漆黑的水底。 越是前进，下一个答案就只能在更深的地方找到。 以前越是潜入，就能获得答案。 比起恐怖，欲望更胜一筹。 但是成为职业棋手 6 年后，如今变得完全不能前进。 即便带着要撕碎全身的想法去潜入，但是却空手而回，已经是很常见的事了。 比起 「也许能找到」，「反正又不一定能找到」这个念头胜利的时候，就只能进行有限的努力了。 但是，桐山和二海堂无视了那样的我。 理所当然一样无论多少次都跳入其中。根本就不正常。 他们即便屡次空手而归，也会制定对策继续挑战。 丝毫不介意痛苦，无论多少次都投身其中。 只留下，被恐惧压倒的我。 Day 1像往常一样，听了 YUKI 的两首三狮 OP 和 IOI2018 主题曲，抽签进考场。 由于自己还算小有名气，这次也不是 NOI 或是什么比赛，只是 CSP，于是避开了人群，也并没有人过来搭话。大概不露出准考证上的名字的话，其他人要么不认识我，要么已经退役了，要么知道我实际上有多菜吧。 T1 当然是看完题就会做了。$n\le 64$ 真毒瘤，只不过给个 $95\%$ 的 $k\le 2^{63}-1$ 提示太明显了（然而后 $50\%$ 的数据 $n$ 还是可以到 $64$…不知道有没有这样的数据）。 T2 一开始想了个神秘的树套树做法，感觉非常蠢，于是去看 T3，发现并不会做，就把 T2 的 $O(n^3)$ 和 T3 的暴力写了。 写完之后想到了若干 T2 的假做法，然后想到了一个略麻烦的线性做法，只不过写起来也没花太多时间。拍上的时候已经 10:30 了，好像比大众 AC 时间 9:00 晚了不少。 之后开始自闭。大概 11:20 的时候去上了个厕所，想到了个感觉挺对的做法：把删边视作给边编号，每个点出发先走编号最小的出边，然后走来到当前点的边在当前点出边中编号的后继。于是可以关于每个点用链表维护一个出边的顺序，再枚举每个数字，DFS 求出它的终点可以在哪些位置，选择其中最小的一个。感觉挺难写的，11:54 的时候算是写完了，但由于赶时间几乎是乱写的，测样例 RE 了，于是就注释掉了，换成了暴力。 我是从学 OI 一个月起就 using namespace std; 的选手，但这次就突然想不 using 来防止 CE，而且每题都在 NOI Linux 虚拟机下编译了，但 11:58 的时候突然发现自己 T3 暴力的 next_permutation 没有加 std，不是很清楚为什么不会 CE，当时的代码也没有了，可能是我哪看错了，总之我最后是把 using namespace std; 加上了.. 所以说不要试图在考场上改代码习惯。 考场须知的签名是在监考说考试结束之后写的，写的时候手都在抖..所以说最后 10min 都别写代码了，5min 根本不够。 考完立刻出了考场，无视掉身边所有人，假装世界上只有自己一个人考了 CSP（ 然后由于最后搞得有点紧张，还有神秘的 std::next_permutation 事件，一直担心文件错误 / CE 。于是就下了一下午（酒馆战）棋，试图忘掉 Day 1。 可是屏蔽 QQ 并不能妨碍我妈晚餐时告诉我人均 210，myh AK 之类的。 Day 2今天是一次崭新的比赛（自我洗脑成功）。 依然是 YUKI 的两首三狮 OP 和 IOI2018 主题曲，然而因为估错时间，为了避免听车载广播，多听了一遍 Euphoria 。 今天不用校内集合，然而考场在 8 楼，于是要坐电梯。只不过还是没人过来搭话。 T1，怎么是计数啊（ 看了几分钟感觉不太会做，人要懵了，这是 D2T1 吗（ 冷静了一下，想到一个假的 $O(n^2m)$ 做法。 然后去看 T2，怎么办我只会 $O(n^3)$..但 $O(n^2)$ 好像很可做的样子。 然后去看 T3，怎么办我只会 $O(n^2)$..但链和菊花好像很可做的样子。 写 T1 写到一半，发现自己假了。冷静了一下，想到一个 $O(n^3m)$ 做法。8700k 应该啥都能过吧.png 写完一测，4.8s，人没了。 卡了卡常，3.6s，人没了。 开 O2，1.2s。但要是手开 O2 我就真没了。怎么手写取模优化啊.png 然后去写 T2，还没开始写就发现可以 $O(n^2\log n)$。写完一测，5s，我又没了。发现多次二分可以用双指针（在 一些注意事项 中有），于是就 $O(n^2)$ 了，跑的挺快。 然后去写 T3。$O(n^2)$ 挺好写的。链好像很简单。完美二叉树是啥..手画一下，发现剩下来较大的那部分的重心只能是根或根的儿子或根和根的儿子，于是也很好写。 此时 11:00 了。 为什么我不会做 D2T1 啊..于是选择去看 T1。这个背包可以 NTT 优化吗..在脑内思考了 5s NTT 是否应当出现在 CSP 中后，我成功算错了复杂度，以为它是 $O(n^2m\log)$ 的，然后写了个极限数据跑 80s 的 $O(n^2m\log^2)$… 最后也没有获得更多分数了。只不过这天提前 10min 就开始检查文件相关问题了。而且全部都 using namespace std; 了，也在 NOI Linux 下编译了。感觉挺放心的。 这次出来没有直接跑掉，然后就听说闫老师 A 了 T1，T2 88。还听说华一前几天校内讲了 T2.. 在回家的路上被告知下午要去学校上 whk..然后书包都没拿（实际上书包里也没有任何 whk 相关的东西），吃完饭就去了，还迟到了 5min。 听说是与前段时间内容无关的物理课，然后还真是与前面的电学无关的动量，给人的感觉几乎是接着我停课前往后讲，于是还算顺畅。 选修 3-5 后面的几章还稍微有一点点涉及电学内容，量子力学什么的也没有完全看懂，计算什么的都跳过了，然而我晚自习就顺着把书看完了（感觉看完后啥都没学会）。 Day 3上午是快乐的 whk 生活。语文课讲期中考试卷子，我就拿别人的卷子看了下上面的几篇阅读。数学课讲求导，于是就写了下物理作业（没毛病）。化学课完全自闭了，于是就写完了物理作业（另一种意义上的没毛病）。 下午好像啥都没干，看着闫老师和肖老师拿民间数据测全省，然后发现 jxl 可能 535… 晚上写游记。 然后发现 D1T3 wqy 的题解好像和我的思路差不多，就试图拿我的考场代码调，发现调不出来，就重写了一遍，调过小样例之后获得了链的 25 分.. Day 4今天上了一整天 whk，上午还是化学自闭，其它课还好，下午是体检 &amp; 地理 &amp; 政治（马上学考了）。 晚上过来给 UOJ #487 加了个负自环的样例，稍微修了下题面。第一次用 svn。（并不知道 UOJ 社区版把 svn 阉割掉之后怎么远程下载数据，只不过 Hinata Online Judge 是资瓷的。） 然后继续调 D1T3，一开始用 $n=10$ 的数据调自闭了，对拍出 $n=4$ 的数据之后 5min 就调出来了.. 感觉要是头脑清醒而且像兔那样 30min AC T1T2，还是能在考场上写出来的.. 题解D1T1依题意模拟，记得开 unsigned long long 。 考场代码 123456789101112131415161718192021222324252627282930313233#include &lt;iostream&gt;#include &lt;cstdio&gt;typedef unsigned long long ull;void solve(int n, ull k)&#123; if (n == 0) return; if (k &lt; (1ull &lt;&lt; (n - 1))) &#123; std::cout &lt;&lt; 0; solve(n - 1, k); &#125; else &#123; std::cout &lt;&lt; 1; solve(n - 1, (1ull &lt;&lt; (n - 1)) - 1 - (k &amp; ((1ull &lt;&lt; (n - 1)) - 1))); &#125;&#125;int main()&#123; int n; ull k; std::cin &gt;&gt; n &gt;&gt; k; solve(n, k); puts(""); return 0;&#125; D1T2我的考场做法好像比较麻烦.. 大致思路是定义一个点的权值是它到根的路径上左括号个数减去右括号个数，并且维护每个点向上多少个点满足右括号个数之和不少于左括号个数之和，后面这个东西维护的时候要分几种情况讨论。 维护了这两个信息，每个点新增的合法括号串就是一段区间里权值为某个数的点的个数，离线下来就可以 $O(n)$ 且无需高级数据结构地解决了。 考场代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;fstream&gt;using std::cin;using std::string;using std::vector;typedef long long ll;typedef std::pair&lt;int, int&gt; pii;int n;string s, t;vector&lt;ll&gt; ans;vector&lt;vector&lt;int&gt; &gt; g;vector&lt;vector&lt;pii&gt; &gt; q;vector&lt;int&gt; jump, tot, pa;void dfs(int u, int cnt)&#123; cnt += s[u - 1] == '(' ? 1 : -1; if (s[u - 1] == ')') ans[u] = tot[cnt + n]; if (u == 1) jump[u] = 1; else if (s[u - 1] == ')') jump[u] = jump[pa[jump[pa[u]]]]; else if (s[pa[u] - 1] == ')') jump[u] = jump[pa[pa[u]]]; else jump[u] = u; if (s[u - 1] == ')') q[pa[pa[jump[pa[u]]]]].push_back(pii(u, cnt)); ++tot[cnt + n]; for (int i = 0; i &lt; g[u].size(); ++i) dfs(g[u][i], cnt); for (int i = 0; i &lt; q[u].size(); ++i) ans[q[u][i].first] -= tot[q[u][i].second + n]; --tot[cnt + n];&#125;int main()&#123; cin &gt;&gt; n &gt;&gt; s; g.resize(n + 1); q.resize(n + 1); ans.resize(n + 1); pa.resize(n + 1, 0); jump.resize(n + 1, 1); tot.resize(2 * n + 1, 0); for (int i = 2; i &lt;= n; ++i) &#123; cin &gt;&gt; pa[i]; g[pa[i]].push_back(i); &#125; jump[0] = 1; tot[n] = 1; dfs(1, 0); ll out = ans[1]; for (int i = 2; i &lt;= n; ++i) &#123; ans[i] += ans[pa[i]]; out ^= ans[i] * i; &#125; std::cout &lt;&lt; out &lt;&lt; std::endl; return 0;&#125; D1T3（我在游记里说过大致思路了。） 把删边视作给边编号，每个点出发先走编号最小的出边，然后走来到当前点的边在当前点出边中编号的后继。于是可以关于每个点用链表维护一个出边的顺序，再枚举每个数字，DFS 求出它的终点可以在哪些位置，选择其中最小的一个。 然后会发现有很多细节，使用并查集会比链表好写一些（虽然复杂度会略微大一点点）。 代码是调试了一万遍写出来的，可能有地方会有些冗余.. 参考代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;using namespace std;vector&lt;bool&gt; able; vector&lt;vector&lt;bool&gt; &gt; haspre;vector&lt;int&gt; a, pa, ans, head, tail;vector&lt;vector&lt;int&gt; &gt; f, g, nxt, siz;int find(int u, int x)&#123; return x == f[u][x] ? x : f[u][x] = find(u, f[u][x]);&#125;void dfs(int u)&#123; if (!pa[u]) &#123; if (head[u]) &#123; int v = head[u]; pa[v] = u; dfs(v); &#125; else &#123; for (int i = 0; i &lt; g[u].size(); ++i) &#123; int v = g[u][i]; if (!haspre[u][v] &amp;&amp; !(tail[u] &amp;&amp; find(u, v) == find(u, tail[u]) &amp;&amp; siz[u][find(u, v)] &lt; g[u].size())) &#123; pa[v] = u; dfs(v); &#125; &#125; &#125; &#125; else &#123; if (nxt[u][pa[u]]) &#123; int v = nxt[u][pa[u]]; pa[v] = u; dfs(v); &#125; else &#123; if (!tail[u] &amp;&amp; !(find(u, pa[u]) == find(u, head[u]) &amp;&amp; siz[u][find(u, head[u])] &lt; g[u].size())) able[u] = true; if (find(u, pa[u]) != find(u, tail[u])) &#123; for (int i = 0; i &lt; g[u].size(); ++i) &#123; int v = g[u][i]; if (find(u, v) != find(u, head[u]) &amp;&amp; find(u, pa[u]) != find(u, v) &amp;&amp; !haspre[u][v] &amp;&amp; !(find(u, pa[u]) == find(u, head[u]) &amp;&amp; find(u, v) == find(u, tail[u]) &amp;&amp; siz[u][find(u, pa[u])] + siz[u][find(u, v)] &lt; g[u].size())) &#123; pa[v] = u; dfs(v); &#125; &#125; &#125; &#125; &#125;&#125;void apply(int u, int from)&#123; if (!from) tail[u] = pa[u]; else if (!pa[u]) &#123; head[u] = from; return; &#125; else &#123; nxt[u][pa[u]] = from; haspre[u][from] = true; siz[u][find(u, from)] += siz[u][find(u, pa[u])]; f[u][find(u, pa[u])] = find(u, from); &#125; apply(pa[u], u);&#125;int main()&#123; int T; cin &gt;&gt; T; while (T--) &#123; int n; cin &gt;&gt; n; a.resize(n + 1); ans.resize(n + 1); head.assign(n + 1, 0); tail.assign(n + 1, 0); g.assign(n + 1, vector&lt;int&gt;()); f.assign(n + 1, vector&lt;int&gt;(n + 1, 0)); siz.assign(n + 1, vector&lt;int&gt;(n + 1, 1)); nxt.assign(n + 1, vector&lt;int&gt;(n + 1, 0)); haspre.assign(n + 1, vector&lt;bool&gt;(n + 1, false)); for (int i = 1; i &lt;= n; ++i) cin &gt;&gt; a[i]; for (int i = 1; i &lt; n; ++i) &#123; int u, v; cin &gt;&gt; u &gt;&gt; v; g[u].push_back(v); g[v].push_back(u); f[u][v] = v; f[v][u] = u; &#125; if (n == 1) &#123; puts("1"); continue; &#125; for (int i = 1; i &lt;= n; ++i) &#123; able.assign(n + 1, false); pa.assign(n + 1, 0); dfs(a[i]); for (int j = 1; j &lt;= n; ++j) &#123; if (able[j]) &#123; cout &lt;&lt; j &lt;&lt; " \n"[i == n]; apply(j, 0); break; &#125; &#125; &#125; &#125; return 0;&#125; D2T1首先可以通过 $O(n^2)$ 的 DP 求出没有 Yazid 的限制（每种主要食材不超过一半）的答案。 然后枚举每种主要食材，算出超过一半的方案数。 两部分答案相减即为最终答案。 第一部分比较简单，我猜大家都会，毕竟这是个基本的背包问题.. 第二部分的话，枚举主要食材后有一个比较容易想到的 $O(n^3)$ DP，但应该是无法通过本题的。 这个 $O(n^3)$ DP 计算了使用多少种当前枚举的食材以及多少种非当前枚举的食材的方案数，但实际上我们并不关心这两种情况具体有多少种食材，而只关心它们的差，所以可以得到下面这种 $O(n^2)$ 的 DP 方法： 令 $f_{i, j}$ 表示使用 $1\sim i$ 这些烹饪方法，做了 $x$ 道当前枚举的食材，$x-j$ 道非当前枚举的食材，的方案数。令当前枚举的食材为 $t$ 。 转移有三种情况，不做/做枚举的/做非枚举的，所以，$f_{i,j}=f_{i-1,j}+a_{i,t}f_{i-1,j-1}+\left(\left(\sum_{p=1}^m a_{i, p}\right)-a_{i,t}\right)f_{i-1,j+1}$ 。 对第二部分答案的贡献是 $\sum_{i=1}^nf_{n,i}$ 。 总复杂度 $O(n^2m)$ 。 参考代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;using namespace std;typedef long long ll;const int mod = 998244353;int n, m, ans;vector&lt;int&gt; sum;vector&lt;vector&lt;int&gt; &gt; a, f;int main()&#123; scanf("%d%d", &amp;n, &amp;m); sum.resize(n + 1, 0); a.resize(n + 1, vector&lt;int&gt;(m + 1)); for (int i = 1; i &lt;= n; ++i) &#123; for (int j = 1; j &lt;= m; ++j) &#123; scanf("%d", &amp;a[i][j]); sum[i] = (sum[i] + a[i][j]) % mod; &#125; &#125; f.resize(n + 1, vector&lt;int&gt;(n + 1, 0)); f[0][0] = 1; for (int i = 1; i &lt;= n; ++i) &#123; f[i][0] = 1; for (int j = 1; j &lt;= i; ++j) &#123; f[i][j] = (f[i - 1][j] + (ll) f[i - 1][j - 1] * sum[i]) % mod; &#125; &#125; for (int i = 1; i &lt;= n; ++i) ans = (ans + f[n][i]) % mod; for (int i = 1; i &lt;= m; ++i) &#123; f.assign(n + 1, vector&lt;int&gt;(2 * n + 3, 0)); f[0][n + 1] = 1; // 下标加上 n+1 避免负数下标 for (int j = 1; j &lt;= n; ++j) &#123; for (int k = n + 1 - j; k &lt;= n + 1 + j; ++k) &#123; f[j][k] = ((ll) a[j][i] * f[j - 1][k - 1] + (ll) (sum[j] - a[j][i] + mod) * f[j - 1][k + 1] + f[j - 1][k]) % mod; &#125; &#125; for (int j = n + 2; j &lt;= n * 2 + 1; ++j) ans = (ans - f[n][j] + mod) % mod; &#125; cout &lt;&lt; ans; return 0;&#125; D2T2首先是一个结论：最后一个断点最大的解是最优解。证明请参考 myy 的题解。（因为自己并没有想到什么更加简洁的证法..）（当然还可以打表发现。） 有了这个结论之后，令 $f_i$ 表示 $[1,i]$ 这段的最后一个断点的最大值，那么，$f_i=\max\{j|j\in\mathbb{N},(\sum_{t=f_j+1}^ja_t)\le(\sum_{t=j+1}^ia_t)\}$ 。 预处理前缀和 $pre[i]=\sum_{j=1}^ia_i$，那么 $f_{i}=\max\{j|j\in\mathbb{N},2pre[j]-pre[f_j]\le pre[i]\}$ ，然后就可以用单调队列优化了。 需要高精的只有最后的答案计算，这可以用 __int128 实现。 参考代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;struct IO &#123;#define MAXSIZE (1 &lt;&lt; 20)#define isdigit(x) (x &gt;= '0' &amp;&amp; x &lt;= '9') char buf[MAXSIZE], *p1, *p2; char pbuf[MAXSIZE], *pp;#if DEBUG#else IO() : p1(buf), p2(buf), pp(pbuf) &#123;&#125; ~IO() &#123; fwrite(pbuf, 1, pp - pbuf, stdout); &#125;#endif inline char gc() &#123;#if DEBUG return getchar();#endif if (p1 == p2) p2 = (p1 = buf) + fread(buf, 1, MAXSIZE, stdin); return p1 == p2 ? ' ' : *p1++; &#125; inline bool blank(char ch) &#123; return ch == ' ' || ch == '\n' || ch == '\r' || ch == '\t'; &#125; template &lt;class T&gt; inline void read(T &amp;x) &#123; register double tmp = 1; register bool sign = 0; x = 0; register char ch = gc(); for (; !isdigit(ch); ch = gc()) if (ch == '-') sign = 1; for (; isdigit(ch); ch = gc()) x = x * 10 + (ch - '0'); if (ch == '.') for (ch = gc(); isdigit(ch); ch = gc()) tmp /= 10.0, x += tmp * (ch - '0'); if (sign) x = -x; &#125; inline void read(char *s) &#123; register char ch = gc(); for (; blank(ch); ch = gc()) ; for (; !blank(ch); ch = gc()) *s++ = ch; *s = 0; &#125; inline void read(char &amp;c) &#123; for (c = gc(); blank(c); c = gc()) ; &#125; inline void push(const char &amp;c) &#123;#if DEBUG putchar(c);#else if (pp - pbuf == MAXSIZE) fwrite(pbuf, 1, MAXSIZE, stdout), pp = pbuf; *pp++ = c;#endif &#125; template &lt;class T&gt; inline void write(T x) &#123; if (x &lt; 0) x = -x, push('-'); static T sta[35]; T top = 0; do &#123; sta[top++] = x % 10, x /= 10; &#125; while (x); while (top) push(sta[--top] + '0'); &#125; template &lt;class T&gt; inline void write(T x, char lastChar) &#123; write(x), push(lastChar); &#125;&#125; io;const int N = 4e7 + 5;typedef long long ll;ll a[N];int n, type, f[N], q[N], ql = 1, qr;ll calc(int x)&#123; return a[x] * 2 - a[f[x]];&#125;void write(__int128 x)&#123; if (x &gt; 9) write(x / 10); putchar(x % 10 + '0');&#125;int main()&#123; io.read(n); io.read(type); if (type == 0) for (int i = 1; i &lt;= n; ++i) io.read(a[i]); else &#123; int x, y, z, b, c, m; io.read(x); io.read(y); io.read(z); io.read(b); io.read(c); io.read(m); int k = 1; for (int i = 1; i &lt;= m; ++i) &#123; int p, l, r; io.read(p); io.read(l); io.read(r); while (k &lt;= p) &#123; int t; if (k == 1) t = b; else if (k == 2) t = c; else &#123; t = ((ll) x * c + (ll) y * b + z) &amp; ((1 &lt;&lt; 30) - 1); b = c; c = t; &#125; a[k++] = t % (r - l + 1) + l; &#125; &#125; &#125; for (int i = 2; i &lt;= n; ++i) a[i] += a[i - 1]; for (int i = 1; i &lt;= n; ++i) &#123; while (ql &lt; qr &amp;&amp; calc(q[ql + 1]) &lt;= a[i]) ++ql; if (ql &gt; qr || calc(q[ql]) &gt; a[i]) f[i] = 0; else f[i] = q[ql]; ll tmp = calc(i); while (ql &lt;= qr &amp;&amp; tmp &lt;= calc(q[qr])) --qr; q[++qr] = i; &#125; __int128 ans = 0; for (int i = n; i; i = f[i]) ans += (__int128) (a[i] - a[f[i]]) * (a[i] - a[f[i]]); write(ans); return 0;&#125; D2T3怎么今年 D2T3 又是 NOI 选手们纷纷用神仙做法秒掉，然后题解区窜出一个神奇的倍增做法（ 瞟了眼主席树题解，感觉自己大约能想出来，于是去学习了一下神奇的倍增做法： 进行树链剖分（实际上只用求出重儿子而不用进行剖分），有一个性质：如果重心在一个子树内，且这个子树的根不是重心，那么重心一定在根的重儿子那棵子树里。 （如果有多个儿子大小一样，重心只能是根。） 然后就可以向下倍增找到重心（如果跳过去之后“向上”的子树大小不超过总点数一半就跳过去）。找到之后还要判其父亲是否也是重心。 然而这样只能处理有根树的子树，另一半的子树（“向上”的子树）需要类似换根 DP 进行处理，需要分几种情况讨论，具体细节可以自行脑补 + 对拍发现自己漏了哪种情况。 参考代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cctype&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;typedef pair&lt;int, int&gt; pii;int read()&#123; int out = 0; char c; while (!isdigit(c = getchar())); for (; isdigit(c); c = getchar()) out = out * 10 + c - '0'; return out;&#125;int n, dfntot;long long ans;vector&lt;vector&lt;int&gt; &gt; g, bz;vector&lt;int&gt; dep, siz, pa, dfn, exi;struct Val&#123; pii fi, se; Val() &#123; fi = se = pii(0, 0); &#125; void insert(pii x) &#123; if (x &gt; fi) &#123; se = fi; fi = x; &#125; else if (x &gt; se) se = x; &#125; pii get(pii x = pii(-1, -1)) &#123; if (x == fi) return se; return fi; &#125;&#125;;vector&lt;Val&gt; son;void dfs1(int u)&#123; siz[u] = 1; dfn[u] = ++dfntot; for (int i = 0; i &lt; g[u].size(); ++i) &#123; int v = g[u][i]; if (v == pa[u]) continue; dep[v] = dep[u] + 1; pa[v] = u; dfs1(v); siz[u] += siz[v]; son[u].insert(pii(siz[v], v)); &#125; exi[u] = dfntot; if (u == 1) return; bz[u][0] = son[u].get().second; for (int i = 1; i &lt;= 17; ++i) bz[u][i] = bz[bz[u][i - 1]][i - 1]; int x = u; for (int i = 17; i &gt;= 0; --i) &#123; int v = bz[x][i]; if (v &amp;&amp; siz[u] - siz[v] &lt;= siz[u] / 2) x = v; &#125; ans += x; if (siz[x] &lt;= siz[u] / 2) ans += pa[x];&#125;bool judge(int u, int v)&#123; if (!v) return false; int f = pa[u]; if (v == f) return true; if (dfn[f] &gt;= dfn[v] &amp;&amp; dfn[f] &lt;= exi[v]) return siz[pa[v]] - siz[u] &lt;= (n - siz[u]) / 2; return n - siz[u] - siz[v] &lt;= (n - siz[u]) / 2;&#125;bool judge2(int u, int v)&#123; if (v == u || !v) return false; int f = pa[u]; if (dfn[f] &gt;= dfn[v] &amp;&amp; dfn[f] &lt;= exi[v]) &#123; return n - siz[v] &lt;= (n - siz[u]) / 2 &amp;&amp; son[v].get(pii(siz[pa[v]], pa[v])).first &lt;= (n - siz[u]) / 2; &#125; return son[v].get().first &lt;= (n - siz[u]) / 2;&#125;void dfs2(int u)&#123; vector&lt;int&gt; tmp = bz[u]; Val rson = son[u]; int f = pa[u]; int paf = pa[f]; if (u != 1) &#123; pa[f] = u; son[u].insert(pii(n - siz[u], f)); bz[f][0] = son[f].get(pii(siz[u], u)).second; for (int i = 1; i &lt;= 17; ++i) bz[f][i] = bz[bz[f][i - 1]][i - 1]; int x = f; for (int i = 17; i &gt;= 0; --i) &#123; int v = bz[x][i]; if (judge(u, v)) x = v; &#125; ans += x; if (judge2(u, pa[x])) ans += pa[x]; &#125; for (int i = 0; i &lt; g[u].size(); ++i) &#123; int v = g[u][i]; if (v == f) continue; dfs2(v); &#125; bz[u] = tmp; pa[f] = paf; son[u] = rson;&#125;int main()&#123; int T; T = read(); while (T--) &#123; n = read(); bz.resize(n + 1, vector&lt;int&gt;(18, 0)); g.assign(n + 1, vector&lt;int&gt;()); son.assign(n + 1, Val()); dep.resize(n + 1, 0); dfn.resize(n + 1, 0); exi.resize(n + 1, 0); siz.resize(n + 1, 0); pa.resize(n + 1, 0); ans = dfntot = 0; for (int i = 1; i &lt; n; ++i) &#123; int u = read(); int v = read(); g[u].push_back(v); g[v].push_back(u); &#125; dfs1(1); dfs2(1); cout &lt;&lt; ans &lt;&lt; endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>游记</category>
      </categories>
      <tags>
        <tag>CCF系列赛事</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于 Capacity Scaling 的弱多项式复杂度最小费用流算法]]></title>
    <url>%2F%E5%9F%BA%E4%BA%8E-Capacity-Scaling-%E7%9A%84%E5%BC%B1%E5%A4%9A%E9%A1%B9%E5%BC%8F%E5%A4%8D%E6%9D%82%E5%BA%A6%E6%9C%80%E5%B0%8F%E8%B4%B9%E7%94%A8%E6%B5%81%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[大多数人所使用的费用流算法，即每次求出残量网络中 $s$ 到 $t$ 关于费用的最短路进行增广（将 Dinic 最大流算法中的 BFS 改为 SPFA），是伪多项式复杂度的，最坏情况下复杂度为 $O(nmf)$，其中 $f$ 为最大流。已知有一种在点数为 $n$，边数为 $O(n^2)$，值域为 $O(2^{n/2})$ 时将其用时卡成关于 $n$ 的指数级复杂度的构造方法。 本文将介绍一种复杂度为进行 $O(m\log U)$ 次（$U$ 表示边的最大容量）无负权边单源最短路（使用 priority_queue 实现 Dijkstra 算法，总复杂度即为 $O(m^2\log U\log m)$）的弱多项式复杂度算法。 其实这个算法并不是很复杂（只是相关资料比较少，会对学习造成一定困难，这也是我写这篇博客的原因），最小费用最大流的模板也只需要 $2.5KB$，并不比常见的伪多项式复杂度算法长很多。 hack 常见的费用流算法可以参考 这篇博客，里面给出了一个用 Python 写的数据生成器，调用函数 mcmf_worst_instance(k) 可以得到 $2k+2$ 个点的数据，格式为第一行点数和边数，后面每行描述一条边（起点、终点、容量、费用），源点是 $1$ 汇点是 $2k+2$。 k=20 生成的数据 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697989910010110210310410510610710810911011111211311411511611711811912012112212312412512612712812913013113213313413513613713813914014114214314414514614714814915015115215315415515615715815916016116216316416516616716816917017117217317417517617717817918018118218318418518618718818919019119219319419519619719819920020120220320420520620720820921021121221321421521621721821922022122222322422522622722822923023123223323423523623723823924024124224324424524624724824925025125225325425525625725825926026126226326426526626726826927027127227327427527627727827928028128228328428528628728828929029129229329429529629729829930030130230330430530630730830931031131231331431531631731831932032132232332432532632732832933033133233333433533633733833934034134234334434534634734834935035135235335435535635735835936036136236336436536636736836937037137237337437537637737837938038138238338438538638738838939039139239339439539639739839940040140240340440540640740840941041141241341441541641741841942042142242 4211 2 1 01 3 3 01 4 5 01 5 10 01 6 20 01 7 40 01 8 80 01 9 160 01 10 320 01 11 640 01 12 1280 01 13 2560 01 14 5120 01 15 10240 01 16 20480 01 17 40960 01 18 81920 01 19 163840 01 20 327680 01 21 655360 02 22 5242880 02 23 5242880 12 24 5242880 32 25 5242880 72 26 5242880 152 27 5242880 312 28 5242880 632 29 5242880 1272 30 5242880 2552 31 5242880 5112 32 5242880 10232 33 5242880 20472 34 5242880 40952 35 5242880 81912 36 5242880 163832 37 5242880 327672 38 5242880 655352 39 5242880 1310712 40 5242880 2621432 41 5242880 5242873 22 5242880 13 24 5242880 33 25 5242880 73 26 5242880 153 27 5242880 313 28 5242880 633 29 5242880 1273 30 5242880 2553 31 5242880 5113 32 5242880 10233 33 5242880 20473 34 5242880 40953 35 5242880 81913 36 5242880 163833 37 5242880 327673 38 5242880 655353 39 5242880 1310713 40 5242880 2621433 41 5242880 5242874 22 5242880 34 23 5242880 34 25 5242880 74 26 5242880 154 27 5242880 314 28 5242880 634 29 5242880 1274 30 5242880 2554 31 5242880 5114 32 5242880 10234 33 5242880 20474 34 5242880 40954 35 5242880 81914 36 5242880 163834 37 5242880 327674 38 5242880 655354 39 5242880 1310714 40 5242880 2621434 41 5242880 5242875 22 5242880 75 23 5242880 75 24 5242880 75 26 5242880 155 27 5242880 315 28 5242880 635 29 5242880 1275 30 5242880 2555 31 5242880 5115 32 5242880 10235 33 5242880 20475 34 5242880 40955 35 5242880 81915 36 5242880 163835 37 5242880 327675 38 5242880 655355 39 5242880 1310715 40 5242880 2621435 41 5242880 5242876 22 5242880 156 23 5242880 156 24 5242880 156 25 5242880 156 27 5242880 316 28 5242880 636 29 5242880 1276 30 5242880 2556 31 5242880 5116 32 5242880 10236 33 5242880 20476 34 5242880 40956 35 5242880 81916 36 5242880 163836 37 5242880 327676 38 5242880 655356 39 5242880 1310716 40 5242880 2621436 41 5242880 5242877 22 5242880 317 23 5242880 317 24 5242880 317 25 5242880 317 26 5242880 317 28 5242880 637 29 5242880 1277 30 5242880 2557 31 5242880 5117 32 5242880 10237 33 5242880 20477 34 5242880 40957 35 5242880 81917 36 5242880 163837 37 5242880 327677 38 5242880 655357 39 5242880 1310717 40 5242880 2621437 41 5242880 5242878 22 5242880 638 23 5242880 638 24 5242880 638 25 5242880 638 26 5242880 638 27 5242880 638 29 5242880 1278 30 5242880 2558 31 5242880 5118 32 5242880 10238 33 5242880 20478 34 5242880 40958 35 5242880 81918 36 5242880 163838 37 5242880 327678 38 5242880 655358 39 5242880 1310718 40 5242880 2621438 41 5242880 5242879 22 5242880 1279 23 5242880 1279 24 5242880 1279 25 5242880 1279 26 5242880 1279 27 5242880 1279 28 5242880 1279 30 5242880 2559 31 5242880 5119 32 5242880 10239 33 5242880 20479 34 5242880 40959 35 5242880 81919 36 5242880 163839 37 5242880 327679 38 5242880 655359 39 5242880 1310719 40 5242880 2621439 41 5242880 52428710 22 5242880 25510 23 5242880 25510 24 5242880 25510 25 5242880 25510 26 5242880 25510 27 5242880 25510 28 5242880 25510 29 5242880 25510 31 5242880 51110 32 5242880 102310 33 5242880 204710 34 5242880 409510 35 5242880 819110 36 5242880 1638310 37 5242880 3276710 38 5242880 6553510 39 5242880 13107110 40 5242880 26214310 41 5242880 52428711 22 5242880 51111 23 5242880 51111 24 5242880 51111 25 5242880 51111 26 5242880 51111 27 5242880 51111 28 5242880 51111 29 5242880 51111 30 5242880 51111 32 5242880 102311 33 5242880 204711 34 5242880 409511 35 5242880 819111 36 5242880 1638311 37 5242880 3276711 38 5242880 6553511 39 5242880 13107111 40 5242880 26214311 41 5242880 52428712 22 5242880 102312 23 5242880 102312 24 5242880 102312 25 5242880 102312 26 5242880 102312 27 5242880 102312 28 5242880 102312 29 5242880 102312 30 5242880 102312 31 5242880 102312 33 5242880 204712 34 5242880 409512 35 5242880 819112 36 5242880 1638312 37 5242880 3276712 38 5242880 6553512 39 5242880 13107112 40 5242880 26214312 41 5242880 52428713 22 5242880 204713 23 5242880 204713 24 5242880 204713 25 5242880 204713 26 5242880 204713 27 5242880 204713 28 5242880 204713 29 5242880 204713 30 5242880 204713 31 5242880 204713 32 5242880 204713 34 5242880 409513 35 5242880 819113 36 5242880 1638313 37 5242880 3276713 38 5242880 6553513 39 5242880 13107113 40 5242880 26214313 41 5242880 52428714 22 5242880 409514 23 5242880 409514 24 5242880 409514 25 5242880 409514 26 5242880 409514 27 5242880 409514 28 5242880 409514 29 5242880 409514 30 5242880 409514 31 5242880 409514 32 5242880 409514 33 5242880 409514 35 5242880 819114 36 5242880 1638314 37 5242880 3276714 38 5242880 6553514 39 5242880 13107114 40 5242880 26214314 41 5242880 52428715 22 5242880 819115 23 5242880 819115 24 5242880 819115 25 5242880 819115 26 5242880 819115 27 5242880 819115 28 5242880 819115 29 5242880 819115 30 5242880 819115 31 5242880 819115 32 5242880 819115 33 5242880 819115 34 5242880 819115 36 5242880 1638315 37 5242880 3276715 38 5242880 6553515 39 5242880 13107115 40 5242880 26214315 41 5242880 52428716 22 5242880 1638316 23 5242880 1638316 24 5242880 1638316 25 5242880 1638316 26 5242880 1638316 27 5242880 1638316 28 5242880 1638316 29 5242880 1638316 30 5242880 1638316 31 5242880 1638316 32 5242880 1638316 33 5242880 1638316 34 5242880 1638316 35 5242880 1638316 37 5242880 3276716 38 5242880 6553516 39 5242880 13107116 40 5242880 26214316 41 5242880 52428717 22 5242880 3276717 23 5242880 3276717 24 5242880 3276717 25 5242880 3276717 26 5242880 3276717 27 5242880 3276717 28 5242880 3276717 29 5242880 3276717 30 5242880 3276717 31 5242880 3276717 32 5242880 3276717 33 5242880 3276717 34 5242880 3276717 35 5242880 3276717 36 5242880 3276717 38 5242880 6553517 39 5242880 13107117 40 5242880 26214317 41 5242880 52428718 22 5242880 6553518 23 5242880 6553518 24 5242880 6553518 25 5242880 6553518 26 5242880 6553518 27 5242880 6553518 28 5242880 6553518 29 5242880 6553518 30 5242880 6553518 31 5242880 6553518 32 5242880 6553518 33 5242880 6553518 34 5242880 6553518 35 5242880 6553518 36 5242880 6553518 37 5242880 6553518 39 5242880 13107118 40 5242880 26214318 41 5242880 52428719 22 5242880 13107119 23 5242880 13107119 24 5242880 13107119 25 5242880 13107119 26 5242880 13107119 27 5242880 13107119 28 5242880 13107119 29 5242880 13107119 30 5242880 13107119 31 5242880 13107119 32 5242880 13107119 33 5242880 13107119 34 5242880 13107119 35 5242880 13107119 36 5242880 13107119 37 5242880 13107119 38 5242880 13107119 40 5242880 26214319 41 5242880 52428720 22 5242880 26214320 23 5242880 26214320 24 5242880 26214320 25 5242880 26214320 26 5242880 26214320 27 5242880 26214320 28 5242880 26214320 29 5242880 26214320 30 5242880 26214320 31 5242880 26214320 32 5242880 26214320 33 5242880 26214320 34 5242880 26214320 35 5242880 26214320 36 5242880 26214320 37 5242880 26214320 38 5242880 26214320 39 5242880 26214320 41 5242880 52428721 22 5242880 52428721 23 5242880 52428721 24 5242880 52428721 25 5242880 52428721 26 5242880 52428721 27 5242880 52428721 28 5242880 52428721 29 5242880 52428721 30 5242880 52428721 31 5242880 52428721 32 5242880 52428721 33 5242880 52428721 34 5242880 52428721 35 5242880 52428721 36 5242880 52428721 37 5242880 52428721 38 5242880 52428721 39 5242880 52428721 40 5242880 52428722 42 2 023 42 2 024 42 5 025 42 10 026 42 20 027 42 40 028 42 80 029 42 160 030 42 320 031 42 640 032 42 1280 033 42 2560 034 42 5120 035 42 10240 036 42 20480 037 42 40960 038 42 81920 039 42 163840 040 42 327680 041 42 655360 0 前置知识本文假定读者对网络流有基本的了解（掌握并大致理解了最大流的增广路解法（EK / Dinic）即可）。 还要会解决无负权边的单源最短路问题（会 Dijkstra 算法即可）。 一些定义无源汇的流，每个点需要满足流入量等于流出量（流量平衡），并且每条边的流量不超过上限。 有源汇的流，存在源点 $s$ 和汇点 $t$，$s$ 只流出不流入，$t$ 只流入不流出，其它点满足流量平衡，并且每条边的流量不超过上限。 最大流问题，只在有源汇的流中有意义，即最大化 $s$ 的流出量（也就是 $t$ 的流入量）。 流的费用，是每条边的流量与费用之积的和。 最小费用最大流问题，在最大流的前提下，最小化流的费用。 （无源汇）最小费用流问题，只用最小化流的费用。 残量网络，是原图中每条没满流的边以及每条有流的边的反边（反边指方向相反，费用为相反数）构成的图。 增广路，在有源汇的流中指残量网络上一条 $s$ 到 $t$ 的路径，在无源汇的流中指残量网络上的一个环。 增广，指的是将一条增广路流量加一（增广路上的边容量减一，对应的反边容量加一）。 不加说明时，边的长度 / 路径的长度 / 环的长度（当然还有“最长路径”、“负环”之类的表述）中的“长度”都指费用。 $(u, v)$ 表示从 $u$ 到 $v$ 的有向边（本文只讨论原图为简单图的情况，非简单图是类似的），$cap(u, v)$ 表示 $(u, v)$ 这条边的容量，$cost(u, v)$ 表示 $(u, v)$ 这条边的费用。 将最小费用最大流问题转化为无源汇最小费用流问题最小费用最大流问题可以转化为无源汇最小费用流问题，方法是连一条 $t$ 到 $s$，容量足够大，费用足够小（为一个负数）的边。这里的“容量足够大”指的是不小于最大流，“费用足够小”指的是小于 $s$ 到 $t$ 的最长简单路径费用的相反数。 由于“费用足够小”，若没有达成最大流，即存在 $s$ 到 $t$ 的增广路，任何一条不经过正环（若存在经过正环的增广路，一定也存在不经过正环的增广路）的 $s$ 到 $t$ 的增广路加上 $(t, s)$ 这条边的费用一定为负，所以通过这条增广路增广总费用一定更小，这说明，无源汇流中满足最小费用时，原问题同时满足了最小费用与最大流。 下文中讨论的都是无源汇最小费用流问题，也不会再次强调“无源汇”。 负环一个流是最小费用流，当且仅当其残量网络中没有负环。 证明： 仅当（必要条件）：若存在负环可以在负环上增广，从而得到费用更小的流。 当（充分条件）：令所考虑的这个流为 $f$，取任意一个最小费用流 $f^{\ast}$，计算它们之间的差 $f^{\ast}-f$（对应边流量相减）。假设 $f$ 不是最小费用流，那么 $f^{\ast}-f$ 的总费用一定为负。由于 $f$ 和 $f^{\ast}$ 都流量平衡，$f^{\ast}-f$ 一定也流量平衡，所以它也是个合法的流，而一个流一定可以拆成若干个环（由于流量平衡，每个联通部分都有欧拉回路），若总费用为负就一定包含负环。又因为 $f^{\ast}-f$ 是在 $f$ 的基础上增广的，$f^{\ast}-f$ 一定是 $f$ 残量网络的一个子图，而其包含负环与 $f$ 的残量网络中没有负环矛盾，所以假设不成立。 节点势能 &amp; 边的 reduced cost这两个概念的提出与最小费用流的线性规划形式的对偶问题相关，但了解这个对偶问题并不是必要的，所以本篇博客中不会提及。 给每个节点 $u$ 指定一个任意的势能 $p(u)$。（这个概念看起来很突兀，总之就是给每个节点新增了一个属性，它的值是任意的。）（本质上是线性规划对偶问题中的一个无限制变量。） 定义一条边 $(u, v)$ 关于某一组势能 $p$ 的 reduced cost（并不知道怎么翻译..）$C_p(u, v)$ 为 $p(u)+cost(u, v)-p(v)$。 reduced cost 有两个很好的性质： 将原费用替换为 reduced cost 不影响最短路。（不是不影响最短路长度，而是不影响最短路是哪一条。） 将原费用替换为 reduced cost 不影响环的总费用。 这两个性质都可以由 $C_p(u, v)+C_p(v, w)=p(u)+cost(u, v)+cost(v, w)-p(w)$（中间经过的点的势能相加后抵消）说明。 如果大家有了解过 Johnson 全源最短路径算法，里面也有类似的操作，用于保证边权非负，使得 Dijkstra 算法可以得到应用。在本文所介绍的最小费用流算法中也是一样，为了能够使用 Dijkstra 算法计算最短路，在过程中需要保证 reduced cost 非负。 capacity scaling（这个也不知道怎么翻译..） capacity scaling 从高到低考虑容量的最高若干位（比如容量为 $5$ ($101_2$)，第一次迭代时考虑最高一位，即 $1$ ($1_2$)，第二次迭代时考虑最高两位，即 $2$ ($10_2$)，第三次迭代时考虑最高三位，即 $5$ ($101_2$)），每次加入更低的位后更新答案。（这个过程和求快速幂有点像。） 它基于一个性质：将原图中每条边的容量乘二后，最小费用流每条边的流量分别乘二。 那么，若计算出了以 $\left\lfloor\frac{cap(u, v)}{2^k}\right\rfloor$ 为边 $(u, v)$ 的容量的最小费用流，现在要得到以 $\left\lfloor\frac{cap(u, v)}{2^{k-1}}\right\rfloor$ 为边 $(u, v)$ 的容量的最小费用流，只需要先将流乘二，然后对每条二进制中该位为 $1$ 的边进行容量加一的操作即可。 所以，问题转化为了给一条边的容量加一，更新最小费用流。 给一条边的容量加一在上文中已经证明，最小费用流等价于残量网络中没有负环。 所以，若容量加一后若产生负环，进行增广即可。 为了优化常数，可以特判掉容量加一前该边已存在于残量网络的情况，直接跳过。 令容量加一的这条边为 $(u, v)$，找负环可以先求出从 $v$ 出发以 reduced cost 为长度到每个点 $i$ 的最短路 $d(i)$（这个最短路不包括 $(u, v)$ 这条边， 由于当前维护的残量网络是容量加一之前的最小费用流，不存在负环，所以最短路是可以求的），判断 $d(u)+C_p(u, v)$ 是否小于 $0$ 即可。 为了使用 Dijkstra 算法，还需要保证 reduced cost 非负，所以需要调整节点的势能。 这里直接给出一种做法：求出上文所述的最短路 $d(i)$（若 $x$ 不可达就将 $d(x)$ 设为 $\max_{\text{节点 }i\text{ 可达}}\{d(i)\}+max(0, -C_p(u, v))$），然后将每个点 $i$ 的势能加上 $d(i)$（用 $p’(i)$ 表示节点 $i$ 更新后的势能）。 这样调整后残量网络中的每一条边的 reduced cost 依然非负的证明： 对于 $(u, v)$ 这条边，若 $u$ 不可达，那么： $$\begin{aligned}C_{p’}(u, v)&amp;=p’(u)+cost(u, v)-p’(v)\\&amp;=p(u)+max(0, -C_p(u, v))+cost(u, v)-p(v)\\&amp;\ge p(u)-(p(u)+cost(u, v)-p(v))+cost(u, v)-p(v)\\&amp;=0\end{aligned}$$ 若 $u$ 可达且 $(u, v)$ 这条边加入后产生了负环，负环会被增广，$(u, v)$ 这条边就不存在了。 若 $u$ 可达且 $(u, v)$ 这条边加入后没有产生负环，即 $d(u)+C_p(u, v)\ge 0$，那么 $C_{p’}(u, v)=d(u)+C_p(u, v)-d(v)=d(u)+C_p(u, v)\ge 0$。 capacity scaling 算法在初始时所有边容量均为 $0$（也就是说残量网络为空），所以可以在除 $(u, v)$ 外每条边的 reduced cost 均非负的基础上归纳证明。 对于其它从 $u$ 可达的边 $(x, y)$，由于 $d(y)\le d(x)+C_p(x, y)$（最短路的性质），即 $d(y)\le d(x)+p(x)+cost(x, y)-p(y)$，所以 $p(x)+d(x)+cost(x, y)-(p(y)+d(y))\ge 0$，即 $p’(x)+cost(x, y)-p’(y)\ge 0$，也就是说 $u$ 可达的边 reduced cost 调整后非负。 对于其它从 $u$ 可达与从 $u$ 不可达交界处的边 $(x, y)$（由于这条边不可达，一定是 $x$ 不可达 $y$ 可达），由于 $C_p(x, y)\ge 0$ 且 $d(x)=\max_{\text{节点 }i\text{ 可达}}\{d(i)\}+max(0, -C_p(u, v))\ge d(y)$，这样的边调整后 reduced cost 也非负。 对于连接从 $u$ 不可达的两个点 $x$，$y$ 的边，$d(x)=d(y)$，调整后 reduced cost 也非负。 综上所述，调整后残量网络中的每一条边的 reduced cost 依然非负。 进而我们还可以得出，上述流程结束后，残量网络中不存在负环，即上述流程可以计算出当前的最小费用流。 防止溢出上一部分中给出的势能调整方式能够保证 reduced cost 非负，但在实际实现时会有势能太大从而溢出的风险。 防止溢出的方法也很简单，新建一个点 $k$，从 $k$ 向所有点连长度为 $0$ 的边，求从 $k$ 出发以原费用（而非 reduced cost）为长度的最短路（由于更新后的残量网络是当前的最小费用流，不存在负环，新增的 $k$ 以及 $k$ 连向其它节点的边也不会带来新的负环，所以最短路是可以求的），以 $k$ 到 $i$ 的最短路作为调整后节点 $i$ 的势能。这样调整后，$C_p(x, y)=d(x)+cost(x, y)-d(y)\ge 0$（由最短路性质得到），并且每个节点的势能的值域不会超过 $[\min(0, (n-1)\min\{cost(u, v)\}), 0]$。 虽然是以原费用为长度，计算最短路时还是可以利用 reduced cost 来计算。由于只有从 $k$ 连出的边可能 reduced cost 为负，而 $k$ 又是第一个松弛的，所以这不会影响 Dijkstra 算法的正确性（当然，也可以为 $k$ 设置一个足够大的势能来保证从 $k$ 连出的边 reduced cost 也非负）。 流程总结若求的是最小费用最大流，首先通过加一条 $t$ 到 $s$ 的边转化为无源汇最小费用流。 使用 capacity scaling，枚举考虑容量的最高 $k$ 位，每次迭代开始时将残量网络中每条边的容量以及答案乘二，然后枚举每条二进制中该位为 $1$ 的边，使其容量加一。 给一条边容量加一时，先特判掉这条边本来就在残量网络中的情况（优化常数），然后判是否产生了负环，若产生了负环就增广这个负环，然后调整节点势能使得所有 reduced cost 非负，最后通过计算新增节点到每个节点的最短路来更新节点势能防止溢出。 复杂度瓶颈在求无负权边单源最短路上，总共需要计算 $O(m\log U)$ 次（$U$ 为边的最大容量）最短路，如果使用 priority_queue 来实现 Dijkstra 算法，总复杂度为 $O(m^2\log U\log m)$。 代码模板题。 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144#include &lt;iostream&gt;#include &lt;queue&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;typedef long long ll;typedef pair&lt;ll, int&gt; pli;const ll INF = 1e18;const ll LARGE = 1e12;int n, m;vector&lt;bool&gt; vis;vector&lt;int&gt; head, nxt, from, to, pre;vector&lt;ll&gt; raw_cap, cap, cost, p, dis;priority_queue&lt;pli, vector&lt;pli&gt;, greater&lt;pli&gt; &gt; q;void add(int u, int v, ll f, ll w)&#123; nxt.push_back(head[u]); head[u] = to.size(); from.push_back(u); to.push_back(v); raw_cap.push_back(f); cap.push_back(0); cost.push_back(w);&#125;void add_edge(int u, int v, ll f, ll w)&#123; add(u, v, f, w); add(v, u, 0, -w);&#125;ll c(int id)&#123; return p[from[id]] + cost[id] - p[to[id]];&#125;void dijkstra(int s)&#123; vis.assign(n + 2, false); dis.assign(n + 2, INF); pre.assign(n + 2, -1); dis[s] = 0; q.push(pli(0, s)); while (!q.empty()) &#123; int u = q.top().second; ll w = q.top().first; q.pop(); if (vis[u]) continue; vis[u] = true; for (int i = head[u]; ~i; i = nxt[i]) &#123; int v = to[i]; if (cap[i] &amp;&amp; dis[v] &gt; w + c(i)) &#123; dis[v] = w + c(i); pre[v] = i; q.push(pli(dis[v], v)); &#125; &#125; &#125;&#125;void add_one_cap(int id)&#123; int u = from[id]; int v = to[id]; if (cap[id]) &#123; ++cap[id]; return; &#125; dijkstra(v); if (dis[u] &lt; INF &amp;&amp; dis[u] + c(id) &lt; 0) &#123; ++cap[id ^ 1]; while (u != v) &#123; int x = pre[u]; --cap[x]; ++cap[x ^ 1]; u = from[x]; &#125; &#125; else ++cap[id]; ll max_dis = 0; ll cur_len = c(id); for (int i = 1; i &lt;= n; ++i) if (dis[i] &lt; INF) max_dis = max(max_dis, dis[i]); for (int i = 1; i &lt;= n; ++i) p[i] += dis[i] &lt; INF ? dis[i] : max_dis + max(0ll, -cur_len); dijkstra(n + 1); for (int i = 1; i &lt;= n; ++i) p[i] += dis[i];&#125;int main()&#123; int s, t; cin &gt;&gt; n &gt;&gt; m &gt;&gt; s &gt;&gt; t; head.resize(n + 2, -1); p.resize(n + 2, 0); for (int i = 1; i &lt;= m; ++i) &#123; ll u, v, f, w; cin &gt;&gt; u &gt;&gt; v &gt;&gt; f &gt;&gt; w; add_edge(u, v, f, w); &#125; add_edge(t, s, LARGE, -LARGE); for (int i = 1; i &lt;= n; ++i) &#123; add_edge(n + 1, i, 0, 0); cap[to.size() - 2] = 1; &#125; for (int i = 40; i &gt;= 0; --i) &#123; for (int j = 0; j &lt;= m * 2 + 1; ++j) cap[j] &lt;&lt;= 1; for (int j = 0; j &lt;= m * 2; j += 2) &#123; if ((raw_cap[j] &gt;&gt; i) &amp; 1) &#123; add_one_cap(j); &#125; &#125; &#125; ll min_cost = 0; for (int i = 0; i &lt; m; ++i) min_cost += cap[i &lt;&lt; 1 | 1] * cost[i &lt;&lt; 1]; cout &lt;&lt; cap[m &lt;&lt; 1 | 1] &lt;&lt; ' ' &lt;&lt; min_cost; return 0;&#125; 关于 SPFA如果把算法中的 Dijkstra 换成 SPFA，reduced cost 就不需要了，调整势能和防止溢出两部分都可以去掉，加上 SPFA 本身就略微比 Dijkstra 好写，总体会好写不少，复杂度是 $O(nm^2\log U)$，但很难卡满，而且由于不用防止溢出，少跑很多遍最短路，总体跑的非常快。 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135#include &lt;iostream&gt;#include &lt;queue&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;typedef long long ll;typedef pair&lt;ll, int&gt; pli;const ll INF = 1e18;const ll LARGE = 1e12;int n, m;queue&lt;int&gt; q;vector&lt;bool&gt; inq;vector&lt;ll&gt; raw_cap, cap, cost, dis;vector&lt;int&gt; head, nxt, from, to, pre;void add(int u, int v, ll f, ll w)&#123; nxt.push_back(head[u]); head[u] = to.size(); from.push_back(u); to.push_back(v); raw_cap.push_back(f); cap.push_back(0); cost.push_back(w);&#125;void add_edge(int u, int v, ll f, ll w)&#123; add(u, v, f, w); add(v, u, 0, -w);&#125;void spfa(int s)&#123; inq.assign(n + 2, false); dis.assign(n + 2, INF); pre.assign(n + 2, -1); dis[s] = 0; q.push(s); while (!q.empty()) &#123; int u = q.front(); inq[u] = false; q.pop(); for (int i = head[u]; ~i; i = nxt[i]) &#123; int v = to[i]; ll w = cost[i]; if (cap[i] &amp;&amp; dis[v] &gt; dis[u] + w) &#123; dis[v] = dis[u] + w; pre[v] = i; if (!inq[v]) &#123; inq[v] = true; q.push(v); &#125; &#125; &#125; &#125;&#125;void add_one_cap(int id)&#123; int u = from[id]; int v = to[id]; if (cap[id]) &#123; ++cap[id]; return; &#125; spfa(v); if (dis[u] &lt; INF &amp;&amp; dis[u] + cost[id] &lt; 0) &#123; ++cap[id ^ 1]; while (u != v) &#123; int x = pre[u]; --cap[x]; ++cap[x ^ 1]; u = from[x]; &#125; &#125; else ++cap[id];&#125;int main()&#123; int s, t; cin &gt;&gt; n &gt;&gt; m &gt;&gt; s &gt;&gt; t; head.resize(n + 2, -1); for (int i = 1; i &lt;= m; ++i) &#123; ll u, v, f, w; cin &gt;&gt; u &gt;&gt; v &gt;&gt; f &gt;&gt; w; add_edge(u, v, f, w); &#125; add_edge(t, s, LARGE, -LARGE); for (int i = 1; i &lt;= n; ++i) &#123; add_edge(n + 1, i, 0, 0); cap[to.size() - 2] = 1; &#125; for (int i = 40; i &gt;= 0; --i) &#123; for (int j = 0; j &lt;= m * 2 + 1; ++j) cap[j] &lt;&lt;= 1; for (int j = 0; j &lt;= m * 2; j += 2) &#123; if ((raw_cap[j] &gt;&gt; i) &amp; 1) &#123; add_one_cap(j); &#125; &#125; &#125; ll min_cost = 0; for (int i = 0; i &lt; m; ++i) min_cost += cap[i &lt;&lt; 1 | 1] * cost[i &lt;&lt; 1]; cout &lt;&lt; cap[m &lt;&lt; 1 | 1] &lt;&lt; ' ' &lt;&lt; min_cost; return 0;&#125; 关于出题尽管多数人使用的费用流算法是伪多项式复杂度的，我并不建议在题目中卡掉它。 但需要注意的是，“不卡掉”是指设置合适的数据范围，使得常见费用流算法可以确保通过。如果设置了不合理的数据范围而测试数据中没有卡掉常见费用流算法，那么不仅 卡了 常见费用流算法，数据也造的不合格。 参考资料 Min_25 最小費用最大流の悪例題 Stanford CS 361B: Advanced Algorithms, Spring 2014 Lecture Notes A Faster Strongly Polynomial Minimum Cost Flow Algorithm Theoretical Improvements in Algorithmic Efficiency for Network Flow Problems Github repo Laakeri/tiralabra]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>网络流</tag>
        <tag>费用流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CF3D Least Cost Bracket Sequence（贪心）]]></title>
    <url>%2FCF3D-Least-Cost-Bracket-Sequence%EF%BC%88%E8%B4%AA%E5%BF%83%EF%BC%89%2F</url>
    <content type="text"><![CDATA[题目链接CF 题意简述有一个长为 $n$ 的括号序列，其中一些位置是问号，每个问号替换成左括号或替换成右括号各有给定的代价，判断是否能够构造出一个合法的括号序列，如果可以，求出最小代价。 $n\le 5\cdot 10^4$（实际上可以大很多）。 简要做法考虑使用带反悔的贪心。 如果用 $cnt[i]$ 表示 $\sum_{j=1}^i(-1)^{[a_i=’)’]}$（左括号比右括号多的个数），括号序列合法当且仅当 $\forall i,cnt[i]\ge 0$ 且 $cnt[n]=0$。 如果把右括号反悔成左括号，一定可以保证 $cnt[i]\ge 0$ 这个条件依然满足。 但是，如果把左括号反悔成右括号，有可能造成本来 $cnt[i]\ge 0$ 的位置小于 $0$。 并且，如果选择了多余的左括号，还会导致 $cnt[n]&gt;0$。 如何解决这些问题呢？ 可以发现，如果初始时优先选择右括号，上述问题就都得到解决了。 即，每次碰到问号都选右括号，并且将其标记为可以反悔为左括号。如果 $cnt[i]&lt;0$，就从可反悔的右括号里选反悔代价最小的改成左括号。这样的话，$cnt[i]\ge 0$ 不会因反悔而被破坏，$cnt[n]&gt;0$ 也不会在有解时发生。 具体实现可以用堆（priority_queue）。 参考代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;queue&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt; using namespace std; typedef pair&lt;int, int&gt; pii; const int N = 50010; int n;char s[N];long long ans;priority_queue&lt;pii, vector&lt;pii&gt;, greater&lt;pii&gt; &gt; q; int main()&#123; scanf("%s", s + 1); n = strlen(s + 1); int cnt = 0; for (int i = 1; i &lt;= n; ++i) &#123; if (s[i] == '(') ++cnt; else if (s[i] == ')') --cnt; else &#123; int a, b; scanf("%d%d", &amp;a, &amp;b); --cnt; s[i] = ')'; ans += b; q.push(pii(a - b, i)); &#125; if (cnt &lt; 0) &#123; if (q.empty()) break; cnt += 2; ans += q.top().first; s[q.top().second] = '('; q.pop(); &#125; &#125; if (cnt == 0) printf("%I64d\n%s", ans, s + 1); else puts("-1"); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CF512C Fox And Dinner（二分图，最大流）]]></title>
    <url>%2FCF512C-Fox-And-Dinner%EF%BC%88%E4%BA%8C%E5%88%86%E5%9B%BE%EF%BC%8C%E6%9C%80%E5%A4%A7%E6%B5%81%EF%BC%89%2F</url>
    <content type="text"><![CDATA[题目链接CF 题意简述给你 $n$ 个整数，需要将它们分成任意个至少包含 $3$ 个数的环，使得每相邻两个数加起来是一个质数。 判断是否有解，若有解输出任意一组解。 $3\le n\le 200$, 数的范围是 $[2,10^4]$。 简要做法首先，由于每个数都大于等于 $2$，加起来是质数的必要条件是一奇一偶。 所以，如果把数看成点，相加得到质数看成边，就得到了一张二分图。 而题目的要求可以看作是每个点都匹配两个点。因为所有点度数都为 $2$ 的简单无向图一定是一个至少包含 $3$ 个点的环。 所以可以这样建图：源点到奇数，容量为 $2$；奇数到与其之和为质数的偶数，容量为 $1$；偶数到汇点，容量为 $2$。 如果最大流为 $n$ 就有解。输出方案就和普通的网络流输出方案差不多（可以参考代码）。 参考代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;queue&gt;#include &lt;vector&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const int N = 210;const int W = 20010;int n, a[N], p[W], tot;bool np[W];struct Flow&#123; const int s = N - 2; const int t = N - 1; int head[N], nxt[N * N], to[N * N], edge[N * N], cnt; queue&lt;int&gt; q; bool vis[N]; int dep[N]; void add(int u, int v, int w) &#123; nxt[++cnt] = head[u]; head[u] = cnt; to[cnt] = v; edge[cnt] = w; &#125; void Add(int u, int v, int w) &#123; add(u, v, w); add(v, u, 0); &#125; bool bfs() &#123; memset(dep, -1, sizeof(dep)); dep[s] = 0; q.push(s); while (!q.empty()) &#123; int u = q.front(); q.pop(); for (int i = head[u]; i; i = nxt[i]) &#123; int v = to[i]; int w = edge[i]; if (w &gt; 0 &amp;&amp; dep[v] == -1) &#123; dep[v] = dep[u] + 1; q.push(v); &#125; &#125; &#125; return ~dep[t]; &#125; int dfs(int u, int flow) &#123; if (dep[u] == dep[t]) return u == t ? flow : 0; int out = 0; for (int i = head[u]; i &amp;&amp; flow - out; i = nxt[i]) &#123; int v = to[i]; int w = edge[i]; if (dep[v] == dep[u] + 1) &#123; int f = dfs(v, min(flow - out, w)); edge[i] -= f; edge[i ^ 1] += f; out += f; &#125; &#125; return out; &#125; int maxFlow() &#123; int out = 0; while (bfs()) out += dfs(s, N); return out; &#125; void init() &#123; cnt = 1; for (int i = 1; i &lt;= n; ++i) &#123; if (a[i] &amp; 1) Add(s, i, 2); else Add(i, t, 2); &#125; for (int i = 1; i &lt;= n; ++i) &#123; if (!(a[i] &amp; 1)) continue; for (int j = 1; j &lt;= n; ++j) &#123; if (np[a[i] + a[j]]) continue; Add(i, j, 1); &#125; &#125; &#125; vector&lt;int&gt; cycle(int u) &#123; vector&lt;int&gt; out(1, u); vis[u] = true; while (1) &#123; bool flag = false; for (int i = head[u]; i; i = nxt[i]) &#123; int v = to[i]; int w = edge[i]; if (((a[u] &amp; 1) ^ (w &gt; 0)) &amp;&amp; v &lt;= n &amp;&amp; !vis[v]) &#123; vis[v] = flag = true; out.push_back(v); u = v; break; &#125; &#125; if (!flag) break; &#125; return out; &#125; void output() &#123; vector&lt;vector&lt;int&gt; &gt; ans; for (int i = 1; i &lt;= n; ++i) if (!vis[i]) ans.push_back(cycle(i)); printf("%d\n", ans.size()); for (int i = 0; i &lt; ans.size(); ++i) &#123; printf("%d", ans[i].size()); for (int j = 0; j &lt; ans[i].size(); ++j) printf(" %d", ans[i][j]); puts(""); &#125; &#125;&#125; flow;int main()&#123; for (int i = 2; i &lt; W; ++i) &#123; if (!np[i]) p[++tot] = i; for (int j = 1; j &lt;= tot &amp;&amp; i * p[j] &lt; W; ++j) &#123; np[i * p[j]] = true; if (i % p[j] == 0) break; &#125; &#125; scanf("%d", &amp;n); for (int i = 1; i &lt;= n; ++i) scanf("%d", a + i); flow.init(); if (flow.maxFlow() != n) &#123; puts("Impossible"); return 0; &#125; flow.output(); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>二分图</tag>
        <tag>网络流</tag>
        <tag>最大流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CF508D Tanya and Password（欧拉路径）]]></title>
    <url>%2FCF508D-Tanya-and-Password%EF%BC%88%E6%AC%A7%E6%8B%89%E8%B7%AF%E5%BE%84%EF%BC%89%2F</url>
    <content type="text"><![CDATA[题目链接CF 题意简述有一个字符串 $S[1..n+2]$，告诉你 $\forall 1\le i\le n, S[i..i+2]$（所有长为 $3$ 的子串），求任意一个满足条件的 $S$。 $1\le n\le 2\cdot 10^5$，字符集为大小写字母 + 数字。 简要做法容易想到需要建图。 但是，如果把每个长为 $3$ 的子串看成点，前后缀匹配看成边，就做不下去了。 正确做法是把每个长为 $2$ 的子串看成点，长为 $3$ 的子串看成边。这样原问题就转化成了求有向图的欧拉路径。（不会这个的话建议自行搜索一下。） 如果每次 dfs 同一个点时都遍历所有出边，度数比较大就会挂。使用 vector 存边的话可以 pop_back() 或者记录一下已经遍历到了哪一条边，使用前向星的话可以像当前弧优化那样修改 head。 参考代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cctype&gt;#include &lt;cstdlib&gt;using namespace std;const int N = 200010;const int W = 62 * 62;int head[N], nxt[N], to[N], cnt;int n, ind[N], outd[N], tot;char s[N], ans[N];int charToInt(char x)&#123; if (isdigit(x)) return x - '0'; if (islower(x)) return x - 'a' + 10; return x - 'A' + 36;&#125;char intToChar(int x)&#123; if (x &lt; 10) return x + '0'; if (x &lt; 36) return x - 10 + 'a'; return x - 36 + 'A';&#125;int wordToInt(char x, char y)&#123; return charToInt(x) * 62 + charToInt(y);&#125;void add(int u, int v)&#123; nxt[++cnt] = head[u]; head[u] = cnt; to[cnt] = v;&#125;void fail()&#123; puts("NO"); exit(0);&#125;void dfs(int u)&#123; for (int&amp; i = head[u]; i; ) &#123; int v = to[i]; i = nxt[i]; dfs(v); &#125; ans[--tot] = intToChar(u % 62);&#125;int main()&#123; scanf("%d", &amp;n); for (int i = 1; i &lt;= n; ++i) &#123; scanf("%s", s); int u = wordToInt(s[0], s[1]); int v = wordToInt(s[1], s[2]); ++outd[u]; ++ind[v]; add(u, v); &#125; int oneMoreIn = 0, oneMoreOut = 0; for (int i = 0; i &lt; W; ++i) &#123; if (ind[i] == outd[i]) continue; if (ind[i] == outd[i] + 1) &#123; if (oneMoreIn) fail(); oneMoreIn = i; &#125; else if (ind[i] + 1 == outd[i]) &#123; if (oneMoreOut) fail(); oneMoreOut = i; &#125; else fail(); &#125; if (!oneMoreOut) &#123; for (int i = 0; i &lt; W; ++i) &#123; if (outd[i]) &#123; oneMoreOut = i; break; &#125; &#125; &#125; tot = n + 2; dfs(oneMoreOut); ans[--tot] = intToChar(oneMoreOut / 62); if (!tot) printf("YES\n%s", ans); else puts("NO"); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>建图</tag>
        <tag>欧拉路径</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[gym102268D Dates（贪心，二分图匹配，线段树）]]></title>
    <url>%2Fgym102268D-Dates%EF%BC%88%E8%B4%AA%E5%BF%83%EF%BC%8C%E4%BA%8C%E5%88%86%E5%9B%BE%E5%8C%B9%E9%85%8D%EF%BC%8C%E7%BA%BF%E6%AE%B5%E6%A0%91%EF%BC%89%2F</url>
    <content type="text"><![CDATA[题目链接CF 题意简述给你一张二分图：左边 $t$ 个位置，第 $i$ 个位置上有 $a_i$ 个点；右边 $n$ 个带权的点，第 $i$ 个点与位置在 $[l_i, r_i]$ 之间的所有左边的点有连边；匹配权值为匹配中右边点的权值之和；求最大权匹配。 $1\le n,t\le 3\cdot 10^5$，保证 $l_i\le l_{i+1}$, $r_i\le r_{i+1}$。 简要做法首先，将右边的点按权值从大到小排序，依次加入，看有没有完全匹配，有就选这个点。这样一定是最优的，好像可以用拟阵相关的理论证明，但我不太会.. 于是，问题转化成了如何判定是否存在完全匹配，而霍尔定理恰恰是用来做这件事的——考虑右边的点中被选择的那些，选择其一个子集，判断是否所有子集的邻域（即与其相邻的点构成的集合）大小都比子集本身大。 如果选择的子集中元素对应的区间的并集不是连续的，霍尔定理的条件成立等价于对于断点两边分别成立，所以只需要考虑子集对应的区间连续的情况。 又由于 $l_i\le l_{i+1}$, $r_i\le r_{i+1}$，只用考虑子集中的元素本身编号连续的情况。那么，霍尔定理的条件就可以表示为： $$\forall 1\le i&lt; j\le n,[i,j]\text{中被选择的右侧点个数}\le [l_i,r_j]\text{中左侧点数量}$$ 如果处理出 $a_{1..t}$ 的前缀和 $pre[i]=\sum_{j=1}^ia_j$，用 $p[i]$ 表示 $[1,i]$ 中被选择的右侧点个数，那么式子就变成了： $$\forall1\le i&lt; j\le n, p[j]-p[i-1]\le pre[r_j]-pre[l_i-1]$$ 也就是： $$\forall1\le i&lt; j\le n, pre[l_i-1]-p[i-1]\le pre[r_j]-p[j]$$ 所以，可以对每个元素 $i$ 维护 $pre[l_{i+1}-1]-p[i]$ 以及 $pre[r_j]-p[j]$。 $pre$ 是定值，考虑如何更新 $p$。事实上，往已选择的点中加入一个点，就是把一段后缀的 $p$ 加一。所以可以考虑用线段树维护。 并且，一段后缀加一（令这段后缀为 $[x..n]$）后，只有 $i&lt; x,j\ge x$ 的数对 $(i,j)$ 对应的大小关系发生改变，事实上只用判断 $i&lt;x$ 的 $pre[l_i-1]-p[i-1]$ 的最大值与 $j\ge x$ 的 $pre[r_j]-p[j]$ 的最小值的大小关系即可，同样可以使用线段树维护。 另一种判断方法，是在线段树上的每个节点处判断左儿子与右儿子有没有出现不满足霍尔定理条件的情况。 参考代码代码中使用了 segmenttree.h。 每次判断前缀与后缀的大小关系12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cctype&gt;#include &lt;algorithm&gt;#include "segmenttree.h"using namespace std;typedef long long ll;int read()&#123; int out = 0; char c; while (!isdigit(c = getchar())); for (; isdigit(c); c = getchar()) out = out * 10 + c - '0'; return out;&#125;const int N = 300010;const ll INF = 1e18;int n, m;ll pre[N], ans;struct Girl&#123; int l, r, p, id; bool operator&lt;(const Girl&amp; y) const &#123; return p &gt; y.p; &#125;&#125; g[N];struct Value&#123; ll mn, mx; Value(ll _mn = INF, ll _mx = -INF) &#123; mn = _mn; mx = _mx; &#125;&#125;;vector&lt;Value&gt; a;Value merge(Value x, Value y)&#123; return Value(min(x.mn, y.mn), max(x.mx, y.mx));&#125;void update(segmentTreeNode&lt;Value, int&gt;&amp; u, int x)&#123; u.val.mx += x; u.val.mn += x; u.tag += x;&#125;int main()&#123; n = read(); m = read(); for (int i = 1; i &lt;= m; ++i) pre[i] = pre[i - 1] + read(); a.resize(n + 1); for (int i = 1; i &lt;= n; ++i) &#123; g[i].l = read(); g[i].r = read(); g[i].p = read(); g[i].id = i; a[i].mn = pre[g[i].r]; a[i - 1].mx = pre[g[i].l - 1]; &#125; sort(g + 1, g + n + 1); segmentTree&lt;Value, int, merge, update&gt; t(0, n + 1, a, Value()); for (int i = 1; i &lt;= n; ++i) &#123; if (t.query(0, g[i].id).mx &gt;= t.query(g[i].id, n + 1).mn) continue; t.modify(g[i].id, n + 1, -1); ans += g[i].p; &#125; cout &lt;&lt; ans; return 0;&#125; 在线段树的每个节点处判断123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cctype&gt;#include &lt;algorithm&gt;#include "segmenttree.h"using namespace std;typedef long long ll;int read()&#123; int out = 0; char c; while (!isdigit(c = getchar())); for (; isdigit(c); c = getchar()) out = out * 10 + c - '0'; return out;&#125;const int N = 300010;const ll INF = 1e18;int n, m;ll pre[N], ans;struct Girl&#123; int l, r, p, id; bool operator&lt;(const Girl&amp; y) const &#123; return p &gt; y.p; &#125;&#125; g[N];struct Value&#123; ll mn, mx; bool inv; Value(ll _mn = INF, ll _mx = -INF, int _inv = false) &#123; mn = _mn; mx = _mx; inv = _inv; &#125;&#125;;vector&lt;Value&gt; a;Value merge(Value x, Value y)&#123; return Value(min(x.mn, y.mn), max(x.mx, y.mx), x.inv || y.inv || x.mx &gt; y.mn);&#125;void update(segmentTreeNode&lt;Value, int&gt;&amp; u, int x)&#123; u.val.mx += x; u.val.mn += x; u.tag += x;&#125;int main()&#123; n = read(); m = read(); for (int i = 1; i &lt;= m; ++i) pre[i] = pre[i - 1] + read(); a.resize(n + 1); for (int i = 1; i &lt;= n; ++i) &#123; g[i].l = read(); g[i].r = read(); g[i].p = read(); g[i].id = i; a[i].mn = pre[g[i].r]; a[i - 1].mx = pre[g[i].l - 1]; &#125; sort(g + 1, g + n + 1); segmentTree&lt;Value, int, merge, update&gt; t(0, n + 1, a, Value()); for (int i = 1; i &lt;= n; ++i) &#123; t.modify(g[i].id, n + 1, -1); if (t.query(0, n + 1).inv) t.modify(g[i].id, n + 1, 1); else ans += g[i].p; &#125; cout &lt;&lt; ans; return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>贪心</tag>
        <tag>数据结构</tag>
        <tag>线段树</tag>
        <tag>图论</tag>
        <tag>二分图</tag>
        <tag>二分图匹配</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CF878E Numbers on the blackboard（贪心，并查集）]]></title>
    <url>%2FCF878E-Numbers-on-the-blackboard%EF%BC%88%E8%B4%AA%E5%BF%83%EF%BC%8C%E5%B9%B6%E6%9F%A5%E9%9B%86%EF%BC%89%2F</url>
    <content type="text"><![CDATA[题目链接CF 题意简述对于一个数列，每次操作可以将相邻的两个数 $x$ 和 $y$ 合并成一个数 $x+2y$，定义一个数列的权值为进行操作直至只剩一个数能得到的最大值。 多组询问，每次给定一个区间，求这个区间的权值。 数列值域 $-10^9\sim10^9$，数列长度和询问个数不超过 $10^5$。 简要做法先不考虑多组询问。 经过（并不）简单的推理，可以发现，设数列 $a_{1..n}$ 的权值为 $\sum_{i=1}^na_i2^{k_i}$，那么 $k_1=0$, $1\le k_i\le k_{i-1}+1(i\ge 2)$。 那么，最优方案中，$k_{2..n}$ 一定是一块一块从 $1$ 开始严格递增的。 如果我们已经知道了一个数列 $k_i$ 的构成，这时要在其末端加入一个数，那么可以得到贪心策略： 若加入的数是正数，与前一块合并。若合并后整块构成的等比数列之和仍为正数，继续合并。 否则结束合并过程。 这个合并的过程可以用并查集维护。 问题在于，如何判断一块的正负。可以对每块维护它的大小（块中的第 $i$ 个数与 $2^i$ 的乘积之和），合并时更新。但这样做可能会溢出，但可以发现，一旦一块的大小达到 $10^9$，一定会一直合并到最前面，所以大于 $10^9$ 的都可以视作 $10^9$；一旦前一块的长度超过 $30$ 且当前块大小为正，也一定会一直合并到最前面，也可以视作 $10^9$。 接下来考虑如何回答询问。 把询问离线下来，右端点相同的询问一起处理。处理一个询问之前先计算出 $a_{1..r}$ 的块，若 $l=1$ 答案就是所有块大小的和，否则的话答案会是若干块的答案之和加上一个块的后缀。因为取一个块的后缀，断点所在块一定不会分开（一块的真后缀一定为正），后面的块也不会合并到前面去。处理出模意义下块答案的前缀和，以及 $presum_i=\sum_{j=1}^i2^{i-1}a_i$，就可以快速回答询问了。 还有一个小问题：只有第一块的系数是从 $2^0=1$ 开始的。由于计算时第一块一定是那个后缀，计算后缀答案时从 $1$ 开始，计算整块答案时从 $2$ 开始即可。 参考代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;typedef long long ll;typedef pair&lt;int, int&gt; pii;const int N = 100010;const int mod = 1e9 + 7;int n, m, a[N], presum[N], inv2[N], f[N], len[N], sum[N], preans[N], out[N];vector&lt;pii&gt; q[N];int find(int x)&#123; return x == f[x] ? x : f[x] = find(f[x]);&#125;int calc(int l, int r)&#123; return (ll) (presum[r] - presum[l - 1] + mod) * inv2[l - 1] % mod;&#125;int main()&#123; scanf("%d%d", &amp;n, &amp;m); inv2[0] = 1; for (int i = 1, two = 1; i &lt;= n; ++i, two = two * 2 % mod) &#123; scanf("%d", a + i); inv2[i] = (ll) inv2[i - 1] * (mod + 1) / 2 % mod; presum[i] = (presum[i - 1] + (ll) two * a[i] % mod + mod) % mod; &#125; for (int i = 1; i &lt;= m; ++i) &#123; int l, r; scanf("%d%d", &amp;l, &amp;r); q[r].push_back(pii(l, i)); &#125; for (int i = 1; i &lt;= n; ++i) &#123; f[i] = i; len[i] = 1; sum[i] = a[i]; while (find(i) &gt; 1 &amp;&amp; sum[find(i)] &gt; 0) &#123; int x = find(i); int y = find(x - 1); if (len[y] &gt;= 30 || (((ll) sum[x]) &lt;&lt; len[y]) + sum[y] &gt;= 1e9) sum[y] = 1e9; else sum[y] += sum[x] &lt;&lt; len[y]; len[y] += len[x]; f[x] = y; &#125; preans[find(i)] = (preans[find(find(i) - 1)] + 2ll * calc(find(i), i)) % mod; for (int j = 0; j &lt; q[i].size(); ++j) &#123; int l = q[i][j].first; int id = q[i][j].second; out[id] = (0ll + preans[find(i)] - preans[find(l)] + mod + calc(l, find(l) + len[find(l)] - 1)) % mod; &#125; &#125; for (int i = 1; i &lt;= m; ++i) printf("%d\n", out[i]); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>贪心</tag>
        <tag>并查集</tag>
        <tag>离线算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UOJ 自动备份]]></title>
    <url>%2FUOJ-%E8%87%AA%E5%8A%A8%E5%A4%87%E4%BB%BD%2F</url>
    <content type="text"><![CDATA[作为一个刚刚上线两周就回滚了无数次数据的 OJ，备份自然是很重要的~ 一些脚本commit.sh123456#!/bin/bashtime=$(date "+%Y%m%d%H%M%S")echo $&#123;time&#125;docker commit uoj uoj_backup_$&#123;time&#125;docker images --format "&#123;&#123;.ID&#125;&#125;: &#123;&#123;.CreatedSince&#125;&#125;" | grep 'day' | cut -d : -f 1 | xargs docker image rm commit，然后删掉比较久远（在 CREATED 中显示为 XX days ago）的镜像节约空间（不然在自动备份下过不了几天硬盘就爆了）。 save.sh1234567#!/bin/bashtime=$(date "+%Y%m%d%H%M%S")echo $&#123;time&#125;docker commit uoj uoj_backup_$&#123;time&#125;docker save -o /home/ouuan/uoj/uoj_backup_$&#123;time&#125;.tar uoj_backup_$&#123;time&#125;docker images --format "&#123;&#123;.ID&#125;&#125;: &#123;&#123;.CreatedSince&#125;&#125;" | grep 'day' | cut -d : -f 1 | xargs docker image rm 先 commit，然后存为 tar。即使系统挂了，也能从文件恢复。 new.sh1234567891011#!/bin/bashtime=$(date "+%Y%m%d%H%M%S")echo $&#123;time&#125;docker commit uoj uoj_backup_$&#123;time&#125;docker stop uojdocker rm uojdocker image lsecho "Please enter the version (after uoj_backup_): "read versiondocker run --name uoj -dit -p 23333:80 -p 3690:3690 --cap-add SYS_PTRACE "uoj_backup_$version" 便捷地从镜像创建新容器，在删除当前容器之前 commit。 计划任务输入命令 sudo crontab -e。 （可能会先让你选择一个文本编辑器）然后输入： 1230 * * * * bash path/commit.sh0 22 * * * bash path/save.sh path 就是放脚本文件的路径。 前面五项分别是 分钟 / 小时 / 日期 / 月份 / 星期，在符合条件时就会执行后面的命令。 上面的例子会在 xx:30 时 commit 一次，在每天晚上 10 点 save 一次。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hinata Online Judge 的搭建]]></title>
    <url>%2FHinata-Online-Judge-%E7%9A%84%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[程序员就是代码重用的艺术家（ 这周回到学校，基于 社区版 UOJ 搭了一个校内 OJ。 过程中现在还记得的遇到的问题，是重启后显示 “wrong database”，解决方案是 docker 里运行命令 service mysql restart。 一周里大部分时间都是在魔改，并且是 开源 的。 这几天算是稍微体验了一下程序员的生活。会为精妙的代码重用而惊叹，也会为一个 bug 而苦苦求索。commit 中的两行代码，可能是若干小时搜索的结果，经过了数十次错误的尝试。 以前我对程序员的印象是「苦力活」，现在稍微有点改变了。诗人给同一个事物起不同的名字，数学家给不同的事物起相同的名字，程序员给不同的需求使用同一个函数。 回想起来，不到一年前，也就是我开始使用 hexo 博客之前，我还对 web 开发一无所知。只不过现在所会的那些东西都是通过阅读源码 + 需要什么就搜什么学到的，导致有很多不清楚的地方，这也是导致效率低下的重要原因。 总之，欢迎大家自由选取 Hinata Online Judge 的 feature copy 到自己的 UOJ 里！ 然而代码太不规范了，所以暂时不太准备发 pr…也欢迎大家来帮我规范一下发 pr。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>OJ</tag>
        <tag>工程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BJOI2019 删数（贪心，线段树）]]></title>
    <url>%2FBJOI2019-%E5%88%A0%E6%95%B0%EF%BC%88%E8%B4%AA%E5%BF%83%EF%BC%8C%E7%BA%BF%E6%AE%B5%E6%A0%91%EF%BC%89%2F</url>
    <content type="text"><![CDATA[题目链接洛谷 LOJ BZOJ 题意简述一个数列是“可删除的”，当且仅当可以通过这种操作将其清空：将数列中等于这个数列长度的数删去。 如，$[1, 2, 4, 4]$ 是“可删除的”，第一次操作删成 $[1, 2]$，第二次操作删成 $[1]$，第三次操作清空。 定义一个数列的权值为至少需要进行的单点修改数目，使得这个数列变成“可删除的”。 现在给你一个数列 $a_{1..n}$，以及 $m$ 次修改操作，你需要在每次修改后回答这个数列的权值。 修改操作有三种： 单点修改。 全局加一。 全局减一。 $1\le n,m\le 150000$，数列初始值以及单点修改成的值在 $[1,n]$ 内，但全局修改可能使数列中的元素超过这个范围。 简要做法计算数列的权值如果将数 $i$ 出现的次数 $cnt[i]$ 看做一个高度为 $cnt[i]$、放在位置 $i$ 的柱子，让所有柱子向左倒，每个位置就会被若干个柱子覆盖。也就是说，$i$ 这个柱子覆盖了 $[i-cnt[i]+1,i]$。 一个数列是“可删除的”当且仅当 $[1,n]$ 都被恰好覆盖了一次。 并且，一个数列的权值就是它没被覆盖的位置数量，证明如下： 这是答案的下界，因为每次单点修改最多覆盖一个新位置。 这是答案的上界，因为你可以把重复覆盖的换到未覆盖处。 全局修改全局修改会导致 $cnt$ 以及覆盖数量发生位移，所以可以考虑使用一个标记 $delta$ 来表示现在全局加了多少，那么 $cnt[i]$ 表示 $cnt[i+delta]$，位置 $i$ 被覆盖的次数被记录在 $i-delta$ 处，$a[i]$ 表示 $a_i-delta$。 需要特别注意的是，全局加时需要减去原来位置 $n$ 的贡献，因为它们来到 $n+1$ 后必定会是累赘，全局减时要再加回来。但不需要特殊处理位置 $1$ 的贡献，因为覆盖是向左的，查询时只会查询 $[1,n]$ 的覆盖次数，小于 $1$ 的位置对答案没有影响。 可以用线段树维护覆盖次数。 实现细节使用一个线段树来维护覆盖次数，它支持区间加减、区间查询最小值及其出现次数。 下面是实现的细节。（代码中所有 $cnt$ 的下标都要加上 $m$ 避免负数下标。） 单点修改首先处理原来的 $a_p$。 先判断 $a_p$ 是否小于等于 $n$，只有 $a_p\le n$ 时才会有贡献，也就是说，当 $a[p]+delta\le n$ 时需要在线段树上 $a[p]-cnt[a[p]]+1$ 处单点减一。 然后将 $cnt[a[p]]$ 减一。 接着处理新增的 $x$。 $x$ 必定在 $[1,n]$ 内，所以一定需要在线段树上 $x-cnt[x-delta]-delta$ 处单点加一。 然后将 $cnt[x-delta]$ 加一。 最后将 $a[p]$ 修改为 $x-delta$。 全局加需要减去位置 $n$ 的贡献：$[n-cnt[n-delta]+1-delta,n-delta]$ 区间减一。 然后将 $delta$ 加一。 全局减先将 $delta$ 减一。 然后加上位置 $n$ 的贡献：$[n-cnt[n-delta]+1-delta,n-delta]$ 区间加一。 查询答案查询 $[1-delta,n-delta]$ 的最小值及出现次数。 若最小值不为 $0$ 则答案为 $0$。 否则答案为最小值的出现次数。 参考代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138#include &lt;iostream&gt;#include &lt;cstdio&gt;using namespace std;const int N = 150010; struct Min&#123; int val, cnt; Min(int _val = 0, int _cnt = 0): val(_val), cnt(_cnt) &#123;&#125;&#125;;Min merge(Min a, Min b)&#123; if (a.val &lt; b.val) return a; if (b.val &lt; a.val) return b; return Min(a.val, a.cnt + b.cnt);&#125;struct SegmentTree&#123;#define ls (cur &lt;&lt; 1)#define rs (cur &lt;&lt; 1 | 1)#define mid ((l + r) &gt;&gt; 1) Min mn[N &lt;&lt; 4]; int tag[N &lt;&lt; 4]; void pushup(int cur) &#123; mn[cur] = merge(mn[ls], mn[rs]); &#125; void add(int cur, int x) &#123; mn[cur].val += x; tag[cur] += x; &#125; void pushdown(int cur) &#123; add(ls, tag[cur]); add(rs, tag[cur]); tag[cur] = 0; &#125; void build(int cur, int l, int r) &#123; if (l == r - 1) mn[cur] = Min(0, 1); else &#123; build(ls, l, mid); build(rs, mid, r); pushup(cur); &#125; &#125; void add(int cur, int l, int r, int L, int R, int x) &#123; if (l &gt;= R || r &lt;= L) return; if (L &lt;= l &amp;&amp; r &lt;= R) add(cur, x); else &#123; pushdown(cur); add(ls, l, mid, L, R, x); add(rs, mid, r, L, R, x); pushup(cur); &#125; &#125; Min min(int cur, int l, int r, int L, int R) &#123; if (l &gt;= R || r &lt;= L) return Min(N, -1); if (L &lt;= l &amp;&amp; r &lt;= R) return mn[cur]; pushdown(cur); return merge(min(ls, l, mid, L, R), min(rs, mid, r, L, R)); &#125; #undef ls#undef rs#undef mid&#125; t;int n, m, delta, a[N], cnt[N * 3];int main()&#123; scanf("%d%d", &amp;n, &amp;m); for (int i = 1; i &lt;= n; ++i) &#123; scanf("%d", a + i); ++cnt[a[i] + m]; &#125; const int ll = 1 - m - n, rr = m + n + 2; t.build(1, ll, rr); for (int i = 1; i &lt;= n; ++i) t.add(1, ll, rr, i - cnt[i + m] + 1, i + 1, 1); for (int i = 1; i &lt;= m; ++i) &#123; int p, x; scanf("%d%d", &amp;p, &amp;x); if (p == 0) &#123; if (x == -1) &#123; --delta; t.add(1, ll, rr, n + 1 - cnt[n - delta + m] - delta, n - delta + 1, 1); &#125; else &#123; t.add(1, ll, rr, n + 1 - cnt[n - delta + m] - delta, n - delta + 1, -1); ++delta; &#125; &#125; else &#123; if (a[p] + delta &lt;= n) t.add(1, ll, rr, a[p] - cnt[a[p] + m] + 1, a[p] - cnt[a[p] + m] + 2, -1); --cnt[a[p] + m]; t.add(1, ll, rr, x - cnt[x - delta + m] - delta, x - cnt[x - delta + m] - delta + 1, 1); ++cnt[x - delta + m]; a[p] = x - delta; &#125; Min res = t.min(1, ll, rr, 1 - delta, n - delta + 1); if (res.val &gt; 0) puts("0"); else printf("%d\n", res.cnt); &#125; return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>贪心</tag>
        <tag>数据结构</tag>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CF1209F Koala and Notebook（BFS，最短路）]]></title>
    <url>%2FCF1209F-Koala-and-Notebook%EF%BC%88BFS%EF%BC%8C%E6%9C%80%E7%9F%AD%E8%B7%AF%EF%BC%89%2F</url>
    <content type="text"><![CDATA[题目链接CF 题意简述给你一张 $n$ 个点 $m$ 条边的无向连通图，一条路径的权值是路径上的边的编号（十进制）顺次连接而成的数字。求 $1$ 到每个点的最短路，输出 对 $10^9+7$ 取模。 $2\le n\le10^5$, $n-1\le m\le10^5$。 简要做法数字越长就越大，所以转化成优先长度短，其次字典序小。 把每条边拆成位数条边（如 $(u, v, 718)$ 拆成 $(u, x, 7)$, $(x, y, 1)$, $(y, v, 8)$, $(v, x, 7)$, $(y, u, 8)$），这样的话长度的边权就全是一，可以用 BFS 解决。 如何使字典序最小呢？容易想到优先遍历边权（拆边后全是一位数）小的边，但是，如果两个点的最短路相同，这样做就会导致错误。（如：$dis[u]=dis[v]=233$，$u$ 在队列里在 $v$ 的前面，$(u, x, 3)$ 和 $(v, x, 2)$ 这两条边都存在，$dis[x]$ 就会被错误地设为 $2333$，而它应当是 $2332$。） 正确的做法是将最短路相同的点绑在一起放入队列，实现可以使用 vector。 参考代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;cstring&gt;using namespace std;const int N = 100010;const int mod = 1e9 + 7;int n, m, tot, dis[N * 5], digit[10];vector&lt;int&gt; g[N * 5][10];queue&lt;vector&lt;int&gt; &gt; q;int main()&#123; scanf("%d%d", &amp;n, &amp;m); tot = n; for (int ww = 1; ww &lt;= m; ++ww) &#123; int u, v, w = ww; scanf("%d%d", &amp;u, &amp;v); if (w &lt; 10) &#123; g[u][w].push_back(v); g[v][w].push_back(u); &#125; else // 拆边 &#123; int l = ++tot; int r = l; int d = 0; while (w) &#123; digit[++d] = w % 10; w /= 10; &#125; for (int i = d - 1; i &gt; 1; --i) &#123; g[tot][digit[i]].push_back(tot + 1); r = ++tot; &#125; g[u][digit[d]].push_back(l); g[r][digit[1]].push_back(u); g[v][digit[d]].push_back(l); g[r][digit[1]].push_back(v); &#125; &#125; memset(dis, -1, sizeof(dis)); q.push(vector&lt;int&gt;(1, 1)); dis[1] = 0; while (!q.empty()) &#123; vector&lt;int&gt; vec = q.front(); q.pop(); for (int i = 0; i &lt;= 9; ++i) &#123; vector&lt;int&gt; nxt; // nxt 里存的是最短路相同的点 for (auto u : vec) &#123; for (auto v : g[u][i]) &#123; if (dis[v] == -1) &#123; dis[v] = (dis[u] * 10ll + i) % mod; nxt.push_back(v); &#125; &#125; &#125; if (!nxt.empty()) q.push(nxt); &#125; &#125; for (int i = 2; i &lt;= n; ++i) printf("%d\n", dis[i]); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>最短路</tag>
        <tag>BFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CF516D Drazil and Morning Exercise（up and down，并查集）]]></title>
    <url>%2FCF516D-Drazil-and-Morning-Exercise%EF%BC%88up-and-down%EF%BC%8C%E5%B9%B6%E6%9F%A5%E9%9B%86%EF%BC%89%2F</url>
    <content type="text"><![CDATA[题目链接CF 洛谷 题意简述给定一棵 $n$ 个点带边权的树，定义 $d(u)$ 为树上离它最远的点到它的距离，$q$ 次询问，每次询问给定 $l$，求一个最大的树上连通块 $V’$ 的大小，满足 $\forall u, v\in V’$，$|d(u)-d(v)|\le l$。 $1\le n\le 10^5$, $1\le q\le 50$。 简要做法首先使用 up and down（两遍 dfs，第一遍求往下走的最远距离，第二遍求往上走的最远距离）求出 $d(u)$。 有一个性质：如果以 $d(u)$ 最小的 $u$ 为根，$\forall v, d(v)\ge d(parent(v))$。（下文中的“子树”都是以 $d$ 最小的点为根的。） 简单证明 不难发现，我们只要证明 $u$ 的每个儿子 $v$ 都是子树 $v$ 中 $d$ 最小的，即可归纳地证明原命题。 假设子树 $v$ 中存在一个点 $w$，$d(w)&lt;d(v)$，那么从 $v$ 出发的最长路的第一步一定是 $v$ 到 $w$ 的路径上的第一条边（否则的话，从 $w$ 出发可以走到 $v$ 再走从 $v$ 出发的最长路，就会导致 $d(w)&gt;d(v)$），这样的话，从 $u$ 出发也可以先走到 $v$ 再走 $v$ 出发的最长路，这样的话 $d(u)&gt;d(v)$，与题设矛盾。 题目所求的连通块一定是 $d$ 的大小连续的一段，令所求连通块中 $d$ 最小且离根最近的点为 $u$，由上面的性质不难发现，所求连通块一定在子树 $u$ 中。 如果按 $d$ 从大到小枚举每个点，用并查集维护符合条件的点的连通性以及每块的大小，可以发现，删去一个点（一个 $d&gt;d(u)+l$ 的点）并不影响连通性，只需要将其所在块的大小减一即可。（加入一个点就是合并子树，删去一个点是删去叶子。） 这样的话答案就是过程中最大的一块的大小。 总时间复杂度就是 $O(qn\alpha(n)+n\log n)$ 或 O(qn+nlogn) 或 $O(qn\log n)$。 参考代码（非常抱歉，使用了 CF 模板 qaq） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193#ifndef OUUAN#pragma GCC optimize("Ofast,no-stack-protector,unroll-loops,fast-math")#endif#include&lt;bits/stdc++.h&gt;#define int LoveLive//#define FAST_IOSTREAM 1#define For(i,l,r)for(int i=(l),i##end=(r);i&lt;=i##end;++i)#define FOR(i,r,l)for(int i=(r),i##end=(l);i&gt;=i##end;--i)#define SON(i,u)for(int i=head[u];i;i=nxt[i])#define ms(a,x)memset(a,x,sizeof(a))#define fi first#define se second#define pb emplace_back#define pq priority_queue#define isinf(x)(x&gt;=INF?-1:x)#define y1 why_is_there_a_function_called_y1#define DEBUG(x)cerr&lt;&lt;(#x)&lt;&lt;":"&lt;&lt;x&lt;&lt;endlusing namespace std;typedef long long LoveLive;typedef pair&lt;int,int&gt;pii;typedef vector&lt;int&gt;vi;#ifdef intconst int INF=0x3f3f3f3f3f3f3f3fll;#elseconst int INF=0x3f3f3f3f;#endifconst double eps=1e-9;mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());int randint(int l,int r)&#123;int out=rng()%(r-l+1)+l;return out&gt;=l?out:out+r-l+1;&#125;#ifdef FAST_IOSTREAM#define br cout&lt;&lt;'\n'#define sp cout&lt;&lt;' 'long long read()&#123;long long x;cin&gt;&gt;x;return x;&#125;template&lt;typename T&gt;void read(T&amp;x)&#123;cin&gt;&gt;x;&#125;template&lt;typename T&gt;void write(const T&amp;x)&#123;cout&lt;&lt;x;&#125;#else#define br putchar('\n')#define sp putchar(' ')template&lt;typename T&gt;typename enable_if&lt;!is_integral&lt;T&gt;::value,void&gt;::type read(T&amp;x)&#123;cin&gt;&gt;x;&#125;long long read()&#123;char c;long long out=0,f=1;for(c=getchar();!isdigit(c)&amp;&amp;c!='-';c=getchar());if(c=='-')&#123;f=-1;c=getchar();&#125;for(;isdigit(c);c=getchar())out=(out&lt;&lt;3)+(out&lt;&lt;1)+c-'0';return out*f;&#125;template&lt;typename T&gt;typename enable_if&lt;is_integral&lt;T&gt;::value,T&gt;::type read(T&amp;x)&#123;char c;T f=1;x=0;for(c=getchar();!isdigit(c)&amp;&amp;c!='-';c=getchar());if(c=='-')&#123;f=-1;c=getchar();&#125;for(;isdigit(c);c=getchar())x=(x&lt;&lt;3)+(x&lt;&lt;1)+c-'0';return x*=f;&#125;char read(char&amp;x)&#123;for(x=getchar();isspace(x);x=getchar());return x;&#125;double read(double&amp;x)&#123;scanf("%lf",&amp;x);return x;&#125;template&lt;typename T&gt;typename enable_if&lt;!is_integral&lt;T&gt;::value,void&gt;::type write(const T&amp;x)&#123;cout&lt;&lt;x;&#125;template&lt;typename T&gt;typename enable_if&lt;is_integral&lt;T&gt;::value,void&gt;::typewrite(const T&amp;x)&#123;if(x&lt;0)&#123;putchar('-');write(-x);return;&#125;if(x&gt;9)write(x/10);putchar(x%10+'0');&#125;void write(const char&amp;x)&#123;putchar(x);&#125;void write(const double&amp;x)&#123;printf("%.10lf",x);&#125;#endiftemplate&lt;typename T,typename...Args&gt;void read(T&amp;x,Args&amp;...args)&#123;read(x);read(args...);&#125;template&lt;typename OutputIt,typename=typename enable_if&lt;is_same&lt;output_iterator_tag,typename iterator_traits&lt;OutputIt&gt;::iterator_category&gt;::value||(is_base_of&lt;forward_iterator_tag,typename iterator_traits&lt;OutputIt&gt;::iterator_category&gt;::value&amp;&amp;!is_const&lt;OutputIt&gt;::value)&gt;::type&gt;void read(OutputIt __first,OutputIt __last)&#123;for(;__first!=__last;++__first)read(*__first);&#125;template&lt;typename InputIt,typename=typename enable_if&lt;is_base_of&lt;input_iterator_tag,typename iterator_traits&lt;InputIt&gt;::iterator_category&gt;::value&gt;::type&gt;void wts(InputIt __first,InputIt __last)&#123;bool isFirst=true;for(;__first!=__last;++__first)&#123;if(isFirst)isFirst=false;else sp;write(*__first);&#125;br;&#125;template&lt;typename InputIt,typename=typename enable_if&lt;is_base_of&lt;input_iterator_tag,typename iterator_traits&lt;InputIt&gt;::iterator_category&gt;::value&gt;::type&gt;void wtb(InputIt__first,InputIt __last)&#123;for(;__first!=__last;++__first)&#123;write(*__first);br;&#125;&#125;template&lt;typename T&gt;void wts(const T&amp;x)&#123;write(x);sp;&#125;template&lt;typename T&gt;void wtb(constT&amp;x)&#123;write(x);br;&#125;template&lt;typename T&gt;void wte(const T&amp;x)&#123;write(x);exit(0);&#125;template&lt;typename T,typename...Args&gt;void wts(const T&amp;x,Args...args)&#123;wts(x);wts(args...);&#125;template&lt;typename T,typename...Args&gt;void wtb(const T&amp;x,Args...args)&#123;wts(x);wtb(args...);&#125;template&lt;typename T,typename...Args&gt;void wte(const T&amp;x,Args...args)&#123;wts(x);wte(args...);&#125;template&lt;typename T&gt;inline bool up(T&amp;x,const T&amp;y)&#123;return x&lt;y?x=y,1:0;&#125;template&lt;typename T&gt;inline bool dn(T&amp;x,const T&amp;y)&#123;return y&lt;x?x=y,1:0;&#125;const int N = 100010;const int mod = 1000000007;int head[N], nxt[N &lt;&lt; 1], to[N &lt;&lt; 1], edge[N &lt;&lt; 1], cnt;int n, f[N], siz[N], id[N], rid[N];struct Element&#123; int fi, se; Element() &#123; fi = 0; se = -INF; &#125; void insert(int x) &#123; if (x &gt; fi) &#123; se = fi; fi = x; &#125; else if (x &gt; se) se = x; &#125; int get(int x) &#123; if (x == fi) return se; return fi; &#125;&#125; dis[N];void dfsdn(int u, int fa)&#123; SON (i, u) &#123; int v = to[i]; int w = edge[i]; if (v == fa) continue; dfsdn(v, u); dis[u].insert(dis[v].fi + w); &#125;&#125;void dfsup(int u, int fa)&#123; SON (i, u) &#123; int v = to[i]; int w = edge[i]; if (v == fa) continue; dis[v].insert(dis[u].get(dis[v].fi + w) + w); dfsup(v, u); &#125;&#125;void add(int u, int v, int w)&#123; nxt[++cnt] = head[u]; head[u] = cnt; to[cnt] = v; edge[cnt] = w;&#125;int find(int x)&#123; return x == f[x] ? x : f[x] = find(f[x]);&#125;void merge(int x, int y)&#123; if (find(x) == find(y)) return; if (siz[find(x)] &lt; siz[find(y)]) swap(x, y); siz[find(x)] += siz[find(y)]; f[find(y)] = find(x);&#125;signed main()&#123; #ifdef FAST_IOSTREAM cin.sync_with_stdio(false); cin.tie(0); #endif read(n); For (i, 1, n - 1) &#123; int u, v, w; read(u, v, w); add(u, v, w); add(v, u, w); &#125; dfsdn(1, 0); dfsup(1, 0); For (i, 1, n) id[i] = i; sort(id + 1, id + n + 1, [](int x, int y)&#123;return dis[x].fi &gt; dis[y].fi;&#125;); For (i, 1, n) rid[id[i]] = i; int q = read(); while (q--) &#123; int len = read(); int l = 1; int ans = 0; For (i, 1, n) &#123; f[i] = i; siz[i] = 1; &#125; For (u, 1, n) &#123; while (dis[id[l]].fi &gt; dis[id[u]].fi + len) --siz[find(id[l++])]; SON (i, id[u]) &#123; int v = to[i]; if (rid[v] &lt; u) merge(id[u], v); &#125; up(ans, siz[find(id[u])]); &#125; wtb(ans); &#125; return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>up and down</tag>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LOJ6519 魔力环（Burnside引理，容斥原理）]]></title>
    <url>%2FLOJ6519-%E9%AD%94%E5%8A%9B%E7%8E%AF%EF%BC%88Burnside%E5%BC%95%E7%90%86%EF%BC%8C%E5%AE%B9%E6%96%A5%E5%8E%9F%E7%90%86%EF%BC%89%2F</url>
    <content type="text"><![CDATA[题目链接LOJ 洛谷 题意简述你需要给 $n$ 颗珠子的项链染 $m$ 颗黑色，$n-m$ 颗白色，不能有连续的一串黑色珠子长度超过 $k$，求旋转同构下本质不同的染色方案数。 $1\le m,k\le n\le10^5$ 简要做法首先套用 Burnside 引理，以及位移为 $r$ 的旋转周期为 $\gcd(r, n)$ 的结论，得到答案的式子：$$\begin{aligned}answer&amp;=\frac 1 n\sum\limits_{i=1}^nf\left(\frac n{\gcd(i,n)}\right)\\&amp;=\frac 1 n\sum\limits_{d|n}\varphi(d)f(d)\end{aligned}$$其中 $f(x)$ 表示在一个长为 $\frac n x$ 的项链上，染 $\frac{m}{x}$ 个黑珠子，$\frac{n-m}x$ 个白珠子，不能有连续的一串黑色珠子长度超过 $k$ 的方案数（在不旋转的意义下计数）。 可以看出只有 $d|m$ 时 $f(d)$ 可能不为零，如果用 $f(x, y)$ 表示在一个长为 $x+y$ 的项链上，染 $x$ 个黑珠子，$y$ 个白珠子，不能有连续的一串黑色珠子长度超过 $k$ 的方案数（在不旋转的意义下计数），答案的式子可以写成： $$answer=\frac 1 n\sum\limits_{d|\gcd(n, m)}\varphi(d)f\left(\frac m d, \frac{n-m}d\right)$$ 现在的问题转化成了快速求 $f(x, y)$。 首先，特判掉两种情况： $k=n$ $y\ne 0$ 且 $x\le k$ 这两种情况下 $f(x, y)=\binom{x+y}x$ 由于是在环上不好处理，枚举两侧的黑珠子个数，就可以转化为序列上的问题。 而序列上的问题，就相当于求方程 $x_1+x_2+\cdots+x_{y+1}=x\ (0\le x_i\le k)$ 的解的个数。 考虑容斥，枚举至少有 $i$ 个变量的值大于 $k$（实际上是枚举大小为 $i$ 的子集都大于 $k$），解的个数为 $\binom{x+y-i(k+1)}y$。 这样的话，枚举两侧黑珠子个数最多枚举到 $k$，容斥复杂度为 $O(\frac{x+y}k)$，计算 $f(x,y)$ 的复杂度为 $O(x+y)$，整道题的复杂度就是 $O(\text{预处理组合数}+\sigma(n))$，其中 $\sigma(n)$ 表示 $n$ 的所有约数之和，在数据范围内最大为 $403200$。 参考代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103#include &lt;iostream&gt;#include &lt;cstdio&gt;using namespace std;typedef long long ll;const int N = 100005;const int mod = 998244353;int n, m, k, p[N], ptot, phi[N], fact[N], invf[N];bool np[N];int qpow(int x, int y)&#123; int out = 1; while (y) &#123; if (y &amp; 1) out = (ll) out * x % mod; x = (ll) x * x % mod; y &gt;&gt;= 1; &#125; return out;&#125;int c(int x, int y)&#123; if (y &gt; x || y &lt; 0) return 0; return (ll) fact[x] * invf[y] % mod * invf[x - y] % mod;&#125;int calc(int x, int y)&#123; int out = 0; for (int i = 0; i * (k + 1) &lt;= x + y; ++i) &#123; out = (out + (i &amp; 1 ? -1ll : 1ll) * c(x + y - (k + 1) * i, y) * c(y + 1, i) % mod + mod) % mod; &#125; return out;&#125;int f(int x, int y)&#123; if (k == n || y != 0 &amp;&amp; x &lt;= k) return c(x + y, x); int out = 0; for (int i = 0; i &lt;= x &amp;&amp; i &lt;= k; ++i) &#123; out = (out + (ll) (i + 1) * calc(x - i, y - 2)) % mod; &#125; return out;&#125;int gcd(int x, int y)&#123; return y ? gcd(y, x % y) : x;&#125;int main()&#123; cin &gt;&gt; n &gt;&gt; m &gt;&gt; k; fact[0] = invf[0] = 1; for (int i = 1; i &lt;= n; ++i) fact[i] = (ll) fact[i - 1] * i % mod; invf[n] = qpow(fact[n], mod - 2); for (int i = n - 1; i &gt;= 1; --i) invf[i] = (ll) invf[i + 1] * (i + 1) % mod; phi[1] = 1; for (int i = 2; i &lt;= n; ++i) &#123; if (!np[i]) &#123; p[++ptot] = i; phi[i] = i - 1; &#125; for (int j = 1; j &lt;= ptot &amp;&amp; i * p[j] &lt;= n; ++j) &#123; int x = i * p[j]; np[x] = true; if (i % p[j]) phi[x] = phi[i] * (p[j] - 1); else &#123; phi[x] = phi[i] * p[j]; break; &#125; &#125; &#125; int ans = 0; int g = gcd(m, n); for (int i = 1; i * i &lt;= g; ++i) &#123; if (g % i == 0) &#123; if (i * i == g) ans = (ans + (ll) f(m / i, (n - m) / i) * phi[i]) % mod; else ans = (ans + (ll) f(m / i, (n - m) / i) * phi[i] + (ll) f(m / (g / i), (n - m) / (g / i)) * phi[g / i]) % mod; &#125; &#125; cout &lt;&lt; (ll) ans * qpow(n, mod - 2) % mod; return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>组合数学</tag>
        <tag>容斥原理</tag>
        <tag>群论</tag>
        <tag>Burnside引理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LOJ6077 逆序对（生成函数，计数dp）]]></title>
    <url>%2FLOJ6077-%E9%80%86%E5%BA%8F%E5%AF%B9%EF%BC%88%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B0%EF%BC%8C%E8%AE%A1%E6%95%B0dp%EF%BC%89%2F</url>
    <content type="text"><![CDATA[题目链接LOJ 题意简述求长度为 $n$ 逆序对数为 $k$ 的排列个数。 $1\le n, k\le 10^5$，$k\le \binom n 2$ 简要作法从小到大依次考虑将每个数插入排列，那么每个数 $i$ 都可以贡献 $0\dots i-1$ 个逆序对，所以答案的生成函数为 $(1 + x)(1 + x + x^2)\cdots(1+x+\cdots+x^{n-1})$。 上下同时乘上 $(1-x)^n$，即求：$$\frac{(1-x)(1-x^2)\cdots(1-x^n)}{(1-x)^n}$$（不约分是为了方便求。） 分母 $\frac{1}{(1-x)^n}=\sum\limits_{i\ge 0}\binom{n-1+i}{n-1}x^i$，是一个大家熟知的结论，可以利用 $(1+x+x^2+\cdots)^n$ 的组合意义说明。 分子的 $x^i$ 项系数的组合意义为：考虑从 $1,2,\ldots,n$ 中选若干个和为 $i$ 的数（每个数只能选一遍）的所有方案，若选了奇数个数贡献为 $-1$，若选了偶数个数贡献为 $1$。 这个东西可以用类似 LOJ6089 的方法求： 令 $f_{i,j}$ 表示选 $i$ 个数和为 $j$ 的方案数。 由于选择的数两两不同，第一维的大小是 $O(\sqrt k)$ 的。 转移有两种方式： 背包里的所有数加一。 背包里的所有数加一，并向背包中放入一个体积为 $1$ 的物品。 $$f_{i,j}=f_{i-1,j-i}+f_{i,j-i}$$ 但这样算可能会出现体积大于 $n$ 的物品。 具体来说，当 $j\ge n+1$ 时，会有 $f_{i-1,j-n-1}$ 种不合法的方案，需要减去。 计算完 dp 之后，分子的 $x^i$ 项系数即为 $\sum\limits_{j\ge0}(-1)^jf_{j,i}$ 最后把分子和分母卷积起来即可，总时间复杂度为 $O(n+k\sqrt k)$ 或 $O(n\log p+k\sqrt k)$（取决于计算组合数与逆元的方式）。 参考代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;cstdio&gt;#include &lt;cstring&gt;using namespace std;typedef long long ll;const int N = 100005;const int mod = 1e9 + 7;int n, k, f[2][N], cur, ans, fact[N &lt;&lt; 1], invf[N &lt;&lt; 1];int qpow(int x, int y)&#123; int out = 1; while (y) &#123; if (y &amp; 1) out = (ll) out * x % mod; x = (ll) x * x % mod; y &gt;&gt;= 1; &#125; return out;&#125;int c(int x, int y)&#123; return (ll) fact[x] * invf[y] % mod * invf[x - y] % mod;&#125;int main()&#123; scanf("%d%d", &amp;n, &amp;k); fact[0] = invf[0] = 1; for (int i = 1; i &lt;= n + k; ++i) &#123; fact[i] = (ll) fact[i - 1] * i % mod; invf[i] = qpow(fact[i], mod - 2); &#125; ans = c(n - 1 + k, n - 1); f[cur][0] = 1; for (int i = 1, sum = 1; sum &lt;= k; sum += (++i)) &#123; memset(f[cur ^= 1], 0, sizeof(int) * i); for (int j = i; j &lt;= k; ++j) &#123; f[cur][j] = (f[cur ^ 1][j - i] + f[cur][j - i]) % mod; if (j &gt;= n + 1) f[cur][j] = (f[cur][j] - f[cur ^ 1][j - n - 1] + mod) % mod; ans = (ans + (i &amp; 1 ? -1ll : 1ll) * f[cur][j] * c(n - 1 + k - j, n - 1) % mod + mod) % mod; &#125; &#125; printf("%d", ans); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>组合数学</tag>
        <tag>计数dp</tag>
        <tag>生成函数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LOJ6089 小Y的背包计数问题（根号分治，计数dp）]]></title>
    <url>%2FLOJ6089-%E5%B0%8FY%E7%9A%84%E8%83%8C%E5%8C%85%E8%AE%A1%E6%95%B0%E9%97%AE%E9%A2%98%EF%BC%88%E6%A0%B9%E5%8F%B7%E5%88%86%E6%B2%BB%EF%BC%8C%E8%AE%A1%E6%95%B0dp%EF%BC%89%2F</url>
    <content type="text"><![CDATA[题目链接LOJ 题意简述你有体积为 $i$ ($1\le i\le n$) 的物品 $i$ 个，同体积物品在计数时没有区别，求装满大小为 $n$ 的背包的方案数。 $1\le n\le 10^5$。 简要作法体积大于等于 $\sqrt n$ 的物品可以无限选，所以考虑分开处理小于根号的和大于等于根号的。 小于根号的令 $f_{i, j}$ 表示从前 $i$ 种物品中选体积为 $j$ 的方案数。$$f_{i, j} = \sum\limits_{k = 0}^{\min(i, \left\lfloor\frac j i\right\rfloor)}f_{i-1, j - ik}$$可以使用模 $i$ 同余的前缀和优化。 这部分的时间复杂度为 $O(n\sqrt n)$，空间复杂度可以优化至 $O(n)$。 大于等于根号的令 $g_{i, j}$ 表示选择 $i$ 个物品体积为 $j$ 的方案数。 转移有两种方式： 向背包中放入一个体积为 $\left\lceil\sqrt n\right\rceil$ 的物品。 将背包中所有物品体积加一。 $$g_{i, j} = g_{i - 1, j - \left\lceil\sqrt n\right\rceil} + g_{i, j - i}$$ 由于最多选 $\left\lfloor\sqrt n\right\rfloor$ 个物品，第一维大小为 $O(\sqrt n)$，这部分复杂度也是 $O(n\sqrt n)$。 合并相当于求卷积的一位。 两部分加起来体积为 $n$ 就计入答案。 需要注意的是，第二部分中体积为 $k$ 的方案数是 $\sum\limits_{i=0}^{\left\lfloor\sqrt n\right\rfloor}g_{i, k}$，而不是某个单独的 dp 值。 参考代码123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;const int mod = 23333333;const int N = 100010;int n, b, f[N], pre[N], g[2][N], cur, ans;int main()&#123; scanf("%d", &amp;n); b = int(sqrt(n) + 1); f[0] = 1; for (int i = 1; i &lt; b; ++i) &#123; for (int j = 0; j &lt;= n; ++j) pre[j] = (f[j] + (j &gt;= i ? pre[j - i] : 0)) % mod; for (int j = 0; j &lt;= n; ++j) &#123; if (j &lt; i * (i + 1)) f[j] = pre[j]; else f[j] = (pre[j] - pre[j - i * (i + 1)] + mod) % mod; &#125; &#125; ans = f[n]; g[cur][0] = 1; for (int i = 1; i &lt; b; ++i) &#123; memset(g[cur ^= 1], 0, sizeof(int) * (i * b)); for (int j = i * b; j &lt;= n; ++j) &#123; g[cur][j] = (g[cur ^ 1][j - b] + g[cur][j - i]) % mod; ans = (ans + 1ll * f[n - j] * g[cur][j]) % mod; &#125; &#125; printf("%d", ans); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>计数dp</tag>
        <tag>根号分治</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LGV 引理学习笔记]]></title>
    <url>%2FLGV-%E5%BC%95%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[Lindström–Gessel–Viennot lemma，即 LGV 引理，可以用来处理有向无环图上不相交路径计数等问题。 前置知识： 图论简介 、 图论基础 、 矩阵 、 高斯消元求行列式 。 LGV 引理仅适用于 有向无环图 。 定义 $\omega(P)$ 表示 $P$ 这条路径上所有边的边权之积。（路径计数时，可以将边权都设为 $1$ ）（事实上，边权可以为生成函数） $e(u, v)$ 表示 $u$ 到 $v$ 的 每一条 路径 $P$ 的 $\omega(P)$ 之和，即 $e(u, v)=\sum\limits_{P:u\rightarrow v}\omega(P)$ 。 起点集合 $A$ ，是有向无环图点集的一个子集，大小为 $n$ 。 终点集合 $B$ ，也是有向无环图点集的一个子集，大小也为 $n$ 。 一组 $A\rightarrow B$ 的不相交路径 $S$ ： $S_i$ 是一条从 $A_i$ 到 $B_{\sigma(S)_i}$ 的路径（ $\sigma(S)$ 是一个排列），对于任何 $i\ne j$ ， $S_i$ 和 $S_j$ 没有公共顶点。 $N(\sigma)$ 表示排列 $\sigma$ 的逆序对个数。 引理$$M = \begin{bmatrix}e(A_1,B_1)&amp;e(A_1,B_2)&amp;\cdots&amp;e(A_1,B_n)\\e(A_2,B_1)&amp;e(A_2,B_2)&amp;\cdots&amp;e(A_2,B_n)\\\vdots&amp;\vdots&amp;\ddots&amp;\vdots\\e(A_n,B_1)&amp;e(A_n,B_2)&amp;\cdots&amp;e(A_n,B_n)\end{bmatrix}$$ $$\det(M)=\sum\limits_{S:A\rightarrow B}(-1)^{N(\sigma(S))}\prod\limits_{i=1}^n \omega(S_i)$$ 其中 $\sum\limits_{S:A\rightarrow B}$ 表示满足上文要求的 $A\rightarrow B$ 的每一组不相交路径 $S$ ，$\det$ 表示行列式。 证明请参考 维基百科 。 例题 hdu5852 Intersection is not allowed! 题意：有一个 $n\times n$ 的棋盘，一个棋子从 $(x, y)$ 只能走到 $(x, y+1)$ 或 $(x + 1, y)$ ，有 $k$ 个棋子，一开始第 $i$ 个棋子放在 $(1, a_i)$ ，最终要到 $(n, b_i)$ ，路径要两两不相交，求方案数对 $10^9+7$ 取模。 $1\le n\le 10^5$ , $1\le k\le 100$ ，保证 $1\le a_1&lt;a_2&lt;\dots&lt;a_n\le n$ , $1\le b_1&lt;b_2&lt;\dots&lt;b_n\le n$ 。 观察到如果路径不相交就一定是 $a_i$ 到 $b_i$ ，因此 LGV 引理中一定有 $\sigma(S)_i=i$ ，不需要考虑符号问题。边权设为 $1$ ，直接套用引理即可。 从 $(1, a_i)$ 到 $(n, b_j)$ 的路径条数相当于从 $n-1+b_j-a_i$ 步中选 $n-1$ 步向下走，所以 $e(A_i, B_j)=\binom{n-1+b_j-a_i}{n-1}$ 。 行列式可以使用高斯消元求。 复杂度为 $O(n+k^2(k + \log p))$ ，其中 $\log p$ 是求逆元复杂度。 参考代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485#include &lt;algorithm&gt;#include &lt;cstdio&gt;typedef long long ll;const int K = 105;const int N = 100005;const int mod = 1e9 + 7;int T, n, k, a[K], b[K], fact[N &lt;&lt; 1], m[K][K];int qpow(int x, int y)&#123; int out = 1; while (y) &#123; if (y &amp; 1) out = (ll)out * x % mod; x = (ll)x * x % mod; y &gt;&gt;= 1; &#125; return out;&#125;int c(int x, int y)&#123; return (ll)fact[x] * qpow(fact[y], mod - 2) % mod * qpow(fact[x - y], mod - 2) % mod;&#125;int main()&#123; fact[0] = 1; for (int i = 1; i &lt; N * 2; ++i) fact[i] = (ll)fact[i - 1] * i % mod; scanf("%d", &amp;T); while (T--) &#123; scanf("%d%d", &amp;n, &amp;k); for (int i = 1; i &lt;= k; ++i) scanf("%d", a + i); for (int i = 1; i &lt;= k; ++i) scanf("%d", b + i); for (int i = 1; i &lt;= k; ++i) &#123; for (int j = 1; j &lt;= k; ++j) &#123; if (a[i] &lt;= b[j]) m[i][j] = c(b[j] - a[i] + n - 1, n - 1); else m[i][j] = 0; &#125; &#125; for (int i = 1; i &lt; k; ++i) &#123; if (!m[i][i]) &#123; for (int j = i + 1; j &lt;= k; ++j) &#123; if (m[j][i]) &#123; std::swap(m[i], m[j]); break; &#125; &#125; &#125; if (!m[i][i]) continue; for (int j = i + 1; j &lt;= k; ++j) &#123; if (!m[j][i]) continue; int mul = (ll)m[j][i] * qpow(m[i][i], mod - 2) % mod; for (int p = i; p &lt;= k; ++p) &#123; m[j][p] = (m[j][p] - (ll)m[i][p] * mul % mod + mod) % mod; &#125; &#125; &#125; int ans = 1; for (int i = 1; i &lt;= k; ++i) ans = (ll)ans * m[i][i] % mod; printf("%d\n", ans); &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>线性代数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CF1208G Polygons（数论）]]></title>
    <url>%2FCF1208G-Polygons%EF%BC%88%E6%95%B0%E8%AE%BA%EF%BC%89%2F</url>
    <content type="text"><![CDATA[题目链接CF 洛谷 题意简述给定 $n$ 和 $k$，你需要在圆上画 $k$ 个不超过 $n$ 条边的正多边形，求顶点去重后至少有多少个。 $3\le n\le10^6$，$1\le k\le n-2$。 简要做法 所有正多边形至少有一个公共顶点。可以感性理解，也可以看 imp 的评论。 选了 $x$ 边形就选了 $x$ 的所有约数（除了 $1$ 和 $2$）边形一定最优，因为选约数相当于是免费的。 那么，我们可以把 $x$ 边形的第 $y$ 个顶点看成分数 $\dfrac y x$，这样的话，在已经选了 $x$ 的所有约数的前提下，选 $x$ 边形的代价就是 $\varphi(x)$，问题就变成了求最小的 $k$ 个 $\varphi$ 之和。 但是，一边形和二边形是不存在的，需要特殊考虑。 “一边形”其实就是那个所有正多边形的公共顶点，只需要在计算答案时加一即可。 “二边形”会且仅会影响偶数边形，相当于“一旦选了某个偶数边形，答案加一”。因为 $\varphi(x)=1$ 的 $x$ 只有 $1$ 和 $2$， 而 $\varphi(x)=2$ 的 $x$ 只有 $3$, $4$, $6$，所以只有仅选择正三角形这种情况会受到影响。特判 $k=1$ 输出 $3$ 即可。 用线性筛 + nth_element（值域不大，其实也可以线性排序）即可做到 $O(n)$。 参考代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt; using namespace std;const int N = 1000010; int n, k, p[N], tot, phi[N];bool np[N]; int main()&#123; cin &gt;&gt; n &gt;&gt; k; if (k == 1) &#123; puts("3"); return 0; &#125; phi[1] = 1; for (int i = 2; i &lt;= n; ++i) &#123; if (!np[i]) &#123; p[++tot] = i; phi[i] = i - 1; &#125; for (int j = 1; j &lt;= tot &amp;&amp; i * p[j] &lt;= n; ++j) &#123; int x = i * p[j]; np[x] = true; if (i % p[j]) phi[x] = phi[i] * (p[j] - 1); else &#123; phi[x] = phi[i] * p[j]; break; &#125; &#125; &#125; nth_element(phi + 1, phi + k + 3, phi + n + 1); // 选了最小的 k+2 个，其中前两个是“一边形”和“二边形”的代价 long long ans = 0; for (int i = 1; i &lt;= k + 2; ++i) ans += phi[i]; cout &lt;&lt; ans; return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一些注意事项]]></title>
    <url>%2F%E4%B8%80%E4%BA%9B%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%2F</url>
    <content type="text"><![CDATA[—— 简单题不 sb 是什么水平？ —— 国家队水平。 sb 错误开 long long 时记得快读也要开 long long。 记得删调试信息，尤其是 cerr。 多测时要小心使用 memset。 operator 前面记得加返回值类型名。（dev c++ 不报错不警告） 跑的很快可能是因为被优化了，因此不要用空循环测运行用时。 （用于在线比赛）RE 可能是爆栈了。 不要假根号分治（可能大于 / 小于根号的同样可以处理小于 / 大于根号的）。 sb 想不到计数 → 什么是重复的，什么是相同的。要做到不重不漏 最优化 → 什么是不优的，什么是不劣的。 要是怎么样就好了 → 能不能转化成这样。 存在反例 → 反例能否特殊处理。 只用管大小而不关心具体值 → 从小到大、从大到小考虑 / 二分答案转成 01。 构造最小值 → 找到一个较紧的下界，构造出下界（或者构造出一个方案，证明它是下界）。 多次二分时想一想能不能用双指针。 成双成对的元素，在一起怎么样，不在一起怎么样，经常可以用随机数异或来处理。 把整个序列分成若干段，每段求一个值再加起来求最值，暴力是 DP，经常可以用决策单调性优化。 图论相关问题（包括树上问题）可以考虑点和边互相转化。 能够卷积时想一想能不能直接背包。 求生成函数然后带值进去求答案，可以过程中直接算点值。 无法继续优化往往是因为求了不必要的东西。]]></content>
      <categories>
        <category>其它</category>
      </categories>
      <tags>
        <tag>注意事项</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AGC007F Shik and Copying String（贪心，实现）]]></title>
    <url>%2FAGC007F-Shik-and-Copying-String%EF%BC%88%E8%B4%AA%E5%BF%83%EF%BC%8C%E5%AE%9E%E7%8E%B0%EF%BC%89%2F</url>
    <content type="text"><![CDATA[题目链接洛谷 AtCoder 题意简述给你初始串 $S_0$ 和目标串 $T$，每一步操作可以将当前串 $S_i$ 变成 $S_{i+1}$，其中： $$S_{i+1}[j]=\begin{cases}S_i[1]&amp;j=1\\S_i[j]\text{ 或 }S_{i+1}[j-1]&amp;j&gt;1\end{cases}$$ 求最少需要几次操作可以将当前串变为 $T$。 串长 $10^6​$。 这题题解真的难写..之前觉得别人的题解写的不清楚，然而自己也写的不是很清楚… 简要做法首先，这个过程可以用折线表示： （如果您在色觉方面存在障碍，还请见谅。） 可以发现，每条折线都尽量靠右是最优的，一旦画不下了，就加一行。 现在问题变成了如何高效地维护这一贪心。 当 $S_0=T$ 时，先特判掉，输出 $0​$。 由于每次拐点都会往左下移动一格，我们可以用队列来维护当前折线的每个拐点（折线往右拐的点，也就是 $S_i[j]=S_i[j-1]$ 的 $j-1$ 这个点）（不包括最后一行的拐点），其中靠近队首表示靠下（离 $T$ 较近）的拐点，靠近队尾表示靠上（靠近 $S_0$）的拐点。 详见代码（因为这题文字写出来不如代码好理解）： 参考代码12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;string&gt;#include &lt;queue&gt;#include &lt;algorithm&gt;using namespace std;int n, ans;string s, t;queue&lt;int&gt; q;int main()&#123; cin &gt;&gt; n &gt;&gt; s &gt;&gt; t; if (s == t) // 特判两串相等 &#123; puts("0"); return 0; &#125; int up = n - 1, down = n - 1; while (down &gt;= 0) &#123; while (down &amp;&amp; t[down - 1] == t[down]) --down; // 找到当前折线在最后一行最左的位置 while (up &gt;= 0 &amp;&amp; (up &gt; down || s[up] != t[down])) --up; // 找到当前折线在第一行最左的位置 if (up &lt; 0) // 如果第一行没有对应的字符，输出无解 &#123; puts("-1"); return 0; &#125; while (!q.empty() &amp;&amp; q.front() - q.size() &gt;= down) q.pop(); // 把当前折线不会碰到的部分弹出 if (up != down) q.push(up); // 如果当前折线真的是“折线”而不是竖直下来不拐弯，就把 S1 的拐点压入队列 ans = max(ans, (int)q.size() + 1); // 后文会解释为什么这样更新答案 --down; &#125; cout &lt;&lt; ans; return 0;&#125; 补充说明这个维护拐点的方式应该画画图就能明白。 最后剩下一个问题：为什么是这样更新答案？ 换句话说：为什么答案是拐点个数的历史最大值？（加一是因为没有维护最后一行的拐点） 如果没有这个 pop 操作，应该是很显然的。但 pop 操作破坏了“队列中每个元素对应除最后一行外每一行最左位置”这个性质。 这里需要一个引理： 除了最后一行的拐点，其它拐点一定位于连续的前几行。 我们可以归纳地证明： 对于最右的那条折线，显然成立。 对于之后的每条折线，一定是先贴着上一条折线，再直接往下到最后一行。由于上一条折线满足引理，如果中途有一段没有拐点而后又出现拐点，中途的那一段就没有紧贴上一条折线。 有了这个引理，就可以感性理解说明为什么有 pop 操作的情况下答案依然是拐点个数的历史最大值了。]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>贪心</tag>
        <tag>实现</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一些有趣的小工程]]></title>
    <url>%2F%E4%B8%80%E4%BA%9B%E6%9C%89%E8%B6%A3%E7%9A%84%E5%B0%8F%E5%B7%A5%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[说实话我觉得竞赛题目挺坑爹的……木有啥意思。人类为何要出题刁难人类。 我更喜欢做的事情是写点工程啥的 &gt;_&lt;… 做做小游戏挺好玩的。 —— vfk 《四色的 NOI》 （这算哪门子引用啊） CP Editor这个的 owner 不是我，但我写了不少。 是一个为 OI 而设计的 IDE，有很多为 OI 设计的 feature，具体可以去项目主页看。 长期欢迎 contributors！ BZOJ-Local-Judge我自己现在做 BZOJ 上有的题（5000 之前）全都用这个了。真的非常方便。 Hinata Online Judge是 UOJ 的魔改，有 挺多 feature 的。 Despised除了选项单一，我觉得这是我用过体验最好的被鄙视小程序了。感觉加一些错误选项比较好，不然背着背着就变成背错误选项了。希望明年不要咕。 Tree-Generator造树挺方便的。（顺便 求 up）。 segmentTree基础线段树万能板子，只用写两个函数（merge 和 update）就拥有了一棵线段树。（继续 求 up） Anti-YiGeDingLiaDemo 大家知道 QQ 的接龙红包吗？我写这个东西的时候接龙红包特别火，然而大家都很喜欢“一个顶俩” qaq。有了这个项目，当你看到 yi 结尾时就能及时意气高昂啦！ LuoguPaintBoard顾名思义，是画洛谷冬日绘板用的。我明年一定画个ひなた！ Code-Disturber并没有什么用，实际作用是用 emoji 美化代码。 SwapArrayDimension或许是个实用的东西。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>工程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ1758 [WC2010]重建计划（二分答案，长链剖分）]]></title>
    <url>%2FBZOJ1758-WC2010-%E9%87%8D%E5%BB%BA%E8%AE%A1%E5%88%92%EF%BC%88%E4%BA%8C%E5%88%86%E7%AD%94%E6%A1%88%EF%BC%8C%E9%95%BF%E9%93%BE%E5%89%96%E5%88%86%EF%BC%89%2F</url>
    <content type="text"><![CDATA[题目链接洛谷 题意简述给你一棵带边权的树，求所有长度在 $[L,U]$ 这个范围内的路径里平均权值（总权值除以边数）的最大值。 $2\le n\le 10^5$，保证至少有一条满足要求的路径。 简要做法#define 父亲 单亲（如果有谴责“父亲节点”人士的话） 首先可以二分答案，就可以把每条边的边权都减去二分的答案，然后转化为判断有没有权值和为正的符合长度要求的路径。 然后有点分治和长链剖分两种做法，本题解介绍长链剖分的做法。 由于合并时要区间查询最大值，可以用线段树来维护。 具体来说，我们可以像重链剖分一样计算 dfs 序时优先 dfs 重（长）儿子，这样的话长链的 dfs 序就是连续的一段。当我们处理到子树 $u$ 时，$dfn_u+k$ 这个位置上的值表示自 $u$ 起向下长度为 $k$ 的路径的最大权值。可以发现不同长链之间不会互相影响，而重儿子的信息只要一个区间加就可以继承给父亲。所以，每次先 dfs 重儿子把信息继承上来，并检查有没有权值和为正的符合长度要求的路径，然后 dfs 轻儿子并枚举深度，在线段树中查询对应的一段长度合法的区间的最大值来检查有没有权值和为正的符合长度要求的路径，并将轻儿子信息也合并上来。 参考代码代码用了 CF 模板，还请谅解..（只不过这种题就算按正常码风写估计也很难看懂吧..不如自己思考细节如何实现） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252#ifndef OUUAN#pragma GCC optimize("Ofast,no-stack-protector,unroll-loops,fast-math")#endif#include&lt;bits/stdc++.h&gt;#define int LoveLive//#define FAST_IOSTREAM 1#define For(i,l,r)for(int i=(l),i##end=(r);i&lt;=i##end;++i)#define FOR(i,r,l)for(int i=(r),i##end=(l);i&gt;=i##end;--i)#define SON(i,u)for(int i=head[u];i;i=nxt[i])#define ms(a,x)memset(a,x,sizeof(a))#define fi first#define se second#define pq priority_queue#define pb emplace_back#define isinf(x)(x&gt;=INF?-1:x)#define DEBUG(x)cerr&lt;&lt;(#x)&lt;&lt;":"&lt;&lt;x&lt;&lt;endlusing namespace std;typedef long long LoveLive;typedef pair&lt;int,int&gt;pii;typedef vector&lt;int&gt;vi;#ifdef intconst int INF=0x3f3f3f3f3f3f3f3fll;#elseconst int INF=0x3f3f3f3f;#endifconst double eps=1e-9;mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());int randint(int l,int r)&#123;return(int)rng()%(r-l+1)+l;&#125;#ifdef FAST_IOSTREAM#define br cout&lt;&lt;'\n'#define sp cout&lt;&lt;' 'long long read()&#123;long long x;cin&gt;&gt;x;return x;&#125;template&lt;typename T&gt;void read(T&amp;x)&#123;cin&gt;&gt;x;&#125;template&lt;typenameT&gt;void write(const T&amp;x)&#123;cout&lt;&lt;x;&#125;#else#define br putchar('\n')#define sp putchar(' ')template&lt;typename T&gt;typename enable_if&lt;!is_integral&lt;T&gt;::value,void&gt;::type read(T&amp;x)&#123;cin&gt;&gt;x;&#125;long longread()&#123;char c;long long out=0,f=1;for(c=getchar();!isdigit(c)&amp;&amp;c!='-';c=getchar());if(c=='-')&#123;f=-1;c=getchar();&#125;for(;isdigit(c);c=getchar())out=(out&lt;&lt;3)+(out&lt;&lt;1)+c-'0';return out*f;&#125;template&lt;typename T&gt;typename enable_if&lt;is_integral&lt;T&gt;::value,T&gt;::type read(T&amp;x)&#123;char c;T f=1;x=0;for(c=getchar();!isdigit(c)&amp;&amp;c!='-';c=getchar());if(c=='-')&#123;f=-1;c=getchar();&#125;for(;isdigit(c);c=getchar())x=(x&lt;&lt;3)+(x&lt;&lt;1)+c-'0';return x*=f;&#125;char read(char&amp;x)&#123;for(x=getchar();isspace(x);x=getchar());return x;&#125;double read(double&amp;x)&#123;scanf("%lf",&amp;x);return x;&#125;void read(char*x)&#123;scanf("%s",x);&#125;template&lt;typename T&gt;typename enable_if&lt;!is_integral&lt;T&gt;::value,void&gt;::type write(const T&amp;x)&#123;cout&lt;&lt;x;&#125;template&lt;typename T&gt;typename enable_if&lt;is_integral&lt;T&gt;::value,void&gt;::type write(const T&amp;x)&#123;if(x&lt;0)&#123;putchar('-');write(-x);return;&#125;if(x&gt;9)write(x/10);putchar(x%10+'0');&#125;void write(const char&amp;x)&#123;putchar(x);&#125;void write(const double&amp;x)&#123;printf("%.10lf",x);&#125;void write(const char*x)&#123;printf("%s",x);&#125;#endiftemplate&lt;typename T,typename...Args&gt;void read(T&amp;x,Args&amp;...args)&#123;read(x);read(args...);&#125;template&lt;typename...Args&gt;void read(char*x,Args&amp;...args)&#123;read(x);read(args...);&#125;template&lt;typename OutputIt,typename=typenameenable_if&lt;is_same&lt;output_iterator_tag,typename iterator_traits&lt;OutputIt&gt;::iterator_category&gt;::value ||(is_base_of&lt;forward_iterator_tag,typename iterator_traits&lt;OutputIt&gt;::iterator_category&gt;::value&amp;&amp;!is_const&lt;OutputIt&gt;::value)&gt;::type&gt;void read(OutputIt __first,OutputIt __last)&#123;for(;__first!=__last;++__first)read(*__first);&#125;template&lt;typename InputIt,typename=typename enable_if&lt;is_base_of&lt;input_iterator_tag,typenameiterator_traits&lt;InputIt&gt;::iterator_category&gt;::value&gt;::type&gt;void wts(InputIt __first,InputIt __last)&#123;for(;__first!=__last;++__first)&#123;write(*__first);sp;&#125;&#125;template&lt;typename InputIt,typename=typename enable_if&lt;is_base_of&lt;input_iterator_tag,typename iterator_traits&lt;InputIt&gt;::iterator_category&gt;::value&gt;::type&gt;voidwtb(InputIt __first,InputIt __last)&#123;for(;__first!=__last;++__first)&#123;write(*__first);br;&#125;&#125;void wts(constchar*x)&#123;write(x);sp;&#125;void wtb(const char*x)&#123;write(x);br;&#125;void wte(const char*x)&#123;write(x);exit(0);&#125;template&lt;typename T&gt;void wts(const T&amp;x)&#123;write(x);sp;&#125;template&lt;typename T&gt;void wtb(const T&amp;x)&#123;write(x);br;&#125;template&lt;typename T&gt;void wte(const T&amp;x)&#123;write(x);exit(0);&#125;template&lt;typename...Args&gt;void wts(const char*x,Args...args)&#123;wts(x);wts(args...);&#125;template&lt;typename...Args&gt;void wtb(const char*x,Args...args)&#123;wts(x);wtb(args...);&#125;template&lt;typename...Args&gt;void wte(const char*x,Args...args)&#123;wts(x);wte(args...);&#125;template&lt;typenameT,typename...Args&gt;void wts(const T&amp;x,Args...args)&#123;wts(x);wts(args...);&#125;template&lt;typename T,typename...Args&gt;void wtb(const T&amp;x,Args...args)&#123;wts(x);wtb(args...);&#125;template&lt;typename T,typename...Args&gt;void wte(const T&amp;x,Args...args)&#123;wts(x);wte(args...);&#125;template&lt;typename T&gt;inline bool up(T&amp;x,const T&amp;y)&#123;returnx&lt;y?x=y,1:0;&#125;template&lt;typename T&gt;inline bool dn(T&amp;x,const T&amp;y)&#123;return y&lt;x?x=y,1:0;&#125;const int N = 100010;struct SegmentTree&#123;#define ls (cur &lt;&lt; 1)#define rs (cur &lt;&lt; 1 | 1)#define mid ((l + r) &gt;&gt; 1) double mx[N &lt;&lt; 2], tag[N &lt;&lt; 2]; void reset() &#123; ms(mx, 0); ms(tag, 0); &#125; void add(int x, double y) &#123; mx[x] += y; tag[x] += y; &#125; void pushdown(int cur) &#123; if (fabs(tag[cur]) &lt; eps) return; add(ls, tag[cur]); add(rs, tag[cur]); tag[cur] = 0; &#125; void modify(int cur, int l, int r, int p, double x) &#123; up(mx[cur], x); if (l == r - 1) return; pushdown(cur); if (p &lt; mid) modify(ls, l, mid, p, x); else modify(rs, mid, r, p, x); &#125; void madd(int cur, int l, int r, int L, int R, double x) &#123; if (l &gt;= R || r &lt;= L) return; if (L &lt;= l &amp;&amp; r &lt;= R) add(cur, x); else &#123; pushdown(cur); madd(ls, l, mid, L, R, x); madd(rs, mid, r, L, R, x); mx[cur] = max(mx[ls], mx[rs]); &#125; &#125; double query(int cur, int l, int r, int L, int R) &#123; if (l &gt;= R || r &lt;= L) return -INF; if (L &lt;= l &amp;&amp; r &lt;= R) return mx[cur]; pushdown(cur); return max(query(ls, l, mid, L, R), query(rs, mid, r, L, R)); &#125; double query(int cur, int l, int r, int p) &#123; if (l == r - 1) return mx[cur]; pushdown(cur); if (p &lt; mid) return query(ls, l, mid, p); return query(rs, mid, r, p); &#125;#undef ls#undef rs#undef mid&#125; t;int head[N], nxt[N &lt;&lt; 1], to[N &lt;&lt; 1], edge[N &lt;&lt; 1], cnt;void add(int u, int v, int w)&#123; nxt[++cnt] = head[u]; head[u] = cnt; to[cnt] = v; edge[cnt] = w;&#125;int n, mnlen, mxlen, dep[N], son[N], f[N], dfn[N], dfntot;void dfs1(int u, int fa)&#123; dep[u] = 1; SON(i, u) &#123; int v = to[i]; if (v == fa) continue; f[v] = edge[i]; dfs1(v, u); if(up(dep[u], dep[v] + 1)) son[u] = v; &#125;&#125;void dfs2(int u, int fa)&#123; dfn[u] = ++dfntot; if (son[u]) dfs2(son[u], u); SON(i, u) &#123; int v = to[i]; if (v != fa &amp;&amp; v != son[u]) dfs2(v, u); &#125;&#125;bool flag;void dfs(int u, int fa, double x)&#123; if (flag || !son[u]) return; dfs(son[u], u, x); t.madd(1, 1, n + 1, dfn[son[u]], dfn[son[u]] + dep[son[u]], f[son[u]] - x); if (dep[u] - 1 &gt;= mnlen &amp;&amp; t.query(1, 1, n + 1, dfn[u] + mnlen, min(dfn[u] + mxlen + 1, dfn[u] + dep[u])) &gt; 0) &#123; flag = true; return; &#125; SON(i, u) &#123; int v = to[i]; if (v != fa &amp;&amp; v != son[u]) &#123; dfs(v, u, x); t.madd(1, 1, n + 1, dfn[v], dfn[v] + dep[v], f[v] - x); For (j, max(0ll, mnlen - dep[u]), min(mxlen - 1, dep[v] - 1)) &#123; if (t.query(1, 1, n + 1, dfn[v] + j) + t.query(1, 1, n + 1, max(0ll, mnlen - j - 1) + dfn[u], min(dep[u], mxlen - j) + dfn[u]) &gt; 0) &#123; flag = true; return; &#125; &#125; For (j, 0, dep[v] - 1) t.modify(1, 1, n + 1, dfn[u] + j + 1, t.query(1, 1, n + 1, dfn[v] + j)); &#125; &#125;&#125;bool check(double x)&#123; flag = false; t.reset(); dfs(1, 0, x); return flag;&#125;signed main()&#123;#ifdef FAST_IOSTREAM cin.sync_with_stdio(false); cin.tie(0);#endif read(n, mnlen, mxlen); For (i, 2, n) &#123; int u, v, w; read(u, v, w); add(u, v, w); add(v, u, w); &#125; dfs1(1, 0); dfs2(1, 0); double l = 0, r = 1e6; For (i, 1, 40) &#123; double mid = (l + r) / 2; if (check(mid)) l = mid; else r = mid; &#125; printf("%.3lf", r); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>二分答案</tag>
        <tag>长链剖分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NIO9102 落雨大]]></title>
    <url>%2FNIO9102-%E8%90%BD%E9%9B%A8%E5%A4%A7%2F</url>
    <content type="text"><![CDATA[我也来到 NOI 了，呢。 郑重声明本博客内所有与 NOI2019（第 36 届全国青少年信息学奥林匹克竞赛）试题相关之内容，均在对应之机试与复评结束之后发布，详细发布时间与内容可以在 commits 中查看。 Day 499122177广二宿舍还是没有网. 床边的插座不是一般人能插的..（Orz lbw 插上去了）然而因为有时候要去机房（其实基本上也就刚到那天晚上没事去了..），所以后来还是拔下来了。然后发现不带 220V 转 USB 母头的插头真是个错误的决定..虽然可以用笔记本充电，可如果在寝室门口充电就没法用电脑，所以没法一会儿充电脑用手机、一会儿充手机用电脑。 晚餐有点抽卡的感觉..看名字很难看出拿到手上的到底是什么东西（ 吃完晚饭去自习室水了半小时群，然后打短裙 OJ。 切完前两题，好像 rk 5.. 然后看 C，问满足一堆条件的个数..一眼容斥..然后真的写了 1h 的容斥 qaq 好不容易过拍了，提交，又 WA 了.. 在群里一问，woc，p 不是排列… 5 min 后过了，愉快地垫底了.. 过于自闭，看了眼 D，没秒掉，就懒得去想了。 赛后听说 C 可以状压，一想，真的可以状压…..学傻了.webp Day 557219762咕掉早饭把火车上剩的吃了。 （开幕式竟然没有 wh 讲话） （灯光打得好！覆盖方位广！给灯光师点个赞！） 果然有公开处刑大头照展示，只不过速度比较快，问题不大。 感觉大家喊的口号都听不太清啊.. 明 示 爆 零 ： dzd 的讲话中，有这么一段话： 无论何种情况，这个竞赛都会继续下去。因为这个竞赛是正当的，是正义的，合法的。 听到这段话，又想起 ひなた 在桥边含泪喊出的那段话了。 但是，我没有后悔，不能后悔，因为，我所做的事情一定没有错！ （欢迎大家来 Hitokoto 点赞 ） （当然还有 这句 ） NOI 可能真的如 dzd 所说，带有一些“净化灵魂”的成分在吧。 最后鸽子蛋破不开，明示摆脱不了爆零的命运。 （离场后目击 dzd 被采访） 中餐感觉海星..还是得看看别人买到的是什么再选。（千万不要用排除法来选 中午写了写博客，做了遍笔试，睡了会儿觉。 还是感觉好方..毕竟被鄙视用的错误选项从来没变过（ 结果笔试挺水的..题目和题库里完全一样（没有之前在 vfk 博客里看见的“那道题不选 foobar.sh”之类的情况），很多题都不是四个选项而是更少，所以没有任何奇怪的错误选项.. Day 1看到 T1 就很快想出了 70 分的拆点做法，写完之后几乎一遍过了大样例。 然后去把 T2 和 T3 的 20 + 28 写了，此时 $1.5h​$ 左右。 然后去写 T1 $A=0$ 的部分分，各种写挂写了接近 $2h$.. 然后感觉 T2 还是没什么想法，T3 想了几个假贪心，又想了几个假网络流，最后还剩半小时的时候想到了一个考后才叉掉的 $n^3\log$ 的假贪心（讲题时发现稍微改动一下就是正确的 40 分做法..），幸好没写完，不然万一过了样例就 GG 了。 出来之后发现大家都 $148​$ 起步..T1 有正解的，但还有一堆利用数据范围改小的，以及一堆 $70​$ 分算错复杂度的。 T1 我写的数据分治是不可能 $85​$ 以上的，所以特别怕 $70​$ 分做法最后 $90​$ 或者 $95​$。 然后下午一看，我自己倒是没挂分，$85+20+28=133​$，可其它和我写一样东西的都是 $100+20+40​$.. T1 数据范围不知道是不是为了防止爆 int 而改小就算了，复杂度完全错误的 $70​$ 分做法竟然直接 A 了..就很自闭。T3 其他人的 $n^4​$ 常数比我小一截，我也不好说什么..只不过那些“数据有梯度”的出题人凭什么不多给几档部分分啊？ 感觉还是赛制问题啊..没有 Subtask 并且现场评测的 OI 赛制出题人也很无奈吧.. 把 NOI 嘉年华咕了（玩一些体育运动之类的游戏得奖品什么的），回寝室躺了一会儿，又看了一遍 四色的NOI，感觉自己的心境和 vfk Cu 那年挺像的..只不过就算把 vfk Fe 那年去掉，我也比 vfk 少一年啊.. 讲题的话..放一张 T2 讲题的图吧： Day 116195171今天是社会活动日。 听说真的有人没去..不知道会不会扣分。 坐 D7 的被奶了： 在博物馆先打了把四人南，然后去随便逛了半个小时。 暗示 route 数据水： 暗示 Day 2 Au 线 30 Ag 线 20： 假毛，请大家自行脑补假毛在风中打转的样子。 晚上是 zzq 和象的见面会，感觉还是象比较励志，其它三名国家队都是小学开始学的..刷题量好像非常恐怖，而“好好打模拟赛”对我来说几乎不需要解释..我知道平时我是怎样在打模拟赛的，“这个知识点还没学”，“这题没意思”，“题解看不懂”，“这题太简单了，只是考场 sb 了而已，懒得写”，“我先按我的计划补知识点，模拟赛不重要”，最后一题都没有改。这样的话我又在渴求什么呢。 以为自己很努力了，但是不知为何还是系统告诉我：Mission Failed. Play Again. 不知道原因。 张着嘴巴我可以说出一堆：经验少啦，在弱省啦，题做得少啦，数学太弱啦…… 但是这是不是真正的原因？怎样解决？ 天地无言。 —— vfk《四色的NOI》 可我甚至不能“以为自己很努力了”。 Day 2今天的纸质题面考前是正面朝上的。 果然有交互，还依然是 I 君。 等等，T2 斗主地？ 等等，T1 128MB？简洁数据结构.pdf 开始考试，T1，线段树优化连边？爆空间。88 可能能卡过？感觉很难卡，还得数据分治，写了不到 5min 就放弃了，去写了 72 分。 T2，dp 算洗牌前是 $i​$ 洗牌后是 $j​$ 的概率，第四个点矩阵快速幂，很快就写完了，一遍过样例。这个时候两小时多一点。 考前就想着靠交互翻盘了，还剩接近 3h 肝交互，感觉海星。 这个数据范围好像不太统一啊..既然强制数据分治的话不如会一档写一档好了。 先把 $\mathcal O(n^2)$ 次询问的写了，一开始还写错了，写成了 $n$ 次修改，差点挂掉 $8$ 分。 然后想了一会儿想到了性质 $A$ 一个期望 $\log$ 的做法。写完 + 调完之后 3h 多一点。 然后开始想 T3 各种各样的部分分，乱搞了 2h 一无所获。 出来之后发现大家 T1 都会 K-D Tree，又听说 T2 结论题可以打表..感觉 Ag 基本上没了啊。 我博客用模 998244353 的等比数列，是不是暗示 T2 模 998244353 等差数列，会被禁赛啊。 下午看成绩，$72+30+36=138$，发现 T2 30，原因是 a 数组开小了…只不过不挂分应该也是 Cu，问题不大。 讲题的时候松松松把 NOI 弄成了鸭子营。 T2 出题人表示：不止要让训练有素的选手进队，也要让那些能够发现题目性质的选手进队。感觉要是不能打表的话这样的想法也挺有道理的.. 出排名，果然 Cu 了。 HB 只有 jxl 和 lwc Ag。只不过两个 E 都上了 Ag 分数线。 zyy 捧杯了，zzy rk2，zzq rk3，_rqy rk4，jumpmelon rk6，myh rk7，zhf rk19。 看到熟悉的名字进集训队的感觉真的很奇妙。 晚上去高校宣讲看热闹。 清华那位老师的气质真的就完全不一样（之前 THUWC 和 THUSC 的时候就体会地非常明显了），有条不紊地讲出硬核的优点（而不是那些花里胡哨的东西）（也没有一种”我是来完成任务“的感觉）（也不会说“那我今天就用这个 PPT 来讲一下”“那我就不用 PPT 了”这样的话），感觉讲了非常多，最后正好卡时讲完了（其它学校都感觉没讲啥就匆匆忙忙结束了）（只不过这也可能是学校实力原因）。（顺带一提，THU 没用 PPT） 北大：我准备了一个 PPT，发邮件的时候挂了，今天我把 PPT 带过来了，我是干讲还是用 PPT，你们觉得怎么样比较好？ 主持人：抱歉，请遵守规则口头讲。 北大：我觉得准备这么一个 PPT 不给大家看实在是对不起大家。 （说着就打开了 PPT） ？？？ 天津大学很快就讲完了，然后说“不用打铃了”，很多人鼓掌..感觉 THU 那样打铃的同时有条不紊地结束才比较帅啊（ 感觉武大也讲的海星，也是真的在讲而不是完成任务，感觉比较自然。 华东师范大学：男生们可以和很多文科的女生交流。女生们也不要担心，因为你们也可以和很多文科的女生交流。emm… 排在最后的三个学校直接咕了… 只不过我一个 Cu 凭什么评价高校宣讲啊。 “我也是有约的人了！”「两年 OI 换一纸签约」—— 一名拿到人大一等约的我省高二选手。 好像还有面试到晚上十二点，最后拿到“替补二等约”的选手.. 看到身边的人退役更是一种说不出的感觉。 Day 232390342早上咕掉嘉年华，去机房把 D1T1 写了，然后试图学习 k-d tree。 感觉资料还是太少了，也不知道网上那些复杂度是不是对的.. 下午闭幕式。大家该 Au 的 Au，该捧杯的捧杯，该扫射的灯光师继续扫射。 结束之后真的落雨大了..下了一个多小时的大雨，选手袜子没了。 我双色 NOI 的第一色，是古铜色的。 Day 4本来不想写 Day 4 的，但广州南的便利店竟然没有泡面，必须得吐槽一下。 G1114 竟然没有插座，更得吐槽了。 那么，长沙一中再会。 题解估计会比较咕 D1T1“去年 D1T1 最短路，今年也是呢”选手自闭了。 出考场听说斜率优化，以为是斜率优化预处理等待时间的连边然后跑最短路。 看了题解才知道原来这题根本不用最短路，连 DAG 最短路都不用.. 把边按结束时间（$q_i$）排序，令 $f_i$ 表示走完第 $i$ 条边后还需要的烦躁值的最小值。 $\begin{aligned}f_i&amp;=\min\limits_{p_j\ge q_i,x_j=y_i}{A(p_j-q_i)^2+B(p_j-q_i)+C+q_j-q_i+f_j}\\&amp;=\min\limits_{p_j\ge q_i,x_j=y_i}\\{Ap_j^2+Bp_j+q_j+f_j-2Ap_jq_i\\}+Aq_i^2-Bq_i+C-q_i\end{aligned}​$ 然后就可以斜率优化了。（因为转移有 $x_j=y_i$ 的限制，要开 $n$ 个双端队列，但不要开 deque，开大量 deque 是会 MLE 的。写法的话，用 vector 存，普通方法写就好了。） 参考代码 按理来说题解里不应该包含模板，只不过这也不是什么官方题解，我就懒得换成正常写法了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166#ifndef OUUAN#pragma GCC optimize("Ofast,no-stack-protector,unroll-loops,fast-math")#endif#include&lt;bits/stdc++.h&gt;#define int LoveLive//#define FAST_IOSTREAM 1#define For(i,l,r)for(int i=(l),i##end=(r);i&lt;=i##end;++i)#define FOR(i,r,l)for(int i=(r),i##end=(l);i&gt;=i##end;--i)#define SON(i,u)for(int i=head[u];i;i=nxt[i])#define ms(a,x)memset(a,x,sizeof(a))#define fi first#define se second#define pq priority_queue#define pb emplace_back#define isinf(x)(x&gt;=INF?-1:x)#define DEBUG(x)cerr&lt;&lt;(#x)&lt;&lt;":"&lt;&lt;x&lt;&lt;endlusing namespace std;typedef long long LoveLive;typedef pair&lt;int,int&gt;pii;typedef vector&lt;int&gt;vi;#ifdef intconst int INF=0x3f3f3f3f3f3f3f3fll;#elseconst int INF=0x3f3f3f3f;#endifconst double eps=1e-9;mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());int randint(int l,int r)&#123;return(int)rng()%(r-l+1)+l;&#125;#ifdef FAST_IOSTREAM#define br cout&lt;&lt;'\n'#define sp cout&lt;&lt;' 'long long read()&#123;long long x;cin&gt;&gt;x;return x;&#125;template&lt;typename T&gt;void read(T&amp;x)&#123;cin&gt;&gt;x;&#125;template&lt;typenameT&gt;void write(const T&amp;x)&#123;cout&lt;&lt;x;&#125;#else#define br putchar('\n')#define sp putchar(' ')template&lt;typename T&gt;typename enable_if&lt;!is_integral&lt;T&gt;::value,void&gt;::type read(T&amp;x)&#123;cin&gt;&gt;x;&#125;long longread()&#123;char c;long long out=0,f=1;for(c=getchar();!isdigit(c)&amp;&amp;c!='-';c=getchar());if(c=='-')&#123;f=-1;c=getchar();&#125;for(;isdigit(c);c=getchar())out=(out&lt;&lt;3)+(out&lt;&lt;1)+c-'0';return out*f;&#125;template&lt;typename T&gt;typename enable_if&lt;is_integral&lt;T&gt;::value,T&gt;::type read(T&amp;x)&#123;char c;T f=1;x=0;for(c=getchar();!isdigit(c)&amp;&amp;c!='-';c=getchar());if(c=='-')&#123;f=-1;c=getchar();&#125;for(;isdigit(c);c=getchar())x=(x&lt;&lt;3)+(x&lt;&lt;1)+c-'0';return x*=f;&#125;char read(char&amp;x)&#123;for(x=getchar();isspace(x);x=getchar());return x;&#125;double read(double&amp;x)&#123;scanf("%lf",&amp;x);return x;&#125;void read(char*x)&#123;scanf("%s",x);&#125;template&lt;typename T&gt;typename enable_if&lt;!is_integral&lt;T&gt;::value,void&gt;::type write(const T&amp;x)&#123;cout&lt;&lt;x;&#125;template&lt;typename T&gt;typename enable_if&lt;is_integral&lt;T&gt;::value,void&gt;::type write(const T&amp;x)&#123;if(x&lt;0)&#123;putchar('-');write(-x);return;&#125;if(x&gt;9)write(x/10);putchar(x%10+'0');&#125;void write(const char&amp;x)&#123;putchar(x);&#125;void write(const double&amp;x)&#123;printf("%.10lf",x);&#125;void write(const char*x)&#123;printf("%s",x);&#125;#endiftemplate&lt;typename T,typename...Args&gt;void read(T&amp;x,Args&amp;...args)&#123;read(x);read(args...);&#125;template&lt;typename...Args&gt;void read(char*x,Args&amp;...args)&#123;read(x);read(args...);&#125;template&lt;typename OutputIt,typename=typenameenable_if&lt;is_same&lt;output_iterator_tag,typename iterator_traits&lt;OutputIt&gt;::iterator_category&gt;::value ||(is_base_of&lt;forward_iterator_tag,typename iterator_traits&lt;OutputIt&gt;::iterator_category&gt;::value&amp;&amp;!is_const&lt;OutputIt&gt;::value)&gt;::type&gt;void read(OutputIt __first,OutputIt __last)&#123;for(;__first!=__last;++__first)read(*__first);&#125;template&lt;typename InputIt,typename=typename enable_if&lt;is_base_of&lt;input_iterator_tag,typenameiterator_traits&lt;InputIt&gt;::iterator_category&gt;::value&gt;::type&gt;void wts(InputIt __first,InputIt __last)&#123;for(;__first!=__last;++__first)&#123;write(*__first);sp;&#125;&#125;template&lt;typename InputIt,typename=typename enable_if&lt;is_base_of&lt;input_iterator_tag,typename iterator_traits&lt;InputIt&gt;::iterator_category&gt;::value&gt;::type&gt;voidwtb(InputIt __first,InputIt __last)&#123;for(;__first!=__last;++__first)&#123;write(*__first);br;&#125;&#125;void wts(constchar*x)&#123;write(x);sp;&#125;void wtb(const char*x)&#123;write(x);br;&#125;void wte(const char*x)&#123;write(x);exit(0);&#125;template&lt;typename T&gt;void wts(const T&amp;x)&#123;write(x);sp;&#125;template&lt;typename T&gt;void wtb(const T&amp;x)&#123;write(x);br;&#125;template&lt;typename T&gt;void wte(const T&amp;x)&#123;write(x);exit(0);&#125;template&lt;typename...Args&gt;void wts(const char*x,Args...args)&#123;wts(x);wts(args...);&#125;template&lt;typename...Args&gt;void wtb(const char*x,Args...args)&#123;wts(x);wtb(args...);&#125;template&lt;typename...Args&gt;void wte(const char*x,Args...args)&#123;wts(x);wte(args...);&#125;template&lt;typenameT,typename...Args&gt;void wts(const T&amp;x,Args...args)&#123;wts(x);wts(args...);&#125;template&lt;typename T,typename...Args&gt;void wtb(const T&amp;x,Args...args)&#123;wts(x);wtb(args...);&#125;template&lt;typename T,typename...Args&gt;void wte(const T&amp;x,Args...args)&#123;wts(x);wte(args...);&#125;template&lt;typename T&gt;inline bool up(T&amp;x,const T&amp;y)&#123;returnx&lt;y?x=y,1:0;&#125;template&lt;typename T&gt;inline bool dn(T&amp;x,const T&amp;y)&#123;return y&lt;x?x=y,1:0;&#125;const int N = 100010;const int M = 200010;int n, m, a, b, c, id[M];struct Edge&#123; int u, v, p, q, f; bool operator&lt;(const Edge &amp; b) const &#123; return q &gt; b.q; &#125;&#125; e[M];struct Point&#123; int x, y; Point(int j = 0): x(2 * a * e[j].p), y(a * e[j].p * e[j].p + b * e[j].p + e[j].q + e[j].f) &#123;&#125; friend bool cmp(const Point &amp; a1, const Point &amp; a2, const Point &amp; a3) &#123; if (a1.x == a2.x) return a1.y &lt; a2.y; return (a1.y - a3.y) * (a2.x - a3.x) &gt;= (a2.y - a3.y) * (a1.x - a3.x); &#125; int cal(int k) const &#123; return y - k * x; &#125;&#125;;struct Deque&#123; vector&lt;Point&gt; q; int ql, qr; Deque() &#123; q.resize(1); ql = 1; qr = 0; &#125; bool empty() const &#123; return ql &gt; qr; &#125; void push_back(const Point &amp; x) &#123; ++qr; if (q.size() == qr) q.push_back(x); else q[qr] = x; &#125; void cal(int i) &#123; while (ql &lt; qr &amp;&amp; q[ql + 1].cal(e[i].q) &lt;= q[ql].cal(e[i].q)) ++ql; e[i].f = q[ql].cal(e[i].q) + a * e[i].q * e[i].q - b * e[i].q + c - e[i].q; &#125; void insert(const Point &amp; x) &#123; while (ql &lt; qr &amp;&amp; cmp(x, q[qr], q[qr - 1])) --qr; push_back(x); &#125;&#125; q[N];signed main()&#123;#ifdef FAST_IOSTREAM cin.sync_with_stdio(false); cin.tie(0);#endif read(n, m, a, b, c); For (i, 1, m) read(e[i].u, e[i].v, e[i].p, e[i].q); ++m; e[m].u = 0; e[m].v = 1; e[m].p = 0; e[m].q = 0; sort(e + 1, e + m + 1); For (i, 1, m) id[i] = i; sort(id + 1, id + m + 1, [](int x, int y) &#123; return e[x].p &gt; e[y].p; &#125;); int idp = 1; For (i, 1, m) &#123; if (e[i].v == n) &#123; e[i].f = 0; continue; &#125; while (idp &lt;= m &amp;&amp; e[id[idp]].p &gt;= e[i].q) &#123; if (e[id[idp]].f &lt; INF) q[e[id[idp]].u].insert(Point(id[idp])); ++idp; &#125; if (q[e[i].v].empty()) &#123; e[i].f = INF; continue; &#125; q[e[i].v].cal(i); &#125; For (i, 1, m) if (e[i].u == 0) wte(e[i].f); return 0;&#125; D1T3其实可以模拟费用流，但如果你写一篇模拟费用流的题解，会发现那是一篇费用流建图的题解和一篇贪心题解拼起来。所以下面是一篇纯贪心题解。 我们要从两个序列中各选 $k$ 个下标，考虑每一步（选择一组下标）： 如果还允许选两个不一样的下标，那就从剩下还没选的数里选最大的 $a$ 和最大的 $b$。 如果无法选择不一样的下标了，那么有三种选择： 选择一组 $a_i+b_i$（即 $a$, $b$ 下标相同） $a_i$ 被选了，$b_i$ 没有被选，那么把 $a_i$ 与 $b_i$ 匹配，再给 $a_i$ 原来匹配的那个 $b_j$ 找到一个剩下的里面最大的 $a_k$，然后把 $b_j$ 和 $a_k$ 匹配。 把第二条的 $a$ 和 $b$ 互换。 那么，维护剩下的最大的 $a$，剩下的最大的 $b$，剩下的最大的 $a+b$，$a_i$ 已匹配的最大的 $b_i$，$b_i$ 已匹配的最大的 $a_i$，剩余可选择的不一样下标个数，每个数匹配的数，就可以完成这个贪心了。 前三个最大值排序即可，后两个最大值使用堆维护。细节有些多，写的时候注意每一步都确保每个量正确更新了。尤其需要注意的是“剩余可选择的不一样下标个数”的更新。 参考代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cctype&gt;#include &lt;queue&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;int read()&#123; int out = 0; char c; while (!isdigit(c = getchar())); for (; isdigit(c); c = getchar()) out = out * 10 + c - '0'; return out;&#125;typedef pair&lt;int, int&gt; pii;const int N = 200010;const int INF = 1e9;int T, n, k, dif, a[N], b[N], ida[N], idb[N], idab[N], pa, pb, pab, fa[N], fb[N]; // dif 是剩余可选择的不一样下标个数，id 是用来排序的，pa，pb，pab 记录用到了第几个值（即当前最大值是 a[pa] 之类的），fa，fb 分别记录 a_i 和 b_i 匹配的数的下标priority_queue&lt;pii&gt; sa, sb, emptypq; // sa 是 b 已匹配的 a，sb 是 a 已匹配的 b，emptypq 是用来多测清空的void link(int u, int v) // 匹配两个数&#123; --dif; fa[u] = v; fb[v] = u; if (u == v) --dif; // 去重，否则会在下面三行代码里加两次 if (fb[u]) ++dif; else sb.push(pii(b[u], u)); if (fa[v]) ++dif; else sa.push(pii(a[v], v));&#125;void cut(int u, int v) // 断开匹配&#123; ++dif; if (fb[u]) --dif; if (fa[v]) --dif; if (u == v) ++dif; // 去重 fa[u] = fb[v] = 0;&#125;pii geta() // 获取当前剩余的最大 a&#123; while (fa[ida[pa]]) ++pa; return pii(a[ida[pa]], ida[pa]);&#125;pii getb() // 获取当前剩余的最大 b&#123; while (fb[idb[pb]]) ++pb; return pii(b[idb[pb]], idb[pb]);&#125;pii getab() // 获取当前剩余的最大 a + b&#123; while (pab &lt;= n &amp;&amp; (fa[idab[pab]] || fb[idab[pab]])) ++pab; return pii(pab &lt;= n ? a[idab[pab]] + b[idab[pab]] : -INF, idab[pab]);&#125;pii getsa() // 获取 b 已选的最大 a&#123; while (!sa.empty() &amp;&amp; fa[sa.top().second]) sa.pop(); return sa.empty() ? pii(-INF, 0) : sa.top();&#125;pii getsb() // 获取 a 已选的最大 b&#123; while (!sb.empty() &amp;&amp; fb[sb.top().second]) sb.pop(); return sb.empty() ? pii(-INF, 0) : sb.top();&#125;int main()&#123; T = read(); while (T--) &#123; pa = pb = pab = 1; sa = sb = emptypq; memset(fa, 0, sizeof(fa)); memset(fb, 0, sizeof(fb)); n = read(); k = read(); dif = k - read(); for (int i = 1; i &lt;= n; ++i) a[i] = read(); for (int i = 1; i &lt;= n; ++i) b[i] = read(); for (int i = 1; i &lt;= n; ++i) ida[i] = idb[i] = idab[i] = i; sort(ida + 1, ida + n + 1, [](int x, int y)&#123;return a[x] &gt; a[y];&#125;); sort(idb + 1, idb + n + 1, [](int x, int y)&#123;return b[x] &gt; b[y];&#125;); sort(idab + 1, idab + n + 1, [](int x, int y)&#123;return a[x] + b[x] &gt; a[y] + b[y];&#125;); while (k--) &#123; if (dif) link(geta().second, getb().second); else &#123; pii nab = getab(); pii na_a = getsa(); pii na_b = getb(); pii nb_a = geta(); pii nb_b = getsb(); if (nab.first &gt;= na_a.first + na_b.first &amp;&amp; nab.first &gt;= nb_a.first + nb_b.first) link(nab.second, nab.second); else if (na_a.first + na_b.first &gt;= nb_a.first + nb_b.first) &#123; int t = fb[na_a.second]; cut(t, na_a.second); link(t, na_b.second); link(na_a.second, na_a.second); &#125; else &#123; int t = fa[nb_b.second]; cut(nb_b.second, t); link(nb_a.second, t); link(nb_b.second, nb_b.second); &#125; &#125; &#125; long long ans = 0; for (int i = 1; i &lt;= n; ++i) ans += (fa[i] ? a[i] : 0) + (fb[i] ? b[i] : 0); printf("%lld\n", ans); &#125; return 0;&#125;]]></content>
      <categories>
        <category>游记</category>
      </categories>
      <tags>
        <tag>CCF系列赛事</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++11 enable_if 的使用]]></title>
    <url>%2FC-11-enable-if-%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[今天想更新一下自己的 CF 模板，然后发现由于写法问题可能要给每种整型（int，long，long long，unsigned int，unsigned long long……）分别定义函数，于是尝试搜了一下有没有什么好的代码重用方式，发现了 enable_if，还挺好用的，但去网上搜教程可能比较难学..我乱搞了两三个小时才学会。于是就来分享一下.. 重载的匹配SFINAESFINAE 是 substitution failure is not an error 的缩写，即匹配失败不是错误。就是说，匹配重载的函数 / 类时如果匹配后会引发编译错误，这个函数 / 类就不会作为候选。这是一个 C++11 的新特性，也是 enable_if 最核心的原理。 完整的重载匹配顺序（SFINAE 下） 找到候选函数，去掉其中会引发编译错误的。 完全匹配 &gt; 提升转换 &gt; 标准转换 &gt; 用户定义的转换。 完全匹配： 值 ↔ 引用 [] → * type(argument-list) → (type *)(argument-list)（函数指针） type → const / volatile type type * → const type type * → volatile type * 提升转换：char / shorts → int，float → double。 标准转换：int → char，long → double。 用户定义的转换：类中的构造函数，类型转换函数等。 非模板函数优先于模板函数。 寻找“最佳匹配”，我自己也不是很了解，可以参见 《C++ Primer Plus（第五版）》8.5.4 或上网搜索。 若经过以上过程仍有多个候选函数，则会引发二义性错误。 enable_if 的原理enable_if 的定义类似于下面的代码：（只有 Cond = true 时定义了 type） 12template&lt;bool Cond, class T = void&gt; struct enable_if &#123;&#125;;template&lt;class T&gt; struct enable_if&lt;true, T&gt; &#123; typedef T type; &#125;; 这样的话，enable_if&lt;true, T&gt;::type 即为 T，而 enable_if&lt;false, T&gt;::type 会引发编译错误（在 SFINAE 下，即不将包含这一 enable_if 的函数 / 类作为候选）。 enable_if 的使用enable_if 可以在任何地方充当一个类型使用，可以有实际意义，也可以新增一个多余的仅用来 enable / unable 的参数。 12345678910111213141516171819202122#include &lt;iostream&gt;#include &lt;type_traits&gt;using namespace std;template&lt;int a, int b&gt;typename enable_if&lt;a + b == 233, bool&gt;::type is233()&#123; return true;&#125;template&lt;int a, int b&gt;typename enable_if&lt;a + b != 233, bool&gt;::type is233()&#123; return false;&#125;int main()&#123; cout &lt;&lt; is233&lt;1, 232&gt;() &lt;&lt; endl &lt;&lt; is233&lt;114514, 1919&gt;(); return 0;&#125; 只不过，大多数时候 enable_if 都用来判断模板参数的类型，此时一般要和 is_integral 等模板类结合使用。 有关 is_integral 等相关模板类的信息可以参见 C++ Reference。 is_integral&lt;T&gt;::value 是一个布尔值，在 T 为整型时为真，否则为假。 1234567891011121314151617#include &lt;iostream&gt;#include &lt;type_traits&gt;using namespace std;template&lt;typename T, typename = typename enable_if&lt;is_integral&lt;T&gt;::value, void&gt;::type&gt;bool isodd(T x)&#123; return x % 2;&#125;int main()&#123; cout &lt;&lt; isodd(4) &lt;&lt; endl &lt;&lt; isodd('a'); //cout &lt;&lt; isodd("qwq"); -- compile error return 0;&#125; 一个 OutputIterator 的例子： 12template &lt;typename OutputIt, typename = typename enable_if&lt;is_same&lt;output_iterator_tag, typename iterator_traits&lt;OutputIt&gt;::iterator_category&gt;::value || (is_base_of&lt;forward_iterator_tag, typename iterator_traits&lt;OutputIt&gt;::iterator_category&gt;::value &amp;&amp; !is_const&lt;OutputIt&gt;::value)&gt;::type&gt;void read(OutputIt __first, OutputIt __last) &#123; for (; __first != __last; ++__first) read(*__first); &#125;]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>泛型编程</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Surreal Numbers 阅读笔记]]></title>
    <url>%2FSurreal-Numbers-%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[今天模拟赛遇到了一道需要超现实数的题目，赛后在阅读 Matrix67 的博客 时听说了唐纳德所著的《Surreal Numbers》（中译：研究之美）这本书，于是就阅读了一下。 大约会把书里的定理证一遍吧.. 学习超现实数的时候请假装自己不知道关于数字的一切知识，并且不要把定义的名字真的当回事（某些定义有着熟悉的名字，但可能与我们熟知的意义相同，也可能不同）。 小说下载地址 本文可能比较咕，不知道什么时候能填完坑… Conway’s rules（翻译挺神仙的） 创生二道，大小诸数盖由此出。 凡数，皆合于前创二数之集，其位左者，无一大于或似于其位右者。 甲数小于或似于乙数，当且仅当甲数之左集中无一大于或似于乙数，且乙数之右集中无一小于或似于甲数。 Conway 检视二道，连呼妙哉！此二道真妙绝。 DefinitionsSymbols比较运算符上画一道斜线表示不满足该运算符。 $x\le y$ 表示 $x$ 小于或似于 $y$。 $x\ge y$ 表示 $y\le x$。 $x\equiv y$ 表示 $x$ 似于 $y$，即 $x\le y$ 且 $y\le x$。 根据下文会介绍的定理 (T4)，“不小于或似于” 即 “大于且不似于”，所以可以定义 $x&lt;y$ 表示 $x\not\ge y$，$x&gt;y$ 表示 $x\not\le y$。 $A\le x$（$A$ 是一个集合，$x$ 是一个数）表示 $A$ 中任意一个元素都 $\le x$。（其它运算符类似） $x\le A$（$A$ 是一个集合，$x$ 是一个数）表示 $A\ge x$。（其它运算符类似） $A\le B$（$A$ 和 $B$ 都是集合）表示 $A$ $\le$ $B$ 中任意一个元素。（其它运算符类似） Number一个数 $x$ 可以表示为 $(X_L,X_R)$ 的形式，其中 $X_L$ 表示 $x$ 的左集，$X_R$ 表示 $x$ 的右集。即 $x=(X_L,X_R)$。 $x_L$ 表示 $X_L$ 中的一个元素，$x_R$ 表示 $X_R$ 中的一个元素。 Rule #1$$x_L\not\ge x_R$$ Rule #2$$x\le y\Leftrightarrow X_L\not\ge y\land Y_R\not\le x$$ TheoremsT1$$x\le y\land y\le z\Rightarrow x\le z$$ 证明 假设该命题不成立，即存在 $x\le y,y\le z,x\not\le z$。 $\because x\not\le z$ $\therefore \exists\ x_L\ge z\lor\exists\ z_R\le x$ 当 $x_L\ge z$ 时 ​ $\because x\le y$ ​ $\therefore x_L\not\ge y$ ​ $\therefore y\le z,z\le x_L,y\not\le x_L$ 当 $z_R\le x$ 时 ​ $\because y\le z$ ​ $\therefore z_R\not\le y$ ​ $\therefore z_R\le x,x\le y,z_R\not\le y$ 综上，无论是哪种情形，都会得到新的一组不满足原命题的数，而这组数的其中一个数会比原来的三个数中的一个创造的早，新的这组数的另外两个数就是原来的三个数中另外两个数。这样的话，若出现了一组不满足原命题的数，创造时间就会不断向前追溯，而追溯是有尽头的，因此这种情形不可能出现。 证毕。 T2$$X_L\le x\le X_R$$ 证明 T3$x\le x$ 证明 T4$$x\not\le y\Rightarrow y\le x$$ 证明 T5$$x&lt;y\land y\le z\Rightarrow x&lt;z$$ 证明 T6$$x\le y\land y&lt;z\Rightarrow x&lt;z$$ 证明 T7$$Y_L&lt;x&lt;Y_R\Rightarrow x\equiv(x_L\bigcup Y_L,x_R\bigcup Y_R)$$ 证明 （本文咕咕中……）]]></content>
      <categories>
        <category>其它知识</category>
      </categories>
      <tags>
        <tag>博弈论</tag>
        <tag>超现实数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CF708C Centroids（树形dp，up and down）]]></title>
    <url>%2FCF708C-Centroids%EF%BC%88%E6%A0%91%E5%BD%A2dp%EF%BC%8Cup-and-down%EF%BC%89%2F</url>
    <content type="text"><![CDATA[题目链接CF 洛谷 题意简述给你一棵 $n$ 个点的树，对每个点，判断能否删去一条边再加上一条边，使得这个点成为树的重心。（树的重心：将其删去后每个联通块大小不超过 $\frac n 2$） $2\le n\le 4\cdot10^5​$ 简要做法up and down，即用两遍 dfs，第一遍用孩子更新父亲，第二遍用父亲更新孩子，好像也叫做“换根 dp”。 如何修改一条边使一个点成为重心？要把那个点原来最大的子树删掉一条边分成不超过 $\frac n 2$ 的两半，再把切下来那个子树接到这个点上。切下来的那个子树只要不超过 $\frac n 2$ 即可，所以我们希望切下来一个尽可能大的不超过 $\frac n 2$ 的子树，这样剩下来那一半就可以尽量小。 也就是说，我们需要找到以每个点为根的最大子树，以及每个子树（注意是无根树的每个子树）可以切出来的最大的不超过 $\frac n 2$ 的子树。求这个可以使用 up and down 这个技巧，详见代码。 求出这个之后，就可以 $\mathcal O(1)$ 判断每个点是否合法了。 up and down 的过程中有一个小技巧：第二遍 dfs 中用父亲更新孩子时，父亲的 down（父亲的孩子们对父亲的贡献）中要减去当前节点的贡献再更新当前节点的值，所以需要存最大值和次大值，这个可以利用一个小数据结构来简化代码，详见代码中的 struct Node。 参考代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;const int N = 400010;struct Node&#123; int fi, se; void insert(int x) // 向最大值和次大值中插入一个值 &#123; if (x &gt; fi) &#123; se = fi; fi = x; &#125; else if (x &gt; se) se = x; &#125; int get(int x) // 得到除了 x 外的最大值 &#123; if (x == fi) return se; else return fi; &#125;&#125; dn[N];int calc(int u);void dfs1(int u);void dfs2(int u);void add(int u, int v);int head[N], nxt[N &lt;&lt; 1], to[N &lt;&lt; 1], cnt;int n, siz[N], fa[N], son[N], up[N];int main()&#123; int i, u, v, mx, sz; scanf("%d", &amp;n); for (i = 1; i &lt; n; ++i) &#123; scanf("%d%d", &amp;u, &amp;v); add(u, v); add(v, u); &#125; dfs1(1); dfs2(1); for (u = 1; u &lt;= n; ++u) &#123; v = son[u]; if (v == fa[u]) &#123; sz = n - siz[u]; mx = up[u]; // 也可以 max(dn[v].get(calc(u)), up[v]) &#125; else &#123; sz = siz[v]; mx = dn[v].fi; // 也可以 calc(v) &#125; printf("%d ", sz - mx &lt;= n / 2); &#125; return 0;&#125;void dfs1(int u)&#123; int i, v; siz[u] = 1; for (i = head[u]; i; i = nxt[i]) &#123; v = to[i]; if (v == fa[u]) continue; fa[v] = u; dfs1(v); siz[u] += siz[v]; dn[u].insert(calc(v)); &#125;&#125;void dfs2(int u)&#123; int i, v; if (n - siz[u] &lt;= n / 2) up[u] = n - siz[u]; else up[u] = max(up[fa[u]], dn[fa[u]].get(calc(u))); for (i = head[u]; i; i = nxt[i]) &#123; v = to[i]; if (v == fa[u]) continue; dfs2(v); if (siz[v] &gt; siz[son[u]]) son[u] = v; // son 是一个节点的最大子树 &#125; if (n - siz[u] &gt; siz[son[u]]) son[u] = fa[u];&#125;int calc(int u) // 计算孩子对父亲的贡献&#123; return siz[u] &lt;= n / 2 ? siz[u] : dn[u].fi;&#125;void add(int u, int v)&#123; nxt[++cnt] = head[u]; head[u] = cnt; to[cnt] = v;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>up and down</tag>
        <tag>树形dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ2115 [WC2011]最大XOR和路径（线性基，图论）]]></title>
    <url>%2FBZOJ2115-WC2011-%E6%9C%80%E5%A4%A7XOR%E5%92%8C%E8%B7%AF%E5%BE%84%EF%BC%88%E7%BA%BF%E6%80%A7%E5%9F%BA%EF%BC%8C%E5%9B%BE%E8%AE%BA%EF%BC%89%2F</url>
    <content type="text"><![CDATA[题目链接洛谷 darkbzoj 题意简述给你一张带边权的无向图，求 $1$ 到 $n$ 的边权异或和最大的路径。 点数 $5\times 10^4$，边数 $10^5$。 简要做法我们先随便找一条从 $1$ 到 $n$ 的链，然后看能如何修改它。 如果我们不走这条链，从某个位置分叉出去，为了回到这条链上，我们一定是从某条岔路走出去，走一个环，再沿着这条岔路走回来。由于边权异或，这条岔路就不会产生贡献。因此，最终答案可以表示为一条链 + 若干个环的异或和。这条链是可以随便选的，因为一条链可以异或若干个环得到另一条链。 然而，环可能有很多，事实上我们可以得到 dfs 树，只需考虑那些仅包含一条返祖边的环，其它环都可以由若干个这样的环异或得到。代码实现非常简单，具体可以看参考代码。 找到这些环之后用线性基就可以求出答案了。 参考代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cctype&gt;using namespace std;typedef long long ll;ll read()&#123; ll out = 0; char c; while (!isdigit(c = getchar())); for (; isdigit(c); c = getchar()) out = out * 10 + c - '0'; return out;&#125;const int N = 50010;const int M = 100010;void add(int u, int v, ll w);void dfs(int u, int fa);void insert(ll x);int n, m, head[N], nxt[M &lt;&lt; 1], to[M &lt;&lt; 1], cnt;ll edge[M &lt;&lt; 1], dis[N], p[70], ans;bool vis[N];int main()&#123; int i, u, v; ll w; n = read(); m = read(); for (i = 0; i &lt; m; ++i) &#123; u = read(); v = read(); w = read(); add(u, v, w); add(v, u, w); &#125; dfs(1, 0); ans = dis[n]; for (i = 59; ~i; --i) &#123; if (!((ans &gt;&gt; i) &amp; 1)) &#123; ans ^= p[i]; &#125; &#125; cout &lt;&lt; ans; return 0;&#125;void insert(ll x)&#123; for (int i = 59; ~i; --i) &#123; if ((x &gt;&gt; i) &amp; 1) &#123; if (p[i]) x ^= p[i]; else &#123; p[i] = x; break; &#125; &#125; &#125;&#125;void dfs(int u, int fa)&#123; ll w; int i, v; vis[u] = true; for (i = head[u]; i; i = nxt[i]) &#123; v = to[i]; w = edge[i]; if (v == fa) continue; if (vis[v]) insert(dis[u] ^ dis[v] ^ w); else &#123; dis[v] = dis[u] ^ w; dfs(v, u); &#125; &#125;&#125;void add(int u, int v, ll w)&#123; nxt[++cnt] = head[u]; head[u] = cnt; to[cnt] = v; edge[cnt] = w;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>线性基</tag>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ouuan 的出题规范]]></title>
    <url>%2Fouuan-%E7%9A%84%E5%87%BA%E9%A2%98%E8%A7%84%E8%8C%83%2F</url>
    <content type="text"><![CDATA[首先，你需要意识到，自己出的题是要给别人做的。 请不要说这是一句废话。这是做一名好的出题人必须要明白的。 出题比起展示自己，更是服务他人。 UPD: 本文已于 pr #1672 经优化、扩充后合并至 OI-wiki，推荐在 OI-wiki 上阅读。 题目内容关于原题原题大致可分为完全一致、几乎一致和做法一致三种。 完全一致：使用一题的 AC 代码可以 AC 另一题。 几乎一致：由一题的 AC 代码改动至另一题的 AC 代码可以由一个不会该题的人完成。 做法一致：核心思路、做法一致，但代码实现上、不那么关键的细节上有差异。 这三种原题自下而上为包含关系。 以下情况不应出现： 在明知有“几乎一致”的原题的情况下出原题。 由于未使用搜索引擎查找导致自己不清楚有原题，从而出了“几乎一致”的原题。 在“做法一致”的原题广为人知（如：NOIp、NOI 原题）时出原题。 在带有选拔性的考试的非送分题中出现“做法一致”的原题。 以下情况最好不要出现： 在明知有至少为“做法一致”的原题的情况下出原题。 由于未使用搜索引擎查找导致自己不清楚有原题，从而出了“做法一致”的原题。 在任何情况下出“几乎一致”的原题。 可以放宽要求的例外情况： 校内模拟赛。 以专题训练为目的的模拟赛。 难度较低的比赛，或是定位为送分题的题目。 关于毒瘤题“毒瘤题”是一个非常模糊而主观的观念，我在这只是引用一些前人关于此的探讨，加以自己的一些理解。这个话题是非常开放的，欢迎大家来发表自己的观点。 一道好题不应该是两道题拼在一起，一道好题会有自己的idea —— 而它应该不加过多包装地突出这个idea。 一道好题应该新颖。真正的好题，应该是能让人脑洞出新的好题的好题。 —— vfk《UOJ精神之源流》 例子：【XR-1】柯南家族，做法的前后两部分完全割裂，前半部分为【模板】树上后缀排序，后半部分是经典树上问题。 一类OI题以数学为主，无论是题目描述还是做法都是数学题的特征，并且解法中不含算法相关的知识点，这类OI题目统称为纯数学题。 —— 王天懿《论偏题的危害》 经典例子：NOIP2017 小凯的疑惑 我自己的标准是：尽量不要出数学填空题。但这样的纯数学题也不是完全不可取，有时纯粹地考察一些 OI 常用数学知识也是可以接受的。 一部分偏题中牵涉到了大学物理的内容，导致选手在面对这些从未接触过的物理知识点时变得不知所措，造成了知识上的隔膜。 —— 王天懿《论偏题的危害》 经典例子：【清华集训2015】多边形下海 不止是物理，OI 题目中不应过多涉及到其它学科的知识，如果涉及应当给予详细的解释，不应使其它学科的知识作为解题的重大障碍。 一道好题无论难度如何，都应该具有自己的思维难度，需要选手去思考并发现一些性质。 一道好题的代码可以长，但一定不是通过强行嵌套或者增加条件而让代码变长，而是长得自然，让人感觉这个题的代码就应该是这么长。 —— 王天懿《论偏题的危害》 经典例子：[SDOI2010]猪国杀，【集训队互测2015】未来程序·改 在一般的 OI 比赛中，思维难度应占主要部分。当然，如 THUWC / THUSC 的 Day 2+ 那样的工程题也有其存在的道理 —— 毕竟体验营的目的除了考察选手的算法设计能力，还有和大学学习对接的工程代码以及文档学习能力。但在一般的 OI 比赛中，考察更多的应当还是算法设计与思维能力。 题面题目背景题目背景最好尽量简短。 在题目背景较长时，应当与题目描述分开。 需要绝对避免的情况：题目背景严重影响题意的理解。 必要时，可以提供与背景结合的题目描述与简洁的题目描述两个版本。 题目描述简而言之，题目描述需要清晰易懂。 题面中的每个可能不被理解的定义都应得到解释，不应凭空冒出未加定义的概念。例如：在 CF1172D Nauuo and Portals 中，你必须在题面中解释什么是“传送门”。 题面中涉及到的每个概念应当使用单一的词汇来描述。例如：不应一会儿说“费用”，一会儿说“代价“。 不应不加说明地使用与原义、常见义不同的词汇。例如：不应不加说明地用“路径”代指一条边。 你需要保证你的题面不会自相矛盾。例如：在 CF 1173A Nauuo and Votes 中，没有把 “?” 作为一种 “result”，是因为 “?” 的含义是 “there are more than one possible results”。 你需要保证你的题面不能被错误理解而自圆其说，即使这种理解是反常识、没有人会这么去想的。例如：在 CF1172D Nauuo and Portals 中，之所以要繁琐地定义 “walk into” 并与 “teleport” 区分，是为了防止这种理解：通过传送门可以到另一个传送门，而到了传送门会传送，因此会反复横跳。 顺着读题目描述应当能看懂每一句话，并理解题目的任务与要求。至少在紧接着的下一段话中疑惑能够得到解释，而不是需要在若干段后才能得到解释，或者要看了输入输出格式才能明白题意，甚至需要根据样例来猜题意。例如：在 「GuOJ Round #1」琪露诺的冰雪宴会 中，在输出格式才第一次出现了题目的目标“雾之湖最终能接收到的最大水量”，再加上“灵梦当然能很快算出来清理完全部小溪的总费用是多少”这句带有误解性质的话，更容易使人读错题意，这是不可取的，应当在题目描述中就对题目的目标进行说明。（在这个例子中还存在题目背景严重影响题意理解的问题。） 输入输出格式输入输出格式清晰完整即可，没有死板的要求，个人建议参照 CF 的题目来写输入输出格式，具体可以参考 cf 出题人须知。 需要特别注意的是，如果输出中含有小数，请尽量使用 SPJ。如果无法使用 SPJ，请保证对精度的要求是有限的。 如果没有保证，对精度的要求可能是无限的。例如：要求保留三位小数，实际答案为 $0.0015$，此时只要有任意大小的误差导致计算出的答案小于 $0.0015$，即使计算出的答案是 $0.0014999999999\cdots$ 也会输出错误的答案。 保证对精度要求有限的例子：请输出答案四舍五入后保留小数点后三位的结果。令标准答案为 $ans$，数据保证对于任意满足 $\frac{|x-ans|}{\max(1,ans)}&lt;10^{-9}$ 的 $x$，四舍五入后结果与 $ans$ 四舍五入后相同。 可以参考的一些句子： 1输入的第一行包含三个正整数 $n$, $m$, $k$ ($1\le n,m\le 2\cdot 10^5$, $1\le k\le 100$) — $n$ 表示数列的长度，$m$ 表示操作个数，$k$ 的意义见题目描述。 1输入的第二行包含 $n$ 个非负整数 $a_1,a_2,\ldots,a_n$ ($1\le a_i\le 10^9$) — 题目给出的数列。 1接下来的 $m$ 行中的第 $i$ 行包含两个正整数 $l_i$ 和 $r_i$ ($1\le l_i\le r_i\le n$)，表示第 $i$ 次操作在区间 $[l_i,r_i]$ 上进行。 123接下来的 $n-1$ 行，每行包含两个正整数 $u$ 和 $v$ ($1\le u,v\le n$)，表示 $u$ 和 $v$ 之间由一条边相连。数据保证给出的边能构成一棵树。 1输入的唯一一行包含一个由小写英文字母构成的非空字符串，其长度不超过 $10^6$。 1输入的第二行包含一个小数点后不超过三位的实数 $x$ ($-10^6\le x\le 10^6$)，意义见题目描述。 1输出包含一个实数，当你的输出与标准答案之间的绝对误差或相对误差小于 $10^&#123;-6&#125;$ 时视作正确。 123输出的第二行包含 $n$ 个正整数，表示你构造的一组方案 — 其中第 $i$ 个数表示你打出的第 $i$ 张牌的编号。如果有多组合法的答案，可以任意输出其中一组。 数据范围按照 CF 的要求，数据范围要写在输入格式里，但在国内，数据范围往往是写在题目的最后的。 数据范围中最容易犯的错误就是不完整。输入中的每一个数、每一个字符串都应该有清晰的界定。在上文所给出的输入输出格式示例中就有一些数据范围的正确写法。 数据范围的常见遗漏： “整数”中的“整”。 题面中只说了是“整数”没说是“正整数”，并且数据范围中只有上限没有下限。 字符串没说字符集。 实数没说小数点后位数。 某些变量没有给范围。 你需要保证标程可以通过满足题面所述数据范围的任何一组数据。 样例样例应当有一定的强度，能够查出一些简单的错误。读错题意的人应当能够通过样例发现自己读错了题意。 有多种操作的题，每种操作都应在样例中出现。 有多种输出的题（如 CF 1173A Nauuo and Votes），每种输出都应在样例中出现。例外：实际上不可能无解，但要求判断是否有解的题目。 样例解释题目描述越复杂、越不易理解就越应当有详细的样例解释。 题目难度越简单就越应当有详细的样例解释。 详细的样例解释可以选择配上图片。 较大的样例可以没有样例解释。 为了照顾色觉障碍者，最好不要使颜色成为理解样例解释所必备的。可以用彩色图片来美化样例解释，但如果一定要用颜色传递一些必要的信息，最好不要同时出现红黄或者红绿。 时限、空间限制与部分分时限与空间限制的目的是卡掉复杂度错误的做法。（当然，也是为了防止评测用时过长，如：只对交互次数有限制而对时间复杂度没有限制的交互题也有时间限制。） 因此，原则上时间限制应当选取不使错误做法通过的尽量大的值。 一般地，时限应满足以下要求： 至少为 std 在最坏情况下用时的两倍。 如果比赛允许使用 Java，应使 Java 能够通过。 不应使错误做法通过（实在卡不掉、想放某种错解过除外）。 为了更好地在放大常数做法过的同时卡掉错解，一般可以采用同时增大数据范围和时限的方法。但要注意，有时正解（由于缓存等玄学问题）会在数据范围增大时有极大的常数增加，此时增大数据范围不一定能够增大正解与错解之间用时的差距。 在有部分分的赛制中，还可以通过设置有梯度的数据、数据范围稍小的数据来使较为优秀的错解和大常数正解不能通过，同时使其获得较高的部分分。 需要注意的是，在数据范围小于 $5\cdot 10^5$ 时，应当考虑是否能使用指令集通过。 一般情况下空间限制应当设置的足够大，除非空间复杂度更优的做法的确十分巧妙，值得卡掉空间复杂度大的做法。这种情况下可以考虑设置空间限制较松的部分分。值得注意的是，如果不想卡掉空间消耗较大的做法，数据结构题一般需要设置较大的空间限制。 一道好题应该具有它的选拔性质，具有足够的区分度。应该至少4档部分分，让新手可以拿到分，让高手能够展示自己的实力。 —— vfk《UOJ精神之源流》 部分分一般分为较小数据范围与特殊性质两种。 较小数据范围一般要设置多档，即使你想不到某种复杂度的做法，也可以考虑给这种复杂度一档分。一般来说，为了避免卡常，可以设置一档极限数据除以二的部分分。 “数据有梯度”最好用多档部分分替代。 特殊性质部分分的设置要依具体题目而定。理想的特殊性质部分分应当是能够引导选手思考正解的。与较小数据范围部分分不同，在你不会针对某种特殊性质的做法时，最好不要给这种特殊性质一档分。例如：[CTS2019]随机立方体 的 $k=1$ 这档部分分在讲题时就被很多人吐槽，称这档部分分妨碍了思考正解。 如果不是测试点等分且总分为测试点得分相加（如：绑 Subtask 测试），一定要在题面中说明。 数据数据的多样性与强度在不绑 Subtask，按测试点给分时，本部分内容可以酌情不遵守。 数据中应当包含每个变量的最小值与最大值。 数据中应当包含各种各样的构造，即使你不知道什么错解会挂在这组构造上。 当然，如果你已知一个（正常人能想的到、写的出的）正确性有问题的错解，要尽量卡掉它。（时间复杂度有问题的错解已在上文讨论过了。） 需要特别提醒的是，如果有整型溢出的可能，一定要卡掉会溢出的做法。在有部分分的赛制中，不应使不开 long long 的人得到和暴力一样甚至更低的分数。 如果有 pretestspretests 应尽量强（，同时尽量少）。换言之，你需要在 pt 中（用尽量少的数据组数）包含该题的所有已知叉点。（括号中为个人观点。） 如果你希望出现少量而非没有 fst，你可以问问 Sooke 对这件事的看法（Sooke 曾经坚称“fst 是 CF 的灵魂”，在我的强烈要求下，在 CF1172A Nauuo and Cards 中，他构造了许多数据，在 pt 中卡掉了所有已知错解，最后，这题在比赛中 Div.2 的 fst 率为 $18.5\%$）。 使用 testlib.h 造数据在平常的出题中使用 Polygon 可能不是最为方便的选择（事实上如果是多人协作出题，即使不是出 cf，使用 Polygon 依然是非常棒的选择），但 Polygon 为我们提供的出题方式十分值得借鉴。 简而言之，在 Polygon 中，数据要么是手造，要么由 generator 生成。而这个 generator 使用 testlib.h，并且使用命令行参数来设置数据范围、构造类型等参数。 使用 testlib.h 的好处是，它内置了随机数生成器 rnd.next()，它在不同平台上返回同样的结果，并且其种子是基于整个命令行参数生成的，不用手动设置种子，并且在参数一样时生成的数据总是一样的。 使用命令行参数的好处是，你可以写一个 .bat 文件（或者 Linux 下的 .sh 文件），把生成数据的命令写进去，可以十分方便地生成数据。 一个简单的 generator 例子： 123456789101112131415161718192021222324252627// gen.cpp#include "testlib.h"using namespace std;int n, m, k;vector&lt;int&gt; p;int main(int argc, char* argv[])&#123; registerGen(argc, argv, 1); int i; n = atoi(argv[1]); m = atoi(argv[2]); k = rnd.next(1, n); for (i = 1; i &lt;= n; ++i) p.push_back(i); shuffle(p.begin(), p.end()); // testlib.h 自带的 random_shuffle，使用 rnd.next() 进行 shuffle printf("%d %d %d\n", n, m, k); for (i = 0; i &lt; n; ++i) printf("%d%c", p[i], " \n"[i == n - 1]); // 把字符串当作数组用，中间空格，末尾换行，是一个造数据时常用的技巧 return 0;&#125; 12345gen 10 10 &gt; 1.ingen 1 1 &gt; 2.ingen 100 200 &gt; 3.ingen 2000 1000 &gt; 4.ingen 100000 100000 &gt; 5.in 官方 generator 教程。 如果你愿意，还可以写一个 validator。validator 是用来检查数据合法性的，在 cf 赛制中由于 hack 的存在是必备的，而在其它赛制中，validator 相当于给数据上了一道保险锁，个人十分推荐写一个 validator。 官方 validator 教程。 最后推荐一个我自己经常使用的生成输出文件的 bat： 12345678@echo offfor /R "%cd%" %%i in (*.in) do ( echo %%ivalidator &lt; %%iif errorlevel 1 pausestd &lt; %%i &gt; %%~ni.out)pause Special Judge输出方案题和输出浮点数题是两种较为常见的需要使用 SPJ 的题型，其它题目视情况也需要使用 SPJ。在 CF 上，所有题目都必须使用基于 testlib.h 的 checker，例如：题目要求输出若干个整数时，你可以任意输出空白字符（既可以空格也可以换行）。 checker 一般使用 testlib.h 编写，在 lemon 中也可以使用 testlib.h。一般来说，不使用 testlib.h 是很难写好 checker 的，因为你要应对各种各样的不合法输出，需要极强的鲁棒性。 编写 checker 需要注意以下两点： 你需要应对各种不合法的输出，因此，请检查读入的每个变量是否在合法范围中（readInt(minvalue, maxvalue)）。例如：读入一个在 check 过程中会作为数组下标的变量时必须检查其范围，否则可能引发数组越界，有时这会导致 RE，有时则可能判为 AC。 原则上 checker 中不应检查空白字符（即，不应使用 readSpace()、readEoln()、readEof()，值得一提的是，testlib.h 会自动检查是否有多余的输出）。 官方 checker 教程。 题解题解的目标是让预计会来参加比赛的人都能看懂。所以官方题解详细程度的要求会比一般的题解高。 关于部分分在有部分分的题目中，题解里可以考虑写一写部分分的做法。 关于知识点解题中用到的知识点应当写出来。对于一些难度和题目难度相当的知识点，最好给出学习该知识点的资料（比如一篇博客的地址）。“这样，再这样，然后用一些技巧就可以了”，而其中的“一些技巧”并不是谁都会的，这种情况要绝对避免。 关于定义题解中不要凭空冒出来一些概念。 例如：dp 的题解要解释清楚状态的定义。 再例如：cy 曾经写过一版 CF1172F Nauuo and Bug 的题解，其中对“分段函数”没有定义，这是绝对不可取的。 关于细节具体的实现细节如果比较巧妙最好写出来，否则的话“详见代码”也是可以的。如果“详见代码”的话，最好在代码中加上一定的注释。 标程标程中最好去掉冗余部分。比如，有人在题解中保留了完整的 define 模板（为了提高做题速度，包含大量 define 与常用函数，常用于 CF 等在线比赛），并且其中很大一部分都没有用到，这是不好的。 上文已经说过了，如果涉及到一些题解中没有详细说明的实现细节，最好加上适量的注释。 比赛比赛通知中的题目难度需真实感觉这个是比赛通知中比较需要注意的一点。 如果不会评难度可以不评.. Remember that authors tend to underestimate the difficulty of their problems. —— Codeforces PROPOSE A PROBLEM 页面的提醒 需要特别强调的是，如果你以 CF 的难度来进行类比（如：该比赛为 Div.2 A ~ Div.2 E 难度），不仅是难度需要与 CF Div.2 类似，题型也应当是 CF 风格。 题目难度的分配在类国内 OI 的模拟赛中，往往是三道题的整体难度与比赛难度相当即可。 在类 CF / ATC 这种线上赛的比赛中，需要尽量保证难度的递增（虽然由于对难度的误估很多时候都并不能真正做到），并且尽量避免出现大的 difficulty gap。可以通过把一题分为难易两题（两个 Subtask）来减少 difficulty gap。 题目知识点的分配一场比赛应尽量涵盖较广的知识点（专题训练赛当然除外）。 经典反例：涵盖了动态规划、期望、组合计数、容斥原理、多项式等多种知识点的 CTS2019。（组题人：我要从五道题里选六道，我也很无奈啊。） 参考资料 vfk《UOJ精神之源流》 王天懿《论偏题的危害》 cf 出题人须知 vfk 博客中的CF出题人的自我修养]]></content>
      <categories>
        <category>出题</category>
      </categories>
      <tags>
        <tag>出题规范</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ2460 [BJWC2011]元素（线性基，贪心）]]></title>
    <url>%2FBZOJ2460-BJWC2011-%E5%85%83%E7%B4%A0%EF%BC%88%E7%BA%BF%E6%80%A7%E5%9F%BA%EF%BC%8C%E8%B4%AA%E5%BF%83%EF%BC%89%2F</url>
    <content type="text"><![CDATA[题目链接洛谷 darkbzoj 题意简述给你 $n$ 个带权值的数（数和权值是两个东西），求一个权值最大的异或线性无关子集，即取这个子集的任意一个非空子集，异或和都不为零。 原题 $n\le1000$，实际上可以轻松 $n\le10^5$。数 $10^{18}$，权值 $10^4$。 简要做法看到这题，就随便贪心一下：按权值排序，插入到线性基所在的线性空间的元素集合里（说的这么绕口是因为“插入到线性基里”是一种极不严谨的表述，而且无法和真正的“插入到线性基里”区分开），如果插入到了线性基里，就把答案加上这个数的权值。 然后…过了？ 仔细一想发现也不难证。 首先，一堆线性无关的向量中，如果加进来一个线性相关的，一定可以删掉这些向量（包括刚加进来这个）中的某一个（并不是任意一个，但只要一个就可以了），让它们变得线性无关。这个性质在异或中可能不那么显然，但线性相关就相当于方程组中有一个多余的方程（可以由其它方程推出来），这时只要删掉一个方程就不会有多余的方程了，这样就是大家所熟知的了。 因此，考虑加入一个元素时删掉谁呢？当然是权值小的那一个。如果事先排好序，加不进去的时候不加就好了。 参考代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;typedef long long ll;typedef pair&lt;int, ll&gt; pil; const int N = 1010;pil a[N];ll p[70];int n, ans;int main()&#123; int i, j; scanf("%d", &amp;n); for (i = 1; i &lt;= n; ++i) scanf("%lld%d", &amp;a[i].second, &amp;a[i].first); sort(a + 1, a + n + 1); for (i = n; i &gt;= 1; --i) &#123; ll x = a[i].second; for (j = 59; ~j; --j) &#123; if ((x &gt;&gt; j) &amp; 1) &#123; if (p[j]) x ^= p[j]; else &#123; p[j] = x; ans += a[i].first; break; &#125; &#125; &#125; &#125; cout &lt;&lt; ans; return 0;&#125; 三倍经验[JLOI2015]装备购买 和 [CQOI2013]新Nim游戏 是两道和此题几乎完全一样的题，前者是用一个类似高斯消元的过程代替异或，后者要利用到 Nim 游戏的经典结论。]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>贪心</tag>
        <tag>线性基</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[线性基学习笔记]]></title>
    <url>%2F%E7%BA%BF%E6%80%A7%E5%9F%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[又是在网上搜不到讲的比较清楚的博客的算法…虽然没找到写的好的博客，但结合若干篇写的不算太差的博客，勉强是学会了.. 线性基在 OI 中特指集合为若干个非负整数，运算为异或的线性基，通常用来处理一些异或相关的问题。 线性空间百度百科说的就非常详细了，请完整阅读一遍。 3b1b 的视频也很不错，如果不了解线性代数相关知识可以看一看。（如果打不开可以尝试复制网址打开） 线性基的定义下文中的“线性基”均指 OI 中“线性基”的常见意思。 线性基所在的线性空间 元素集合：若干个非负整数（线性基可以说是关于若干个非负整数的，在有的教程中称其为“异或集合”）。 数域： $\{0,1\}$（也就是说，线性组合是选择一个子集异或起来，$0$, $1$ 就分别代表不选或选某个元素）。 元素间运算：异或。 数乘：普通的数乘。 线性基线性基就是上文所述的线性空间的一组基底，它具有以下性质： 在线性基中任取若干个元素，它们的异或不为零。即它们线性无关。 其所在线性空间中每个元素都有唯一的方案由线性基中元素异或得到。 选取线性基中若干个元素异或起来得到一个元素，用这个元素去替换原线性基中任意一个元素，得到的新线性基张成的空间不变。 可以发现这就是线性空间基底的性质和线性基所在线性空间的定义合在一起。 线性基的构造构造出的线性基额外满足的性质线性基中的每个元素的二进制最高位均不同，并且，我们称二进制最高位为第 $i$ 位的元素称为“线性基的第 $i$ 位”。 这个性质在构造和实际应用中非常方便，但要注意，它并不是线性基所在线性空间的基底所满足的必要条件。然而下文所述线性基均满足此性质，因为它真的很实用。 构造方式我们考虑如何在已有一组线性基的情况下，向线性空间的元素集合中插入一个元素。 插入新的元素后，我们需要满足： 线性基张成的空间中包含新插入的元素。 线性基仍然线性无关。 具体地，我们依次考虑新插入元素的每个为一的二进制位，若线性基不存在这一位，那么将这个新元素加入线性基中。 否则，将新元素异或上线性基的这一位，然后继续处理下一位。 因为插入一个元素等同于插入其异或上线性基中的一个元素，所以性质一满足。 从构造过程中就可以看出，已有线性基无法异或得到这个新元素，所以性质二满足。 参考代码： 123456789101112131415161718// p[i] 表示线性基的第 j 位for (i = 1; i &lt;= n; ++i)&#123; cin &gt;&gt; x; for (j = 60; ~j; --j) &#123; if (((x &gt;&gt; j) &amp; 1)) &#123; if (p[j]) x ^= p[j]; else &#123; p[j] = x; break; &#125; &#125; &#125;&#125; 线性基的经典应用判断一个数能否由若干数的子集异或得到假装你要把它插入到线性空间的元素集合中，看线性基是否需要新增元素即可。 最大子集异或和求出线性基，依次考虑线性基的每一位，若异或上能让答案更大（即答案的这一位为零）就异或上。因为如果不异或上，这一位就是零，无论后面的位如何，都比这一位为 $1$ 劣。 Luogu P3812 【模板】线性基 第 $k$ 小子集异或和需要构造特殊的线性基，满足线性基中有的位都只在线性基中的一个数中出现。例如：原线性基为 1100 和 0111，这时线性基中有 $2,3$ 两位，而第二位（$2^2$ 这一位）在 1100 和 0111 中都出现了，所以应该修改为 1011 和 0111。 这可以用一个类似于高斯消元的过程完成：处理第 $i$ 位时，依次考虑每个比 $i$ 小的线性基中的位，若第 $i$ 位的该二进制位为 $1$ 就异或这一位。除了先用普通方法构建线性基再转化，也可以在构建时就进行处理（详见代码）。无论哪种方式，复杂度都会再乘上一个额外的二进制位数。 得到这样一个具有特殊性质的线性基后，就可以构造第 $k$ 小子集异或和了：把 $k$ 二进制拆分，每一位的 $0$ / $1$ 对应异或时选 / 不选线性基存在的这一位（比如说，二进制位的 $2^3$ 位对应线性基中第四小的存在的位）。证明也很简单，线性基中存在的位的 0/1 唯一确定了一个异或出的数，由于每个位只在一个基中为 $1​$，这些位组成的二进制数的大小就可以代表异或出的数的大小。 LOJ #114. k 大异或和，毒瘤题，先不说题目名是假的，这个“非空集合”的限制非常的无聊..$0$ 本来就是线性基的线性组合之一，非要选“非空集合”，就得判一下给你的数中有没有能被其它线性基表示的数，实际上判一下线性基中元素个数是否为 $n​$ 即可。 参考代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cctype&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;typedef unsigned long long ull;const int N = 100010;int n, m, cnt;ull p[60], a[60];int main()&#123; int i, j; ull x, k; scanf("%d", &amp;n); for (i = 1; i &lt;= n; ++i) &#123; scanf("%llu", &amp;x); for (j = 51; ~j; --j) &#123; if ((x &gt;&gt; j) &amp; 1) &#123; if (p[j]) x ^= p[j]; else &#123; for (k = j - 1; ~k; --k) if ((x &gt;&gt; k) &amp; 1) x ^= p[k]; for (k = j + 1; k &lt;= 60; ++k) if ((p[k] &gt;&gt; j) &amp; 1) p[k] ^= x; p[j] = x; break; &#125; &#125; &#125; &#125; for (i = 0; i &lt;= 51; ++i) if (p[i]) a[cnt++] = p[i]; scanf("%d", &amp;m); while (m--) &#123; scanf("%lld", &amp;k); if (k &gt;= (1ull &lt;&lt; cnt) + (cnt != n)) &#123; puts("-1"); continue; &#125; if (cnt != n) --k; for (x = i = 0; i &lt; cnt; ++i) &#123; if ((k &gt;&gt; i) &amp; 1ull) &#123; x ^= a[i]; &#125; &#125; printf("%llu\n", x); &#125; return 0;&#125; 一些例题[SCOI2016]幸运数字，由于不带修，倍增维护线性基即可。用点分治可以一个 log 解决。 [BJWC2011]元素，贪心，从大到小判断是否能加入线性基。 [JLOI2015]装备购买，和上一题基本一样，就是把异或换成高斯消元。 [CQOI2013]新Nim游戏，结合 Nim 游戏经典结论，还是和上面两题一样的。 [WC2011]最大XOR和路径，异或的结果必然是一条链异或上若干个环，找出任意一条链以及只含一条返祖边的环即可线性基解决。 shallot，线段树分治维护线性基。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>线性基</tag>
        <tag>线性代数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bad round 与出题人的坚守]]></title>
    <url>%2Fbad-round-%E4%B8%8E%E5%87%BA%E9%A2%98%E4%BA%BA%E7%9A%84%E5%9D%9A%E5%AE%88%2F</url>
    <content type="text"><![CDATA[等你等了五千年，只为这一刹那的回眸一笑。 这句话作为台前幕后的标准开头应该是没问题的。 只不过果然还是写不出 vfk 的水平啊…写的比较散乱。而且是前后断断续续地写的，有的写于赛前，有的写于赛后，所以会有行文不连贯的地方，可能也会有后来忘记修正的地方。 前奏（借用一下 vfk 的标题 qaq） 一切源于一篇博客。 大约是这篇和这篇。 看到这篇博客的时候，是去年（2018）十二月，手里正有刚刚想到的一个 idea，也就是 1C —— Pictures。 当时我自己搞了个简单的随机图片，然后脑海里就冒出了这个 idea，虽然刚想出来的时候并不会做.. 然后就拿着去找 Sooke 了.. 我：您有兴趣看一眼我出的一道题吗？ Sooke：我会 $2^n​$。 Sooke：想出洛谷公开赛？ 我：不。 Sooke：想出 cf？ 我：嗯。 翻翻消息记录发现当时自己太天真了…（2 months 都算少的） 然后我在不会做的情况下第二天写了个英文题面.. 然后 Sooke 给我扔了套他出给 PJ 组的题，让我从里面挑给 Div.2，然后我挑了 2B —— Chess。一开始 Sooke 还想把它放在 2A.. ylh 想了道不错的 1A，然而后来因为树太多就换掉了.. 然后 PinkRabbit 加入了团队，把 Pictures 切掉了（其实花了 2h…只不过比赛和出题还是不一样的，应该有不少人 A？）。 之后莫名想到了 2A 的 idea，只不过题面一开始不是 upvote / downvote，是幼儿园里老师给小朋友发两种类型的糖果..后来感觉出 cf 用 upvote / downvote 挺合适的。 “我们这场要有交互题！” 我在群里喊出这句话，然后没过几天我就在洗澡的时候想到了 1D —— Binary Tree。一开始我还加了个它是堆的限制，过了几个月才想到可以 BFS…树剖的做法是 Sooke 想到的，之前我差点想用我的 nsqrtn 做 std。这道题是这样的，有一棵以 $1$ 为根的二叉树，你可以询问两点间距离，在 $n\log n$ 次询问内求每个点的父亲。 然后 ylh 想了个 1B，结果最后也没有被采用 qaq 这样六道题就齐了，然而果然还是不想出 div.2 only 鸭…到处找人要题没要到（包括后来出了两一题的 lk..），结果 lk 跟我说 lxl 可以出题。然后就有了 1F1E。lxl 说要自己写题面，然而一直咕了几个月都没写.. 然后..当时我们的想法是出五题场，把 pictures / binary tree 放 div.1，差点都提交 proposal 了，然而我还是觉得 1B 得换.. 然后，我去了雅礼集训，和 lk 面基了，就有了 1E —— GCD。一开始 GCD 是没有根号不带 log 做法的，可 lxl 问了 ccz，就有了。 然后 Sooke 出了一道 dl 的博弈论，我不太喜欢，然而一开始还是让它过了..最后还是给换了 qaq 后来 lk 出了 2C（一开始手牌和牌堆的牌不一定相等，我不会做，就改成了相等..），Sooke 拿出了 2D，这场就有了。 准备一开始我们还想抢 round 555 的（受 vfk 250 的影响 qaq）.. 给 300iq 发了个私信，问什么时候能审，能不能抢 555。然后.. 一开始还以为可以的，结果发现第一条才是真的，第二条是假的..（注意 cf 私信顺序从下往上） 我们之前出题的时候就几乎把 Polygon 上要干的事干完了，然而，Aleph0（round 551 出题人）发来了一份 cf 出题须知（不知道是不是 vfk 博客里提到那个长篇英语阅读..），然后发现一堆东西要改..只不过一两天也就改完了。最大的问题是数据要么纯手造要么用 generator，即不能用数据生成器生成出来放 Polygon 上..我自己造的数据还好，lxl 的数据 generator 的参数已经弄丢了，而且lxl 又特别咕。 听说 300iq 有 qq，所以就试着加了一下 300iq，拉进了群里。 然后是 300iq 开始审（gu）题（gu），题目比较顺利地全过审了，（然而断断续续的等了好几天），binary tree 获得了 “Great problem!” 的评价。得知必须放 Java 过，然而不需要让 Java 在一半时限内通过（尤指 GCD 这题，不然卡不掉带 log 做法了…），还是比较可以接受的.. 300iq 好像有验不完的题和无尽的 coordinating，所以经常失踪..contribution 只排第七举报了。 决定比赛时间真是件难事..从一开始的 round 555 抢不到，到 5.18 是 APIO &amp; 俄罗斯最后一轮国家队选拔（这俩是一个东西..），再到 5.21 ~ 5.26 得放弃 whk / sc 选手，然后 6.8 和 Google Code Jam 冲突，6 月一堆 whk 考试，7 月不仅太晚还有 ISIJ，NOI……无论选什么时间都会放弃一部分人，就像某部门决定调整某些政策一样。 最后还是端午节拯救世界..大家好像都比较同意 6.7。 从北京回来的高铁上，突然看到 Sooke 在群里“A big hug to 300iq!” 诶诶诶，上 contests 了！ 诶诶诶，之前开玩笑说的 0x233 真来了！ 于是想搞个什么宣传一下。 想了想感觉雀不错，就 p 了张图： 结果最后还是插进来一场 Div.2 … 0x233 没了… lxl 自己说要写题面，咕了两个多月，终于： 然后 xht37 和神仙 rushcheyo 都来验题了。听说所有题都被 rushcheyo 秒了.. 风怒Round #0x233 开始了。 Sooke：这个 F 也是树上问距离诶。 我：好像和 WC2018 即时战略有点像？ 再一看..非常冷静地在群里宣布，我们的 1D binary tree 没了。 UPD：Binary Tree 已上传至 GuOJ 和 LOJ。 二叉树被替换为了操作二，剩下的部分和我们题的做法完全一样——树剖。 感觉挺难受的..赛前四天撞题谁顶得住啊。而且我自己挺喜欢这题的，感觉做法非常巧妙。而且我们的题不给出树的形态，有的做法只能过那道题，不能过我们这题。 只不过 Sooke 之前就提过 Portals 这道题，于是就想换成 Portals。 一波未平，一波又起。 cy：这个 GCD 好像和一场中国比赛有点像。 然后扔上来一篇题解，求的东西不一样，但做法大同小异。 ok，风怒撞题。 然后群里就各种方案了.. cy 扔上来了四道题.. lk：我去找 _rqy 要一道计数！ lxl：第十一分块！ 于此同时，我们发现 Portals 原来想的做法是假的，给 300iq 也没能切掉.. 当时有点想出五题场，或者强行把 GCD 出出来，毕竟不完全一样。 只不过好消息还是传来了，Sooke 想到了 Portals 的正解，Bug（其实我现在想换这题名字了，还是 modadd 好听）的分块做法和线段树做法也相继有了。 然后，经过讨论，我们不知道为什么觉得换题之后码量比原来减少了，结果就决定把时间改成 2h。 lk 坚持认为 portals 是一道非常难的题。cy 给 portals 的评分比 1EF 都高。最后还是放在了 1D。然后赛后被喷 PJ 题放 1D。最后每题 AC 人数还是单调下降的，说明题目顺序安排的没有任何问题。关于 cards 和 circle，我们是认为对于 div.2 选手 circle 更难，而 div.1 选手顺切无所谓，所以就这样放了。而且 circle 更简单也可能是对于中国选手。而且我们这场每个偶数题都比前一题好写。 因为 cy 把 lxl 题切了，modadd 做了比较久，而且 lxl 和 300iq 都认为 modadd 更难，而且我看了题解之后会做 lxl 题不会 modadd，所以就把 modadd 放在了 F。 于是比赛的题目得到了最终的确定，也就是大家看到的这几题。 然后就是紧张的造题了。 写 modadd 题面里的伪代码时，去网上搜了半天，终于搞出来了一份特别丑的..然后想起来 3 LGM 那场 Chinese Round 的 G 有伪代码，就去找象要，结果没要到..自己研究了半天文档还是不会，就去找 zzq 要，然后顺利要到了。 由于自己本来就菜，又被长期的睡眠不足 + 极度紧张的造题给降智，我看了半天 cy 写的 modadd 题解都不会做..然后我要在不会做的情况下造数据..就胡乱造了一点。只不过这题就算纯随机应该也够强。 本来 lxl 题的数据也是个大问题，我自己是个链菊花随机完全二叉树出题人，lxl 又是只鸽子..幸好 300iq 帮忙造了一点数据，把 Spaly（单旋）也卡掉了。 大约在比赛前 2h，基本上所有东西都造完了。然后，KAN 突然在赛前 1h 出现，删掉了一堆题面里的逗号，提了一堆题面的 Issues..然后就不停修锅，差点都忘记发 scoring distribution 了。 赛前 5min 的时候终于把 KAN 提的所有 Issues fix 了.. 为了连贯性先讲了下造题的事。 然后是上帝视角..其实其它权限都没怎么用，只不过 ban 掉了 xht37 参加比赛（ 只不过有的选项看着很爽，比如，一开始 problems 是空的你可以 add problems（最后是 300iq 还是谁加的，那时我还在修锅），还有喜闻乐见的 Is it rated? 选项，rated 范围，能否查看排行榜，什么时候开始封榜，能不能 vp。 赛前在造锅和修锅之余，也会盯着 registrants 看。然后就看到 JOHNKRAM 报了，司报了，xyx 报了，myy 报了，ACRush 报了，_rqy 报了，txc 报了，Radewoosh 报了，800iq 报了，dmy 报了，kcz 报了，yyb 报了，ljh 报了，wqy 报了，yww 报了……群里大约就是上文去掉逗号，加上换行符和感叹号。 最后倒计时的时候真的就像 vfk 那篇博客一样。 还有 5 秒。 题面有锅吗？ 还有 4 秒。 数据有锅吗？ 还有 3 秒。 题面或者数据有锅吗？ 还有 2 秒。 题面和数据有锅吗？ 还有 1 秒。 有锅也修不了了，contribution 见鬼去吧！ ….. 没办法，赛前 5min 还在修锅的我就是这么想的..只不过最后除了 circle 的样例解释没什么锅。 比赛比赛就这么开始了。cf 并没有卡诶。 Div.1 怎么卡住了.. 完了，史上最难 1A 实锤了.. 6min 的时候终于有人过了 1A，div.2 那边已经成片过 A 了。 然后第二个 div.1 AC 是 B..完了，要被喷 swap(A, B) 了。 25min 的时候有人过 1D 了。赛前我就奶过 portals 一血会比 pictures 早，lk 还不信。 然后我们就看着司登顶之后一点点地往下掉.. 赛时真的可以看 system test 的结果，只不过评测优先度比较低。在 problems 界面还可以看到每题已经测了几个人的 st，其中有多少个过了。成功让 Sooke 学到了再强的 pt 也会有人 fst 这个道理。 当然我们还得回答参赛者的提问。 what mean is the draw the top card from the pile? 意思是 可以在最顶上的一张画画？ 海星，是不是可以画数字上去。 In Test 1 why is the output: 2 1 1 2 1 is wrong? I think it is legitimate. 一看评测记录，他第一行输出的 1，悲惨的故事。 问的最多的是 pictures 权值减到负怎么办..于是让 300iq 发了个 announcement。 还有一位坚称 cards 样例 3 答案是 16 的老哥，好像是在手上把牌排好序了。 Hi! I am a Chinese! Could you explain why there is a “19****17” in the sample 3? 回答分为 text，yes，no 和 no comments，正好可以回答他。 problem D in the example the edges for bad permutation are drawn incorrectly 嗯，额，诶？？woc 真的画错了..打开本地造 notes 的 pptx，发现是对的..这个锅 Sooke 背了。 赶紧让 300iq 发了个 announcement，然后去修锅。 修好了之后让 300iq 发个 fixed，结果一直没发.. 然后看到司在猛肝 1F..然后听群友们说，他写的是 1 log 正解，被卡常了..woc，那不是得去谢罪，卡分块把 treap 卡掉了..但我们不能做什么，只能为他默哀。后来才听说司写的 $\log^2$.. 300iq：check it out，https://codeforces.com/contest/1172/submission/55260499 。 然后之后半个小时几乎都在尝试卡他..然而根本卡不掉..赛后私信问他，也没太看懂他的做法，只不过他说他相信这个做法是对的.. 然后在迷迷糊糊的看榜，回答问题，尝试卡人中，2h 就这么过去了。 dmy 被我们送上黑红了，然而好多神仙被狙了.. 1F 的英文题解还没好..contribution 要没了。 果然比赛结束 announcement 的 up 就开始往下掉，只不过没掉很多。 有位神仙 hack 了 cards，而且是 hack 了过了 st 的..之后我才发现，我之前没意识到不打空白牌可能步数比求那个 max 还大，他的 test 就是针对这个卡的，如果你发现能直接 1~n 就输出答案就过了，如果把两者取 min 就挂了。 然后开始弄中文题解。hexo 博客折叠块总是漏掉百分号，漏掉引号，搞了半个多小时才搞好.. 搞了一整天，整个人都非常晕，然而这时我要尝试去写自己还不完全会的 1F 的英文题解..写到一半还是放弃了，就去发 editorial，先把 1F 空着了。 之后 300iq 同意帮忙写题解，就去睡觉了。 自我感觉 good problems, bad round。如果能不强求在原定的端午节把比赛出出来，或许能办的更好。 后记出这场 cf，究竟是为了什么。 肯定不是为了钱。虽然 cf 会发工资，但要是为了钱，我肯定不会去出 cf，要耗费的时间精力太多了。 真的不推荐其他人在退役之前去出 cf，不然的话，可能出着出着就退役了。 把这么多本可以用来刷题的时间用来出 cf，后悔吗？ 其实，也是一份宝贵的经历吧。与其说后悔，不如说害怕自己的努力不被人认可，如果数百小时的努力换来的是他人的批评甚至 unrated，可能就真的不只是后悔了。 出这场 cf，我得到了什么呢？ 以往的团队合作中，我要么是作为参与者而非组织者，要么其他成员都只是默默完成自己的任务。而且所谓的“团队合作”多半是学校里所谓的“研究性学习”。要统一各方面的意见，的确是一件难事。一开始面对“fst 是 cf 灵魂”的 Sooke（看来他负责的 cards 挺有灵魂的…），然后是“我一眼就切了”和“我想不到啊”的 lk，“来道大分块啊” 的 lxl，还有自说自话，不对自己说的话里提到的概念加以定义或解释，让人根本看不懂的 cy。协调各方的意见可能是一件需要学习的事情吧。 然后的话，也是影响比较大的，我对题目和出题人的要求提升了很多。回首自己之前在洛谷的两场公开赛，第一场漏洞满篇，满屏毒瘤，第二场也有不少的问题。出了 cf 之后，不仅是自己出题变得更加规范了，对自己做的题要求也更严了。国内很多题目质量堪忧，因为题目的外在（题面、题解、数据范围、输入输出格式）而非 idea 本身过于毒瘤而不想做题的事也会发生，抱怨其他题目、比赛成了家常便饭。但回首想来，我也是从一个毒瘤大模拟、无意义 dp 出题人成长起来的。 我讨厌不用心的出题人，讨厌不严谨甚至误导人的博客，因为，我认为出题给别人做、写博客给别人看是应当对别人负责的。如果没有精力、不想负责的话，出题给自己做，博客保存在本地就好了，发出来干什么？即使是能力不够，也得有认真负责的态度才行。如果没有，别人骂你，只当骂醒好了。如果骂不醒，那着实该骂。 一道好题应该被仔细推敲过。好题应该有很强的数据，好题应该有清晰的题面，好题的标程应该优美题解应该详尽。 一道好题不应该是两道题拼在一起，一道好题会有自己的idea —— 而它应该不加过多包装地突出这个idea。 一道好题应该新颖。真正的好题，应该是能让人脑洞出新的好题的好题。 一道好题应该具有它的选拔性质，具有足够的区分度。应该至少4档部分分，让新手可以拿到分，让高手能够展示自己的实力。 —— vfk《UOJ精神之源流》 当我指出其他人题目里的种种不足，当我抛开他人博客中不严谨的话语而豁然开朗大叫原文之漏洞满篇时，有没有想过他人付出的心血呢？当然有，只是我认为尊重不是基于付出，而是基于负责的态度，基于真正做了什么的。就好比你追一个女孩子，辛辛苦苦付出了那么多，如果不提升自己，如果不付出真心，别人凭什么喜欢你？ 说到底，对写给别人的东西负责，是我自己的一种坚守，我自己并不是总能做到，也不是生来就能做到。但我会努力去做，无论在怎样的大环境下，我想尽我所能创造一片小小的净土。 我们所可以自慰的，想来想去，也还是所谓对于将来的希望。希望是附丽于存在的，有存在，便有希望，有希望，便是光明。如果历史家的话不是诳话，则世界上的事物可还没有因为黑暗而长存的先例。黑暗只能附丽于渐就灭亡的事物，一灭亡，黑暗也就一同灭亡了，它不永久。然而将来是永远要有的，并且总要光明起来;只要不做黑暗的附着物，为光明而灭亡，则我们一定有悠久的将来，而且一定是光明的将来。 —— 鲁迅《记谈话》（十二省联考 2019 hope 题解） 说回这场 cf，我按照 cf 出题规范去出题，一遍遍地检查，直接原因当然是 cf 是如此要求的。但我这么去做，绝不只是为了过审，而是为了上千名参赛者，我认为我有理由以认真负责的态度，准备一场好的 cf，呈现给大家 —— 当然也包括正在读着这篇博客的你。 现在我也能够体会到 vfk 当时写《UOJ精神之源流》时的心情了。执著的坚守与残酷现实的矛盾，出题人与参赛者的隔阂，心中交杂的歉意与不甘……无论这场 cf 是否让你满意，我想，我做到了我应该做的，仍然走在自己一直坚持的那条路上。 尽管发生了一些意外，或许这场 cf 并不让你满意，但我认为，I did my best. 附：cf 出题须知 after 后记CF 的工资大约咕了一个月。 付款方式千万不要选 PayPal。]]></content>
      <categories>
        <category>出题</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces Round #564 中文题解]]></title>
    <url>%2FCodeforces-Round-564-%E4%B8%AD%E6%96%87%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[台前幕后 contest on CF 2A Nauuo and Votes题意 $x$ 个人 upvote，$y$ 个人 downvote，$z$ 个人随机 upvote / downvote，问最后总计 up 的多 / down 的多 / up = down / 结果不确定。 题解 考虑两种极端情况： 所有随机投的人都 upvote。 所有随机投的人都 downvote。 如果这两种情况结果一样，结果就是答案；否则结果不确定。 参考代码 123456789101112131415161718192021#include &lt;iostream&gt;using namespace std;const char result[4] = &#123;'+', '-', '0', '?'&#125;;int solve(int x, int y)&#123; return x == y ? 2 : x &lt; y;&#125;int main()&#123; int x, y, z; cin &gt;&gt; x &gt;&gt; y &gt;&gt; z; cout &lt;&lt; result[solve(x + z, y) == solve(x, y + z) ? solve(x, y) : 3]; return 0;&#125; 2B Nauuo and Chess题意 在一个 $m\times m$ 的棋盘上放 $n$ 颗棋子，第 $i$ 颗棋子的坐标为 $(r_i,c_i)$，需要满足 $|r_i-r_j|+|c_i-c_j|\ge|i-j|$，求 $m$ 的最小值以及任意一种摆放方案。 题解 $m\ge\left\lfloor\frac n 2\right\rfloor+1$ $\because\begin{cases}|r_1-r_n|+|c_1-c_n|\ge n-1\\|r_1-r_n|\le m-1\\|c_1-c_n|\le m-1\end{cases}$ $\therefore m-1+m-1\ge n-1$ $\therefore m\ge\frac{n+1}2$ $\because m\text{是整数}$ $\therefore m\ge\left\lfloor\frac n 2\right\rfloor+1$ $m$ 可以取到 $\left\lfloor\frac n 2\right\rfloor+1$ 在每一斜行放一颗棋子即可，即：$r_i+c_i=i+1$。因为 $|r_i-r_j|+|c_i-c_j|\ge|r_i+c_i-r_j-c_j|$。 参考代码 123456789101112131415161718#include &lt;cstdio&gt;using namespace std;int main()&#123; int n, i, ans; scanf("%d", &amp;n); ans = n / 2 + 1; printf("%d", ans); for (i = 1; i &lt;= ans; ++i) printf("\n%d 1", i); for (i = 2; i &lt;= n - ans + 1; ++i) printf("\n%d %d", ans, i); return 0;&#125; 1A Nauuo and Cards题意 $n$ 张带标号的牌和 $n$ 张空白牌，$n$ 张在手上剩下在牌堆里（牌堆有序），每次可以从手上选一张牌放牌堆底部并从牌堆顶部抽一张牌，需要使牌堆从上到下递增地放 $1$ ~ $n$，求最小操作数。 $1\le n\le2\times10^5$。 题解 首先尝试不打空白牌能否直接完成。如果能就是最优解，否则最优解一定是先打若干空白牌然后再也不打空白牌。计 $p_i$ 为 $i$ 在牌堆的初始位置（初始在手上为 $0$），那么答案为 $\max\limits_{i = 1}^n(p_i - i + 1 + n)$（每张牌最早在第 $p_i + 1$ 张被打出，还要打 $n-i$ 张）。 参考代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;const int N = 200010;int n, a[N], b[N], p[N], ans;int main()&#123; int i, j; scanf("%d", &amp;n); for (i = 1; i &lt;= n; ++i) &#123; scanf("%d", a + i); p[a[i]] = 0; &#125; for (i = 1; i &lt;= n; ++i) &#123; scanf("%d", b + i); p[b[i]] = i; &#125; if (p[1]) &#123; for (i = 2; p[i] == p[1] + i - 1; ++i); if (p[i - 1] == n) &#123; for (j = i; j &lt;= n &amp;&amp; p[j] &lt;= j - i; ++j); if (j &gt; n) &#123; printf("%d", n - i + 1); return 0; &#125; &#125; &#125; for (i = 1; i &lt;= n; ++i) ans = max(ans, p[i] - i + 1 + n); printf("%d", ans); return 0;&#125; 1B Nauuo and Circle题意 圆上画一 $n$ 点树，树给定，边要求直而不交，画法与排列一一对应，求方案数。 $2\le n\le 2\times10^5$。 题解 首先，如果选一个根使其变为有根树，可以发现每棵子树一定在一段连续的弧上。 考虑 DP，令 $f_u$ 为子树 $u$ 方案数，那么 $f_u=(|son(u)| + [u\ne root])!\prod\limits_{v\in son(u)}f_v$，$ans = nf_{root}​$。（先固定根的位置，每棵子树要为儿子排位置，如果非根自己也要参与排位置，然后再画子树。） 事实上不需要 DP，答案为每个点的度数阶乘之积乘上 $n​$。 参考代码 1234567891011121314151617181920212223242526272829#include &lt;iostream&gt;#include &lt;cstdio&gt;using namespace std;typedef long long ll;const int N = 200010;const int mod = 998244353;int n, ans, d[N];int main()&#123; int i, u, v; scanf("%d", &amp;n); ans = n; for (i = 1; i &lt; n; ++i) &#123; scanf("%d%d", &amp;u, &amp;v); ans = (ll) ans * (++d[u]) % mod * (++d[v]) % mod; &#125; cout &lt;&lt; ans; return 0;&#125; 1C Nauuo and Pictures题意 给你一个长度为 $n$ 的数列 $w_{1..n}$，其中有一些位置是”被喜欢的”，其它位置是“不被喜欢的”，进行 $m$ 次操作，每次随机选一个数，选到第 $i$ 个数的概率是 $\frac{w_i}{\sum_{j=1}^nw_j}$，如果选到一个“被喜欢的”位置，就会把这个位置上的数加一，否则减一。问 $m$ 次操作过后每个数的期望值，对 $998244353$ 取模。 $1\le n\le2\times 10^5$，$1\le m\le3000$。 题解 裸dp 先只看一个“被喜欢的”位置，这个位置的初始值是 $w$。 计 $SA$ 为“被喜欢的”数之和，$SB$ 为“不被喜欢的”数之和。 令 $f_w[i][j][k]$ 表示：现在 $SA=j$，$SB=k$，一个值为 $w$ 、“被喜欢的”位置经过 $i$ 次操作后的期望值。 边界情况：$f_w[0][j][k]=w$。 转移： 下一次操作选到了当前这个位置。概率：$\frac w{j+k}$。转移到：$f_{w+1}[i-1][j+1][k]$。 下一次操作选到了另一个“被喜欢的”位置。概率：$\frac{j-w}{j+k}$。转移到：$f_w[i-1][j+1][k]$。 下一次操作选到了一个“不被喜欢的”位置。概率：$\frac k{j+k}$。转移到：$f_w[i-1][j][k-1]$。 所以，$f_w[i][j][k]=\frac w{j+k}f_{w+1}[i-1][j+1][k]+\frac{j-w}{j+k}f_w[i-1][j+1][k]+\frac k{j+k}f_w[i-1][j][k-1]​$。 令 $g_w[i][j][k]$ 表示“不被喜欢的”的对应状态，计算方式类似。 这样大约能过简单版。 优化 有两个优化： $f_w[i][j][k]=wf_1[i][j][k]$ 证明： $i=0$ 时显然成立。 假设已经证明了 $f_w[i-1][j][k]=wf_1[i-1][j][k]$，就可以归纳地证明 $f_w[i][j][k]=wf_1[i][j][k]$： $\begin{aligned}f_1[i][j][k]&amp;=\frac 1{j+k}f_2[i-1][j+1][k]+\frac{j-1}{j+k}f_1[i-1][j+1][k]+\frac k{j+k}f_1[i-1][j][k-1]\\&amp;=\frac2{j+k}f_1[i-1][j+1][k]+\frac{j-1}{j+k}f_1[i-1][j+1][k]+\frac k{j+k}f_1[i-1][j][k-1]\\&amp;=\frac{j+1}{j+k}f_1[i-1][j+1][k]+\frac k{j+k}f_1[i-1][j][k-1]\end{aligned}$ $\begin{aligned}f_w[i][j][k]&amp;=\frac w{j+k}f_{w+1}[i-1][j+1][k]+\frac{j-w}{j+k}f_w[i-1][j+1][k]+\frac k{j+k}f_w[i-1][j][k-1]\\&amp;=\frac{w(w+1)}{j+k}f_1[i-1][j+1][k]+\frac{w(j-w)}{j+k}f_1[i-1][j+1][k]+\frac {wk}{j+k}f_1[i-1][j][k-1]\\&amp;=\frac{w(j+1)}{j+k}f_1[i-1][j+1][k]+\frac {wk}{j+k}f_1[i-1][j][k-1]\\&amp;=wf_1[i][j][k]\end{aligned}$ 还有一个比较简单但不那么严谨的理解方式：每一步期望的增量都与期望成正比。（这里被 _rqy 喷了，出题人就是菜，这个证明写不严谨。） 这样的话就只用计算 $f_1[i][j][k]$ 了。 注意到 $i,\,j,\,k,\,m$ 有一些联系。实际上可以令 $f’_w[i][j]$ 表示 $f_w[m-i-j][SA+i][SB-j]$（这里的 $SA$ 和 $SB$ 都是未操作时的初始值）。 令 $g’_1[i][j]$ 表示 $g_w[m-i-j][SA+i][SB-j]$，计算方式类似。 总结 $f’_1[i][j]=1\ (i+j=m)$ $f’_1[i][j]=\frac{SA+i+1}{SA+SB+i-j}f’_1[i+1][j]+\frac{SB-j}{SA+SB+i-j}f’_1[i][j+1]\ (i+j&lt;m)$ $g’_1[i][j]=1\ (i+j=m)$ $g’_1[i][j]=\frac{SA+i}{SA+SB+i-j}g’_1[i+1][j]+\frac{SB-j-1}{SA+SB+i-j}g’_1[i][j+1]\ (i+j&lt;m)$ “被喜欢的”位置答案是 $w_if’_1[0][0]$，“不被喜欢的”位置答案是 $w_ig’_1[0][0]$。 如果每次去算逆元就是 $\mathcal O(n+m^2\log p)$，预处理出来就是 $\mathcal O(n+m^2+m\log p)$。 参考代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;typedef long long ll;const int N = 200010;const int M = 3010;const int mod = 998244353;int qpow(int x, int y) //calculate the modular multiplicative inverse&#123; int out = 1; while (y) &#123; if (y &amp; 1) out = (ll) out * x % mod; x = (ll) x * x % mod; y &gt;&gt;= 1; &#125; return out;&#125;int n, m, a[N], w[N], f[M][M], g[M][M], inv[M &lt;&lt; 1], sum[3];int main()&#123; int i,j; scanf("%d%d", &amp;n, &amp;m); for (i = 1; i &lt;= n; ++i) scanf("%d", a + i); for (i = 1; i &lt;= n; ++i) &#123; scanf("%d", w + i); sum[a[i]] += w[i]; sum[2] += w[i]; &#125; for (i = max(0, m - sum[0]); i &lt;= 2 * m; ++i) inv[i] = qpow(sum[2] + i - m, mod - 2); for (i = m; i &gt;= 0; --i) &#123; f[i][m - i] = g[i][m - i] = 1; for (j = min(m - i - 1, sum[0]); j &gt;= 0; --j) &#123; f[i][j] = ((ll) (sum[1] + i + 1) * f[i + 1][j] + (ll) (sum[0] - j) * f[i][j + 1]) % mod * inv[i - j + m] % mod; g[i][j] = ((ll) (sum[1] + i) * g[i + 1][j] + (ll) (sum[0] - j - 1) * g[i][j + 1]) % mod * inv[i - j + m] % mod; &#125; &#125; for (i = 1; i &lt;= n; ++i) printf("%d\n", int((ll) w[i] * (a[i] ? f[0][0] : g[0][0]) % mod)); return 0;&#125; 1D Nauuo and Portals题意 在一个 $n\times n$ 的网格里放传送门，指定从第 $i$ 行进从第 $r_i$ 行出，从第 $i$ 列进从第 $c_i$ 列出，$r_{1..n}$ 和 $c_{1..n}$ 都是排列，求方案。 题解 考虑一个 $n*n$ 的问题如何转化成 $(n-1)\times(n-1)$：满足第一行和第一列。 如果已经满足直接变成 $(n-1)\times(n-1)$。 否则找到第一行中应该放在第一列那个和第一列中应该放在第一行那个，这两个位置各放一个传送门即可。 这题可以 $\mathcal O(n)$ 做，但 checker 要 $\mathcal O(n^2)$。 参考代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;const int N = 1010;struct Portal&#123; int x, y, p, q; Portal(int _x, int _y, int _p, int _q): x(_x), y(_y), p(_p), q(_q) &#123;&#125;&#125;;vector&lt;Portal&gt; ans;int n, a[N], b[N], c[N], d[N], ra[N], rb[N], rc[N], rd[N];int main()&#123; int i; scanf("%d", &amp;n); for (i = 1; i &lt;= n; ++i) &#123; scanf("%d", b + i); rb[b[i]] = i; &#125; for (i = 1; i &lt;= n; ++i) &#123; scanf("%d", a + i); ra[a[i]] = i; &#125; for (i = 1; i &lt;= n; ++i) c[i] = d[i] = rc[i] = rd[i] = i; for (i = 1; i &lt; n; ++i) &#123; if (c[i] == ra[i] &amp;&amp; d[i] == rb[i]) continue; ans.push_back(Portal(i, rc[ra[i]], rd[rb[i]], i)); int t1 = c[i]; int t2 = d[i]; swap(c[i], c[rc[ra[i]]]); swap(d[i], d[rd[rb[i]]]); swap(rc[ra[i]], rc[t1]); swap(rd[rb[i]], rd[t2]); &#125; printf("%d\n", ans.size()); for (auto k : ans) printf("%d %d %d %d\n", k.x, k.y, k.p, k.q); return 0;&#125; 1E Nauuo and ODT题意 给你一棵 $n$ 个点，点有颜色的树。一条简单路径的权值是其上颜色数，求所有简单路径的权值之和（路径有序，即 $u\rightarrow v$ 和 $v\rightarrow u$ 算两条）。带修，$m$ 次单点颜色修改，每修改一次输出一次。 $n,m\le 4\times10^5$，$7.5s$。 题解 对每种颜色分别考虑不含该颜色的简单路径条数。 令当前处理的颜色为 $c$，把颜色为 $c$ 的视为白色，不是 $c$ 的视为黑色，那么不含 $c$ 的路径条数就是每个黑联通块的大小的平方和，修改就是当颜色是 $c$ $\leftrightarrow$ 颜色不是 $c$ 时翻转一个点的颜色。所以，问题转化成了黑白两色的树，单点翻转颜色，维护黑联通块大小的平方和。这个转化后的问题可以用很多数据结构做，比如：lxl：top tree 随便维护。这篇题解里使用 Link/cut Tree. 对每个点维护子树大小，儿子大小平方和，在 link/cut 的时候更新答案即可。有一个大家熟知的 trick，就是每个黑点向父亲连边，这样真正的联通块就是 Link/cut Tree 里的联通块删掉根。 具体看图吧，图讲的挺清楚的： LCT 的部分就是这样，计算答案的时候先初始化一个全是黑点的树，离线处理每个颜色，处理完一个颜色反着改回去。 参考代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229#include &lt;algorithm&gt;#include &lt;cctype&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;typedef long long ll;const int N = 400010;struct Node&#123; int fa, ch[2], siz, sizi; ll siz2i; ll siz2() &#123; return (ll) siz * siz; &#125;&#125; t[N];bool nroot(int x);void rotate(int x);void Splay(int x);void access(int x);int findroot(int x);void link(int x);void cut(int x);void pushup(int x);void add(int u, int v);void dfs(int u);int head[N], nxt[N &lt;&lt; 1], to[N &lt;&lt; 1], cnt;int n, m, c[N], f[N];ll ans, delta[N];bool bw[N];vector&lt;int&gt; mod[N][2];int main()&#123; int i, j, u, v; ll last; scanf("%d%d", &amp;n, &amp;m); for (i = 1; i &lt;= n; ++i) &#123; scanf("%d", c + i); mod[c[i]][0].push_back(i); mod[c[i]][1].push_back(0); &#125; for (i = 1; i &lt;= n + 1; ++i) t[i].siz = 1; for (i = 1; i &lt; n; ++i) &#123; scanf("%d%d", &amp;u, &amp;v); add(u, v); add(v, u); &#125; for (i = 1; i &lt;= m; ++i) &#123; scanf("%d%d", &amp;u, &amp;v); mod[c[u]][0].push_back(u); mod[c[u]][1].push_back(i); c[u] = v; mod[v][0].push_back(u); mod[v][1].push_back(i); &#125; f[1] = n + 1; dfs(1); for (i = 1; i &lt;= n; ++i) link(i); for (i = 1; i &lt;= n; ++i) &#123; if (!mod[i][0].size()) &#123; delta[0] += (ll)n * n; continue; &#125; if (mod[i][1][0]) &#123; delta[0] += (ll)n * n; last = (ll)n * n; &#125; else last = 0; for (j = 0; j &lt; mod[i][0].size(); ++j) &#123; u = mod[i][0][j]; if (bw[u] ^= 1) cut(u); else link(u); if (j == mod[i][0].size() - 1 || mod[i][1][j + 1] != mod[i][1][j]) &#123; delta[mod[i][1][j]] += ans - last; last = ans; &#125; &#125; for (j = mod[i][0].size() - 1; ~j; --j) &#123; u = mod[i][0][j]; if (bw[u] ^= 1) cut(u); else link(u); &#125; &#125; ans = (ll) n * n * n; for (i = 0; i &lt;= m; ++i) &#123; ans -= delta[i]; printf("%I64d ", ans); &#125; return 0;&#125;bool nroot(int x) &#123; return x == t[t[x].fa].ch[0] || x == t[t[x].fa].ch[1]; &#125;void rotate(int x)&#123; int y = t[x].fa; int z = t[y].fa; int k = x == t[y].ch[1]; if (nroot(y)) t[z].ch[y == t[z].ch[1]] = x; t[x].fa = z; t[y].ch[k] = t[x].ch[k ^ 1]; t[t[x].ch[k ^ 1]].fa = y; t[x].ch[k ^ 1] = y; t[y].fa = x; pushup(y); pushup(x);&#125;void Splay(int x)&#123; while (nroot(x)) &#123; int y = t[x].fa; int z = t[y].fa; if (nroot(y)) (x == t[y].ch[1]) ^ (y == t[z].ch[1]) ? rotate(x) : rotate(y); rotate(x); &#125;&#125;void access(int x)&#123; for (int y = 0; x; x = t[y = x].fa) &#123; Splay(x); t[x].sizi += t[t[x].ch[1]].siz; t[x].sizi -= t[y].siz; t[x].siz2i += t[t[x].ch[1]].siz2(); t[x].siz2i -= t[y].siz2(); t[x].ch[1] = y; pushup(x); &#125;&#125;int findroot(int x)&#123; access(x); Splay(x); while (t[x].ch[0]) x = t[x].ch[0]; Splay(x); return x;&#125;void link(int x)&#123; int y = f[x]; Splay(x); ans -= t[x].siz2i + t[t[x].ch[1]].siz2(); int z = findroot(y); access(x); Splay(z); ans -= t[t[z].ch[1]].siz2(); t[x].fa = y; Splay(y); t[y].sizi += t[x].siz; t[y].siz2i += t[x].siz2(); pushup(y); access(x); Splay(z); ans += t[t[z].ch[1]].siz2();&#125;void cut(int x)&#123; int y = f[x]; access(x); ans += t[x].siz2i; int z = findroot(y); access(x); Splay(z); ans -= t[t[z].ch[1]].siz2(); Splay(x); t[x].ch[0] = t[t[x].ch[0]].fa = 0; pushup(x); Splay(z); ans += t[t[z].ch[1]].siz2();&#125;void pushup(int x)&#123; t[x].siz = t[t[x].ch[0]].siz + t[t[x].ch[1]].siz + t[x].sizi + 1;&#125;void add(int u, int v)&#123; nxt[++cnt] = head[u]; head[u] = cnt; to[cnt] = v;&#125;void dfs(int u)&#123; int i, v; for (i = head[u]; i; i = nxt[i]) &#123; v = to[i]; if (v != f[u]) &#123; f[v] = u; dfs(v); &#125; &#125;&#125; 1F Nauuo and Bug题意 给 $a$ 和 $p$，多组询问 $sum(a,l,r,p)$。 数列长度 $10^6$，询问次数 $2\times10^5$，值域 $-10^9$ ~ $10^9$。 题解 区间询问一般采用分块、线段树等方法维护，这些方法都要求我们单独求出较少个区间的答案后进行合并。我们考虑将 Sum 函数改成如下： 12345int sum(int l, int r, int p, int x) &#123; for (int i = l; i &lt;= r; ++i) x = modadd(x, a[i], p); return x;&#125; 固定 $p$ 和一个区间，sum 是一个关于 x 的分段函数，可以看出段数为 $O(r-l)$，因为 sum 的结果一定可以写成 $x+s_{l..r}-np$，其中 $s_{l..r}$ 是 $a_{l..r}$ 的区间和，随着 $x$ 的增大，$n$ 不会减小，而 $0 \le n \le r-l+1$，所以段数是线性的。 此时有一个简单的分块做法。将序列分为大小为 $B$ 的 $\frac n B$ 块，每块内预处理出这个块的 sum 函数后用一个存有每段端点的数组记录下来；计算这个函数的方法相当暴力，采用增量法，每次将已有的函数和单点合并后重构每段的起止端点，这将消耗 $O(\frac n B \times B^2=nB)$ 的时间。查询时用二分计算单点上函数的值即可，每次询问的时间是 $O(B+\frac n B \log B)$。认为 $n,q$ 同阶，取 $B=\Theta(\sqrt{n \log n})$ 时复杂度最优为 $O(n \sqrt{n \log n})$。 得到更好的时间复杂度需要一个观察：分段函数中每段的长度都至少是 $P$。证明考虑对区间长度 $n$ 归纳。当 $n=1$ 时由于只有两段，长度均为无穷大，显然；$n&gt;1$ 时考虑将前 $n-1$ 个形成的函数和最后一个合并。详细考虑合并的过程，对于 $f(x)=x+s_{1..n-1}-mP(a \le x \le b)$ 的段，$x + s_{1..n}-mP\ge P \to x \ge (m+1)P-s_{1..n}$ 的部分需要多减一次 $P$，从而会和下一段进行合并。考虑这段函数，减少了一个后缀 $[(m+1)P-s_{1..n},b]$，从上一段合并过来的增加了一段前缀 $[mP-s_{1..n},a]$，新的区间为 $[\min(a,mP-s_{1..n}),\min(b,(m+1)P-s_{1..n}-1]$，简单讨论可知长度仍然不小于 $P$。 我们改为采用线段树维护，查询区间被分解成 $O(\log n)$ 个线段树上区间，假如我们能求出所有线段树上区间的分段函数，即可每次查询 $O(\log^2 n)$ 时间解决。我们求解 $[l..r]$ 的函数时，考虑从 $[l..mid]$ 的函数 $f(x)$ 和 $[mid+1..r]$ 的函数 $g(x)$ 合并而来，合并后的函数即为 $g(f(x))$。我们在的分段函数 $f$ 上按 $x$ 升序扫描，维护 $f(x)$ 对应 $g$ 中的哪一段。当 $x$ 移向 $f$ 中的下一段时，我们从之前 $f(x)$ 的位置暴力移动向新的函数。注意每次移动到下一段 $f(x)$ 只是减 $P$，$f(x)$ 在 $g$ 中的位置会左移，但前面证明过所有段的长度都至少为 $P$，所以 $f(x)$ 的位置只会左移至多一段。当 $x$ 在 $f$ 的同一段中移动时，$f(x)$ 的位置只会右移，从而由均摊分析知道合并的时间是线性的。综上我们在 $O(n \log n+q \log ^2 n)$ 的时间内解决了本题，这是非常优秀的。 参考代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int N = 1000005;const ll inf = (ll)1e16;int n, m, P, a[N];ll sum[N];vector&lt;ll&gt; func[N &lt;&lt; 2];vector&lt;ll&gt; merge(int l, int r, int mid, const vector&lt;ll&gt; &amp;f, const vector&lt;ll&gt; &amp;g) &#123; ll suml = sum[mid] - sum[l - 1], sumr = sum[r] - sum[mid]; vector&lt;ll&gt; ret(f.size() + g.size() - 1, inf); for (int i = 0, j = 0; i &lt; (int)f.size(); ++i) &#123; ll xl = f[i], xr = (i + 1 == (int)f.size() ? inf : f[i + 1] - 1), yl = xl + suml - (ll)i * P, yr = xr + suml - (ll)i * P; while (j &gt; 0 &amp;&amp; g[j] &gt; yl) --j; while (j &lt; (int)g.size() &amp;&amp; (j == 0 || g[j] &lt;= yl)) ++j; --j; for (; j &lt; (int)g.size() &amp;&amp; g[j] &lt;= yr; ++j) ret[i + j] = min(ret[i + j], max(xl, g[j] - suml + (ll)i * P)); &#125; ret[0] = -inf; return ret;&#125;void build(int u, int l, int r) &#123; if (l == r) &#123; func[u].push_back(-inf); func[u].push_back(P - a[l]); return; &#125; int mid = l + r &gt;&gt; 1; build(u &lt;&lt; 1, l, mid); build(u &lt;&lt; 1 | 1, mid + 1, r); func[u] = merge(l, r, mid, func[u &lt;&lt; 1], func[u &lt;&lt; 1 | 1]);&#125;ll query(int u, int l, int r, int ql, int qr, ll now) &#123; if (l &gt;= ql &amp;&amp; r &lt;= qr) return now + sum[r] - sum[l - 1] - (ll)P * (upper_bound(func[u].begin(), func[u].end(), now) - func[u].begin() - 1); int mid = l + r &gt;&gt; 1; if (qr &lt;= mid) return query(u &lt;&lt; 1, l, mid, ql, qr, now); if (ql &gt; mid) return query(u &lt;&lt; 1 | 1, mid + 1, r, ql, qr, now); return query(u &lt;&lt; 1 | 1, mid + 1, r, ql, qr, query(u &lt;&lt; 1, l, mid, ql, qr, now));&#125;int main() &#123; scanf("%d%d%d", &amp;n, &amp;m, &amp;P); for (int i = 1; i &lt;= n; ++i) scanf("%d", a + i), sum[i] = sum[i - 1] + a[i]; build(1, 1, n); for (int l, r; m--;) &#123; scanf("%d%d", &amp;l, &amp;r); printf("%I64d\n", query(1, 1, n, l, r, 0)); &#125; return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用 testlib.h 写 lemon SPJ]]></title>
    <url>%2F%E4%BD%BF%E7%94%A8-testlib-h-%E5%86%99-lemon-SPJ%2F</url>
    <content type="text"><![CDATA[不用 testlib.h 是不可能写好 checker 的（逃 大约这样就可以了： 1234567891011121314151617181920212223#include &lt;fstream&gt;#include &lt;cstdlib&gt;#include &lt;cstdio&gt;using namespace std;ofstream fscore;char cmd[1000];int main(int argc, char * argv[])&#123; fscore.open(argv[5]); int score = atoi(argv[4]); sprintf(cmd, "testlibchecker %s %s %s %s", argv[1], argv[2], argv[3], argv[6]); if (system(cmd)) fscore &lt;&lt; 0 &lt;&lt; endl; else fscore &lt;&lt; score &lt;&lt; endl; fscore.close(); return 0;&#125; 注意 testlibchecker 实际使用时要使用绝对路径。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>评测</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[300iq奔北坡]]></title>
    <url>%2F300iq%E5%A5%94%E5%8C%97%E5%9D%A1%2F</url>
    <content type="text"><![CDATA[由于实在想不到这次是什么记了，所以就叫 300iq 奔北坡好了。 实际上是一篇 CTS &amp; APIO &amp; THUSC 2019 游记。 Arrival因为是去北京所以要二次安检，然后剪刀被收了..一开始还说我有两把剪刀，然后又过了一次安检就没有了..最后的结果是吃方便面的时候撕不开酱料包，用圆规戳开的。 车上先是在熟悉的文章、字符串和 Reverses 三道题上分别自闭，然后开始看题解，看 border 相关论文，然后就开始看 THUPC 的榜，然后不小心被 300iq 看到了 300iq_ben_bei_po。 到了之后，发现 Sooke 就比我们早到一点点——实际上比我们早一趟地铁左右。到酒店的时候办入住排队，Sooke 刚好就在我们几个人前面，然后就愉快地面基了。 下午去试机，现场写了一道我们那场 cf 的题，（证明了如果会做还是可以在场上写出来的）。 然后，从 Sooke 来试机起，简单教了一下 Sooke 用 noilinux，一起吃了晚饭，一起走回酒店，然后发现 Sooke 房间就在我隔壁，然后 Sooke 就待在我房间里了，准备看我打他验的那场 cf。 之前 THUWC 的时候试机坐 pr 右边的右边，这次又是来的时间差不多 + 住隔壁..比较神奇。 晚上智商比较掉线（可能和前一天没睡好略有关系），掉了波分。 CTS Day 1咕了 5min（为什么 cf 每次都是 35 开始） 开考前就注意到 T1 12s，原来是 10 组数据…（ctr：我本机 1.Xs，评测姬 6.Xs，怎么办啊） 第一眼就觉得 T1 的暴力好像不太会做，阶乘会挂。 然后去看 T2，3min 想到三方做法，然后又花了 3min 去掉一维，然后 10min 左右写 + 调完了 48 分。 T3 是个提答，（可能是雅礼集训那道五子棋的原因），我就直接搞了个估价函数，每次枚举所有可能的位置，选估价函数最大的那个。前三个点都是立刻出结果，第二个点只有 9 分，然后就把后面的点挂着跑。发现第四个点非常特殊，所以就数了一下每种块各有几个，然后直接在草稿纸上算出方案，然后若干个 for 循环输出。 然后，本来以为 T2 $m=0, 1, 2$ 的几个点要大力数据分治，然后发现如果 $n\ge d+2m-1$ 直接输出 $d^n$ 就好了.. 然后，发现 T3 后面的一个点跑了 1h 还没跑出来，于是就开始乱搞。先是调循环步长，发现还是跑的特别慢。然后就加了个剪枝，每一行找到第一个可以放的位置就放，快了很多。最后把两个点分别跑出来了 3 分和 4 分。 回去看 T1，发现一个剪枝搜索的方法（实际上和那个七方 dp 思路差不多…），然后写到一半想起来可以打表..最后写了个可以在 1s 内跑完一组的搜索，还是打了个表交上去。 最后是 $10+60+46$，被所有人踩了。 为什么我没想到 T1 的七方 dp 呢..当时脑子里大概是 $12\rightarrow2^n$，然而有三维，要 $2^{nml}$，做不了，不做了…（题解：一看就是指数级多项式算法） CTS Day 2又咕了 5min。 第一眼，T1 计几，考场不能开计几。 第二眼，T2 字符串！woc，还是个计数。 第三眼，T3 这是棵树！这边怎么还有反的.. 看了一圈还是感觉 T1 最可做…然而我先去推了一会儿 T2，没有任何成果。T3 的暴力也不会写.. 冷静了一下想到了 T1 $30​$ 分做法，就写了一个。考场上还算错复杂度了..只不过问题不大。 然后在三题之间轮流自闭，T1 猜到了凸包合并后更优肯定要合并，也写了个两两尝试合并，然而过不去样例三，就没管了。（95 分做法：随机合并，记录过程中最优解，直到快超时。） 快结束的时候写了个 T2 10 分爆搜，发现要跑 4s，然后就写了个字符离散化..实际上可以被类似 bdfhjlnprt 之类的串卡掉，只不过还是过了。 最后是 $10+30+0$，好像还挺大众（ CTS 其它讲题比较自闭..就记得 _rqy 自己上台吐槽两天四道计数，组题人（同时是 D1T3 出题人）说“我要从五道题里面选六道题，我也很无奈啊”。 另外首师大附中里的有张摄影的标题戳到我了…（不要说我中二）（也不要在意右边，那是手指挡住了） 录了个论文答辩。 最后闭幕式的时候 wh 和 dzd 的讲话还是非常精彩。譬如：知识点涵盖了容斥原理，动态规划，概率论……为什么要去掉这个 C 呢？没有钱是干不了这个活的，收的钱也不一定够 dzd 还抱着好像是某位博士的女儿上了台.. 在 cf 上抢了个评论。上午答辩完就差不多猜到了名单，然而不敢提前发，就提前写好了评论，一公布立马发出去了。感觉的确可以从答辩判断名单，某个 twr 硬是觉得有黑幕还被 up 了我就很没有办法。 cf 出题组全员 Ag。 APIO 讲课 Day 1上午缓存管理，下午 PJ dp ？？ APIO 考试开场 5min 就交了一发 WA..把 A 的暴力交错题了，一看发现纸质题面和实际顺序不一样（好像是翻译的时候还没给题目顺序…） 评测系统果然是不需要数据分治的，每个子任务分别提交就可以了，会分别在所有提交中取 max。只不过如果出现特殊情况，要由 CCF 来收题，这样写可能会比较惨.. 先把 T1 的暴力和无修改写了，然后把 T2 的 10 分写了，然后把 T3 暴力、询问长度一、零变一写了，然后把 T1 链写了。这些分好像都比较水..过程中想了会儿各种正解，写完的时候大约是 3h。 然后，感觉 T1 的树应该可做，然而不会做。T3 的修改在询问前好像也不太会。然后去看只有 10 分的 T2，怎么这么多 subtask，我一个都不会啊..然后，我发现好像有循环节，然后就是本场比赛最蠢的一个地方，我把循环节暴力跑出来，然后用 map 判下标..然后想了个特别麻烦的 5 分做法，一直调到考试结束… 最后分数就是前 3h 写的 $43+10+60$，一出考场发现所有人都是 243 / 203 … 说好的 100+ Au 呢？以后再也不能按往年分数线打比赛了… APIO 讲题 考虑让大象写题解 大象写了一篇题解 讲完了 APIO 讲课 Day 2上午是 THUWC 时来过的 lzj，又是图像渲染。 下午是四场讲题里最正常的一场（树上线性问题），前半部分是 希望的超详细题解 自顶向下 dp + 长链剖分，后半部分，后半部分是什么啊..好像是各种神仙题，比如树上线性（不带反阿克曼）并查集…… APIO 颁奖五页 113 艹，成功压线 Cu。 四页 203 Au 比 Ag 多艹。 Ag 前几都是神仙艹。 THUSC Day -1THUSC 电脑的用户名是 THUSC Day 0-Test、THUSC Day0、THUSC Day1-1 和 THUSC Day1-2。（为什么 Day -1 要提 THUSC 电脑用户名？因为今天是 Day -1。） 收到选手须知，划重点：WireShark，O3，python，Ubuntu 16.04，没写考试安排。 学一波 WireShark 好了。 结果颓了一整天 晚上 11 点睡了，好像很久没睡这么早了.. THUSC Day 0为什么 tdoj waiting 显示满分啊..一开始我还以为 pt 是假的（ 试机自闭了，sb 字符串二分想了无限假做法，开始怀疑自己的智商。 开营式全是硬广，感觉还是 THUWC 的有意思些，哦不对，那好像是闭幕式… 一进考场就发生了一件很神奇的事，94 和 96 中间没有 95..于是我换了一台机子。 比赛咕了 $40min$（传统艺能）。 开场看 T1，很快发现了（在没有操作 3 时）取空的情况只会发生不超过 $n$ 次，20min 的时候已经完全构思好了正解，然而不知道为什么以为操作 3 会破坏复杂度，就写了个 60 分..第一次尝试在草稿纸上完整地写下要维护哪些量，每个操作各要具体怎么修改怎么询问，写了半张草稿纸，然后写代码极其顺畅，1h 的时候就把 60 分部分分 1A 了。然后发现 $l=r$ 也很水，就写了个 $80$ 分的数据分治，然后各种挂，又过了 $40min$ 才写完，共 $6.2KB$。 然后看了眼 T2，$k=20\rightarrow2^k$，$\min\rightarrow minmax$ 容斥 $\rightarrow$ 不会做（鬼知道我怎么想的），然后去看 T3，侧信道攻击是什么啊..OI 题名全是骗人的.jpg。往后一看，好像还真是题目背景里说的那回事..好像不太可做，回去看 T2。woc 这不是个 sb 题吗…在最短路上就是 $dis[u][k]+dis[k][v]=dis[u][v]$，然后随手写了个 $3^k$——对每个救援队记录哪些点可以。然后发现改成对每个点记录哪些救援队可以，就可以轻松 $n2^k$ 了..pt 1A，然后就没管了。 犹豫了一下，决定还是先别侧信道攻击了，回来看 T1。woc 我又 sb 了，操作三不破坏复杂度啊，每次单点加最多把一个空的变成不空，所以还是只会有不超过 $n+m$ 次取空..于是在 $60​$ 分代码的基础上只加一个函数，其它全都不用改，就 pp 了。 然后去看 T3，这个 $10$ 分，可以枚举 $w$，枚举 $y$，枚举 $q$……诶，询问数超了，那就 get_w().. woc，直接 for (i = 0; i &lt; 500; ++i) Qs[i] = i; 不就可以了吗，我又 sb 了..把枚举删掉，写上 for 循环，一交，怎么爆零了？woc，没设置 $u$ 和 ​$v$…那后面的分怎么做啊..先 get_w() get_y() 吧..二分一下 $q$..怎么过不了啊..哦，是快速幂，所以 $time$ 并不关于 $q$ 单调..那就以二分结果为中心往两边爆搜吧..$subtask2$ 拿了 $16$，继续各种乱搞，拿不到分了，考试结束了。 感觉好像比较大众分啊..可能会被 T3（&amp; 可能比较弱的 pt &amp; 把 THUSC 当成 IOI 赛制打的选手）区分出来了。 大约在宾馆见识到了真正的“抽水马桶”…不是按，不是转，是抽.. 晚上睡得比前一天还早（ THUSC Day 1-194 和 96 中间还是没有 95… 比赛又咕了 $30min$。 开场，T1 不是 sb 题吗 $\rightarrow$ 没过 pt $\rightarrow $ 读错题了？$\rightarrow​$ 草，只有灯塔可以点亮..（鬼知道我为什么在点亮数轴（大约是以为每个点都有灯塔，只是一部分有游客吧.. 于是 20min 才把 T1 过掉（ 然后去看 T2，前两个 subtask 好像挺好写的..继续看 T3，考场上好像不能开计算几何来着（ 然而我还是开了..emm..这玩意不用取模诶..哦，好像每种本质不同的划分都可以用一条两圆公切线表示。但是，怎么求公切线啊..用各种方法算了一个小时，算出来的结果都很麻烦，感觉会算错，于是就没管了（然而降智的效果已经达到了 先写了前两个 subtask，然后发现好像可以处理出每个右端点向左种类数增加的地方，然后写了个假做法写自闭了，最后大致上想到了单调栈做法，然后好像是以为假掉了，也可能没太想清楚，最后写了个 $\mathcal O(nm^2)​$ 交上去… 成功被计几 &amp; 自己的假做法降智，被区分了，白给 $48$ 分。 THUSC Day 1-2果然是网络题.. 有了 WC 的经验，没仔细阅读学习手册直接开始做，还是写了 $1h$ T1.. T2 的 $8$ 分是 CRC32，WC 写过，然后..写了 $1h$，WA 了 $1h$。学习手册里的 CRC32 样例过了，输出中间结果 data 转 01 看起来也没什么问题..不知道怎么回事。 大众分好像是 $48$，㕛被区分了。 THUSC Day 2听说线 428 ？emm..成功被白给区分了。 只不过也没什么白给不白给的，就是不熟练才会白给，会做也没用啊. 网传线假掉了… 我妈在八点半接到我爸的电话，说我爸接到了 THU 电话… 然后，赶去西郊宾馆，等了 2.5h，好像是分块后按字典序排？中途还见到了在其它 SC 游记里听说过的搭矿泉水瓶。 面试大约是自我介绍 + 提问 + 嘤语阅读。毕竟我也是受了其他人游记一定的帮助，简单说一下需要注意的问题.. 自我介绍不需要提 OI 成绩。我一开始说我的 OI 成绩被打断了，好像是考官有成绩..（其实是看别人游记说教官提问“你的 OI 最好成绩”我才说的 qaq 提问会和自我介绍相关。反正我是这样的..比如，我自我介绍的时候提了一下对人工智能略有了解，就被问了有哪些了解、有什么看法之类的。所以建议自我介绍可以提一提自己熟悉的计算机科学领域，然后在相关方面准备一下可能的问题回答。 嘤语阅读要尝试看懂。大约是计算机科学专业文章，一开始会给你 $30s$ 左右看一遍，然后我当时只是想了想应该怎么读，没有仔细看。读了一遍之后他问我看懂了什么，然后就 GG 了..个人感觉这个部分是我面试挂的最惨的地方（ 下午讲题 + 科研 / 科协 / 蒜算协 介绍，感觉不如 WC 有意思..可能是时间比较短，而且也听过一遍类似的内容了..（有个人工智能简笔画妹子挺有意思的） 然后，荣获 3=，就去赶火车了..]]></content>
      <categories>
        <category>游记</category>
      </categories>
      <tags>
        <tag>清华营</tag>
        <tag>CCF系列赛事</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[回文自动机（PAM）学习笔记]]></title>
    <url>%2F%E5%9B%9E%E6%96%87%E8%87%AA%E5%8A%A8%E6%9C%BA%EF%BC%88PAM%EF%BC%89%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[PAM 是一种处理回文串相关问题的有力工具。 又是一句废话。 PAM 是什么？首先它是个自动机…PAM 是一个接受且仅接受某个字符串的所有回文子串的中心及右半部分的 DFA。 “中心及右边部分”在奇回文串中就是字面意思，在偶回文串中定义为一个特殊字符加上右边部分。这个定义看起来很奇怪，但它能让 PAM 真正成为一个自动机，而不仅是两棵树。 PAM 的状态及转移PAM 的每个状态都表示一个回文子串，其中包含两个特殊状态，$len​$ 分别为 $0​$ 和 $-1​$，它们分别作为偶回文子串和奇回文子串两棵树的根。 PAM 的转移表示在串的两侧各加上同一个字符，因此 $len​$ 也会加二。PAM 显然是分别以 $0​$ 和 $-1​$ 为根的两棵树，因为每个状态由唯一的状态转移而来（删掉两端的字符）。 和 SAM / AC 自动机一样，PAM 也有 $fail​$ 边，同样表示真后缀中在自动机里的最长状态（也就是最长回文真后缀）。 为了让 PAM 符合自动机的定义，可以在概念上从 $-1​$ 到 $0​$ 连一条特殊字符边，然后以 $-1​$ 作为起始状态。然而在代码实现里没有人会这么做。 PAM 的构建一个性质在一个字符串后添加一个字符，至多增加一个之前没有出现过的回文子串，且该回文子串必定是原串的一个回文真后缀两侧加上新添加的这个字符。 简单证明：如果新添加的字符处在多个回文子串内，找到最长的一个，剩下的都可以沿其中心翻折过去，所以一定出现过。 这个性质既说明了 PAM 的状态数是 $\mathcal O(n)​$ 的，也为后文的构建方法提供了依据。 基础构建法这是一个增量算法，即每次以均摊 $\mathcal O(1)​$ 的复杂度向 PAM 基于的字符串的末尾添加一个字符。 记上次达到的状态为 $p​$，字符串为 $s​$，当前添加的字符是字符串中第 $pos​$ 位，我们在 $p​$ 的 $fail​$ 链上找到最长的一个状态满足 $s[pos-len(u)-1]=s[pos]​$，那么当前到达的状态就是 $\delta(u,s[pos])​$，如果这个转移不存在则新建节点并连 $fail​$：在 $fail(p)​$ 的 $fail​$ 链上找到最长的满足上述条件的状态，其 $s[pos]​$ 转移即为新建节点的 $fail​$。特别地，如果 $p​$ 是特殊状态 $-1​$，新建节点的 $fail​$ 要设为 $0​$。 因为 $p​$ 和 $fail(p)​$ 都是在 $fail​$ 树上爬上爬下，其中每添加一个字符最多向下爬一次，所以复杂度是均摊 $\mathcal O(1)​$ 的。 当然如果用 map 存边复杂度就会带 log。 参考代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const int N = 300010;struct PAM&#123; int len, fail, ch[26];&#125; pam[N];void extend();char s[N];int n, p = 2, tot = 2, pos;int main()&#123; scanf("%s", s + 1); n = strlen(s + 1); pam[1].len = -1; pam[2].fail = 1; for (pos = 1; pos &lt;= n; ++pos) extend(); return 0;&#125;void extend()&#123; int x = s[pos] - 'a'; while (s[pos - pam[p].len - 1] != s[pos]) p = pam[p].fail; if (pam[p].ch[x]) p = pam[p].ch[x]; else &#123; int np = ++tot; pam[p].ch[x] = np; pam[np].len = pam[p].len + 2; if (p == 1) pam[np].fail = 2; else &#123; for (p = pam[p].fail; s[pos - pam[p].len - 1] != s[pos]; p = pam[p].fail); pam[np].fail = pam[p].ch[x]; &#125; p = np; &#125;&#125; 其它构建法PAM 还有支持前后端插入删除、复杂度不是均摊的构建方法，但我先咕着..感兴趣的话可以看 2017 国家候选队论文《回文树及其应用 翁文涛》。 一些例题[APIO2014]回文串，裸题。和其它自动机一样通过 fail 树子树和来统计出现次数。 CF835D Palindromic characteristics（注意原题数据范围较小，这题可以线性做），从 fail 链上 len / 2 处转移即可，我比较菜只会倍增所以多个 log。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>字符串</tag>
        <tag>PAM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CF17E Palisection（manacher）]]></title>
    <url>%2FCF17E-Palisection%EF%BC%88manacher%EF%BC%89%2F</url>
    <content type="text"><![CDATA[题目链接洛谷 CF 题意简述给你一个字符串，求有多少对相交的回文子串。（包含算作相交，自交不算） 字符串长度小于等于 $2\times 10^6$。 简要做法首先 manacher 求出每个中心的最长回文串半径。 然后，通过差分可以求出每个位置作为左端点 / 右端点各有多少个回文串（知道每个中心的半径之后就相当于区间加），记为 $l_i$, $r_i$。 最后，我们把问题转化为求不相交的回文子串对数，这样的话就是 $\sum\limits_{i = 2}^n\sum\limits_{j=1}^{i-1}l_ir_j$，预处理一下 $r​$ 的前缀和就可以算了。 参考代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;typedef long long ll;const int N = 2000010;const int mod = 51123987;char s[N &lt;&lt; 1];int n, p[N &lt;&lt; 1], mid, rt, l[N], r[N], pre[N], ans;int main()&#123; int i; scanf("%d%s", &amp;n, s + 1); s[0] = '$'; for (i = n * 2 + 1; i &gt;= 1; --i) &#123; if (i &amp; 1) s[i] = '#'; else s[i] = s[i / 2]; &#125; mid = rt = 1; for (i = 2; i &lt;= n * 2 + 1; ++i) &#123; p[i] = min(rt - i, p[mid * 2 - i]); while (s[i + p[i] + 1] == s[i - p[i] - 1]) ++p[i]; if (i + p[i] &gt; rt) &#123; mid = i; rt = i + p[i]; &#125; ++l[(i - p[i] + 1) &gt;&gt; 1]; --l[(i &gt;&gt; 1) + 1]; ++r[(i + 1) &gt;&gt; 1]; --r[(i + p[i] + 1) &gt;&gt; 1]; ans = (ans + (p[i] + 1) / 2) % mod; &#125; ans = (ll) ans * (ans - 1) % mod * (mod + 1) / 2 % mod; for (i = 1; i &lt;= n; ++i) &#123; l[i] += l[i - 1]; r[i] += r[i - 1]; pre[i] = (pre[i - 1] + r[i]) % mod; ans = (ans - (ll) l[i] * pre[i - 1] % mod + mod) % mod; &#125; cout &lt;&lt; ans; return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>字符串</tag>
        <tag>manacher</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CF432D Prefixes and Suffixes（KMP）]]></title>
    <url>%2FCF432D-Prefixes-and-Suffixes%EF%BC%88KMP%EF%BC%89%2F</url>
    <content type="text"><![CDATA[题目链接洛谷 CF 题意简述给你一个字符串，分别求出每个长度的既是其前缀又是其后缀的串出现的次数。 字符串长度小于等于 $10^5$。 简要做法第一眼，SAM 裸题。 然后意识到只用管前缀，KMP 可以达到同样的效果。 做法和 SAM 完全一样：从末尾跳 next 来找到所有前后缀相同的位置（也就是 SAM 的接受状态），然后倒序枚举 $f_{next[i]}+=f_i$（也就是 SAM 的统计子树和）。 多说两句：fail、parent 和 next 其实是一样的东西，但 KMP / AC 自动机的状态是所有前缀，SAM 的状态是所有子串（并被压缩为了 right 集合等价类）。 参考代码123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;using namespace std;const int N = 100010;char s[N];int n, nxt[N], stk[N], top, f[N];int main()&#123; int i, k; scanf("%s", s + 1); n = strlen(s + 1); for (i = 2, k = 0; i &lt;= n; ++i) &#123; while (k &amp;&amp; s[i] != s[k + 1]) k = nxt[k]; if (s[i] == s[k + 1]) ++k; nxt[i] = k; &#125; for (i = n; i &gt;= 1; --i) &#123; ++f[i]; f[nxt[i]] += f[i]; &#125; for (i = n; i; i = nxt[i]) stk[++top] = i; printf("%d\n", top); while (top) &#123; printf("%d %d\n", stk[top], f[stk[top]]); --top; &#125; return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>字符串</tag>
        <tag>KMP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CF494B Obsessive String (KMP,计数dp)]]></title>
    <url>%2FCF494B-Obsessive-String-KMP-%E8%AE%A1%E6%95%B0dp%2F</url>
    <content type="text"><![CDATA[题目链接洛谷 CF contest CF problemset 题意简述给你两个字符串 $S$ 和 $T$，你需要在 $S$ 中取若干个（至少一个）不相交的子串，使得每个子串都包含 $T$，求方案数模 $10^9+7$。 字符串长度小于等于 $10^5$。 简要做法首先用某种字符串算法求出 $T$ 在 $S$ 中匹配的所有位置（一般人都会选择 KMP）。 记 $|S|=n$, $|T|=m$。 然后，我们记 $p_i$ 表示 $[i+m,n]$ 中最小的匹配位置（也就是 $S[i+1..n]$ 这个子串第一个匹配的位置），记 $q_i$ 表示 $[1,i]$ 中最大的匹配位置（也就是 $S[1..i]$ 这个子串最后一个匹配的位置）。 然后开始 dp，令 $f_i​$ 表示子串 $S[i+1..n]​$ 的答案。转移时，我们考虑选择下一个子串的右端点和左端点。右端点可以在 $[q_i,n]​$ 中选取，而对于一个右端点 $j​$，可以选择的左端点有 $p_j-m-i+1​$ 个。另外，也可以不继续选择下一个子串。所以可以得到转移方程： $$f_i=1+\sum\limits_{j=q_i}^nf_j(p_j-m-i+1)$$ 如果我们把 $g_i=\sum\limits_{j=i}^nf_jp_j$ 和 $h_i=\sum\limits_{j=i}^nf_j$ 分别存下来，就可以得到 $f_i=1+g_{q_i}-(m+i-1)f_{q_i}$，然后就可以 $\mathcal O(n)$ 计算了。 最后，这样计算的话会把一个子串都不选计入总数，所以答案要减一。 参考代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;using namespace std;typedef long long ll;const int N = 100010;const int mod = 1e9 + 7;char s[N], t[N];int n, m, nxt[N], q[N], p[N], f[N], g[N];int main()&#123; int i, k; scanf("%s%s", s + 1, t + 1); n = strlen(s + 1); m = strlen(t + 1); for (i = 2, k = 0; i &lt;= m; ++i) &#123; while (k &amp;&amp; t[i] != t[k + 1]) k = nxt[k]; if (t[i] == t[k + 1]) ++k; nxt[i] = k; &#125; for (i = 1, k = 0; i &lt;= n; ++i) &#123; while (k &amp;&amp; s[i] != t[k + 1]) k = nxt[k]; if (s[i] == t[k + 1]) ++k; if (k == m) q[i - m] = p[i] = i; &#125; for (i = 1; i &lt;= n; ++i) if (!p[i]) p[i] = p[i - 1]; for (i = n; i &gt;= 0; --i) &#123; if (!q[i]) q[i] = q[i + 1]; if (q[i]) f[i] = (1 + g[q[i]] - (ll) f[q[i]] * (m + i - 1) % mod + mod) % mod; else f[i] = 1; g[i] = ((ll) f[i] * p[i] + g[i + 1]) % mod; f[i] = (f[i] + f[i + 1]) % mod; &#125; cout &lt;&lt; (f[0] - f[1] + mod - 1) % mod; return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>字符串</tag>
        <tag>KMP</tag>
        <tag>计数dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ1009 [HNOI2008]GT考试（KMP/AC自动机，矩阵乘法）]]></title>
    <url>%2FBZOJ1009-HNOI2008-GT%E8%80%83%E8%AF%95%EF%BC%88KMP-AC%E8%87%AA%E5%8A%A8%E6%9C%BA%EF%BC%8C%E7%9F%A9%E9%98%B5%E4%B9%98%E6%B3%95%EF%BC%89%2F</url>
    <content type="text"><![CDATA[题目链接洛谷 darkbzoj 题意简述给一个长为 $m$ 的字符串，字符集 $0$ ~ $9$，求长为 $n$ 的字符串中不含给定字符串作为子串的字符串有多少个，对 $k$ 取模。 $n\le10^9$，$m\le20$，$k\le1000$。 简要做法首先用 KMP / AC 自动机搞出转移：$f_{i,j}$ 表示从状态 $i$ （或者说位置 $i$，KMP 里就是位置，AC 自动机里虽然是节点但也和位置差不多）起，在后面加 $j$ 个字符，满足要求的字符串个数，则 $f_{i,j} = \sum\limits_{x=0}^9f_{tr[i][x],j-1}$，其中 $tr[i][x]$ 表示状态 $i$ 的字符 $x$ 转移。AC 自动机中不用解释了，KMP 里面就是 $tr[i][x]=\begin{cases}i+1&amp;(s[i+1]=x)\\tr[next[i]][x]&amp;(s[i+1]\ne x)\end{cases}$。 发现每层（相同的 $j$）的转移都是类似的，实际上可以用矩阵表示两层间的转移： $$A\times\begin{bmatrix}f_{0,j}\\f_{1,j}\\\vdots\\f_{m-1,j}\end{bmatrix}=\begin{bmatrix}f_{0,j+1}\\f_{1,j+1}\\\vdots\\f_{m-1,j+1}\end{bmatrix}$$ （只到 $m-1$ 是因为 $f_{m,j}=0$） 其中 $A​$ 是我们要求的一个矩阵，$A_{i,j}​$ 就是 $\sum\limits_{x=0}^9[tr[i][x]=j]​$，求出来之后矩阵快速幂就好了。 参考代码KMP1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cctype&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const int N = 21;int n, m, mod, nxt[N];char s[N];struct Matrix&#123; int a[N][N]; Matrix() &#123; memset(a, 0, sizeof(a)); &#125; int* operator[](int x) &#123; return a[x]; &#125; Matrix operator*(Matrix &amp; b) &#123; Matrix out; int i, j, k; for (i = 0; i &lt; m; ++i) &#123; for (j = 0; j &lt; m; ++j) &#123; for (k = 0; k &lt; m; ++k) &#123; out[i][j] = (out[i][j] + a[i][k] * b[k][j]) % mod; &#125; &#125; &#125; return out; &#125;&#125;;Matrix qpow(Matrix x, int y);int main()&#123; int i, j, k, ans = 0; Matrix mul; scanf("%d%d%d%s", &amp;n, &amp;m, &amp;mod, s + 1); for (i = 2, k = 0; i &lt; m; ++i) &#123; while (k &amp;&amp; s[i] != s[k + 1]) k = nxt[k]; if (s[i] == s[k + 1]) ++k; nxt[i] = k; &#125; for (i = 0; i &lt; m; ++i) &#123; for (j = 0; j &lt;= 9; ++j) &#123; for (k = i; k &amp;&amp; s[k + 1] - '0' != j; k = nxt[k]); if (s[k + 1] - '0' == j) ++k; ++mul[i][k]; &#125; &#125; mul = qpow(mul, n); for (i = 0; i &lt; m; ++i) ans = (ans + mul[0][i]) % mod; cout &lt;&lt; ans; return 0;&#125;Matrix qpow(Matrix x, int y)&#123; Matrix out; for (int i = 0; i &lt; m; ++i) out[i][i] = 1; while (y) &#123; if (y &amp; 1) out = out * x; x = x * x; y &gt;&gt;= 1; &#125; return out;&#125; AC 自动机如果觉得我的 AC 自动机写法比较清奇可以看看我的 AC 自动机学习笔记.. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cctype&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const int N = 21;int n, m, mod, tr[N][10], fail[N];char s[N];struct Matrix&#123; int a[N][N]; Matrix() &#123; memset(a, 0, sizeof(a)); &#125; int* operator[](int x) &#123; return a[x]; &#125; Matrix operator*(Matrix &amp; b) &#123; Matrix out; int i, j, k; for (i = 0; i &lt; m; ++i) &#123; for (j = 0; j &lt; m; ++j) &#123; for (k = 0; k &lt; m; ++k) &#123; out[i][j] = (out[i][j] + a[i][k] * b[k][j]) % mod; &#125; &#125; &#125; return out; &#125;&#125;;Matrix qpow(Matrix x, int y);int main()&#123; int i, j, ans = 0; Matrix mul; scanf("%d%d%d%s", &amp;n, &amp;m, &amp;mod, s + 2); for (i = 0; i &lt;= 9; ++i) tr[0][i] = 1; for (i = 1; i &lt;= m; ++i) &#123; tr[i][s[i + 1] - '0'] = i + 1; for (j = 0; j &lt;= 9; ++j) &#123; if (s[i + 1] - '0' == j) fail[i + 1] = tr[fail[i]][j]; else tr[i][j] = tr[fail[i]][j]; ++mul[i - 1][tr[i][j] - 1]; &#125; &#125; mul = qpow(mul, n); for (i = 0; i &lt; m; ++i) ans = (ans + mul[0][i]) % mod; cout &lt;&lt; ans; return 0;&#125;Matrix qpow(Matrix x, int y)&#123; Matrix out; for (int i = 0; i &lt; m; ++i) out[i][i] = 1; while (y) &#123; if (y &amp; 1) out = out * x; x = x * x; y &gt;&gt;= 1; &#125; return out;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>字符串</tag>
        <tag>AC自动机</tag>
        <tag>KMP</tag>
        <tag>矩阵乘法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ2434 [NOI2011]阿狸的打字机（AC自动机，树状数组）]]></title>
    <url>%2FBZOJ2434-NOI2011-%E9%98%BF%E7%8B%B8%E7%9A%84%E6%89%93%E5%AD%97%E6%9C%BA%EF%BC%88AC%E8%87%AA%E5%8A%A8%E6%9C%BA%EF%BC%8C%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%EF%BC%89%2F</url>
    <content type="text"><![CDATA[题目链接洛谷 darkbzoj 题意简述初始一个空串，三种操作： 添加一个字符。 删除一个字符。 打印当前字符串、 多组询问，每次问第 $x$ 个打印的字符串在第 $y$ 个打印的字符串中出现了几次。 操作数和询问数都不超过 $10^5$。 简要做法先建个 AC 自动机。 fail 树上的祖先是后缀，Trie 上根到一个点的路径是一个前缀，后缀的前缀是子串，因此只要把 Trie 上路径标出来，在 fail 树里统计子树就好了。也就是说，求出 $y$ 的所有前缀中以 $x$ 为后缀的数量。 具体来说，用 fail 树求 dfs 序，然后对 Trie 树进行 dfs，进入一个节点将其（在树状数组中）加一，退出时减一，把询问按 $y$ 存下来，访问到一个点时对以其作为 $y$ 的所有询问计算 $x​$ 在 fail 树中的子树和即为答案。 参考代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cctype&gt;#include &lt;queue&gt;#include &lt;vector&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;int read()&#123; int out = 0; char c; while (!isdigit(c = getchar())); for (; isdigit(c); c = getchar()) out = out * 10 + c - '0'; return out;&#125;typedef pair&lt;int, int&gt; pii;const int N = 100010;void modify(int p, int x);void add(int u, int v);void dfs1(int u);void dfs2(int u);int qsum(int p);int head[N], nxt[N], to[N], cnt;int n, m, tr[N][26], trie[N][26], tot = 1, fail[N], fa[N], id[N], BIT[N], dfn[N], dfntot, exi[N], ans[N];vector&lt;pii&gt; query[N];queue&lt;int&gt; q;char s[N];int main()&#123; int i, u, x, y; scanf("%s", s); for (i = 0; i &lt; 26; ++i) tr[0][i] = 1; for (i = 0, u = 1; s[i]; ++i) &#123; if (s[i] == 'B') u = fa[u]; else if (s[i] == 'P') id[++n] = u; else &#123; int c = s[i] - 'a'; if (!tr[u][c]) fa[tr[u][c] = ++tot] = u; u = tr[u][c]; &#125; &#125; memcpy(trie, tr, sizeof(tr)); q.push(1); while (!q.empty()) &#123; u = q.front(); q.pop(); for (i = 0; i &lt; 26; ++i) &#123; if (tr[u][i]) &#123; fail[tr[u][i]] = tr[fail[u]][i]; q.push(tr[u][i]); &#125; else tr[u][i] = tr[fail[u]][i]; &#125; &#125; for (i = 2; i &lt;= tot; ++i) add(fail[i], i); m = read(); for (i = 1; i &lt;= m; ++i) &#123; x = read(); y = read(); query[id[y]].push_back(pii(id[x], i)); &#125; dfs1(1); dfs2(1); for (i = 1; i &lt;= m; ++i) printf("%d\n", ans[i]); return 0;&#125;void dfs1(int u)&#123; dfn[u] = ++dfntot; for (int i = head[u]; i; i = nxt[i]) dfs1(to[i]); exi[u] = dfntot;&#125;void dfs2(int u)&#123; int i, v; modify(dfn[u], 1); for (i = 0; i &lt; query[u].size(); ++i) ans[query[u][i].second] = qsum(exi[query[u][i].first]) - qsum(dfn[query[u][i].first] - 1); for (i = 0; i &lt; 26; ++i) &#123; v = trie[u][i]; if (v) dfs2(v); &#125; modify(dfn[u], -1);&#125;void modify(int p, int x)&#123; for (; p &lt;= tot; p += (p &amp; -p)) &#123; BIT[p] += x; &#125;&#125;int qsum(int p)&#123; int out = 0; for (; p; p -= (p &amp; -p)) &#123; out += BIT[p]; &#125; return out;&#125;void add(int u, int v)&#123; nxt[++cnt] = head[u]; head[u] = cnt; to[cnt] = v;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>字符串</tag>
        <tag>AC自动机</tag>
        <tag>树状数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AC自动机学习笔记]]></title>
    <url>%2FAC%E8%87%AA%E5%8A%A8%E6%9C%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[AC 自动机其实我去年就学过了，但当时大约只是会敲模板而已..现在几乎全忘光了。于是复习一下，顺便（较为本质地）讲解一下。 AC 自动机是什么？说到这我真的想喷一下网上的各种教程..连“是什么”都不说清楚就开始讲“有什么用”和”怎么用“，怎能知其所以然？ 形式上，AC 自动机基于由若干模式串构成的 Trie 树，并在此之上增加了一些 fail 边；本质上，AC 自动机是一个关于若干模式串的 DFA（确定有限状态自动机），接受且仅接受以某一个模式串作为后缀的字符串。 并且，与一般自动机不同的，AC 自动机还有 关于某个模式串的接受状态（我自己起的名字..），也就是与某个模式串匹配（以某个模式串为后缀）的那些状态。 关于 DFA，我在 SAM 学习笔记里 已经讲过了。 引用一下 2006 年集训队论文《王赟–tire图的构造活用及改进》中的一张图： 有了 AC 自动机，我们把一个文本串逐位地输入到自动机中，当匹配时就会处于接受状态。 AC 自动机怎样构建？大致分为两个过程： 构建模式串组成的 Trie 树。 连 fail 边。 第一个过程不用讲吧。 fail 边是什么？fail 边是 AC 自动机上一种特殊的边，其意义为：当 $u​$ 在 Trie 树上没有字符 $c​$ 的出边时，将 $\delta(u,c)​$ 定义为 $\delta(fail(u),c)​$（特例：初始状态若不存在某字符出边则连向自己，也可以理解为 $\forall c\in\Sigma,\delta(fail(start),c)=start​$）。 另外，fail 边的作用类似于 KMP 算法中的 next 数组。 fail 边怎么连？我们发现一个状态的 fail 边连向的其实就是这个状态的一个自动机上最长真后缀。 为什么呢..感性理解一下，失配了就不看前几位了.. 然后就很好连了：对 Trie 树进行 BFS，将 $fail(\delta(u,c))$ 设为 $\delta(fail(u),c)$。因为一个串加上一个字符的最长真后缀就是这个串的最长真后缀加上这个字符.. 另外，将 $\delta(u,c)$ 设为 $\delta(fail(u),c)$ 可以显式地在代码中完成。 再另外，要么 BFS 开始的时候将根节点的孩子入队，要么将 $fail(root)$ 的每个儿子都设为 $root​$。否则根的儿子的 fail 边会连向自己。（也就是上文所述的“特例”。） 123456789101112131415161718for (i = 0; i &lt; 26; ++i) tr[0][i] = 1;q.push(1);while (!q.empty())&#123; u = q.front(); q.pop(); for (i = 0; i &lt; 26; ++i) &#123; if (tr[u][i]) &#123; fail[tr[u][i]] = tr[fail[u]][i]; q.push(tr[u][i]); &#125; else tr[u][i] = tr[fail[u]][i]; &#125;&#125; fail 树由于每个点都只连出一条 fail 边，且连到的点对应的字符串长度更小，所以 fail 边构成了一棵 fail 树。 如果学过 SAM 的话，可能会发现 fail 树和 parent 树很像..实际上它们具有的性质是相同的，然而构成它们的状态不同——parent 树是所有 right 集合等价类（也就是 SAM 上的所有节点），而 fail 树是 Trie 上的每个前缀（也就是 AC 自动机上的所有节点）。 作为一个自动机，我还没讲 AC 自动机的接受状态是哪些..其实就是 Trie 树上的那些终止节点在 fail 树上的整个子树的并。 而 关于某个模式串的接受状态，也就是与某个模式串匹配（以某个模式串为后缀）的那些状态，就是那个串在 Trie 树上的终止节点在 fail 树上的子树。知道这个也就知道怎么用 AC 自动机进行多模式串匹配了（建出 fail 树，记录自动机上的每个状态被匹配了几次，最后求出每个模式串在 Trie 上的终止节点在 fail 树上的子树总匹配次数就可以了）。 洛谷 P3796 参考代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;queue&gt;#include &lt;vector&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;typedef pair&lt;int, int&gt; pii;const int N = 160;const int L = 80;const int M = 1000010;void add(int u, int v);void dfs(int u);int head[N * L], nxt[N * L], to[N * L], cnt;int n, tr[N * L][26], fail[N * L], tot, suc[N * L], siz[N * L];char s[N][L], t[M];queue&lt;int&gt; q;pii ans[N];int main()&#123; int i, j, u; scanf("%d", &amp;n); while (n) &#123; memset(tr, 0, sizeof(tr)); memset(suc, 0, sizeof(suc)); memset(siz, 0, sizeof(siz)); memset(head, 0, sizeof(head)); tot = 1; cnt = 0; for (i = 0; i &lt; 26; ++i) tr[0][i] = 1; scanf("%d", &amp;n); for (i = 1; i &lt;= n; ++i) &#123; scanf("%s", s[i]); ans[i].first = 0; ans[i].second = i; for (j = 0, u = 1; s[i][j]; ++j) &#123; int c = s[i][j] - 'a'; if (!tr[u][c]) tr[u][c] = ++tot; u = tr[u][c]; &#125; suc[u] = i; &#125; q.push(1); while (!q.empty()) &#123; u = q.front(); q.pop(); for (i = 0; i &lt; 26; ++i) &#123; if (tr[u][i]) &#123; fail[tr[u][i]] = tr[fail[u]][i]; q.push(tr[u][i]); &#125; else tr[u][i] = tr[fail[u]][i]; &#125; &#125; scanf("%s", t); for (i = 0, u = 1; t[i]; ++i) &#123; u = tr[u][t[i] - 'a']; ++siz[u]; &#125; for (i = 2; i &lt;= tot; ++i) add(fail[i], i); dfs(1); sort(ans + 1, ans + n + 1); printf("%d\n", -ans[1].first); for (i = 1; i &lt;= n &amp;&amp; ans[i].first == ans[1].first; ++i) printf("%s\n", s[ans[i].second]); scanf("%d", &amp;n); &#125; return 0;&#125;void dfs(int u)&#123; int i, v; for (i = head[u]; i; i = nxt[i]) &#123; v = to[i]; dfs(v); siz[u] += siz[v]; &#125; ans[suc[u]].first -= siz[u];&#125;void add(int u, int v)&#123; nxt[++cnt] = head[u]; head[u] = cnt; to[cnt] = v;&#125; 一些例题[TJOI2013]单词，基本上是道裸题。 [POI2000]病毒，不访问接受状态找环即可。 [NOI2011]阿狸的打字机，对 Trie 进行 dfs 并打根到当前点的标记，在 fail 树上统计子树标记和。我的题解 与 KMP 之间的关系放在最后面是因为我认为 KMP 并不是 AC 自动机的前置知识..然而他们之间的确有着千丝万缕的联系。 「KMP 是个自动机」 要是早有人告诉我这句话估计我早就（真正地）学会 KMP 了.. KMP 自动机的主体是一条链，加上了一些“next 边”（其实就是 AC 自动机的 fail 边）。 而 KMP 自动机之于 AC 自动机，就像 SAM 之于广义 SAM。 也就是很多人常说的一句话：AC 自动机就是 Trie 上 KMP。 递归地计算转移函数简介“将 $\delta(u,c)​$ 设为 $\delta(fail(u),c)​$”这一步是可以不去显式完成的，并且，在绝大多数情况下（事实上我并不知道任何反例）这样做复杂度是线性的，可以将复杂度中的字符集大小去掉，并节省空间。 做法非常简单：当你需要 $\delta(u,c)$ 而其没有定义时，递归地去计算 $\delta(fail(u),c)$。 构建 fail 的过程复杂度为线性一个节点到根的路径上这些点总共跳 fail 的次数不会超过其深度。 所以总共跳 fail 次数不会超过 Trie 树所有叶子的深度和。 证完了。 将字符串输入进自动机复杂度为线性每输入一个字符串最多深度加一。 每次跳 fail 深度减一。 证完了。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>字符串</tag>
        <tag>AC自动机</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[NOI2010]航空管制（建反图，拓扑排序，优先队列）]]></title>
    <url>%2FNOI2010-%E8%88%AA%E7%A9%BA%E7%AE%A1%E5%88%B6%EF%BC%88%E5%BB%BA%E5%8F%8D%E5%9B%BE%EF%BC%8C%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F%EF%BC%8C%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97%EF%BC%89%2F</url>
    <content type="text"><![CDATA[题目链接洛谷 题意简述给你一个 DAG，每个点有个值 $k_i$。 第一问：求一个拓扑排序，使每个点出现的位置不超过 $k_i$。 第二问：在满足第一问的拓扑排序中，求每个点分别的最早出现位置。 简要做法第一眼看到这题，在多少之前 $\rightarrow$ 反过来考虑，因为之前好像做过 PJ 难度的类似题目.. 然而第二眼就变成了：拓扑排序裸题！然后愉快地写了个假贪心.. 不能随便放过自己的直觉啊.. 正解就是建反图，这样一定可以每次选 $k$ 最大的，用优先队列拓扑排序就可以了。 第二问的话，还是建反图，依次考虑每个点，不把当前考虑的点加入优先队列中，直到无法符合要求便是答案。 参考代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;queue&gt;#include &lt;cstring&gt;using namespace std;typedef pair&lt;int, int&gt; pii;const int N = 2010;const int M = 10010;void add(int u, int v);int head[N], nxt[M], to[M], cnt;int n, m, k[N], ind[N], in[N], stk[N], top;priority_queue&lt;pii&gt; q;int main()&#123; int i, u, v, x, ans; scanf("%d%d", &amp;n, &amp;m); for (i = 1; i &lt;= n; ++i) scanf("%d", k + i); for (i = 1; i &lt;= m; ++i) &#123; scanf("%d%d", &amp;u, &amp;v); add(v, u); ++ind[u]; &#125; memcpy(in, ind, sizeof(in)); for (i = 1; i &lt;= n; ++i) if (!in[i]) q.push(pii(k[i], i)); while (!q.empty()) &#123; u = stk[++top] = q.top().second; q.pop(); for (i = head[u]; i; i = nxt[i]) &#123; v = to[i]; if (--in[v] == 0) q.push(pii(k[v], v)); &#125; &#125; while (top) printf("%d ",stk[top--]); puts(""); for (x = 1; x &lt;= n; ++x) &#123; ans = n; memcpy(in, ind, sizeof(in)); for (i = 1; i &lt;= n; ++i) if (!in[i]) q.push(pii(k[i], i)); while (!q.empty()) &#123; u = q.top().second; q.pop(); if (u == x) continue; if (k[u] &lt; ans) &#123; while (!q.empty()) q.pop(); break; &#125; --ans; for (i = head[u]; i; i = nxt[i]) &#123; v = to[i]; if (--in[v] == 0) q.push(pii(k[v], v)); &#125; &#125; printf("%d ", ans); &#125; return 0;&#125;void add(int u, int v)&#123; nxt[++cnt] = head[u]; head[u] = cnt; to[cnt] = v;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>优先队列</tag>
        <tag>拓扑排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[十二省联考2019 游记 & 题解]]></title>
    <url>%2F%E5%8D%81%E4%BA%8C%E7%9C%81%E8%81%94%E8%80%832019-%E6%B8%B8%E8%AE%B0-%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[口中喊着「僕勝つから。ぜったい、勝て来るから。」的你，真的付出了桐山般的努力吗？ Day -1晚上看 WF 直播，为了看滚榜睡得很晚，结果最后滚的时候 b 站那几个直播的去海底捞吃火锅，然后断断续续的….最后也没有看完滚榜，还是第二天才看的排名… Day 0由于前一天睡得比较晚，所以下午睡了两个小时。晚上 vp 了一场 cf。 然后..本来想早点睡，结果由于下午睡了两个小时，睡不着了..最后很晚才睡。在床上看了四集半《三月的狮子》..（半是因为看困了，于是赶紧抓住机会睡了。） Day 1早上起来的时候感觉特别清醒，后来才想起来，初三有段时间也不怎么睡，也是刚起来的时候并不会很困..走起路来有种 ふわふわ 的感觉..一直持续到快到华科的时候，才稍微觉得有点困.. 拿到题之后看了眼 T1，异或 $\rightarrow$ 可持久化 01 Trie，求前 $k$ 大之和 $\rightarrow$ 分成 $n$ 类每类的最大值塞堆里。大致的思路真的是一眼就想出来了..然而并没有想到三元组的做法，虽然 18 年暑假去安师大附中集训的时候做过一道那样的题.. 我想的做法是记录在 Trie 上 dfs 到的位置，然后根据位置求下一个。一开始我写的是每个点记录父亲，然后写+调 $2h$ 才想起来：这是可持久化啊，怎么记录父亲…然后尝试加了个 map 来记录不同版本的父亲，变成 $\log^2$，然后大样例跑了 $13s$，还 WA… 于是就先把 T1 放了一下，去看 T2。这 T2 什么鬼题面？（赛后结合讲题 PPT 里的简述一下就明白题意了，可能是简述的原因，也可能是没睡好考场上 sb 了..只不过一个没有题目背景的题为什么不写简述题意呢..）看了半天稍微看懂题意了，然后一看第一档暴力，好像第一档就得写个 $20min$ ~ $0.5h$ 的..我的习惯是先写 PJ 难度暴力，然后写正解，最后写不好写的部分分，所以就先放着了。 然后去看 T3..没想到竟然能在考场上碰到 ydc 的题面..先把 998244353 切了，然后写了个从最大值起枚举模数，然后..1145141？唐 突 恶 臭，//echouctr 警告。赛后得知有人直接（抱着恶臭的想法）试出来了..还有只枚举质数的..想不明白为什么要给个质数..搞的我还写了扩展欧拉定理和求 $\varphi$（虽然也没有太麻烦..）。1_?+ 直接弃了。wa 尝试把快速幂里的 long long 去掉，然后没过，就也弃了。后面的..猜到了 p 是质数，根据 0/+/- 猜到了 u 是 $\mu$，猜到了 g 是原根..nmdwsm是区间筛啊.. 回来看 T1，重构的决定还算比较果断，换了种找后继的方式：记录 dfs 路径以及每个点被搜到的次数，满了就换个儿子，否则按原路径往下。写的还算比较顺利，不到 $1h$ 就过了大样例，然后开始对拍，也过拍了。然后，把 rand() 的范围开到 unsigned..不过拍了？？检查了一下，所有该开 unsigned 的地方都开了，于是把所有参与位运算的 1 都改成了 1u，还是过不了..然后我就开始 sb 了：先把 unsigned int 改成 unsigned long long，发现过不了，然后改回 unsigned int，再把循环的范围从 31 改成 32.. 然后我就各种检查，直到考试结束也没过拍..考后发现，是一种边界情况的一行代码放错位置了，除了同时开 unsigned long long 和循环范围 32，也可以把那行代码换个位置来解决。 下午得知正式选手好像必须参加讲题？看分，发现第一题竟然过了..脸挺好的。T2 puts("-1") 果然没分。T3 写多少是多少（废话，这种题..）。$100+0+19$，$rk6$，被吊锤了..在其他省就垫底了.. 晚上打了场 Global，神仙 Div.2 A~C &amp; Div.1 E/F 场..写完 A ~ E 之后发现所有人包括 tourist 都是五题，而且 tourist 在我之前半个小时就写完五题了..于是就不想打了。又过了快一个小时，发现有好多人在 hack A，于是就去看了下，hack 了一个写法奇怪的 A。最后涨了不少分.. 还好晚上顺利睡着了.. Day 2由于昨天调 T1 调的心态爆炸才去看后面的题导致整场爆炸，于是这次先看了每道题.. 看了看 T1，除了 dp 没啥想法，先写了个 $20$ 分暴力，准备把 dp 留到后面写。真的是 sb 了，没想到可以压两维，只压了一维.. 然后去看 T2，第一眼并没有什么想法..暴力连第二档都不太会写，于是先写了个 $\mathcal O(n^n)$。 然后去看 T3，emm..暴力怎么写啊.webp。 然后去上了个厕所。在厕所里想到了 T2 的做法..写的比较顺利，大概不到 $1h$ 吧..就第一次测挂了，改了个小地方就过了所有样例。然后对拍，也过拍了。然后测了下链..RE了？？冷静了一下，猜测是爆栈了，直接去问了监考，答复是栈空间和内存限制一样，然后就愉快地本地开栈过了。 然后去写 T1 的 dp..一开始尝试单数组滚动，然后挂了。于是改成 01 滚动，又调了好久才过.. 最后去写 T3，决定只写 $k=1$。先写了下 $k=1$ &amp; $l=n$ 的 dp，很快就写完了。然后去写剩下的 $k=1$，算了下复杂度，$\mathcal O(nl^2)$，感觉好悬..然后发现可以用 NTT 优化到 $\mathcal O(nl\log l)$，然后开始写 NTT，然后..NTT 没调出来..考前应该写一写的..因为比较头铁，NTT 一直调到了离考试结束 $15min$，然后开始 rush $\mathcal O(nl^2)$，失败了.. 出考场不久，想起来自己 T1 好像忘清空了..辣鸡温馨提示。然后我在影响正确性/不影响正确性之间反复切换了几次结论..最后在看成绩之前得出的结论是，我没有限制（$k=0$）的点稳挂，剩下的点大概率挂。 去看成绩，$20+100+8$。T1 竟然有 $20$？难道是 $k\ne0$ 的点都过了？听完讲题之后去看评测结果，发现是 $k=0$ 的两个点过了…至今没想明白，只不过如果清空了数组就是 $40$ 了。 最后是两天总分第四（和去年一样，白学了），加上 NOIP 还是被胡队爆踩了.. 晚上两天挂分 $100+$ 的裸罗队在裙里问为什么 D2T2 $75​$ 分，我把他的代码复制到 LOJ 发现过了.. 冷静了一下，感觉不可能是 OJ 的问题，所以不开 C++11 测了一下，果然没过..因为前几天写 OI Wiki 的时候查过，所以很快就猜到了，是 swap 的问题.. priority_queue 的 swap 在不开 C++11 时是 $\mathcal O(n)$ 的。 题解D1T1考场做法建可持久化 01 Trie，把区间异或和转化成两个前缀异或和的异或，然后对每个右端点就可以找到最大的异或和，扔进堆里。找最大值的时候记录一下在 Trie 上的路径，以及每一层经过的次数。堆里弹出一个值后插入下一个值时根据记录的路径来找：如果经过次数大于子树当前节点的 siz 就换个儿子并清空比他更深的节点的记录的经过次数，否则按记录的路径走。如果 Trie 的根都满了就不 push 了。 参考代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;queue&gt;#include &lt;map&gt;#include &lt;cctype&gt;#include &lt;algorithm&gt;using namespace std;int n,k;typedef unsigned int ui;typedef pair&lt;ui,int&gt; pui;ui read()&#123; ui out=0; char c; while (!isdigit(c=getchar())); for (;isdigit(c);c=getchar()) out=out*10+c-'0'; return out;&#125;const int N=500010;struct Node&#123; int val,ch[2];&#125; t[N*35];int rt[N],tot,d[N][35],cnt[N][35];ui pre[N];unsigned long long ans;priority_queue&lt;pui&gt; q;int ins(int x,ui y)&#123; int i,u,v,root; u=root=++tot; t[u].val=t[x].val+1; for (i=31;i&gt;=0;--i) &#123; v=((y&gt;&gt;i)&amp;1u); t[u].ch[v^1]=t[x].ch[v^1]; u=t[u].ch[v]=++tot; x=t[x].ch[v]; t[u].val=t[x].val+1; &#125; return root;&#125;signed main()&#123; scanf("%d %d",&amp;n,&amp;k); int i,j,u,v,r; ui x; for (i=1;i&lt;=n;++i) &#123; pre[i]=pre[i-1]^read(); u=rt[i]=ins(rt[i-1],pre[i-1]); for (x=0,j=31;j&gt;=0;--j) &#123; v=(((pre[i]&gt;&gt;j)&amp;1u)^1u); if (t[u].ch[v]) &#123; x|=(1u&lt;&lt;j); d[i][j]=u=t[u].ch[v]; &#125; else d[i][j]=u=t[u].ch[v^1]; ++cnt[i][j]; &#125; q.push(pui(x,i)); &#125; while (k--) &#123; ans+=q.top().first; r=q.top().second; q.pop(); x=0; for (u=rt[r],i=31;i&gt;=0;--i) &#123; v=(((pre[r]&gt;&gt;i)&amp;1u)^1u); if (cnt[r][i]==0) &#123; ++cnt[r][i]; if (t[u].ch[v]) &#123; x|=(1u&lt;&lt;i); u=d[r][i]=t[u].ch[v]; &#125; else u=d[r][i]=t[u].ch[v^1]; &#125; else if (cnt[r][i]&lt;t[d[r][i]].val) &#123; if (d[r][i]==t[u].ch[v]) x|=(1u&lt;&lt;i); ++cnt[r][i]; u=d[r][i]; &#125; else &#123; for (j=i;j&gt;=0;--j) cnt[r][j]=0; ++cnt[r][i]; u=d[r][i]=t[u].ch[v^1]; &#125; &#125; if (cnt[r][31]==t[rt[r]].val) continue; q.push(pui(x,r)); &#125; printf("%lld\n",ans); return 0;&#125; 题解做法除了找后继都是差不多的，找后继的方法是找完 $[0,r)$ 之后把 $[0,ans)$ 和 $(ans,r)$ 塞进堆里。 正常人做法翻了下 LOJ 最短解，然后被自己蠢哭了.. 直接记录每个右端点已经找到第 $k$ 大了，然后找第 $k$ 大的方式类似值域线段树/平衡树找第 $k​$ 大… D1T2讲一下 SAM 做法.. sb 选手不适合打 SA。 把所有串翻转，B 是 A 的前缀就变成了 B 是 A 的后缀。 是后缀就是 parent 树上的祖先，或者同一个节点且 len 更小。 把所有 A/B 串对应的节点按在 A/B 中的 len 拆点，每个 parent 树上的节点从较小的 len 向较大的 len 连边，A 串对应的点 &amp; len 向 A 串连边，B 串向对应的点 &amp; len 连边。 然后拓扑排序/记忆化搜索即可。 当然如果你像我一样 sb，可以按 dfs 序用线段树优化连边，就可以（假装）不用拆点了.. 参考代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;cctype&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;int read()&#123; int out=0; char c; while (!isdigit(c=getchar())); for (;isdigit(c);c=getchar()) out=out*10+c-'0'; return out;&#125;const int N=200010;struct Node&#123; int len,par,ch[26];&#125; sam[N&lt;&lt;1];void insert(int x);int p,tot,fa[N&lt;&lt;1][20],sta[N];void add(int u,int v);long long dp(int u);int head[N*5],nxt[N*6],to[N*6],cnt;int n,na,nb,m,a[N],alen[N],b[N],blen[N],w[N*5],tot2;set&lt;int&gt; aln[N&lt;&lt;1],bln[N&lt;&lt;1];map&lt;int,int&gt; aid[N&lt;&lt;1],bid[N&lt;&lt;1];long long ans,f[N*5];bool vis1[N*5],vis2[N*5],loop;char s[N];int main()&#123; int i,j,l,r,u,pre,T; T=read(); while (T--) &#123; scanf("%s",s+1); n=strlen(s+1); reverse(s+1,s+n+1); for (i=1;i&lt;=2*n;++i) &#123; memset(sam[i].ch,0,sizeof(sam[i].ch)); aln[i].clear(); aid[i].clear(); bln[i].clear(); bid[i].clear(); &#125; memset(w,0,sizeof(w)); memset(head,0,sizeof(head)); memset(vis1,false,sizeof(vis1)); memset(vis2,false,sizeof(vis2)); cnt=ans=0; p=tot=1; loop=false; for (i=1;i&lt;=n;++i) &#123; sta[i]=tot+1; insert(s[i]-'a'); &#125; for (i=2;i&lt;=tot;++i) fa[i][0]=sam[i].par; for (j=1;j&lt;=18;++j) &#123; for (i=2;i&lt;=tot;++i) &#123; fa[i][j]=fa[fa[i][j-1]][j-1]; &#125; &#125; na=read(); for (i=1;i&lt;=na;++i) &#123; r=n+1-read(); l=n+1-read(); u=sta[r]; for (j=18;j&gt;=0;--j) &#123; if (sam[fa[u][j]].len&gt;r-l) &#123; u=fa[u][j]; &#125; &#125; a[i]=u; alen[i]=r-l+1; aln[u].insert(alen[i]); bln[u].insert(alen[i]); &#125; nb=read(); for (i=1;i&lt;=nb;++i) &#123; r=n+1-read(); l=n+1-read(); u=sta[r]; for (j=18;j&gt;=0;--j) &#123; if (sam[fa[u][j]].len&gt;r-l) &#123; u=fa[u][j]; &#125; &#125; b[i]=u; blen[i]=r-l+1; bln[u].insert(blen[i]); &#125; tot2=tot; for (i=2;i&lt;=tot;++i) &#123; if (bln[i].empty()) add(sam[i].par,i); else &#123; for (auto k : aln[i]) w[aid[i][k]=++tot2]=k; pre=sam[i].par; for (auto k : bln[i]) &#123; add(pre,bid[i][k]=++tot2); if (aln[i].find(k)!=aln[i].end()) add(tot2,aid[i][k]); pre=tot2; &#125; add(tot2,i); &#125; &#125; m=read(); for (i=1;i&lt;=m;++i) &#123; l=read(); r=read(); add(aid[a[l]][alen[l]],bid[b[r]][blen[r]]); &#125; for (i=1;i&lt;=na;++i) ans=max(ans,dp(aid[a[i]][alen[i]])); if (loop) puts("-1"); else printf("%lld\n",ans); &#125; return 0;&#125;long long dp(int u)&#123; if (vis2[u]) return f[u]; if (vis1[u]) loop=true; if (loop) return 0; vis1[u]=true; int i,v; f[u]=w[u]; for (i=head[u];i;i=nxt[i]) &#123; v=to[i]; f[u]=max(f[u],dp(v)+w[u]); &#125; vis2[u]=true; return f[u];&#125;void insert(int x)&#123; int np=++tot; sam[np].len=sam[p].len+1; while (p&amp;&amp;!sam[p].ch[x]) &#123; sam[p].ch[x]=np; p=sam[p].par; &#125; if (!p) sam[np].par=1; else &#123; int q=sam[p].ch[x]; if (sam[q].len==sam[p].len+1) sam[np].par=q; else &#123; int nq=++tot; sam[nq].len=sam[p].len+1; memcpy(sam[nq].ch,sam[q].ch,sizeof(sam[q].ch)); sam[nq].par=sam[q].par; sam[q].par=sam[np].par=nq; while (p&amp;&amp;sam[p].ch[x]==q) &#123; sam[p].ch[x]=nq; p=sam[p].par; &#125; &#125; &#125; p=np;&#125;void add(int u,int v)&#123; nxt[++cnt]=head[u]; head[u]=cnt; to[cnt]=v;&#125; D1T3快速幂# 3欧拉定理，边读入边取模。 # 4找到最大值往上枚举 / 抱着恶臭的想法直接猜出来。 # 5按 $x$ 排序后发现有两组相邻的 $x$ 差小于等于 $10$，由于 $p|(y_119^{x_2-x_1}-y_2)$，求出这两组的 $gcd$ 即可。 # 6 / 7先自然溢出再取模。 # 7 暴力找循环节即可。需要注意循环节中不含 $1$ .. 所以不能直接通过 $1$ 来判断循环节，可以用 set。 区间筛质数/莫比乌斯函数# 9 / 12用 $\sqrt n$ 以内的质数筛后面的。 # 10 / 13用 $5\times10^7$ 以内的数筛后面的，然后把错误的项打表。 好像可以用 Miller-Rabin 不打表做，不太会.. 几个优化码长的小技巧： 数组里面存差分。 把 $5\times10^7$ 略微调大，但要注意不要 TLE。 把数组压成字符串。 区间筛原根# 14直接判断 $p-1$ 除掉每个质因数后是否是 $a^x\equiv1\pmod p$ 的解。 # 15先找到任意一个原根 $g$。 预处理出 $x​$ 是 $g​$ 的 $k​$ 次幂，那么 $x​$ 是原根当且仅当 $k​$ 和 $p-1​$ 互质。 # 16枚举质数判断即可快速找到 $p$。（说是快速还是要跑几十秒..） 参考代码LOJ 最慢解 D2T1搞三个背包： 整个城市都没有限制的城市选择阵营。 没有限制的学校选择派系。 有限制的学校选择阵营&amp;派系，注意每个有限制的城市要选一个有限制的学校作为“代表”，在背包时对阵营的贡献为整个城市的总和。 最后再枚举第三个背包的每一项，对答案的贡献就是这一项乘上前两个背包中可以和这一项一起选的方案数，实际上是一段连续的区间，所以前两个背包预处理一下前缀和就可以算了。 用值域优化一下背包的枚举范围，总复杂度是 $\mathcal O(nm+k^2wm)$。 整体思路不难，知识点只有背包..然而还是写了整整一晚上。 在寝室调到快十二点，虽然觉得自己挺 sb 的，但本地在 lemon 上 ac 的时候..真的好爽啊。 不得不说寝室写题效率就是高，又爽。写完还能看一集三狮 参考代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;typedef long long ll;const int N=1005;const int M=2505;const int K=35;const int V=10;const int mod=998244353;struct Node&#123; int b,s,p; bool operator&lt;(const Node&amp; y) const &#123; if ((~p&amp;&amp;~y.p)||(p==-1&amp;&amp;y.p==-1)) return b&lt;y.b; if (p==-1) return false; return true; &#125;&#125; a[N];int n,c,m,f[M],g[M],h[M][K*V][2],zy[2],px[2],sum[N],tot[4],ans;bool ban[N];int main()&#123; int T,i,j,k,x,y,tmp[2]; scanf("%d",&amp;T); while (T--) &#123; memset(f,0,sizeof(f)); memset(g,0,sizeof(g)); memset(h,0,sizeof(h)); memset(tot,0,sizeof(tot)); memset(sum,0,sizeof(sum)); memset(ban,false,sizeof(ban)); scanf("%d%d%d%d%d%d",&amp;n,&amp;c,zy+0,zy+1,px+0,px+1); for (i=1;i&lt;=n;++i) &#123; scanf("%d%d",&amp;a[i].b,&amp;a[i].s); sum[a[i].b]+=a[i].s; a[i].p=-1; tot[0]+=a[i].s; tot[1]+=a[i].s; &#125; scanf("%d",&amp;m); for (i=1;i&lt;=m;++i) &#123; scanf("%d%d",&amp;x,&amp;y); a[x].p=y; ban[a[x].b]=true; tot[0]-=a[x].s; tot[2]+=a[x].s; &#125; sort(a+1,a+n+1); f[0]=1; for (i=1;i&lt;=c;++i) &#123; if (ban[i]||!sum[i]) &#123; tot[1]-=sum[i]; tot[3]+=sum[i]; continue; &#125; for (j=min(zy[0],tot[1]);j&gt;=sum[i];--j) &#123; if (j&gt;=sum[i]) f[j]=(f[j]+f[j-sum[i]])%mod; &#125; &#125; for (j=1;j&lt;=zy[0];++j) f[j]=(f[j-1]+f[j])%mod; g[0]=1; for (i=m+1;i&lt;=n;++i) &#123; for (j=min(px[0],tot[0]);j&gt;=a[i].s;--j) &#123; if (j&gt;=a[i].s) g[j]=(g[j]+g[j-a[i].s])%mod; &#125; &#125; for (j=1;j&lt;=px[0];++j) g[j]=(g[j-1]+g[j])%mod; h[0][0][0]=1; for (i=m;i&gt;=1;--i) &#123; for (j=min(tot[3],zy[0]);j&gt;=0;--j) &#123; for (k=tot[2];k&gt;=0;--k) &#123; for (x=0;x&lt;=1;++x) &#123; tmp[x]=0; for (y=0;y&lt;=1;++y) &#123; if ((x^1)*2+(y^1)==a[i].p||j&lt;x*sum[a[i].b]||k&lt;y*a[i].s) continue; if (a[i].b!=a[i+1].b||i==m) tmp[x]=(0ll+tmp[x]+h[j-x*sum[a[i].b]][k-y*a[i].s][x^1]+h[j-x*sum[a[i].b]][k-y*a[i].s][x])%mod; else tmp[x]=(tmp[x]+h[j][k-y*a[i].s][x])%mod; &#125; &#125; h[j][k][0]=tmp[0]; h[j][k][1]=tmp[1]; &#125; &#125; &#125; ans=0; for (j=0;j&lt;=tot[3]&amp;&amp;j&lt;=zy[0];++j) &#123; if (zy[0]-j&lt;tot[3]-j+tot[1]-zy[1]) continue; for (k=0;k&lt;=tot[2];++k) &#123; if (px[0]-k&lt;tot[2]-k+tot[0]-px[1]) continue; ans=(ans+(ll)(h[j][k][0]+h[j][k][1])*(f[zy[0]-j]-(tot[3]-j+tot[1]-zy[1]&gt;0?f[tot[3]-j+tot[1]-zy[1]-1]:0))%mod*(g[px[0]-k]-(tot[2]-k+tot[0]-px[1]&gt;0?g[tot[2]-k+tot[0]-px[1]-1]:0)))%mod; &#125; &#125; cout&lt;&lt;(ans+mod)%mod&lt;&lt;endl; &#125; return 0;&#125; D2T2用堆维护每个子树的答案（堆里每个元素为每一组的最大值），合并的时候弹出两个堆顶取 max 记录下来，直到其中一个堆为空，再把记录的值加到非空的那个堆里，就是新的答案。可以两两合并，也可以把儿子合并了再加上自己。合并时每弹出两个元素、加入一个元素，元素的总数就会减少一，所以总复杂度是 $\mathcal O(n\log n)$。注意，不能用 = 来复制堆，而要用 swap，而且要开 C++11。如果不开 C++11 可以记录 id 然后 swap id。 贪心合并就不严格证了，感觉稍有点类似最近那场 CF 的 B？ 参考代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cctype&gt;#include &lt;queue&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;int read()&#123; int out=0; char c; while (!isdigit(c=getchar())); for (;isdigit(c);c=getchar()) out=out*10+c-'0'; return out;&#125;const int N=200010;void dfs1(int u);void dfs2(int u);vector&lt;int&gt; son[N];int n,a[N],mxdep[N];priority_queue&lt;int&gt; q[N];int main()&#123; int i; long long ans=0; n=read(); for (i=1;i&lt;=n;++i) a[i]=read(); for (i=2;i&lt;=n;++i) son[read()].push_back(i); dfs1(1); for (i=1;i&lt;=n;++i) sort(son[i].begin(),son[i].end(),[](int x,int y)&#123;return mxdep[x]&gt;mxdep[y];&#125;); dfs2(1); while (!q[1].empty()) &#123; ans+=q[1].top(); q[1].pop(); &#125; cout&lt;&lt;ans; return 0;&#125;void dfs2(int u)&#123; int i,v,mx; vector&lt;int&gt; tmp; for (i=0;i&lt;son[u].size();++i) &#123; v=son[u][i]; dfs2(v); &#125; if (son[u].size()) &#123; if (son[u].size()&gt;1) &#123; while (!q[son[u][1]].empty()) &#123; mx=0; for (i=0;i&lt;son[u].size();++i) &#123; v=son[u][i]; if (q[v].empty()) break; mx=max(mx,q[v].top()); q[v].pop(); &#125; tmp.push_back(mx); &#125; &#125; q[u].swap(q[son[u][0]]); for (i=0;i&lt;tmp.size();++i) q[u].push(tmp[i]); &#125; q[u].push(a[u]);&#125;void dfs1(int u)&#123; int i,v; for (i=0;i&lt;son[u].size();++i) &#123; v=son[u][i]; dfs1(v); mxdep[u]=max(mxdep[u],mxdep[v]+1); &#125;&#125; D2T3待填。]]></content>
      <categories>
        <category>游记</category>
      </categories>
      <tags>
        <tag>CCF系列赛事</tag>
        <tag>省选</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[树分块学习笔记]]></title>
    <url>%2F%E6%A0%91%E5%88%86%E5%9D%97%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[最近发现 OI Wiki 的“树分块”是空的，本来想凭着之前写的莫队教程水一水，结果被告知已经有人写过树上莫队了..于是就得详细介绍一下树分块除了树上莫队以外的应用..然而我除了糖果公园只做过一道树分块..（结果最后并没有找到这道题以外的其它题..） 树分块的方式可以参考 OI Wiki/莫队算法/真-树上莫队。 也可以参考 ouuan的博客/莫队、带修莫队、树上莫队详解/树上莫队。 树上莫队同样可以参考以上两篇文章。 树分块的应用树分块除了应用于莫队，还可以灵活地运用到某些树上问题中。但可以用树分块解决的题目往往都有更优秀的做法，所以相关的题目较少。 顺带提一句，“gty的妹子树”的树分块做法可以被菊花图卡掉。 BZOJ4763 雪辉先进行树分块，然后对每个块的关键点，预处理出它到祖先中每个关键点的路径上颜色的 bitset，以及每个关键点的最近关键点祖先，复杂度是 $\mathcal O(n\sqrt n+\frac{nc}{32})​$，其中 $n\sqrt n​$ 是暴力从每个关键点向上跳的复杂度，$\frac{nc}{32}​$ 是把 $\mathcal O(n)​$ 个 bitset 存下来的复杂度。 回答询问的时候，先从路径的端点暴力跳到所在块的关键点，再从所在块的关键点一块一块地向上跳，直到 $lca$ 所在块，然后再暴力跳到 $lca$。关键点之间的 bitset 已经预处理了，剩下的在暴力跳的过程中计算。单次询问复杂度是 $\mathcal O(\sqrt n+\frac c{32})$，其中 $\sqrt n$ 是块内暴力跳以及块直接向上跳的复杂度，$\mathcal O(\frac c{32})$ 是将预处理的结果与暴力跳的结果合并的复杂度。数颜色个数可以用 bitset 的 count()，求 $\operatorname{mex}$ 可以用 bitset 的 _Find_first()。 所以，总复杂度为 $\mathcal O((n+m)(\sqrt n+\frac c{32}))​$。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cctype&gt;#include &lt;bitset&gt;#include &lt;algorithm&gt;using namespace std;int read()&#123; int out=0; char c; while (!isdigit(c=getchar())); for (;isdigit(c);c=getchar()) out=out*10+c-'0'; return out;&#125;const int N=100010;const int B=666;const int C=30000;void add(int u,int v);void dfs(int u);int head[N],nxt[N&lt;&lt;1],to[N&lt;&lt;1],cnt;int n,m,type,c[N],fa[N],dep[N],sta[N],top,tot,bl[N],key[N/B+5],p[N],keyid[N];bool vis[N];bitset&lt;C&gt; bs[N/B+5][N/B+5],temp;int main()&#123; int i,u,v,x,y,k,lastans=0; n=read(); m=read(); type=read(); for (i=1;i&lt;=n;++i) c[i]=read(); for (i=1;i&lt;n;++i) &#123; u=read(); v=read(); add(u,v); add(v,u); &#125; dfs(1); if (!tot) ++tot; if (keyid[key[tot]]==tot) keyid[key[tot]]=0; key[tot]=1; keyid[1]=tot; while (top) bl[sta[top--]]=tot; for (i=1;i&lt;=tot;++i) //预处理 &#123; if (vis[key[i]]) continue; vis[key[i]]=true; temp.reset(); for (u=key[i];u;u=fa[u]) &#123; temp[c[u]]=1; if (keyid[u]) &#123; if (!p[key[i]]&amp;&amp;u!=key[i]) p[key[i]]=u; bs[keyid[key[i]]][keyid[u]]=temp; &#125; &#125; &#125; while (m--) &#123; k=read(); temp.reset(); while (k--) &#123; u=x=read()^lastans; v=y=read()^lastans; while (key[bl[x]]!=key[bl[y]]) &#123; if (dep[key[bl[x]]]&gt;dep[key[bl[y]]]) &#123; if (x==u) //若是第一次跳先暴力跳到关键点 &#123; while (x!=key[bl[u]]) &#123; temp[c[x]]=1; x=fa[x]; &#125; &#125; else x=p[x]; //否则跳一整块 &#125; else &#123; if (y==v) &#123; while (y!=key[bl[v]]) &#123; temp[c[y]]=1; y=fa[y]; &#125; &#125; else y=p[y]; &#125; &#125; if (keyid[x]) temp|=bs[keyid[key[bl[u]]]][keyid[x]]; if (keyid[y]) temp|=bs[keyid[key[bl[v]]]][keyid[y]]; while (x!=y) &#123; if (dep[x]&gt;dep[y]) &#123; temp[c[x]]=1; x=fa[x]; &#125; else &#123; temp[c[y]]=1; y=fa[y]; &#125; &#125; temp[c[x]]=true; &#125; int ans1=temp.count(),ans2=(~temp)._Find_first(); printf("%d %d\n",ans1,ans2); lastans=(ans1+ans2)*type; &#125; return 0;&#125;void dfs(int u)&#123; int i,v,t=top; for (i=head[u];i;i=nxt[i]) &#123; v=to[i]; if (v==fa[u]) continue; fa[v]=u; dep[v]=dep[u]+1; dfs(v); if (top-t&gt;=B) &#123; key[++tot]=u; if (!keyid[u]) keyid[u]=tot; while (top&gt;t) bl[sta[top--]]=tot; &#125; &#125; sta[++top]=u;&#125;void add(int u,int v)&#123; nxt[++cnt]=head[u]; head[u]=cnt; to[cnt]=v;&#125; BZOJ4812 由乃打扑克这题和上一题基本一样，唯一的区别是得到 bitset 后如何计算答案。 由于BZOJ是计算所有测试点总时限，不好卡，所以可以用 _Find_next() 水过去。 正解是每 $16$ 位一起算，先预处理出 $2^{16}$ 种可能的情况高位连续 $1$ 的个数、低位连续 $1$ 的个数以及中间的贡献。只不过这样要手写 bitset，因为标准库的 bitset 不能取某 $16$ 位.. 代码可以参考这篇博客。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>分块</tag>
        <tag>树分块</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019省选复习周做题计划]]></title>
    <url>%2F2019%E7%9C%81%E9%80%89%E5%A4%8D%E4%B9%A0%E5%91%A8%E5%81%9A%E9%A2%98%E8%AE%A1%E5%88%92%2F</url>
    <content type="text"><![CDATA[随便找了点省选前需要复习的知识点相关的题目.. 题目LCT/树剖共价大爷游长沙 小清新数据结构题 最小差值生成树 QTREE4 淀粉质树上游戏 字符串[APIO2014]回文串 [HEOI2016/TJOI2016]字符串 Trie最大异或和 最长异或路径 整体二分/树套树[ZJOI2013]K大数查询 cdq分治[Violet]天使玩偶/SJY摆棋子 [NOI2007]货币兑换 莫比乌斯反演[SDOI2014]数表 最小公倍数之和 Lucas的数论 组合数学、容斥原理、斯特林数重返现世 [HEOI2016/TJOI2016]求和 [国家集训队] Crash 的文明世界 多项式、生成函数食物 [CodeChef] COUNTARI 万径人踪灭 The Child and Binary Tree 城市规划 付公主的背包 玩游戏 记录共价大爷游长沙：如果要获取一个点的子树信息，要么 access 父亲 Splay 自己然后看实+虚+自己，要么 access 自己然后看虚+自己。 最大异或和：一开始尝试用线段树合并做，复杂度是 $\mathcal O(n(\log(n+m)+\log w)+m\log(n+m)\log w)$，卡常卡不过去，尝试用 bitset 优化，后来发现除以 $32$ 被 $\log$ 掉了，加上带来的一些常数后根本没有优化.. 只不过后来发现可持久化 Trie 真的挺好写的，（只要会主席树不需要学也能 yy 出来的感觉）。 最后果然没做几道题..只不过比我想象中还要少一点.. 写了点 OI Wiki，过程中也写了几道计划外的题。]]></content>
      <categories>
        <category>计划</category>
      </categories>
      <tags>
        <tag>CCF系列赛事</tag>
        <tag>省选</tag>
        <tag>题表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[树状数组——从背模板到树套树]]></title>
    <url>%2F%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%E2%80%94%E2%80%94%E4%BB%8E%E8%83%8C%E6%A8%A1%E6%9D%BF%E5%88%B0%E6%A0%91%E5%A5%97%E6%A0%91%2F</url>
    <content type="text"><![CDATA[这是一篇披着PJ组数据结构外衣的树套树教程。 大约会（尝试着）较为本质地简介一下树状数组？ 基础树状数组树状数组，英文名 BIT(Binary Indexed Tree)（不是TreeArray）。 原理的话..看图大约是一目了然的： 其中，黑色的矩形（包括红色的正方形）代表这一部分的和，而红色的正方形代表这部分和在树状数组中的下标。如果把这些区间连边，就像是一棵二叉树，所以叫树状数组。 举几个栗子，$BIT[3]$ 表示 $A[3]$，$BIT[6]$ 表示 $A[5]+A[6]$，$BIT[12]$ 表示 $A[9]+A[10]+A[11]+A[12]$。 我们把每个下标用二进制表示，可以发现，二进制表示的末尾有 $k​$ 个 $0​$，在树状数组里它就代表一段长为 $2^k​$ 的区间的和。由于树状数组和下标的二进制联系紧密，所以英文叫 Binary Indexed Tree。 可以定义 $lowbit(x)$ 为 $x$ 的二进制表示中最低位的 $1$ 表示的数。如 $lowbit(101_{(2)})=1$，$lowbit(110100_{(2)}=4)$，这样的话，树状数组中下标为 $x$ 的元素就表示了一段长为 $lowbit(x)$ 的区间的和。 由于计算机中存储带符号整数的方式，$lowbit(x)=$x&amp;-x，具体原因可以自行搜索“补码”。 考虑如何更新树状数组：如果我们要更新第 $p$ 位，先更新 $BIT[p]$，再更新 $BIT[p+lowbit(p)]$，再更新 $BIT[p+lowbit(p)+lowbit(p+lowbit(p))]$……一直更新到原数列的长度。 考虑如何查询某个前缀和：如果我们要查询前 $p$ 位的前缀和，结果就是 $BIT[p]+BIT[p-lowbit(p)]+BIT[p-lowbit(p)-lowbit(p-lowbit(p))]$……一直查询到 $lowbit$ 为 $1$ 的节点。 把树状数组看成二叉树，深度不超过 $\log(n)$，所以单次操作复杂度是 $\mathcal O(\log n)$。 大概就是这样，代码比较简短： 1234567891011void add(int p,int x)&#123; for (;p&lt;=n;p+=(p&amp;-p)) BIT[p]+=x;&#125;int query(int p)&#123; int out=0; for (;p;p-=(p&amp;-p)) out+=BIT[p]; return out;&#125; 稍进阶一点点的树状数组由于本篇教程是“从背模板到树套树”而不是“摆脱线段树与平衡树”，所以不会提及那方面的高级用法。 维护前缀积把+改成*。 维护前缀异或和把+改成^。 维护前缀矩阵积把+改成矩阵乘法。 诶，等等，怎么全WA了？ 因为矩阵乘法不具有交换律.. 比如说，两个矩阵 $A$ 和 $B$，树状数组里存的是 $A$ 和 $A\times B$，把 $A$ 乘上 $C$ 后树状数组里第二项我们期望它是 $A\times C\times B$，而实际上它是 $A\times B\times C$.. 所以树状数组到底在维护什么？ 警告：本人其实没怎么学过群论..下文群论相关可能有口胡成分。 在维护一个阿贝尔群.. 等等，群是什么？群号多少？ ..就是一堆元素，定义了一种运算，它满足结合律、交换律，有单位元（谁和它运算都得到本身）、逆元（每个元素都存在一个元素运算后得到单位元）。如果只是前缀信息按理来说是不需要逆元的..然而一般都是要维护区间信息，而不只是前缀信息，所以需要逆元.. 树状数组套动态开点线段树简介终于到正题了。 我们来定义一个阿贝尔群： 它的元素是一些同构的动态开点线段树，运算是把对应节点的信息相加，要求节点维护的信息是阿贝尔群。 一般来说，主席树可以解决的静态问题带修就要用树套树了.. 修改就是把树状数组里的+换成动态开点线段树的修改操作，询问就是把+换成merge。直接 merge 复杂度好像不太对..（其实我不太会证线段树合并复杂度..）所以可以开个数组，把需要询问的节点存下来，然后在询问函数里合并信息。如果是询问区间，就把两个端点在树状数组里对应的节点存下来。 例题P2617 Dynamic Rankings代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cctype&gt;#include &lt;algorithm&gt;using namespace std;int read()&#123; int out=0; char c; while (!isdigit(c=getchar())); for (;isdigit(c);c=getchar()) out=out*10+c-'0'; return out;&#125;const int N=100001;struct Node&#123; int val,ls,rs;&#125; t[N&lt;&lt;9];int modify(int x,int l,int r,int p,int type);int merge(int x,int y);int query(int l,int r,int k);void change(int p,int x,int y);int n,m,tot,a[N],BIT[N],lsh[N&lt;&lt;1],cnt,tp[N],l[N],r[N],xx[N],totx,toty,x[N],y[N];char op[10];int main()&#123; int i,j; n=read(); m=read(); for (i=1;i&lt;=n;++i) lsh[++cnt]=a[i]=read(); for (i=1;i&lt;=m;++i) &#123; scanf("%s",op); if (op[0]=='Q') &#123; tp[i]=0; l[i]=read(); r[i]=read(); xx[i]=read(); &#125; else &#123; tp[i]=1; l[i]=read(); lsh[++cnt]=xx[i]=read(); &#125; &#125; sort(lsh+1,lsh+cnt+1); cnt=unique(lsh+1,lsh+cnt+1)-lsh; for (i=1;i&lt;=n;++i) &#123; a[i]=lower_bound(lsh+1,lsh+cnt,a[i])-lsh; change(i,a[i],1); &#125; for (i=1;i&lt;=m;++i) &#123; if (tp[i]) &#123; change(l[i],a[l[i]],-1); change(l[i],a[l[i]]=xx[i]=lower_bound(lsh+1,lsh+cnt,xx[i])-lsh,1); &#125; else &#123; totx=toty=0; for (j=l[i]-1;j;j-=(j&amp;-j)) x[++totx]=BIT[j]; for (j=r[i];j;j-=(j&amp;-j)) y[++toty]=BIT[j]; printf("%d\n",query(1,cnt,xx[i])); &#125; &#125; return 0;&#125;void change(int p,int x,int y)&#123; for (;p&lt;=n;p+=(p&amp;-p)) BIT[p]=modify(BIT[p],1,cnt,x,y);&#125;int modify(int x,int l,int r,int p,int type)&#123; int u=++tot; t[u]=t[x]; t[u].val+=type; if (l==r-1) return u; int mid=l+r&gt;&gt;1; if (p&lt;mid) t[u].ls=modify(t[u].ls,l,mid,p,type); else t[u].rs=modify(t[u].rs,mid,r,p,type); return u;&#125;int query(int l,int r,int k)&#123; if (l==r-1) return lsh[l]; int i,sum=0; for (i=1;i&lt;=totx;++i) sum-=t[t[x[i]].ls].val; for (i=1;i&lt;=toty;++i) sum+=t[t[y[i]].ls].val; if (sum&gt;=k) &#123; for (i=1;i&lt;=totx;++i) x[i]=t[x[i]].ls; for (i=1;i&lt;=toty;++i) y[i]=t[y[i]].ls; return query(l,l+r&gt;&gt;1,k); &#125; else &#123; for (i=1;i&lt;=totx;++i) x[i]=t[x[i]].rs; for (i=1;i&lt;=toty;++i) y[i]=t[y[i]].rs; return query(l+r&gt;&gt;1,r,k-sum); &#125;&#125; P3380 【模板】二逼平衡树（树套树）代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cctype&gt;#include &lt;algorithm&gt;using namespace std;const int N=50010;const int INF=0x7fffffff;int read()&#123; int out=0; char c; while (!isdigit(c=getchar())); for (;isdigit(c);c=getchar()) out=out*10+c-'0'; return out;&#125;struct Node&#123; int val,ls,rs;&#125; t[N&lt;&lt;8];int insert(int x,int l,int r,int p,int type);int qsum(int l,int r,int L,int R,int d);int kth(int l,int r,int k);void modify(int p,int x,int y);int n,m,tot,a[N],BIT[N],lsh[N&lt;&lt;1],cnt,op[N],l[N],r[N],k[N],totx,toty,X[20][N],Y[20][N];int main()&#123; int i,p; n=read(); m=read(); for (i=1;i&lt;=n;++i) a[i]=lsh[++cnt]=read(); for (i=1;i&lt;=m;++i) &#123; op[i]=read(); if (op[i]==3) &#123; l[i]=read(); k[i]=lsh[++cnt]=read(); &#125; else &#123; l[i]=read(); r[i]=read(); k[i]=read(); if (op[i]!=2) lsh[++cnt]=k[i]; &#125; &#125; sort(lsh+1,lsh+cnt+1); cnt=unique(lsh+1,lsh+cnt+1)-lsh; for (i=1;i&lt;=n;++i) &#123; a[i]=lower_bound(lsh+1,lsh+cnt,a[i])-lsh; modify(i,a[i],1); &#125; for (i=1;i&lt;=m;++i) &#123; if (op[i]==3) &#123; k[i]=lower_bound(lsh+1,lsh+cnt,k[i])-lsh; modify(l[i],a[l[i]],-1); modify(l[i],a[l[i]]=k[i],1); &#125; else &#123; totx=toty=0; for (p=l[i]-1;p;p-=(p&amp;-p)) X[0][++totx]=BIT[p]; for (p=r[i];p;p-=(p&amp;-p)) Y[0][++toty]=BIT[p]; if (op[i]==2) printf("%d\n",kth(1,cnt,k[i])); else &#123; k[i]=lower_bound(lsh+1,lsh+cnt,k[i])-lsh; if (op[i]==1) printf("%d\n",qsum(1,cnt,1,k[i],0)+1); else if (op[i]==4) &#123; int rk=qsum(1,cnt,1,k[i],0); if (rk) printf("%d\n",kth(1,cnt,rk)); else printf("%d\n",-INF); &#125; else &#123; int rk=qsum(1,cnt,1,k[i]+1,0); if (rk&lt;=r[i]-l[i]) printf("%d\n",kth(1,cnt,rk+1)); else printf("%d\n",INF); &#125; &#125; &#125; &#125; return 0;&#125;void modify(int p,int x,int y)&#123; for (;p&lt;=n;p+=(p&amp;-p)) BIT[p]=insert(BIT[p],1,cnt,x,y);&#125;int insert(int x,int l,int r,int p,int type)&#123; int u=++tot; t[u]=t[x]; t[u].val+=type; if (l==r-1) return u; int mid=l+r&gt;&gt;1; if (p&lt;mid) t[u].ls=insert(t[u].ls,l,mid,p,type); else t[u].rs=insert(t[u].rs,mid,r,p,type); return u;&#125;int qsum(int l,int r,int L,int R,int d)&#123; if (l&gt;=R||r&lt;=L) return 0; int i,sum=0; if (L&lt;=l&amp;&amp;R&gt;=r) &#123; for (i=1;i&lt;=totx;++i) sum-=t[X[d][i]].val; for (i=1;i&lt;=toty;++i) sum+=t[Y[d][i]].val; return sum; &#125; for (i=1;i&lt;=totx;++i) X[d+1][i]=t[X[d][i]].ls; for (i=1;i&lt;=toty;++i) Y[d+1][i]=t[Y[d][i]].ls; sum=qsum(l,l+r&gt;&gt;1,L,R,d+1); for (i=1;i&lt;=totx;++i) X[d+1][i]=t[X[d][i]].rs; for (i=1;i&lt;=toty;++i) Y[d+1][i]=t[Y[d][i]].rs; return sum+qsum(l+r&gt;&gt;1,r,L,R,d+1);&#125;int kth(int l,int r,int k)&#123; if (l==r-1) return lsh[l]; int i,sum=0; for (i=1;i&lt;=totx;++i) sum-=t[t[X[0][i]].ls].val; for (i=1;i&lt;=toty;++i) sum+=t[t[Y[0][i]].ls].val; if (sum&gt;=k) &#123; for (i=1;i&lt;=totx;++i) X[0][i]=t[X[0][i]].ls; for (i=1;i&lt;=toty;++i) Y[0][i]=t[Y[0][i]].ls; return kth(l,l+r&gt;&gt;1,k); &#125; for (i=1;i&lt;=totx;++i) X[0][i]=t[X[0][i]].rs; for (i=1;i&lt;=toty;++i) Y[0][i]=t[Y[0][i]].rs; return kth(l+r&gt;&gt;1,r,k-sum);&#125; [CQOI2011]动态逆序对这题用树套树做有点卡空间..需要把带返回值的动态开点改成直接修改。 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cctype&gt;#include &lt;cstring&gt; using namespace std;int read()&#123; int out=0; char c; while (!isdigit(c=getchar())); for (;isdigit(c);c=getchar()) out=out*10+c-'0'; return out;&#125;const int N=100010;struct Node&#123; int val,ls,rs;&#125; t[N*90];void change(int&amp; u,int l,int r,int p);int query(int l,int r,int L,int R,int d);int n,m,a[N],p[N],del[N],BIT[N],x[20][20],y[20][20],xtot,ytot,tot;bool deleted[N];long long ans,out[N];int main()&#123; int i,j; n=read(); m=read(); for (i=1;i&lt;=n;++i) &#123; a[i]=read(); p[a[i]]=i; &#125; for (i=1;i&lt;=m;++i) &#123; del[i]=p[read()]; deleted[del[i]]=true; &#125; for (i=n;i&gt;=1;--i) &#123; if (!deleted[i]) &#123; for (j=a[i];j;j-=(j&amp;-j)) ans+=BIT[j]; for (j=a[i];j&lt;=n;j+=(j&amp;-j)) ++BIT[j]; &#125; &#125; memset(BIT,0,sizeof(BIT)); for (i=1;i&lt;=n;++i) &#123; if (!deleted[i]) &#123; for (j=i;j&lt;=n;j+=(j&amp;-j)) &#123; change(BIT[j],1,n+1,a[i]); &#125; &#125; &#125; for (i=m;i&gt;=1;--i) &#123; xtot=ytot=0; for (j=del[i];j;j-=(j&amp;-j)) y[0][++ytot]=BIT[j]; ans+=query(1,n+1,a[del[i]]+1,n+1,0); xtot=ytot=0; for (j=del[i];j;j-=(j&amp;-j)) x[0][++xtot]=BIT[j]; for (j=n;j;j-=(j&amp;-j)) y[0][++ytot]=BIT[j]; ans+=query(1,n+1,1,a[del[i]],0); for (j=del[i];j&lt;=n;j+=(j&amp;-j)) change(BIT[j],1,n+1,a[del[i]]); out[i]=ans; &#125; for (i=1;i&lt;=m;++i) printf("%lld\n",out[i]); return 0;&#125;void change(int&amp; u,int l,int r,int p)&#123; if (!u) u=++tot; ++t[u].val; if (l==r-1) return; int mid=l+r&gt;&gt;1; if (p&lt;mid) change(t[u].ls,l,mid,p); else change(t[u].rs,mid,r,p);&#125;int query(int l,int r,int L,int R,int d)&#123; if (l&gt;=R||r&lt;=L) return 0; int i,ret=0,mid=l+r&gt;&gt;1; if (L&lt;=l&amp;&amp;R&gt;=r) &#123; for (i=1;i&lt;=xtot;++i) ret-=t[x[d][i]].val; for (i=1;i&lt;=ytot;++i) ret+=t[y[d][i]].val; return ret; &#125; for (i=1;i&lt;=xtot;++i) x[d+1][i]=t[x[d][i]].ls; for (i=1;i&lt;=ytot;++i) y[d+1][i]=t[y[d][i]].ls; ret+=query(l,mid,L,R,d+1); for (i=1;i&lt;=xtot;++i) x[d+1][i]=t[x[d][i]].rs; for (i=1;i&lt;=ytot;++i) y[d+1][i]=t[y[d][i]].rs; ret+=query(mid,r,L,R,d+1); return ret;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>树状数组</tag>
        <tag>树套树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[cdq分治学习笔记]]></title>
    <url>%2Fcdq%E5%88%86%E6%B2%BB%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[cdq分治也是咕了好久了..最近总算把它学了。 cdq分治是一种离线算法，可以代替一些复杂的数据结构，降低代码难度，减小常数。废话大家都知道。 本文未完待续（cdq分治的其它应用，如维护凸壳，待填坑）。 简介感觉cdq分治不如叫“ex归并排序”，就是以操作的时间作为初始顺序，在递归处理的过程中按位置归并排序。 更一般地说，对于一个二维偏序 $P(i,j)=P_1(a_i,a_j)\land P_2(b_i,b_j)​$，位置 $i​$ 的修改对位置 $j​$ 的询问（询问为类前缀和形式，区间询问需拆成两个前缀询问）有影响当且仅当 $P(i,j)=true​$，cdq分治就是以其中一维为初始顺序，对另一维进行归并排序的过程中计算左区间里修改的总和，将左区间修改的影响应用到右区间。 学会了之后就会发现，cdq分治的确就是这样，已经描述的很清楚了，然而在没学会的时候估计是看不懂上面这段话的..所以结合具体题目来看一看吧。 例题P3374 【模板】树状数组 1树状数组裸题！冷静，我们来用ex归并排序做..（嗯，我决定就这么叫它了） 按照我们上面说的，我们把操作存下来，询问拆成两个前缀和相减，初始值视作修改，需要存的信息有操作的种类（修改、询问的左端点减一、询问的右端点），操作的位置（$p$、$l-1$、$r$）以及修改加上的值/询问的编号。如果写法正常的话你已经以操作的时间作为初始顺序了.. 然后，写个归并排序，按操作的位置排序，同一个位置的修改要放在询问的前面。然后，在归并排序的过程中，遇到左区间里的修改就更新左区间修改的总和，遇到右区间里的询问就用记录的“左区间修改的总和”更新这个询问的答案。 具体见代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091#include &lt;iostream&gt;#include &lt;cstdio&gt;using namespace std;typedef long long ll;const int N=500010;struct Node&#123; int type,p,val; //type为2表示修改，type为-1表示左端点减一，type为1表示右端点 bool operator&lt;(const Node&amp; b) const &#123; return p==b.p?type&gt;b.type:p&lt;b.p; &#125;&#125; q[N&lt;&lt;2],tmp[N&lt;&lt;2];void solve(int l,int r);int n,m,tot,qtot;ll ans[N];int main()&#123; int i,op,x,y; scanf("%d%d",&amp;n,&amp;m); for (i=1;i&lt;=n;++i) //初始值视作修改 &#123; scanf("%d",&amp;x); q[++tot].type=2; q[tot].p=i; q[tot].val=x; &#125; for (i=1;i&lt;=m;++i) &#123; scanf("%d%d%d",&amp;op,&amp;x,&amp;y); if (op==1) &#123; q[++tot].type=2; q[tot].p=x; q[tot].val=y; &#125; else //询问拆成两个前缀和相减 &#123; q[++tot].type=-1; q[tot].p=x-1; q[tot].val=++qtot; q[++tot].type=1; q[tot].p=y; q[tot].val=qtot; &#125; &#125; solve(1,tot+1); for (i=1;i&lt;=qtot;++i) printf("%lld\n",ans[i]); return 0;&#125;void solve(int l,int r)&#123; if (l==r-1) return; int i,j,k,mid; ll sum=0; i=k=l; j=mid=(l+r)&gt;&gt;1; solve(l,mid); solve(mid,r); while (i&lt;mid&amp;&amp;j&lt;r) &#123; if (q[i]&lt;q[j]) &#123; if (q[i].type==2) sum+=q[i].val; //记录左区间里的修改之和 tmp[k++]=q[i++]; &#125; else &#123; if (q[j].type!=2) ans[q[j].val]+=q[j].type*sum; //将左区间里的修改应用到右区间里的询问 tmp[k++]=q[j++]; &#125; &#125; while (i&lt;mid) tmp[k++]=q[i++]; while (j&lt;r) &#123; if (q[j].type!=2) ans[q[j].val]+=q[j].type*sum; tmp[k++]=q[j++]; &#125; for (i=l;i&lt;r;++i) q[i]=tmp[i];&#125; 之前说过ex归并排序本质上是一个二维偏序限制了修改对询问的影响，所以也可以先按位置排序再按时间排序。只不过..这样写很奇怪，很麻烦，常数又大。然而为了理解ex归并排序的本质，我还是写了份这个做法.. 一种奇怪的写法 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;typedef long long ll;const int N=500010;struct Node&#123; int type,tim,p,val; Node(int _type=0,int _tim=0,int _p=0,int _val=0):type(_type),tim(_tim),p(_p),val(_val)&#123;&#125;&#125; q[N&lt;&lt;2],tmp[N&lt;&lt;2];void solve(int l,int r);int n,m,tot,qtot;ll ans[N];int main()&#123; int i,j,op,x,y; scanf("%d%d",&amp;n,&amp;m); for (i=1;i&lt;=n;++i) &#123; scanf("%d",&amp;x); q[++tot]=Node(2,0,i,x); &#125; for (i=1;i&lt;=m;++i) &#123; scanf("%d%d%d",&amp;op,&amp;x,&amp;y); if (op==1) q[++tot]=Node(2,i,x,y); else &#123; q[++tot]=Node(-1,i,x-1,++qtot); q[++tot]=Node(1,i,y,qtot); &#125; &#125; sort(q+1,q+tot+1,[](const Node&amp; x,const Node&amp; y)&#123;return x.p==y.p?x.type&gt;y.type:x.p&lt;y.p;&#125;); solve(1,tot+1); for (i=1;i&lt;=qtot;++i) printf("%lld\n",ans[i]); return 0;&#125;void solve(int l,int r)&#123; if (l==r-1) return; int i,j,k,mid; ll sum=0; i=k=l; j=mid=(l+r)&gt;&gt;1; solve(l,mid); solve(mid,r); while (i&lt;mid&amp;&amp;j&lt;r) &#123; if (q[i].tim&lt;q[j].tim) &#123; if (q[i].type==2) sum+=q[i].val; tmp[k++]=q[i++]; &#125; else &#123; if (q[j].type!=2) ans[q[j].val]+=q[j].type*sum; tmp[k++]=q[j++]; &#125; &#125; while (i&lt;mid) tmp[k++]=q[i++]; while (j&lt;r) &#123; if (q[j].type!=2) ans[q[j].val]+=q[j].type*sum; tmp[k++]=q[j++]; &#125; for (i=l;i&lt;r;++i) q[i]=tmp[i];&#125; P3810 【模板】三维偏序（陌上花开）有两种做法，一种是cdq分治套树状数组，需要注意的有两点，一是清空树状数组可以用时间戳，二是 $a,\,b,\,c$ 都相等的元素要合并。 参考代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;const int N=100010;const int K=200010;struct Node&#123; int a,b,c,w,f;&#125; a[N],b[N];void solve(int l,int r);void add(int p,int x);int query(int p);int n,k,d[N],BIT[K],vis[K],tim,tot;int main()&#123; int i; scanf("%d%d",&amp;n,&amp;k); for (i=1;i&lt;=n;++i) &#123; scanf("%d%d%d",&amp;b[i].a,&amp;b[i].b,&amp;b[i].c); b[i].w=1; &#125; sort(b+1,b+n+1,[](const Node&amp; x,const Node&amp; y)&#123;return x.a==y.a?(x.b==y.b?x.c&lt;y.c:x.b&lt;y.b):x.a&lt;y.a;&#125;); for (i=1;i&lt;=n;++i) &#123; if (b[i].a!=b[i+1].a||b[i].b!=b[i+1].b||b[i].c!=b[i+1].c) a[++tot]=b[i]; else b[i+1].w+=b[i].w; &#125; solve(1,tot+1); for (i=1;i&lt;=tot;++i) d[a[i].f+a[i].w]+=a[i].w; for (i=1;i&lt;=n;++i) printf("%d\n",d[i]); return 0;&#125;void solve(int l,int r)&#123; if (l==r-1) return; int i,j,k,mid; i=k=l; j=mid=(l+r)&gt;&gt;1; solve(l,mid); solve(mid,r); ++tim; while (i&lt;mid&amp;&amp;j&lt;r) &#123; if (a[i].b&lt;=a[j].b) &#123; add(a[i].c,a[i].w); b[k++]=a[i++]; &#125; else &#123; a[j].f+=query(a[j].c); b[k++]=a[j++]; &#125; &#125; while (i&lt;mid) b[k++]=a[i++]; while (j&lt;r) &#123; a[j].f+=query(a[j].c); b[k++]=a[j++]; &#125; for (i=l;i&lt;r;++i) a[i]=b[i];&#125;void add(int p,int x)&#123; for (;p&lt;=k;p+=(p&amp;-p)) &#123; if (vis[p]!=tim) &#123; BIT[p]=0; vis[p]=tim; &#125; BIT[p]+=x; &#125;&#125;int query(int p)&#123; int out=0; for (;p;p-=(p&amp;-p)) if (vis[p]==tim) out+=BIT[p]; return out;&#125; 还有一种做法是cdq分治套cdq分治： 参考代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;const int N=100010;struct Node&#123; int a,b,c,d,w,id;&#125; a[N],b[N],c[N];void solve(int l,int r);void solve2(int l,int r);int n,k,d[N],tot,ans[N];int main()&#123; int i; scanf("%d%d",&amp;n,&amp;k); for (i=1;i&lt;=n;++i) &#123; scanf("%d%d%d",&amp;b[i].a,&amp;b[i].b,&amp;b[i].c); b[i].w=1; b[i].id=i; &#125; sort(b+1,b+n+1,[](const Node&amp; x,const Node&amp; y)&#123;return x.a==y.a?(x.b==y.b?x.c&lt;y.c:x.b&lt;y.b):x.a&lt;y.a;&#125;); for (i=1;i&lt;=n;++i) &#123; if (b[i].a!=b[i+1].a||b[i].b!=b[i+1].b||b[i].c!=b[i+1].c) a[++tot]=b[i]; else b[i+1].w+=b[i].w; &#125; solve(1,tot+1); for (i=1;i&lt;=tot;++i) d[ans[a[i].id]+a[i].w]+=a[i].w; for (i=1;i&lt;=n;++i) printf("%d\n",d[i]); return 0;&#125;void solve(int l,int r)&#123; if (l==r-1) return; int i,j,k,mid; i=k=l; j=mid=(l+r)&gt;&gt;1; solve(l,mid); solve(mid,r); while (i&lt;mid&amp;&amp;j&lt;r) &#123; if (a[i].b&lt;=a[j].b) &#123; a[i].d=a[i].w; b[k++]=a[i++]; &#125; else &#123; a[j].d=0; b[k++]=a[j++]; &#125; &#125; while (i&lt;mid) &#123; a[i].d=a[i].w; b[k++]=a[i++]; &#125; while (j&lt;r) &#123; a[j].d=0; b[k++]=a[j++]; &#125; for (i=l;i&lt;r;++i) a[i]=b[i]; solve2(l,r);&#125;void solve2(int l,int r)&#123; if (l==r-1) return; int i,j,k,mid,sum=0; i=k=l; j=mid=(l+r)&gt;&gt;1; solve2(l,mid); solve2(mid,r); while (i&lt;mid&amp;&amp;j&lt;r) &#123; if (b[i].c&lt;=b[j].c) &#123; sum+=b[i].d; c[k++]=b[i++]; &#125; else &#123; if (!b[j].d) ans[b[j].id]+=sum; c[k++]=b[j++]; &#125; &#125; while (i&lt;mid) c[k++]=b[i++]; while (j&lt;r) &#123; if (!b[j].d) ans[b[j].id]+=sum; c[k++]=b[j++]; &#125; for (i=l;i&lt;r;++i) b[i]=c[i];&#125; cdq分治求偏序对的本质（下文中“偏序问题”即求满足偏序关系的数对个数。而”高维偏序“实际上是多个严格弱序的并。非严格偏序与之类似，主要是在代码上有些细节改变。） 大家知道，二维偏序可以先按一维排序后用普通的归并排序解决，那为什么“三维偏序”不可以呢？ 首先，按其中一维排序相当于降了一维，问题就变成了“为什么一维偏序可以用普通的归并排序解决，而二维偏序不可以”。 原因就在于，两个偏序关系的并，不一定具有不可比性的传递性。（Strict Weak Ordering 相关内容参见我的另一篇博客） 可以证明，两个严格弱序的并一定是一个严格偏序，但不一定是一个严格弱序。而 cdq 分治可以将多个严格弱序的并进行降维，每一次 cdq 分治都标记出哪些位置会对其它位置有贡献，并按某一维排序。 上面说的有点乱..简单概括一下。排序可以降维，只有严格弱序能排序，高维偏序不一定是严格弱序，cdq 分治在排序的过程中标记了元素之间如何贡献答案。所以 cdq 分治就可以解决高维偏序问题了.. 所以，我们可以写出一份 cdq 分治求 $k$ 维偏序对的代码： 题意简述：第一行 $n,\,k$，后 $n$ 行每行 $k$ 个数 $a_{i,1..k}$，对每个 $i$ 求 $\forall d\in[1,k],\,a_{i,d}&lt;a_{j,d}$ 的 $j$ 个数。 当然，$n$ 要足够大，否则会被暴力艹。只不过理论上来说，如果维数是常数，复杂度就比暴力更优… 随便造的一个模板题 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;const int N=10005;const int K=15;void solve(int l,int r,int d);int n,k,ans[N];struct Node&#123; int w[K],type,id; bool operator&lt;(const Node&amp; y) const &#123; if (w[0]!=y.w[0]) return w[0]&lt;y.w[0]; for (int i=1;i&lt;k;++i) if (w[i]!=y.w[i]) return w[i]&gt;y.w[i]; //如果是非严格偏序都应该顺着排，严格偏序除了第一维都应该倒着排。这是由于相等元素可以/不可以转移。 return false; &#125;&#125; a[K][N],tmp[N];int main()&#123; int i,j; scanf("%d%d",&amp;n,&amp;k); for (i=1;i&lt;=n;++i) &#123; a[0][i].id=i; for (j=0;j&lt;k;++j) scanf("%d",a[0][i].w+j); &#125; sort(a[0]+1,a[0]+n+1); solve(1,n+1,1); for (i=1;i&lt;=n;++i) printf("%d\n",ans[i]); return 0;&#125;void solve(int l,int r,int d)&#123; if (l==r-1) return; int i,j,p,mid,sum=0; i=p=l; j=mid=(l+r)&gt;&gt;1; solve(l,mid,d); solve(mid,r,d); while (i&lt;mid&amp;&amp;j&lt;r) &#123; if (a[d-1][i].w[d]&lt;a[d-1][j].w[d]) &#123; a[d][p]=tmp[p]=a[d-1][i++]; if (d&gt;1&amp;&amp;a[d][p].type!=1) a[d][p].type=0; else &#123; a[d][p].type=1; if (d==k-1) ++sum; &#125; ++p; &#125; else &#123; a[d][p]=tmp[p]=a[d-1][j++]; if (d&gt;1&amp;&amp;a[d][p].type!=2) a[d][p].type=0; else &#123; a[d][p].type=2; if (d==k-1) ans[a[d][p].id]+=sum; &#125; ++p; &#125; &#125; while (i&lt;mid) &#123; a[d][p]=tmp[p]=a[d-1][i++]; if (d&gt;1&amp;&amp;a[d][p].type!=1) a[d][p].type=0; else a[d][p].type=1; ++p; &#125; while (j&lt;r) &#123; a[d][p]=tmp[p]=a[d-1][j++]; if (d&gt;1&amp;&amp;a[d][p].type!=2) a[d][p].type=0; else &#123; a[d][p].type=2; if (d==k-1) ans[a[d][p].id]+=sum; &#125; ++p; &#125; for (i=l;i&lt;r;++i) a[d-1][i]=tmp[i]; if (d&lt;k-1) solve(l,r,d+1);&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>离线算法</tag>
        <tag>cdq分治</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ4259 残缺的字符串（FFT）]]></title>
    <url>%2FBZOJ4259-%E6%AE%8B%E7%BC%BA%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%EF%BC%88FFT%EF%BC%89%2F</url>
    <content type="text"><![CDATA[题目链接洛谷 darkbzoj 题意简述带通配符的单模式串、单文本串匹配。 字符串长度 $3\times10^5$。 简要做法这题是利用字符串的距离函数来匹配字符串，使用 FFT 优化距离函数的计算。 将通配符的值设为零，定义 $dis(s,t)=\sum(s[i]-t[i])^2s[i]t[i]​$，那么两个等长的字符串匹配当且仅当它们的距离为零。 为了方便卷积，将题目中的 $A$ 串翻转​得到串 $A’​$。 推一波式子： $\begin{aligned}dis(A,B[i..i+m-1])&amp;=\sum\limits_{j=0}^{m-1}(A’[m-j-1]-B[i+j])^2A’[m-j-1]B[i+j]\\&amp;=\left(\sum\limits_{j=0}^{m-1}A’[m-j-1]B^3[i+j]\right)-2\left(\sum\limits_{j=0}^{m-1}(A’)^2[m-j-1]B^2[i+j]\right)+\left(\sum\limits_{j=0}^{m-1}(A’)^3[m-j-1]B[i+j]\right)\end{aligned}$ 设 $f(i)=\sum\limits_{j=0}^{i}A’[i-j]B^3[j]​$（即它们的卷积），将 $A’[m..n-1]​$ 设为 $0​$，那么 $\sum\limits_{j=0}^{m-1}A’[m-j-1]B^3[i+j]=f(i+m-1)​$。 可以类似地计算另外两项，就可以求出所有 $dis(A,B[i..i+m-1])​$，看看哪些等于零就好了。 参考代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cmath&gt;#include &lt;vector&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const int N=1&lt;&lt;19;const double PI=acos(-1);struct cp&#123; double re,im; cp(double _re=0.0,double _im=0.0) &#123; re=_re; im=_im; &#125; cp operator+(const cp&amp; b) const &#123; return cp(re+b.re,im+b.im); &#125; cp operator-(const cp&amp; b) const &#123; return cp(re-b.re,im-b.im); &#125; cp operator*(const cp&amp; b) const &#123; return cp(re*b.re-im*b.im,re*b.im+im*b.re); &#125;&#125; a[N],a2[N],a3[N],b[N],b2[N],b3[N],c1[N],c2[N],c3[N];void fft(cp* A,int type);int n,m,lim,L,r[N];char s[N],t[N];vector&lt;int&gt; ans;int main()&#123; int i; scanf("%d%d%s%s",&amp;m,&amp;n,s,t); for (i=0;i&lt;n;++i) &#123; if (m-i&gt;0&amp;&amp;s[m-i-1]!='*') &#123; a[i].re=s[m-i-1]-'a'+1; a2[i].re=a[i].re*a[i].re; a3[i].re=a[i].re*a2[i].re; &#125; if (t[i]!='*') &#123; b[i].re=t[i]-'a'+1; b2[i].re=b[i].re*b[i].re; b3[i].re=b[i].re*b2[i].re; &#125; &#125; for (lim=0,L=1;L&lt;=n;++lim,L&lt;&lt;=1); for (i=1;i&lt;L;++i) r[i]=(r[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)&lt;&lt;(lim-1)); fft(a,1); fft(a2,1); fft(a3,1); fft(b,1); fft(b2,1); fft(b3,1); for (i=0;i&lt;L;++i) &#123; c1[i]=a[i]*b3[i]; c2[i]=a2[i]*b2[i]; c3[i]=a3[i]*b[i]; &#125; fft(c1,-1); fft(c2,-1); fft(c3,-1); for (i=m-1;i&lt;n;++i) &#123; if (c1[i].re-2*c2[i].re+c3[i].re&lt;0.5) &#123; ans.push_back(i-m+2); &#125; &#125; printf("%d\n",int(ans.size())); for (i=0;i&lt;ans.size();++i) printf("%d ",ans[i]); return 0;&#125;void fft(cp* A,int type)&#123; int i,j,k; for (i=1;i&lt;L;++i) if (i&lt;r[i]) swap(A[i],A[r[i]]); for (i=1;i&lt;L;i&lt;&lt;=1) &#123; cp w1(cos(PI/i),type*sin(PI/i)); for (j=0;j&lt;L;j+=2*i) &#123; cp w(1,0); for (k=j;k&lt;i+j;++k,w=w*w1) &#123; cp t=A[k+i]*w; A[k+i]=A[k]-t; A[k]=A[k]+t; &#125; &#125; &#125; if (type==-1) for (i=0;i&lt;L;++i) A[i].re=A[i].re/L;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>字符串</tag>
        <tag>FFT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019YALI省选集训垫底记]]></title>
    <url>%2F2019YALI%E7%9C%81%E9%80%89%E9%9B%86%E8%AE%AD%E5%9E%AB%E5%BA%95%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[时隔半年又来到了YALI。 Day 0中午放学，下午就坐火车走了。 晚上被骗去吃火宫殿.. 然后做了一个 slide. Day 1T1是个字符串，一开始以为可以 $50$，先把 $30$ 写了然后去看后两题，回来发现那 $20$ 没法写..最后因为数组名 $end$ CE了.. T2还是个字符串，只不过是在图上，是道大象题，求期望，要高斯消元，利用非 $0​$ 项很少来降低复杂度。一开始先把不用求期望（每个点出度为 $1​$）的 $20​$ 分写了，然后就去看 $T3​$。后来回头发现 $T1​$ 的 $20​$ 写不出来，就来写这题的 $10​$ 分暴力高斯消元，然后调了 $1h​$，一开始先是概率各种算错，后来其它的都写对了，结果我脑抽写成了字符串失配跳到 $0​$ … T3是zzq最爱的提答，又是给一种计算机。随便玩了 $47​$ 分。下午讲题的时候有几位神仙在那快乐地碾了碾标算.. 做题的时候先是看到 ctr zzq，然后往右一看，发现 zzq 就在黑板前的电脑前坐着..之前就听说 _rqy 也要来，做题做到一半的时候看到 _rqy 去找 zzq 报告了两个 bug.. 之前就有猜测过： 然后..下午果然是神仙聊天场，_rqy 现场推多项式三角函数.. 晚上没去机房..游记就是晚上写的qaq Day 2今天有三种类型的题目，性价比高。 T1 是道图论交互，只会暴力 $20$.. T2 是道图论传统题，一开始以为直接欧拉回路就是正解，然后随便一拍就挂了..后来得知欧拉回路是正解的一部分。 T3 是道扫雷提答，暴力跑了 $4​$ 个点，构造了两个点，下午的时候手玩了一个点..是除了周围雷数还有行/列之和，行/列连续段个数之类的那种。 下午讲题的时候竟然有人讲美樱的颜料..个人认为那题出的不是很好..尤其是Sooke为卡loglogn设的空间限制.. Day 3今天是讲题..感觉全场可能就我不会生成函数，只不过感觉好像大概弄明白了。 晚上把讲题咕咕了，结果不小心错过了 _rqy 的难题选讲.. Day 4T1 是个数据结构，看了看觉得有 $41$ 分非常可做，先写了个暴力去肝后面两题，最后回来写这题，很快写完了 $30$ 分，然后把 $30$ 分备份了一下去写剩下的 $11$ 分，写的过程中发现 $30$ 分有个地方挂了，就在 $41$ 分代码里面改过来了，后来剩下 $11$ 分没写完，就把备份（没修改那个地方）的代码交上去了..最后连询问数为 $0$ 的 subtask 都挂了，只有 $22$ 分。 T2 是道小清新0.5KB找规律题。成功找到规律然后 A 掉了.. T3 是俄罗斯方块提答..搞了三个点，剩下的随机..获得了 $16$ 分的好成绩。之后 _rqy 说自己写了个模拟器手玩，于是我下午就自己写了个模拟器手玩..草，真的又好写又好玩，$1h$ 十几分绝对没问题.. Day 5今天大众分 $200$..窝愉快垫底了。 T1 是个数据结构，定义数列中每个数的后继为它后面比它大的第一个数，区间询问跳到后继最多能跳多少步。暴力 $30$ 分滚粗。 T2 是个树交互，还比较简单吧..然而 std 做法看起来就很麻烦，所以没仔细听具体是怎么做的。 T3 是道 MO 题，全场只有暴力 $15$ 和爆零..然后我考场上愉快地调了 $2h​$ 暴力，RETLEWA……最后还是没调出来。 Day 6今天又是讲题..晚上轮到我难题讨论，讲了下早就被我讲烂了的皇后游戏&amp;由乃大母神原型与偶像崇拜。 Day 7T1 是一个树上的神仙题..把暴力 $68$ 分打满了（$n^2$&amp;链&amp;菊花）。考场上写完菊花之后去看 T2，T3，然后放在那对拍，错了五六次才调对.. T2 是个神仙博弈论，只写了暴力 $17$ 分.. T3 是个神仙交互，用随机化搞到了 $66$ 分（期望得分 $67$，脸黑被卡到了 $66.99$），然而没有发现把 subtask3 的代码复制到 subtask4 后面就可以轻松获得 $60\%$ subtask5 的分数.. 这场虽然没 A 题，然而好像是我得分最高的一场？ Day 8T1指令集RE了..只不过写了数据分治还有暴力分。本地比正解跑的还快qaq..ylh用 $\mathcal O(n\sqrt n\log n)$ 艹过去了 Orz. T2暴力。 T3暴力被卡常了。 垫底..分最低的一次。 Day 9讲课，颓。 Day 10T1暴力，ylh的暴力偏序被卡了。 T2会求答案不会求方案，结果下午才知道大家都会求答案.. T3暴力，不会类欧自闭了。 Day 11和第二天互换了，讲课，继续春眠zzz.. Day 12今天 T1 是五子棋互打，想着今天是最后一天，于是就真的写了整场（$3.5h$）的 T1。一开始写了个爆搜，后来发现很蠢，于是就算了个估价函数，然后感觉很对。然而 ctr 乱测..之后我把 ctr 测出来的前 $21$ 名测了一下，和 ctr 测出来的差别还挺大的..只不过我好像在执黑/执白的情况下都打过了其它人写的AI..然而被 ylh（人）击败了.. T2 题面掉了个关键条件，于是不会做..花 $20min$ 写了 $35$ 分。 T3 觉得部分分写起来很麻烦，于是最后半个多小时就一直在看自己的 AI 和自己的 AI 下棋.. 总结要是省选没有非传统题就要凉凉的感觉…]]></content>
      <categories>
        <category>游记</category>
      </categories>
      <tags>
        <tag>集训</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ3622 已经没有什么好害怕的了（二项式反演，组合数学）]]></title>
    <url>%2FBZOJ3622-%E5%B7%B2%E7%BB%8F%E6%B2%A1%E6%9C%89%E4%BB%80%E4%B9%88%E5%A5%BD%E5%AE%B3%E6%80%95%E7%9A%84%E4%BA%86%EF%BC%88%E4%BA%8C%E9%A1%B9%E5%BC%8F%E5%8F%8D%E6%BC%94%EF%BC%8C%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6%EF%BC%89%2F</url>
    <content type="text"><![CDATA[题目链接洛谷 darkbzoj 题意简述给你两个长为 $n$ 、无重复元素的数列 $a,b$，求将 $b$ 重排后 $\left(\sum\limits_{i=1}^n[a_i&gt;b_i]\right)-\left(\sum\limits_{i=1}^n[a_i&lt;b_i]\right)=k$（$k$ 给定）的方案数。 $n\le2000$。 简要做法首先，$a$ 大于 $b$ 比 $b$ 大于 $a$ 多 $k$ 对可以转化为 $a$ 大于 $b$ 有 $\frac{n+k}2$ 对。 考虑 $dp​$，设 $f(i,j)​$ 为 $a_{1..i}​$ 中选 $j​$ 个数，给这 $j​$ 个数每个数匹配一个小于它的 $b​$ 的方案数。为方便转移，一开始要先对 $a,b​$ 分别从小到大排序，这样的话若 $a_i&gt;b_j​$，必然有 $a_{i+1}&gt;b_j​$。 设比 $a_i$ 大的 $b$ 有 $cnt_i$ 个，转移方程就是 $f(i,j)=f(i-1,j)+(cnt_i-j+1)\times f(i-1,j-1)$。$cnt_i$ 可以二分查找/双指针计算。 考虑这样一个式子：$f(n,i)\times(n-i)!$，它的意义是，先从 $a$ 中选 $i$ 个数，给它们分别匹配一个小于它们的 $b$，再把剩下的 $n-i$ 个数随意匹配。这个式子并不是某种“方案数”，因为它可能会将相同的匹配方案算重。事实上，对于每种恰有 $j$ 对 $a&gt;b$ 的匹配方案，它在 $f(n,i)\times(n-i)!$ 中被计算了 $\binom{j}{i}$ 次。令 $ans_i$ 表示恰好有 $i$ 对 $a$ 大于 $b$ 的方案数，就有 $ans_i=f(n,i)\times(n-i)!-\sum\limits_{j=i+1}^n\binom{j}{i}ans_j$。这样的话，就可以递推地计算答案。 这题还有另一种做法，叫二项式反演。我自己没有太理解清楚这种方法，所以不详细阐述。这种做法可以 $O(n)​$ 地计算某个 $ans_i​$，但不影响总复杂度（$dp​$ 还是 $O(n^2)​$ 的）： $$ans_i=\sum\limits_{j=i}^n(-1)^{j-i}\binom j i f(n,j)\times(n-j)​$$ 参考代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;typedef long long ll;const int N=2010;const int mod=1e9+9;int qpow(int x,int y);int n,k,a[N],b[N],f[N][N],ans[N],c[N][N],fac[N];int main()&#123; int i,j,cnt=0; cin&gt;&gt;n&gt;&gt;k; if ((n&amp;1)!=(k&amp;1)) &#123; cout&lt;&lt;0; return 0; &#125; k=(n+k)/2; for (i=1;i&lt;=n;++i) scanf("%d",a+i); for (i=1;i&lt;=n;++i) scanf("%d",b+i); sort(a+1,a+n+1); sort(b+1,b+n+1); fac[0]=1; for (i=1;i&lt;=n;++i) fac[i]=(ll)fac[i-1]*i%mod; c[0][0]=1; for (i=1;i&lt;=n;++i) &#123; c[i][0]=1; for (j=1;j&lt;=i;++j) c[i][j]=(c[i-1][j-1]+c[i-1][j])%mod; &#125; f[0][0]=1; for (i=1;i&lt;=n;++i) &#123; f[i][0]=1; while (cnt&lt;n&amp;&amp;b[cnt+1]&lt;a[i]) ++cnt; for (j=1;j&lt;=cnt;++j) &#123; f[i][j]=(f[i-1][j]+(ll)f[i-1][j-1]*(cnt-j+1))%mod; &#125; &#125; for (i=n;i&gt;=k;--i) &#123; ans[i]=(ll)f[n][i]*fac[n-i]%mod; for (j=n;j&gt;i;--j) ans[i]=(ans[i]+mod-(ll)ans[j]*c[j][i]%mod)%mod; &#125; cout&lt;&lt;ans[k]; return 0;&#125;int qpow(int x,int y)&#123; int out=1; while (y) &#123; if (y&amp;1) out=(ll)out*x%mod; x=(ll)x*x%mod; y&gt;&gt;=1; &#125; return out;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>组合数学</tag>
        <tag>二项式反演</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ4665 小w的喜糖（容斥原理，组合数学）]]></title>
    <url>%2FBZOJ4665-%E5%B0%8Fw%E7%9A%84%E5%96%9C%E7%B3%96%EF%BC%88%E5%AE%B9%E6%96%A5%E5%8E%9F%E7%90%86%EF%BC%8C%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6%EF%BC%89%2F</url>
    <content type="text"><![CDATA[题目链接darkbzoj 题意简述给你一个数列，求重排后每个位置都变了的方案数。 数列长度和值域都是 $2000$。 简要做法考虑容斥，计 $g(S)​$ 为 $S​$ 这个集合内的所有位置都不变的方案数，$U​$ 为位置的全集（即 $1​$ ~ $n​$），$i​$ 这个数出现了 $cnt[i]​$ 次，答案即为 $\frac{n!}{\prod\limits_{i=1}^ncnt[i]!}+\sum\limits_{S\subseteq U,S\ne\varnothing}(-1)^{|S|}g(S)​$。 计 $P_i$ 为 $i$ 这个数出现的位置集合，那么 $g(S)=\frac{(n-|S|)!\prod\limits_{i=1}^n\frac{cnt[i]!}{(cnt[i]-|P_i\bigcap S|)!}}{\prod\limits_{i=1}^ncnt[i]!}​$。 暴力枚举子集肯定是过不了的，考虑如何优化。 容斥原理的优化一般是将答案相同/结构相似的部分合在一起算，这题中，可以尝试将 $|S|$ 相同的集合合在一起算，问题就在于如何快速计算 $|S|$ 相同的所有 $\prod\limits_{i=1}^n\frac{cnt[i]!}{(cnt[i]-|P_i\bigcap S|)!}$ 之和。 这个东西可以用 $dp$ 解决：设 $f(i,j)$ 为从值为 $1$ ~ $i$ 的所有数中选 $j$ 个数的所有不同方案的贡献之和，其中，一种选法的贡献就是将选的数作为 $S$ 的 $\prod\limits_{i=1}^n\frac{cnt[i]!}{(cnt[i]-|P_i\bigcap S|)!}$。转移时枚举值为 $i$ 的数选了 $k$ 个，那么 $f(i,j)=\sum\limits_{k=0}^{\min(j,cnt[i])}\frac{cnt[i]!}{(cnt[i]-k)!}\binom{cnt[i]}kf(i-1,j-k)$. 由于 $cnt[i]$ 之和为 $n$，$dp$ 复杂度是 $O(n^2)$。 这样的话，最终的答案就是 $\frac{n!+\sum\limits_{i=1}^n(-1)^i(n-i)!f(n,i)}{\prod\limits_{i=1}^ncnt[i]!}$，实际上 $f(n,0)=1$，所以也可以化简为 $\frac{\sum\limits_{i=0}^n(-1)^i(n-i)!f(n,i)}{\prod\limits_{i=1}^ncnt[i]!}$. 参考代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;iostream&gt;#include &lt;cstdio&gt;using namespace std;typedef long long ll;const int N=2010;const int mod=1e9+9;int qpow(int x,int y);int n,cnt[N],fac[N],inv[N],f[N][N],c[N][N],ans;int main()&#123; int i,j,k,x; cin&gt;&gt;n; fac[0]=inv[0]=1; for (i=1;i&lt;=n;++i) &#123; cin&gt;&gt;x; ++cnt[x]; fac[i]=(ll)fac[i-1]*i%mod; inv[i]=qpow(fac[i],mod-2); &#125; c[0][0]=1; for (i=1;i&lt;=n;++i) &#123; c[i][0]=1; for (j=1;j&lt;=i;++j) c[i][j]=(c[i-1][j-1]+c[i-1][j])%mod; &#125; f[0][0]=1; for (i=1;i&lt;=n;++i) &#123; for (j=0;j&lt;=n;++j) &#123; for (k=0;k&lt;=cnt[i]&amp;&amp;k&lt;=j;++k) &#123; f[i][j]=(f[i][j]+(ll)fac[cnt[i]]*inv[cnt[i]-k]%mod*f[i-1][j-k]%mod*c[cnt[i]][k])%mod; &#125; &#125; &#125; for (i=0;i&lt;=n;++i) ans=(ans+(ll)(i&amp;1?-1:1)*fac[n-i]*f[n][i]+mod)%mod; for (i=1;i&lt;=n;++i) ans=(ll)ans*inv[cnt[i]]%mod; cout&lt;&lt;ans; return 0;&#125;int qpow(int x,int y)&#123; int out=1; while (y) &#123; if (y&amp;1) out=(ll)out*x%mod; x=(ll)x*x%mod; y&gt;&gt;=1; &#125; return out;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>组合数学</tag>
        <tag>容斥原理</tag>
        <tag>计数dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ4003 [JLOI2015]城池攻占（左偏树）]]></title>
    <url>%2FBZOJ4003-JLOI2015-%E5%9F%8E%E6%B1%A0%E6%94%BB%E5%8D%A0%EF%BC%88%E5%B7%A6%E5%81%8F%E6%A0%91%EF%BC%89%2F</url>
    <content type="text"><![CDATA[题目链接洛谷 darkbzoj 题意简述给你一棵树，每个节点有 $h$ 值，一个勇士来到一个节点时如果他的战斗力大于等于 $h$ 就能占领城池并前往这个节点的父亲（除非已经到了根节点），否则阵亡；攻占一个节点后，勇士的战斗力会加/减/乘一个正整数（根据节点而定）；每个勇士有初始战斗力和想占领的第一个节点。问，每个节点各有多少个勇士阵亡，每个勇士各占领了几个节点。 简要做法每个节点搞个小根可并堆维护该节点所有勇士（包括一开始就在这的和爬上来的），当堆顶小于 $h$ 时弹出并更新答案，直到堆为空或者堆顶大于等于 $h$，然后再加/减/乘，合并到父亲。 加/减/乘：更新堆顶并打标记，在所有需要访问儿子的地方（弹出堆顶时/合并时）下传标记。 合并复杂度：每个勇士初始位置需要合并一次，每个节点合并到父亲要一次，$O((n+m)\log m)$；弹出复杂度：每个勇士最多被弹出一次，$O(m\log m)$；修改复杂度：除了下传标记外每次修改都是 $O(1)$ 的，所以是 $O(n)$；总复杂度：$O((n+m)\log m)$。 参考代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cctype&gt;#include &lt;algorithm&gt;using namespace std;typedef long long ll;ll read()&#123; ll out=0; int f=1; char c; for (c=getchar();!isdigit(c)&amp;&amp;c!='-';c=getchar()); if (c=='-') f=-1,c=getchar(); for (;isdigit(c);c=getchar()) out=out*10+c-'0'; return out*f;&#125;const int N=300010;struct Node&#123; int ls,rs,d; ll val,add,mul; Node()&#123;ls=rs=add=0;d=mul=1;&#125;&#125; t[N];int merge(int x,int y);int pop(int x);void madd(int u,ll x);void mmul(int u,ll x);void pushdown(int x);void add(int u,int v);void dfs(int u);int head[N],nxt[N],to[N],cnt;int n,m,p[N],f[N],a[N],dep[N],c[N],ans1[N],ans2[N];ll h[N],b[N];int main()&#123; int i; n=read(); m=read(); for (i=1;i&lt;=n;++i) h[i]=read(); for (i=2;i&lt;=n;++i) &#123; f[i]=read(); add(f[i],i); a[i]=read(); b[i]=read(); &#125; for (i=1;i&lt;=m;++i) &#123; t[i].val=read(); c[i]=read(); p[c[i]]=merge(i,p[c[i]]); &#125; dfs(1); for (i=1;i&lt;=n;++i) printf("%d\n",ans1[i]); for (i=1;i&lt;=m;++i) printf("%d\n",ans2[i]); return 0;&#125;void dfs(int u)&#123; int i,v; for (i=head[u];i;i=nxt[i]) &#123; v=to[i]; dep[v]=dep[u]+1; dfs(v); &#125; while (p[u]&amp;&amp;t[p[u]].val&lt;h[u]) &#123; ++ans1[u]; ans2[p[u]]=dep[c[p[u]]]-dep[u]; p[u]=pop(p[u]); &#125; if (a[u]) mmul(p[u],b[u]); else madd(p[u],b[u]); if (u&gt;1) p[f[u]]=merge(p[u],p[f[u]]); else while (p[u]) &#123; ans2[p[u]]=dep[c[p[u]]]+1; p[u]=pop(p[u]); &#125;&#125;void add(int u,int v)&#123; nxt[++cnt]=head[u]; head[u]=cnt; to[cnt]=v;&#125;int merge(int x,int y)&#123; if (!x||!y) return x|y; if (t[x].val&gt;t[y].val) swap(x,y); pushdown(x); t[x].rs=merge(t[x].rs,y); if (t[t[x].rs].d&gt;t[t[x].ls].d) swap(t[x].ls,t[x].rs); t[x].d=t[t[x].rs].d+1; return x;&#125;int pop(int x)&#123; pushdown(x); return merge(t[x].ls,t[x].rs);&#125;void madd(int u,ll x)&#123; t[u].val+=x; t[u].add+=x;&#125;void mmul(int u,ll x)&#123; t[u].val*=x; t[u].add*=x; t[u].mul*=x;&#125;void pushdown(int x)&#123; mmul(t[x].ls,t[x].mul); madd(t[x].ls,t[x].add); mmul(t[x].rs,t[x].mul); madd(t[x].rs,t[x].add); t[x].add=0; t[x].mul=1;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>左偏树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CF235C Cyclical Quest（SAM）]]></title>
    <url>%2FCF235C-Cyclical-Quest%EF%BC%88SAM%EF%BC%89%2F</url>
    <content type="text"><![CDATA[题目链接洛谷 CF problemset CF contest 题意简述给你一个字符串 $s$ 和 $n$ 个字符串 $x_{1..n}$，对每个 $x_i$，求有多少个 $s$ 的子串可以由 $x_i$ 旋转得到。 旋转一个字符串就是把它的一个前缀移到后面，如 abcd 可以旋转得到的字符串有 abcd，bcda，cdab，dabc。 简要做法对 $s$ 建 SAM，把 $x_i$ 旋转得到的每个字符串用 SAM 读入，就可以求答案了。（SAM 求子串出现次数是经典问题，可以参考我的博客） 分开读入每个 $x_i$ 旋转得到的字符串显然会超时，然而，SAM 读入字符串是支持删除首字符的：记录当前读入的长度 $l$ 以及所处状态 $u$，删除字符就把 $l$ 减一，若减一后 $l=len(parent(u))$，则转移到 $parent(u)$（把 $u$ 赋值为 $parent(t)$）。需要注意的是，如果读入一个字符的时候当前状态没有这个字符的出边，就需要在 $parent$ 树上向上跳，直到有这个字符的出边，同时更新 $l$ 。这样的话，删除字符前就要先判断 $l$ 与需要保留的字符串的长度的关系。具体细节可以参考代码及注释。 所以，先读入 $x_i$ 统计答案，再删去首字符读入 $x_i[0]$ 统计答案，删去首字符读入 $x_i[1]$ 统计答案……就只用读入 $O(len(x_i))​$ 个字符。 还有一个问题，就是去重。$s$ 的一个子串可能可以和 $x_i$ 不同的旋转匹配。解决这个问题有两个方法，第一个是求出 $x_i​$ 的周期（可以用 kmp 求），第二个方法是在 SAM 上打标记。我用的是打标记的方法，具体细节还是可以参考代码及注释。 参考代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;using namespace std;const int N=1000010;struct Node&#123; int len,par,ch[26],vis,cnt;&#125; sam[N&lt;&lt;1];void insert(int x);void read(int x);void del();void calc();void add(int u,int v);void dfs(int u);char s[N];int head[N&lt;&lt;1],nxt[N&lt;&lt;1],to[N&lt;&lt;1],cnt;int p,tot,n,m,l,u,tim,ans;int main()&#123; int i; scanf("%s%d",s,&amp;n); sam[0].par=-1; for (i=0;s[i];++i) insert(s[i]-'a'); for (i=1;i&lt;=tot;++i) add(sam[i].par,i); dfs(0); for (tim=1;tim&lt;=n;++tim) &#123; scanf("%s",s); m=strlen(s); ans=u=l=0; for (i=0;i&lt;m;++i) read(s[i]-'a'); calc(); for (i=0;i&lt;m-1;++i) &#123; read(s[i]-'a'); del(); calc(); &#125; printf("%d\n",ans); &#125; return 0;&#125;void read(int x) //读入一个字符&#123; while (u&amp;&amp;!sam[u].ch[x]) l=sam[u=sam[u].par].len; //向上跳直至有这个字符的出边 if (sam[u].ch[x]) &#123; ++l; u=sam[u].ch[x]; &#125;&#125;void del() //删除首字符&#123; if (l&gt;m&amp;&amp;--l==sam[sam[u].par].len) u=sam[u].par; //m表示当前xi的长度，只有l&gt;m的时候才删除&#125;void calc() //计算当前的答案&#123; if (l==m&amp;&amp;sam[u].vis&lt;tim) //只有当前读入的串长度恰好为m且当前状态没有打上标记时才统计答案 &#123; ans+=sam[u].cnt; sam[u].vis=tim; //打标记 &#125;&#125;void insert(int x) //向SAM中插入字符，有人把这个函数叫做extend&#123; int np=++tot; sam[np].len=sam[p].len+1; sam[np].cnt=1; while (~p&amp;&amp;!sam[p].ch[x]) &#123; sam[p].ch[x]=np; p=sam[p].par; &#125; if (p==-1) sam[np].par=0; else &#123; int q=sam[p].ch[x]; if (sam[q].len==sam[p].len+1) sam[np].par=q; else &#123; int nq=++tot; sam[nq].len=sam[p].len+1; memcpy(sam[nq].ch,sam[q].ch,sizeof(sam[q].ch)); sam[nq].par=sam[q].par; sam[q].par=sam[np].par=nq; while (~p&amp;&amp;sam[p].ch[x]==q) &#123; sam[p].ch[x]=nq; p=sam[p].par; &#125; &#125; &#125; p=np;&#125;void add(int u,int v) //加边，用于遍历parent树&#123; nxt[++cnt]=head[u]; head[u]=cnt; to[cnt]=v;&#125;void dfs(int u) //遍历parent树，计算每个状态的出现次数&#123; int i,v; for (i=head[u];i;i=nxt[i]) &#123; v=to[i]; dfs(v); sam[u].cnt+=sam[v].cnt; &#125;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>字符串</tag>
        <tag>SAM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[后缀自动机（SAM）学习笔记]]></title>
    <url>%2F%E5%90%8E%E7%BC%80%E8%87%AA%E5%8A%A8%E6%9C%BA%EF%BC%88SAM%EF%BC%89%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[后缀自动机是一种处理字符串问题的有力工具（废话），它的码量不比后缀数组大（实际代码难度不比后缀数组小，但也不难），处理问题时的思维难度往往比后缀数组小，复杂度更优秀。若字符集大小为 $|\Sigma|$，则：构建时间复杂度 $O(n|\Sigma|)$，转移时间复杂度 $O(1)$，空间复杂度 $O(n|\Sigma|)$ 或 构建时间复杂度 $O(n\log|\Sigma|)$，转移时间复杂度 $O(\log|\Sigma|)$，空间复杂度 $O(n)$。 这篇文章会按我的理解详细地介绍一下 SAM，是否比其它教程更好懂我就不做评论了（毕竟所有人都认为自己的教程最好懂），只不过我会尽量保证教程的严谨性和正确性，同时尽量简洁（简洁地表达所有内容，而不是有选择地删去内容）。这篇写的比较口胡随意..拉低了我写的教程的平均水平..只不过还是比市面上某些博客要强一些的（吧）。 这篇文章最大的特点..大约是讲了一些关于将自动机的状态数压缩至最少的方法。（然而后来发现百度百科就有。） 确定有限状态自动机（DFA）一个 确定有限状态自动机（DFA） 由以下五部分构成： 字符集（$\Sigma$），该自动机只能输入这些字符。 状态集合（$Q$）。如果把一个DFA看成一张有向图，那么 DFA 中的状态就相当于图上的顶点。 起始状态（$start$），$start\in Q$，是一个特殊的状态。起始状态一般用 $s$ 表示，为了避免混淆，本文中使用 $start$。 接受状态集合（$F$），$F\subseteq Q$，是一堆特殊的状态。 转移函数（$\delta$），$\delta$ 是一个接受两个参数返回一个值的函数，其中第一个参数和返回值都是一个状态，第二个参数是字符集中的一个字符。如果把一个DFA看成一张有向图，那么 DFA 中的转移函数就相当于顶点间的边，而每条边上都有一个字符。 DFA 的作用就是识别字符串，一个自动机 $A$，若它能识别（接受）字符串 $S$，那么 $A(S)=True$，否则 $A(S)=False$。 当一个DFA读入一个字符串时，从初始状态起按照转移函数一个一个字符地转移。如果读入完一个字符串的所有字符后位于一个接受状态，那么我们称这个 DFA 接受 这个字符串，反之我们称这个 DFA 不接受 这个字符串。 如果一个状态 $v$ 没有字符 $c$ 的转移，那么我们令 $\delta(v,c)=null$，而 $null$ 只能转移到 $null$，且 $null$ 不属于接受状态集合。无法转移到任何一个接受状态的状态都可以视作 $null$，或者说，$null$ 代指所有无法转移到任何一个接受状态的状态。 我们扩展定义转移函数 $\delta$，令其第二个参数可以接收一个字符串：$\delta(v,s)=\delta(\delta(v,s[1]),s[2..|s|])$，这个扩展后的转移函数就可以表示从一个状态起接收一个字符串后转移到的状态。那么，$A(s)=[\delta(start,s)\in F]$。 如，一个接受且仅接受字符串 “a”, “ab”, “aac” 的 DFA： 后缀自动机（SAM）定义一个字符串的 后缀自动机（SAM） 就是一个 接受且仅接受 这个字符串的 所有后缀 的 DFA。 下文中以 $SAM_s$ 代指字符串 $s$ 的后缀自动机，$\delta_s$ 代指 $SAM_s$ 的转移函数。若不带下标则表示字符串为母串 $s$（需要构建 SAM 的那个字符串）。 根据定义，一个字符串 $t$ 是一个字符串 $s$ 的后缀，当且仅当 $SAM_s(t)=True$。 性质一个字符串 $t$ 是一个字符串 $s$ 的子串，当且仅当 $\delta_s(start_s,t)\neq null$。 因为，若 $t$ 是 $s$ 的子串，则在 $t$ 之后添加字符可能成为 $s$ 的一个后缀，反之不可能。 一个朴素的SAM若我们将一个字符串的所有后缀插入到一个字典树（Trie 树）中，并将每次插入的终止节点标记为接受状态，就可以得到一个状态数为 $O(n^2)$ 的SAM。 如，串 “abaaabaa” 的一个 朴素SAM： 最简SAM上文中的“朴素SAM”状态数是 $O(n^2)$ 的，而 最简SAM 的状态数和转移数（点数和边数）都是 $O(n)$ 的。 $right$ 集合对于一个字符串 $t$，若它在 $s$ 中出现的位置集合为：$\{[l_1,r_1),[l_2,r_2),\cdots,[l_n,r_n)\}$（下标从 $0$ 开始），那么定义 $right(t)$ 为 $\{r_1,r_2,\cdots,r_n\}$。 如，又是串 “abaaabaa”，那么 $right(a)=\{1,3,4,5,7,8\}$，$right(aa)=\{4,5,8\}$，$right(aab)=\{6\}$。 在有的教程中，也称其为 $endpos$ 集合。 $right$ 集合等价类$right$ 集合等价类的定义$right$ 集合相等的字符串组成一个 $right$ 集合等价类。 如，双是串 “abaaabaa”，那么 $right$ 集合为 $\{4,8\}$ 的字符串有 $\{abaa,baa\}$，这两个字符串组成一个 $right$ 集合等价类。 $right$ 集合等价类与最简SAM我们定义 $reg(v)$ 表示 从状态 $v$ 开始能识别的字符串的集合。即：$t\in reg(v)$ 当且仅当 $\delta(v,t)\in F$（$F$ 为接受状态集合）。 如果在 $t$ 的后面补上一个字符串 $s[r_i..n]$（$r_i\in right(t)$，$n$ 表示 $s$ 的长度），就得到了 $s$ 的一个后缀。所以，若 $right(t_1)=right(t_2)$，那么 $reg(SAM(t_1))=reg(SAM(t_2))=\{s[r_i..n]|r_i\in right(t_1)\}$。 对于每个状态 $v$，我们只关心 $reg(v)$，所以可以用SAM上的每一个状态去表示一个 $right$ 集合等价类，转移函数也相应地更改为对应的等价类（令 $f(v)$ 表示原状态 $v$ 对应的字符串的 $right$ 集合等价类在最简SAM中对应的状态，那么原来的转移函数 $\delta(u,c)=v$ 更改为 $\delta’(f(u),c)=f(v)$。可以证明，若 $right(u_1)=right(u_2)$，那么 $right(\delta(u_1,c))=right(\delta(u_2,c))$，因为 $right(\delta(u,c))=\{r_i|r_i\in right(u),s[r_i]=c\}$）。 这样的SAM是状态数最少的，因为状态的 $reg$ 两两不同。这样的SAM若要和朴素SAM区分，可以叫做 最简SAM。但一般不加说明的SAM都指最简SAM。 这样的SAM，从起始状态到某个状态可能有多条路径，每条路径都对应一个字符串，那么我们称这个状态 对应 着这些字符串。 如，叒是串 “abaaabaa​” 的最简SAM： $right$ 集合等价类的性质对于每个状态 $v$，定义 $max(v)$ 和 $min(v)$ 分别表示 这个状态对应的 最长 和 最短 的字符串。 那么，$v$ 对应的任意一个字符串都是 $max(v)$ 的后缀，且不是 $min(v)$ 的真后缀。并且，$v$ 包含了所有这样的字符串。 第一点（$v$ 中的任意一个字符串都是 $max(v)$ 的后缀）可以由 $right$ 集合的定义得到。 第二点（且不是 $min(v)$ 的真后缀）可以由 $min(v)$ 的定义得到。 第三点（$v$ 包含了所有这样的字符串）可以由一个引理证明：对于一个字符串 $t$ ，它的 $right$ 集合是它的任意一个后缀的 $right$ 集合的子集。这个引理很好证明，进而可以证明这条性质。 如，叕是串 “abaaabaa”，$right$ 集合为 $\{6\}$ 的串有 $\{aab,aaab,baaab,abaaab\}$，若这个 $right$ 集合等价类对应状态 $v$，那么 $max(v)=abaaab$，$min(v)=aab$。 这条性质说明 “aaab” 和 “baaab” 都属于这个 $right$ 集合等价类，且 “ab” 和 “b” 不属于这个 $right$ 集合等价类。 证明第三点所用的引理说明，$right(aaab)\subseteq right(aab)\subseteq right(ab)\subseteq right(b)$，也就是 $\{6\}\subseteq\{6\}\subseteq\{2,6\}\subseteq\{2,6\}$ 。 $parent$$parent$ 的定义$parent$ 有两种等价的定义（你也可以把其一视作定义，另一个视作性质）： 定义一对于每个状态 $v$（除了起始状态），找到最长的一个字符串 $t$ 所对应的状态，使得 $right(v)\subsetneq right(t)$（注意是真子集；如果不存在这样的字符串就找起始状态），这样的状态就是 $parent(v)$。 定义二对于每个状态 $v$（除了起始状态），$min(v)[1..n-1]$ 对应的状态（$n$ 表示 $min(v)$ 的长度，假定空串对应起始状态）就是 $parent(v)$。 有的教程中把 $parent$ 叫做后缀连接 $link$。 $parent$ 的性质$len(min(v))=len(max(parent(v)))+1$，这个可以由定义二说明。 $parent$ 树$parent$ 连接可以构成一棵树。 由定义一，由 $right$ 集合要么包含要么不相交可以说明。$parent$ 树可以看成 $right$ 集合的包含关系所构成的树。 由定义一或定义二，由除起始状态外的状态都有且仅有一条出边并且 $parent$ 连接无环（$right$ 集合大小递增/对应字符串长度递减）可以说明。 如，醊是串 “abaaabaa”，它的 $parent$ 树：（用 $max(v)$ 代表每个状态） SAM上的接受状态就是包含 $r_i=n$（字符串长度）的一些 $right$ 集合等价类，也就是 $parent$ 树上 $\{n\}$ 对应的状态及其祖先。因此，可以通过 $parent$ 树确定SAM的接受状态集合。 最简SAM状态数为线性的证明每次把 $right$ 集合分成 $k$ 部分需要 $k$ 条边，最坏情况下每次都只分成两部分，总共要分成至多 $n$ 部分，所以状态数不会超过 $2n-1$（分 $n-1$ 次最多 $2n-2$ 条边，也就是 $2n-1$ 个点）。 最简SAM转移数为线性的证明考虑SAM的任意一个生成树，那么SAM上的边就会被分成树边和非树边。 树边最多只有 $2n-2$ 条。 对于字符串的每个后缀，将其输入到SAM中都会经过一条终点为接受状态的路径，若经过了一条非树边，则称该后缀对应它经过的 第一条 非树边。 对于每条非树边 $(u,v)$，一定存在一条从起始状态到 $u$ 的不经过任何非树边的路径（因为树上两点间必定有路径），也一定存在一条从 $v$ 到任意一个接受状态的路径（否则 $v=null$），所以，至少有一个后缀对应着这条非树边。 因此，非树边数量不会超过后缀数量。总的边数就是 $O(n)$ 的。 最简SAM的线性构造SAM的线性构造可以在均摊 $O(1)$ 的时间复杂度内向SAM增加一个字符（从 $SAM_{s[0..i-1]}$ 变成 $SAM_{s[0..i]}$）。 向SAM增加一个字符，就是在所有接受状态后增加一个字符。所以，我们需要考虑上一次插入时的最后一个状态（$last$）以及它在 $parent$ 树上的祖先（也就是所有接受状态）。 加入一个字符 $x$ 时，我们先创建一个新状态 $np$，这个状态刚插入时代表 $right$ 集合 $\{i\}$（$i$ 表示这是插入的第 $i$ 个字符）。 一个引理：若一个状态有字符 $c$ 的转移，则它在 $parent$ 树上的祖先都有。 引理的证明：$right(\delta(v,c))=\{r_i|r_i\in right(v),s[r_i]=c\}$，而 $right(v)\subsetneq right(parent(v))$。 因此，找到 $last$ 最深的有出边 $x$ 的祖先 $p$ 后，在其之上的祖先都有出边 $x$。 对于在其之下的状态，直接向 $np$ 连边即可。 接下来要分三种情况讨论： 若不存在 $p$（起始状态都没有出边 $x$），则将 $parent(np)$ 设为初始状态。 否则，令 $len(v)$ 表示 $max(v)$ 的长度，$q$ 表示 $\delta(p,x)$。 若 $len(q)=len(p)+1$，将 $parent(np)$ 设为 $q$ 即可。 否则，新建状态 $nq$，$len(nq)$ 设为（实际上不是人为设定，它本来就是）$len(p)+1$，将 $q$ 的转移函数复制到 $nq$，然后将 $parent(nq)$ 设为 $parent(q)$，再将 $parent(q)$ 和 $parent(np)$ 都设为 $nq$，最后把 $p$ 及 $p$ 的祖先中所有出边 $x$ 连到 $q$ 的都改为连到 $nq$。实际上，枚举祖先时只要遇到出边 $x$ 不连到 $q$ 的就可以停止枚举了。 至于为什么这样做..恕我表达能力有限，还请参考陈立杰WC课件第 $35$ 页。 构建过程的复杂度证明可以参考 OI-Wiki。 参考代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;cstdio&gt;#include &lt;cstring&gt;const int N=1000010;struct Node&#123; int len,par,ch[26];&#125; sam[N&lt;&lt;1];void insert(int x);char s[N];int p,tot;int main()&#123; int i; scanf("%s",s); sam[0].par=-1; for (i=0;s[i];++i) insert(s[i]-'0'); return 0;&#125;void insert(int x)&#123; int np=++tot; sam[np].len=sam[p].len+1; while (~p&amp;&amp;!sam[p].ch[x]) &#123; sam[p].ch[x]=np; p=sam[p].par; &#125; if (p==-1) sam[np].par=0; else &#123; int q=sam[p].ch[x]; if (sam[q].len==sam[p].len+1) sam[np].par=q; else &#123; int nq=++tot; sam[nq].len=sam[p].len+1; memcpy(sam[nq].ch,sam[q].ch,sizeof(sam[q].ch)); sam[nq].par=sam[q].par; sam[q].par=sam[np].par=nq; while (~p&amp;&amp;sam[p].ch[x]==q) &#123; sam[p].ch[x]=nq; p=sam[p].par; &#125; &#125; &#125; p=np;&#125; SAM的一些应用一些应用我还没有写过..写过之后可能会补（gu）上（gu）来（gu）。可以参考OI wiki。 判断子串/后缀根据SAM的定义和性质，建出文本串的SAM，将模式串分别输入SAM，若转移到 $null$ 则不是子串，否则是；若转移到接受状态则是后缀，否则不是。 读入字符串时删除首字符记录一下已读入的字符串长度，若小于等于当前状态的 $parent.len$，就转移到 $parent$。 例题：CF235C Cyclical Quest 子串出现次数一个子串出现次数就是其对应 $right$ 集合的元素个数。 在创建 $np$ 时，将其 $cnt$ 赋为 $1$，建好SAM后，每个状态的出现次数就是 $parent$ 子树内的 $cnt$ 之和。 例题：【模板】后缀自动机 子串第一次出现位置和子串出现次数差不多，创建 $np$ 时，将 $firstpos(np)$ 设为 $len(np)-1$，复制 $nq$ 时，将 $firstpos(nq)$ 设为 $firstpos(q)$，最后对子树内取 $min$。 本质不同子串数每个状态表示 $maxlen-minlen+1$ 个字符串，而 $minlen=len(parent)+1$，所以一个状态表示的字符串数量就是 $len-parent.len$。求和即可。 例题：[SDOI2016]生成魔咒 第 $k$ 大子串预处理每个状态可以转移到多少个不同的子串，然后就可以做了。 例题： SP7258 SUBLEX [TJOI2015]弦论 两串的最长公共子串对其中一个串建SAM，从起始状态开始，读入另一个字符串，若有转移则转移，将已匹配长度 $+1$，否则跳到 $parent$（这里和 $kmp$ 有点像），并将已匹配长度修改为 $len(parent)$。过程中最大的已匹配长度就是答案。 例题：SP1811 LCS 多串的最长公共子串还是对其中一个串建SAM，以同样的方式依次读入每个字符串，只不过对每个状态要保存当前字符串的最大匹配长度，所有字符串在某个状态的最大匹配长度的最小值就是这一堆字符串在这个状态能匹配的最大长度。如果能在一个状态匹配，一定能在 $parent$ 处匹配，所以要对子树取 $max$，但也不要忘了对 $len$ 取 $min$。 例题： SP1812 LCS2 [SDOI2008]Sandy的卡片 任意DFA的压缩（UPD: 如果真的想学习这部分的内容，建议看百度百科或者查阅相关资料。） 这部分估计没人感兴趣..OI里没用，也不是证明SAM最小性必需的（最小性的证明我在前文中已经简略说明了：状态的 $reg$ 两两不同）。只不过或许会对理解SAM本质以及发明它的人怎么想到的有些帮助… 或许这种方式在很多年前就已经被人提出了..总之这部分内容完全是我自己yy的，我也懒得去查有没有人发明过。 这部分内容不保证正确性，如果有误欢迎指正。如果有人愿意提供严谨证明（怎么可能有人啊..只不过我这里都懒得严谨证明了，随便口头地说了一下）一定非常感谢。 “DFA的压缩”的定义一个可用于压缩DFA的映射 $f:Q_A\rightarrow Q_B$ 需要满足以下几个条件： $\forall v\ne start_A,f(v)\ne f(start_A)$ $\forall u\in F,v\notin F,f(u)\ne f(v)$ $\forall f(u)=f(v),c\in\Sigma,f(\delta_A(u,c))=f(\delta_A(v,c))$ 如：在SAM中，把所有 $right$ 集合相同的状态映射到同一状态就是一个符合条件的映射。 定义DFA $A$ 在映射 $f$ 下的压缩为 $B$，其中： $\Sigma_B=\Sigma_A$ $Q_B=f(Q_A)$ $start_B=f(start_A)$ $F_B=f(F_A)$ $\delta_B(f(v),c)=f(\delta_A(v,c))$，这一定义依赖于 $f$ 的性质 $3$。 如：用 $right$ 集合等价类这个映射可以将朴素SAM压缩成最简SAM。 压缩后的自动机与原自动机等价的证明我们证明一个比 $A(s)=B(s)$ 更强的命题：$[\delta_A(v,s)\in F_A]=[\delta_B(f(v),s)\in F_B]$。 当 $s$ 只有一个字符时，根据 $f$ 满足的性质 $2$ 以及 $B$ 的定义 $4,5$，命题显然成立。 当 $s$ 不止一个字符时，可以归纳地说明命题成立。 DFA的最简压缩方法 这里给出一个将任意DFA压缩至最简的方法： 由于DFA是一个DAG，它的任意生成子图都必定有出度为 $0$ 的点。每次找到这些点，然后从中选取尽量多的点，使其映射到同一个状态后满足 $f$ 需要满足的三条性质（也就是，同一字符转移到的状态映射到的状态相同，且没有一个是接受状态另一个不是的情况），然后将这些点从图中删去，重复直至所有点都有了映射后的状态（所有点都被删去）。这样得到的映射 $f$ 能够将原DFA压缩至最简。 压缩至最简的证明我们先证明每个状态的 $reg$（定义参见上文，表示从一个状态起能识别的字符串集合）两两不等。我们按照拓扑序归纳地证明。 没有出边的非接受状态可以视作 $null$，而没有出边的接受状态按上文所述方法必定会被映射至同一状态。所以命题对没有出边的状态成立。 假设一个状态所有出边的对应状态都已被证明，那么转移函数不同就等价于 $reg$ 不同，所以命题成立。 接着，我们由 $reg$ 两两不同证明压缩至最简： 若状态数继续减少，那么必然存在原来 $reg$ 不同的两个状态 $B(s_1)$ 和 $B(s_2)$ 被压缩到了一起，任取一个只在 $reg(B(s_1))$ 或只在 $reg(B(s_2))$ 中的字符串 $t$，原来 $B(s_1+t)\ne B(s_2+t)$，压缩后却使得 $B’(s_1+t)=B’(s_2+t)$，不符合要求。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>字符串</tag>
        <tag>SAM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[P3804 【模板】后缀自动机（SAM/后缀数组）]]></title>
    <url>%2FP3804-%E3%80%90%E6%A8%A1%E6%9D%BF%E3%80%91%E5%90%8E%E7%BC%80%E8%87%AA%E5%8A%A8%E6%9C%BA%2F</url>
    <content type="text"><![CDATA[题目链接洛谷 题意简述求 出现次数不为 $1$ 的子串的 出现次数 $\times$ 长度 的最大值。 SAM 做法简要做法一个状态的出现次数可以这么计算： 插入一个字符时，$np$ 的 $cnt$ 设为 $1$，一个状态的出现次数就是它在 $parent$ 树上的子树的 $cnt$ 之和。 证明..简要说一下：因为 $np$ 的 $right$ 集合为 $\{L\}$ 。 所以，插入整个字符串后 dfs 一遍 $parent$ 树算一算就好了。 参考代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;typedef long long ll;const int N=1000010;const int DELTA=26;struct Node&#123; int len,ch[DELTA],par,cnt; Node()&#123; memset(ch,0,sizeof(ch)); &#125;&#125; sam[N&lt;&lt;1];void insert(int x);void add(int u,int v);void dfs(int u);char s[N];int p,tot,head[N&lt;&lt;1],nxt[N&lt;&lt;1],to[N&lt;&lt;1],cnt;ll ans;int main()&#123; int i; scanf("%s",s); for (i=0;s[i];++i) insert(s[i]-'a'); for (i=1;i&lt;=tot;++i) add(sam[i].par,i); dfs(0); cout&lt;&lt;ans; return 0;&#125;void insert(int x)&#123; int np=++tot; sam[np].len=sam[p].len+1; sam[np].cnt=1; while (p&amp;&amp;!sam[p].ch[x]) &#123; sam[p].ch[x]=np; p=sam[p].par; &#125; if (sam[p].ch[x]) &#123; int q=sam[p].ch[x]; if (sam[q].len==sam[p].len+1) sam[np].par=q; else &#123; int nq=++tot; sam[nq].len=sam[p].len+1; memcpy(sam[nq].ch,sam[q].ch,sizeof(sam[q].ch)); sam[nq].par=sam[q].par; sam[q].par=sam[np].par=nq; while (sam[p].ch[x]==q) &#123; sam[p].ch[x]=nq; p=sam[p].par; &#125; &#125; &#125; else &#123; sam[p].ch[x]=np; sam[np].par=0; &#125; p=np;&#125;void add(int u,int v)&#123; nxt[++cnt]=head[u]; head[u]=cnt; to[cnt]=v;&#125;void dfs(int u)&#123; int i,v; for (i=head[u];i;i=nxt[i]) &#123; v=to[i]; dfs(v); sam[u].cnt+=sam[v].cnt; &#125; if (sam[u].cnt&gt;1) ans=max(ans,(ll)sam[u].cnt*sam[u].len);&#125; 后缀数组做法简要做法一个长度为 $h$ 的子串出现 $k$ 次就是有 $k-1$ 个连续的 $height\ge h$。单调栈维护即可。 然而..卡常卡不过去QAQ 参考代码（最高80分）12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const int N=1000010;char s[N];int n,sa[N],rk[N&lt;&lt;1],id[N&lt;&lt;1],px[N],cnt[N],ht[N],l[N],sta[N],top;long long ans;bool cmp(int x,int y,int w)&#123; return id[x]==id[y]&amp;&amp;id[x+w]==id[y+w]; &#125;int main()&#123; int i,w,p,m=300,k; scanf("%s",s+1); n=strlen(s+1); for (i=1;i&lt;=n;++i) ++cnt[rk[i]=s[i]]; for (i=1;i&lt;=m;++i) cnt[i]+=cnt[i-1]; for (i=n;i&gt;=1;--i) sa[cnt[rk[i]]--]=i; for (w=1;w&lt;n;w&lt;&lt;=1,m=p) &#123; memset(cnt,0,sizeof(cnt)); for (p=0,i=n;i&gt;n-w;--i) id[++p]=i; for (i=1;i&lt;=n;++i) if (sa[i]&gt;w) id[++p]=sa[i]-w; for (i=1;i&lt;=n;++i) ++cnt[px[i]=rk[id[i]]]; for (i=1;i&lt;=m;++i) cnt[i]+=cnt[i-1]; for (i=n;i&gt;=1;--i) sa[cnt[px[i]]--]=id[i]; swap(id,rk); for (p=0,i=1;i&lt;=n;++i) rk[sa[i]]=cmp(sa[i],sa[i-1],w)?p:++p; &#125; for (i=1,k=0;i&lt;=n;++i) &#123; if (k) --k; while (s[i+k]==s[sa[rk[i]-1]+k]) ++k; ht[rk[i]]=k; &#125; for (i=1;i&lt;=n;++i) &#123; while (top&amp;&amp;ht[sta[top]]&gt;=ht[i]) --top; l[i]=sta[top]; sta[++top]=i; &#125; sta[top=1]=n+1; for (i=n;i&gt;=1;--i) &#123; while (top&amp;&amp;ht[sta[top]]&gt;ht[i]) --top; if (sta[top]-l[i]&gt;1) ans=max(ans,(long long)ht[i]*(sta[top]-l[i])); sta[++top]=i; &#125; cout&lt;&lt;ans; return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>字符串</tag>
        <tag>SAM</tag>
        <tag>后缀数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ4516 [SDOI2016]生成魔咒（SAM）]]></title>
    <url>%2FBZOJ4516-SDOI2016-%E7%94%9F%E6%88%90%E9%AD%94%E5%92%92%EF%BC%88SAM%EF%BC%89%2F</url>
    <content type="text"><![CDATA[题目链接洛谷 dark bzoj 题意简述给你一个字符串（字符集大小 $10^9$，长度 $10^5$），求每个前缀的本质不同子串数。 简要做法如果只求整个串的本质不同子串，由于每个本质不同子串可以与 SAM 上一个状态+串的长度一一对应，所以本质不同子串数就是每个状态的 $maxlen-minlen+1$，也就是 $len-parent.len$。 $parent$ 不改变时，逐个加入字符并计算即可。 考虑 $parent$ 改变的情况，四次 $parent$ 改变分别为 $nq-q.parent$，$-(q-q.parent)$，$q-nq$，$np-nq$。总贡献为 $nq-q.parent-q+q.parent+q-nq+np-nq=np-nq$，也是新加入的点的 $len$ 减去 $parent.len$，是一样的。 由于字符集较大，用 map 存边。 参考代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;map&gt;#include &lt;cctype&gt;using namespace std;typedef long long ll;int read()&#123; int out=0; char c; while (!isdigit(c=getchar())); for (;isdigit(c);c=getchar()) out=out*10+c-'0'; return out;&#125;const int N=100010;struct Node&#123; int len,par; map&lt;int,int&gt; ch;&#125; sam[N&lt;&lt;1];void insert(int x);int n,p,tot;ll ans;int main()&#123; int i; n=read(); sam[0].par=-1; for (i=1;i&lt;=n;++i) &#123; insert(read()); printf("%lld\n",ans); &#125; return 0;&#125;void insert(int x)&#123; int np=++tot; sam[np].len=sam[p].len+1; while (~p&amp;&amp;sam[p].ch.find(x)==sam[p].ch.end()) &#123; sam[p].ch[x]=np; p=sam[p].par; &#125; if (p==-1) sam[np].par=0; else &#123; int q=sam[p].ch[x]; if (sam[q].len==sam[p].len+1) sam[np].par=q; else &#123; int nq=++tot; sam[nq].len=sam[p].len+1; sam[nq].ch=sam[q].ch; sam[nq].par=sam[q].par; sam[q].par=sam[np].par=nq; while (~p&amp;&amp;sam[p].ch[x]==q) &#123; sam[p].ch[x]=nq; p=sam[p].par; &#125; &#125; &#125; ans+=sam[np].len-sam[sam[np].par].len; p=np;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>字符串</tag>
        <tag>SAM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[后缀数组学习笔记]]></title>
    <url>%2F%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[后缀数组是一种处理字符串问题的有力工具（废话），本文的主要特点是一步步地由最朴素的后缀数组构建方法逐步优化，而非直接给出最终优化后的代码。 希望这篇文章能让更多的人看懂后缀数组的代码，学会后缀数组。 本文已于 pr #1730 优化并合并至 OI Wiki，推荐在 OI Wiki 上阅读。 模板题链接洛谷（只用求 $sa$） LOJ（只用求 $sa$） UOJ（求 $sa$ 和 $height$） 评测鸭（求 $sa$ 和 $height$） 两（can）篇（kao）论（zi）文（liao）[1]：[2004]后缀数组 by.徐智磊 [2]：[2009]后缀数组——处理字符串的有力工具 by.罗穗骞 这两篇论文还是写的很好的，大家可以看看。 下文中如果有引用这两篇论文中的内容，将以上标形式标出（$^{[1]}$ $^{[2]}$）。 关于字符串..说到字符串算法，就得先提一些定（fei）义（hua），知道的就可以不看了.. 字符集$^{[1]}$一个字符集 $Σ$ 是一个建立了全序关系的集合，也就是说，$Σ$ 中的任意两个不同的元素 $α$ 和 $β$ 都可以比较大小，要么 $α&lt;β$，要么 $β&lt;α$（也就是$α&gt;β$）。字符集 $Σ$ 中的元素称为字符。 字符串$^{[1]}$一个字符串 $S$ 是将 $n$ 个字符顺次排列形成的数组，$n$ 称为 $S$ 的长度，表示为 $len(S)$。$S$ 的第 $i$ 个字符表示为 $S[i]$。 子串$^{[1]}$字符串 $S$ 的子串 $S[i..j]，i≤j$，表示 $S$ 串中从 $i$ 到 $j$ 这一段，也就是顺次排列 $S[i],S[i+1],\ldots,S[j]$ 形成的字符串。 后缀后缀是指从某个位置 $i$ 开始到整个串末尾结束的一个特殊子串。字符串 $S$ 的从 $i$ 开头的后缀表示为 $Suffix(S,i)$，也就是 $Suffix(S,i)=S[i..len(S)]$。$^{[1]}$ 下文中以 “后缀 $i$” 代指字符串从 $i$ 开头的后缀。$i$ 称作这个后缀的编号。 字典序以第 $i$ 个字符作为第 $i$ 关键字进行大小比较，空字符小于字符集内任何字符（即：$a&lt;aa$）。 后缀数组是什么？后缀数组主要是两个数组：$sa$ 和 $rk$。 其中，$sa[i]$ 表示将所有后缀排序后第 $i$ 小的后缀的编号。$rk[i]$ 表示后缀 $i$ 的排名。 这两个数组满足性质：$sa[rk[i]]=rk[sa[i]]=i$。 后缀数组示例：$^{[2]}$ 后缀数组怎么求？$O(n^2\log n)$ 做法我相信这个做法大家还是能自己想到的..用string+sort就可以了。由于比较两个字符串是 $O(n)$ 的，所以排序是 $O(n^2\log n)$ 的。 $O(n\log^2n)$ 做法这个做法要用到倍增的思想。 先对每个长度为 $1$ 的子串（即每个字符）进行排序。 假设我们已经知道了长度为 $w$ 的子串的排名 $rk_w[1..n]$（即，$rk_w[i]$ 表示 $s[i..\min(i+w-1,n)]$ 在 $\{s[x..\min(x+w-1,n)]\ |\ x\in\mathbb{N}\bigcap[1,n]\}$ 中的排名），那么，以 $rk_w[i]$ 为第一关键字， $rk_w[i+w]$ 为第二关键字（若 $i+w&gt;n$ 则令 $rk_w[i+w]$ 为 $-INF$）进行排序，就可以求出 $rk_{2w}[1..n]$。 倍增排序示意图：$^{[2]}$ 如果用 sort 进行排序，复杂度就是 $O(n\log^2n)$ 的。 参考代码 1234567891011121314151617181920212223242526272829303132#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const int N=1000010;char s[N];int n,w,sa[N],rk[N&lt;&lt;1],oldrk[N]; //为了防止访问rk[i+w]导致数组越界，开两倍数组。当然也可以在访问前判断是否越界，但直接开两倍数组方便一些。int main()&#123; int i,p; scanf("%s",s+1); n=strlen(s+1); for (i=1;i&lt;=n;++i) rk[i]=s[i]; for (w=1;w&lt;n;++w) &#123; for (i=1;i&lt;=n;++i) sa[i]=i; sort(sa+1,sa+n+1,[](int x,int y)&#123;return rk[x]==rk[y]?rk[x+w]&lt;rk[y+w]:rk[x]&lt;rk[y];&#125;); //这里用到了lambda表达式 memcpy(oldrk,rk,sizeof(oldrk)); //由于计算rk的时候原来的rk会被覆盖，要先复制一份 for (p=0,i=1;i&lt;=n;++i) rk[sa[i]]=oldrk[sa[i]]==oldrk[sa[i-1]]&amp;&amp;oldrk[sa[i]+w]==oldrk[sa[i-1]+w]?p:++p; //若两个子串相同，它们对应的rk也需要相同，所以要去重 &#125; for (i=1;i&lt;=n;++i) printf("%d ",sa[i]); return 0;&#125; $O(n\log n)$ 做法在刚刚的 $O(n\log^2n)$ 做法中，一次排序是 $O(n\log n)$ 的，如果能 $O(n)$ 排序，就能 $O(n\log n)$ 计算后缀数组了。 计数排序计数排序的核心思想还是比较好理解的，可以先看代码： 1234//对a这个数组进行排序，结果存到数组b中（b[i]表示第i名的编号），cnt是一个辅助数组，m是a的值域for (i=1;i&lt;=n;++i) ++cnt[a[i]];for (i=1;i&lt;=m;++i) cnt[i]+=cnt[i-1];for (i=n;i&gt;=1;--i) b[cnt[a[i]]--]=i; 其实就是先数一数小于等于 $a[i]$ 的数有多少个，然后从后往前看每个数的名次。感性理解/手玩一下就能明白这个排序算法了。 这个算法有两个特点： 它是 $O(n+m)$ 的（$m$ 为待排序数据的值域范围）。 它是一个稳定排序，即，相等的数会按原位置（下标）进行排序。 基数排序值得一提的是很多人经常把计数排序和基数排序搞混.. 基数排序是一个基于稳定排序的多关键字排序算法，复杂度为关键字个数乘上稳定排序的复杂度。而这个稳定排序通常用计数排序实现。 它的思想是，如果有 $k$ 个关键字，先以第 $k$ 关键字进行一次稳定排序，然后再以第 $k-1$ 关键字进行一次稳定排序，……，最后以第一关键字进行一次稳定排序。可以看出，这样做就完成了以这 $k$ 个关键字的排序。 具体实现大约是这样的： 12345678910//key[i][j]表示第j个数的第i关键字，b[i]依然表示第i名的编号，m是key的值域，cnt和id都是辅助数组for (i=1;i&lt;=n;++i) id[i]=i;for (i=k;i&gt;=1;--i)&#123; memset(cnt,0,sizeof(cnt)); for (j=1;j&lt;=n;++j) id[j]=b[j]; for (j=1;j&lt;=n;++j) ++cnt[key[i][id[j]]]; for (j=1;j&lt;=m;++j) cnt[j]+=cnt[j-1]; for (j=n;j&gt;=1;--j) b[cnt[key[i][id[j]]]--]=id[j];&#125; 将基数排序运用于求后缀数组如果你学会了基数排序，也会 $O(n\log^2n)$ 求后缀数组，那你应该可以自己写出一个 $O(n\log n)$ 求后缀数组的程序了。 参考代码 12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const int N=1000010;char s[N];int n,sa[N],rk[N&lt;&lt;1],oldrk[N&lt;&lt;1],id[N],cnt[N];int main()&#123; int i,m,p,w; scanf("%s",s+1); n=strlen(s+1); m=max(n,300); for (i=1;i&lt;=n;++i) ++cnt[rk[i]=s[i]]; for (i=1;i&lt;=m;++i) cnt[i]+=cnt[i-1]; for (i=n;i&gt;=1;--i) sa[cnt[rk[i]]--]=i; for (w=1;w&lt;n;w&lt;&lt;=1) &#123; memset(cnt,0,sizeof(cnt)); for (i=1;i&lt;=n;++i) id[i]=sa[i]; for (i=1;i&lt;=n;++i) ++cnt[rk[id[i]+w]]; for (i=1;i&lt;=m;++i) cnt[i]+=cnt[i-1]; for (i=n;i&gt;=1;--i) sa[cnt[rk[id[i]+w]]--]=id[i]; memset(cnt,0,sizeof(cnt)); for (i=1;i&lt;=n;++i) id[i]=sa[i]; for (i=1;i&lt;=n;++i) ++cnt[rk[id[i]]]; for (i=1;i&lt;=m;++i) cnt[i]+=cnt[i-1]; for (i=n;i&gt;=1;--i) sa[cnt[rk[id[i]]]--]=id[i]; memcpy(oldrk,rk,sizeof(oldrk)); for (p=0,i=1;i&lt;=n;++i) rk[sa[i]]=oldrk[sa[i]]==oldrk[sa[i-1]]&amp;&amp;oldrk[sa[i]+w]==oldrk[sa[i-1]+w]?p:++p; &#125; for (i=1;i&lt;=n;++i) printf("%d ",sa[i]); return 0;&#125; 一些常数优化如果你把上面那份代码交到洛谷上.. 怎么会这样呢？是这题卡常吗？ 一翻其他人的代码，最慢点也不过 $1s$.. 这是因为，上面那份代码的常数的确很大.. 第二关键字无需计数排序实际上，像这样就可以了： 12for (p=0,i=n;i&gt;n-w;--i) id[++p]=i;for (i=1;i&lt;=n;++i) if (sa[i]&gt;w) id[++p]=sa[i]-w; 意会一下，先把 $s[i+w..i+2w-1]$ 为空串的位置放前面，再把剩下的按排好的顺序放进去。 优化计数排序的值域每次对 $rk$ 进行去重之后，我们都计算了一个 $p$，这个 $p$ 即是 $k$ 的值域，将值域改成它即可。 将 $rk[id[i]]$ 存下来，减少不连续内存访问这个优化在数据范围较大时效果非常明显。 用函数cmp来计算是否重复同样是减少不连续内存访问，在数据范围较大时效果比较明显。 把 oldrk[sa[i]]==oldrk[sa[i-1]]&amp;&amp;oldrk[sa[i]+w]==oldrk[sa[i-1]+w] 替换成 cmp(sa[i],sa[i-1],w)，bool cmp(int x,int y,int w){ return id[x]==id[y]&amp;&amp;id[x+w]==id[y+w]; }。 参考代码 12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const int N=1000010;char s[N];int n,sa[N],rk[N],oldrk[N&lt;&lt;1],id[N],px[N],cnt[N]; //px[i]=rk[id[i]]（用于排序的数组所以叫px）bool cmp(int x,int y,int w)&#123; return oldrk[x]==oldrk[y]&amp;&amp;oldrk[x+w]==oldrk[y+w]; &#125;int main()&#123; int i,m=300,p,w; scanf("%s",s+1); n=strlen(s+1); for (i=1;i&lt;=n;++i) ++cnt[rk[i]=s[i]]; for (i=1;i&lt;=m;++i) cnt[i]+=cnt[i-1]; for (i=n;i&gt;=1;--i) sa[cnt[rk[i]]--]=i; for (w=1;w&lt;n;w&lt;&lt;=1,m=p) //m=p就是优化计数排序值域 &#123; for (p=0,i=n;i&gt;n-w;--i) id[++p]=i; for (i=1;i&lt;=n;++i) if (sa[i]&gt;w) id[++p]=sa[i]-w; memset(cnt,0,sizeof(cnt)); for (i=1;i&lt;=n;++i) ++cnt[px[i]=rk[id[i]]]; for (i=1;i&lt;=m;++i) cnt[i]+=cnt[i-1]; for (i=n;i&gt;=1;--i) sa[cnt[px[i]]--]=id[i]; memcpy(oldrk,rk,sizeof(rk)); for (p=0,i=1;i&lt;=n;++i) rk[sa[i]]=cmp(sa[i],sa[i-1],w)?p:++p; &#125; for (i=1;i&lt;=n;++i) printf("%d ",sa[i]); return 0;&#125; 这样优化之后应该不开O2都能过。 $O(n)$ 做法名字叫DC3，我不会 可以参考[2009]后缀数组——处理字符串的有力工具 by.罗穗骞，里面有介绍这个算法。 一般情况下用倍增法做足常数优化是不会被卡的.. 还有个叫“诱导排序”的东西，也是 $O(n)$ 的，听说又好写（相对于 DC3）又快。 后缀数组无需 $height$ 数组的应用如果用不到 $height$ 数组，一般就是利用 $rk$ 数组对字符串进行排序，有时需要对原串进行一定的加工使需要排序的字符串变成后缀，或者是只需对后缀进行排序便能对需要排序的字符串进行排序。 [JSOI2007]字符加密洛谷 dark bzoj [USACO07DEC]Best Cow Line, Gold洛谷 我的题解 $height$ 数组后缀数组的题目往往是要用到 $height$ 数组的。 lcp（最长公共前缀）两个字符串 $S$ 和 $T$ 的 $lcp$ 就是最大的 $x$ 使得 $S_i=T_i\ (\forall\ 1\le i\le x)$ 。 下文中以 $lcp(i,j)$ 表示后缀 $i$ 和后缀 $j$ 的最长公共前缀（的长度）。 $height$ 数组的定义$height[i]=lcp(sa[i],sa[i-1])$，即第 $i$ 名的后缀与它前一名的后缀的最长公共前缀。 $O(n)$ 求 $height$ 数组需要的一个引理$height[rk[i]]\ge height[rk[i-1]]-1$ 证明的话..感性理解 当 $height[rk[i-1]]\le1$ 时，上式显然成立（右边小于等于 $0$ ）。 当 $height[rk[i-1]]&gt;1$ 时： 设后缀 $i-1$ 为 $aAD$（$A$ 是一个长度为 $height[rk[i-1]]-1$ 的字符串），那么后缀 $i$ 就是 $AD$。设后缀 $sa[rk[i-1]-1]$ 为 $aAB$ ，那么 $lcp(i-1,sa[rk[i-1]-1])=aA$。由于后缀 $sa[rk[i-1]-1]+1$ 是 $AB$，一定排在后缀 $i$ 的前面，所以后缀 $sa[rk[i]-1]$ 一定含有前缀 $A$，所以 $lcp(i,sa[rk[i]-1])$ 至少是 $height[rk[i-1]]-1$。 简单来说： $i-1$：$aAD$ $i$：$AD$ $sa[rk[i-1]-1]$：$aAB$ $sa[rk[i-1]-1]+1$：$AB$ $sa[rk[i]-1]$：$A[B/C]$ $lcp(i,sa[rk[i]-1])$：$AX$（$X$ 可能为空） $O(n)$ 求 $height$ 数组的代码实现利用上面这个引理暴力求即可： 123456for (i=1,k=0;i&lt;=n;++i)&#123; if (k) --k; while (s[i+k]==s[sa[rk[i]-1]+k]) ++k; ht[rk[i]]=k; //height太长了缩写为ht&#125; 利用摊还分析/势能分析可以发现是O(n)的，$k$ 不会超过 $n$，最多减 $n$ 次，所以最多加 $2n$ 次。 应用 $height$ 数组需要的一个性质$lcp(sa[i],sa[j])=\min\{height[i+1..j]\}$ 感性理解：如果 $height$ 一直大于某个数，前这么多位就一直没变过；反之，由于后缀已经排好序了，不可能变了之后变回来。 严格证明可以参考[2004]后缀数组 by.徐智磊。 $height$ 数组的应用$height$ 数组往往用来解决关于字符串公共部分的题目，通常需要和RMQ/单调栈等算法相结合。 [USACO06DEC]Milk Patterns洛谷 我的题解 [AHOI2013]差异洛谷 dark bzoj [HAOI2016]找相同字符洛谷 dark bzoj 我的题解 [NOI2015]品酒大会洛谷 dark bzoj SP8222 NSUBSTR - Substrings洛谷 SPOJ]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>字符串</tag>
        <tag>后缀数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ4566 [HAOI2016]找相同字符（后缀数组）]]></title>
    <url>%2FBZOJ4566-HAOI2016-%E6%89%BE%E7%9B%B8%E5%90%8C%E5%AD%97%E7%AC%A6%EF%BC%88%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84%EF%BC%89%2F</url>
    <content type="text"><![CDATA[题目链接洛谷 dark bzoj 题意简述给你两个字符串，从中各取一个子串使这两个子串相同，求方案数。 简要做法以某两个位置开头的相同子串数=这两个位置开头的后缀的 $lcp$ 如果在同一个字符串中，求出 height 数组后使用单调栈求出每个位置作为最小值的贡献即可（单调栈部分与 P2659 美丽的序列，[ZJOI2007]棋盘制作 等题类似，在此就不赘述了；求两两 $lcp​$ 之和这部分与 [AHOI2013]差异 类似，故没有写那题的题解）。 由于有两个字符串不太方便，考虑将它们拼接起来并在中间加上一个不存在的字符（如#）。这样求出拼接后的字符串的答案，减去两个原串的答案，就是最终的答案。 参考代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const int N=400010;typedef long long ll;int sa[N],sa2[N&lt;&lt;1],rk[N&lt;&lt;1],px[N],cnt[N],sta[N],top,f[N],height[N];struct Suffix_Array&#123; char s[N]; ll calc() &#123; ll out=0; int n,i,k,w,p,m=200; n=strlen(s+1); memset(sa2,0,sizeof(sa2)); memset(cnt,0,sizeof(cnt)); for (i=1;i&lt;=n;++i) ++cnt[rk[i]=s[i]]; for (i=1;i&lt;=m;++i) cnt[i]+=cnt[i-1]; for (i=n;i&gt;=1;--i) sa[cnt[rk[i]]--]=i; for (w=1;w&lt;n;w&lt;&lt;=1,m=p) &#123; memset(cnt,0,sizeof(cnt)); for (p=0,i=n;i&gt;n-w;--i) sa2[++p]=i; for (i=1;i&lt;=n;++i) if (sa[i]&gt;w) sa2[++p]=sa[i]-w; for (i=1;i&lt;=n;++i) ++cnt[px[i]=rk[sa2[i]]]; for (i=1;i&lt;=m;++i) cnt[i]+=cnt[i-1]; for (i=n;i&gt;=1;--i) sa[cnt[px[i]]--]=sa2[i]; swap(rk,sa2); for (p=0,i=1;i&lt;=n;++i) rk[sa[i]]=sa2[sa[i]]==sa2[sa[i-1]]&amp;&amp;sa2[sa[i]+w]==sa2[sa[i-1]+w]?p:++p; &#125; for (i=1,k=0;i&lt;=n;++i) &#123; if (k) --k; while (s[i+k]==s[sa[rk[i]-1]+k]) ++k; height[rk[i]]=k; &#125; for (i=1;i&lt;=n;++i) &#123; while (top&amp;&amp;height[sta[top]]&gt;=height[i]) --top; f[i]=i-sta[top]; sta[++top]=i; &#125; top=0; sta[++top]=n+1; height[n+1]=0; for (i=n;i&gt;=1;--i) &#123; while (top&amp;&amp;height[sta[top]]&gt;height[i]) --top; out+=(ll)f[i]*(sta[top]-i)*height[i]; sta[++top]=i; &#125; return out; &#125;&#125; a,b,ab;int main()&#123; int n,m,i; scanf("%s%s",a.s+1,b.s+1); n=strlen(a.s+1); m=strlen(b.s+1); for (i=1;i&lt;=n;++i) ab.s[i]=a.s[i]; ab.s[n+1]='#'; for (i=1;i&lt;=m;++i) ab.s[n+1+i]=b.s[i]; cout&lt;&lt;ab.calc()-a.calc()-b.calc(); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>字符串</tag>
        <tag>后缀数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[P2852 [USACO06DEC]Milk Patterns（后缀数组）]]></title>
    <url>%2FP2852-USACO06DEC-Milk-Patterns%EF%BC%88%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84%EF%BC%89%2F</url>
    <content type="text"><![CDATA[题目链接洛谷 题意简述给你一个字符串，求最长的出现了至少 $k$ 次的子串的长度。 简要做法求出 height 数组，若一个长为 $x$ 的子串在原串中出现了至少 $k$ 次，则 height 数组中一定存在至少 $k-1$ 个 连续的大于等于 $x$ 的值。所以，问题就转化成了：求 height 数组中 每连续 $k-1$ 个数的最小值 的最大值。即：$a_i=\min\{height_{i..i+k-2}\}$，求 $a_i$ 的最大值。可以用RMQ/平衡树/线段树/multiset解决。 参考代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;set&gt;using namespace std;const int N=40010;int n,k,a[N],sa[N],rk[N],sa2[N],px[N],cnt[1000010],height[N],ans;multiset&lt;int&gt; t;int main()&#123; int i,j,w,p,m=1000000; scanf("%d%d",&amp;n,&amp;k); --k; for (i=1;i&lt;=n;++i) scanf("%d",a+i); for (i=1;i&lt;=n;++i) ++cnt[rk[i]=a[i]]; for (i=1;i&lt;=m;++i) cnt[i]+=cnt[i-1]; for (i=n;i&gt;=1;--i) sa[cnt[rk[i]]--]=i; for (w=1;w&lt;n;w&lt;&lt;=1,m=p) &#123; memset(cnt,0,sizeof(cnt)); for (p=0,i=n;i&gt;n-w;--i) sa2[++p]=i; for (i=1;i&lt;=n;++i) if (sa[i]&gt;w) sa2[++p]=sa[i]-w; for (i=1;i&lt;=n;++i) ++cnt[px[i]=rk[sa2[i]]]; for (i=1;i&lt;=m;++i) cnt[i]+=cnt[i-1]; for (i=n;i&gt;=1;--i) sa[cnt[px[i]]--]=sa2[i]; swap(rk,sa2); for (p=0,i=1;i&lt;=n;++i) rk[sa[i]]=sa2[sa[i]]==sa2[sa[i-1]]&amp;&amp;sa2[sa[i]+w]==sa2[sa[i-1]+w]?p:++p; &#125; for (i=1,j=0;i&lt;=n;++i) &#123; if (j) --j; while (a[i+j]==a[sa[rk[i]-1]+j]) ++j; height[rk[i]]=j; &#125; for (i=1;i&lt;=n;++i) &#123; t.insert(height[i]); if (i&gt;k) t.erase(t.find(height[i-k])); ans=max(ans,*t.begin()); &#125; cout&lt;&lt;ans; return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>字符串</tag>
        <tag>后缀数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[P2870 [USACO07DEC]Best Cow Line, Gold（后缀数组）]]></title>
    <url>%2FP2870-USACO07DEC-Best-Cow-Line-Gold%EF%BC%88%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84%EF%BC%89%2F</url>
    <content type="text"><![CDATA[题目链接洛谷 题意简述给你一个字符串，每次从首或尾取一个字符组成字符串，问所有能够组成的字符串中字典序最小的一个。 简要做法暴力做法就是每次最坏 $O(n)$ 地判断当前应该取首还是尾，只需优化这一判断过程即可。 将原串reverse后拼接在原串后，并在中间加上一个没出现过的字符（如 # ），求SA，即可 $O(1)$ 完成这一判断。 参考代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;using namespace std;const int N=1000010;char s[N];int n,sa[N],sa2[N&lt;&lt;1],rk[N&lt;&lt;1],px[N],cnt[N];int main()&#123; int i,w,m=200,p,l=1,r,tot=0; cin&gt;&gt;n; r=n; for (i=1;i&lt;=n;++i) while (!isalpha(s[i]=getchar())); for (i=1;i&lt;=n;++i) rk[i]=rk[2*n+2-i]=s[i]; n=2*n+1; for (i=1;i&lt;=n;++i) ++cnt[rk[i]]; for (i=1;i&lt;=m;++i) cnt[i]+=cnt[i-1]; for (i=n;i&gt;=1;--i) sa[cnt[rk[i]]--]=i; for (w=1;w&lt;n;w&lt;&lt;=1,m=p) &#123; memset(cnt,0,sizeof(cnt)); for (p=0,i=n;i&gt;n-w;--i) sa2[++p]=i; for (i=1;i&lt;=n;++i) if (sa[i]&gt;w) sa2[++p]=sa[i]-w; for (i=1;i&lt;=n;++i) ++cnt[px[i]=rk[sa2[i]]]; for (i=1;i&lt;=m;++i) cnt[i]+=cnt[i-1]; for (i=n;i&gt;=1;--i) sa[cnt[px[i]]--]=sa2[i]; swap(sa2,rk); for (p=0,i=1;i&lt;=n;++i) rk[sa[i]]=sa2[sa[i]]==sa2[sa[i-1]]&amp;&amp;sa2[sa[i]+w]==sa2[sa[i-1]+w]?p:++p; &#125; while (l&lt;=r) &#123; printf("%c",rk[l]&lt;rk[n+1-r]?s[l++]:s[r--]); if ((++tot)%80==0) puts(""); &#125; return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>字符串</tag>
        <tag>后缀数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ1856 [SCOI2010]生成字符串（组合数学）]]></title>
    <url>%2FBZOJ1856-SCOI2010-%E7%94%9F%E6%88%90%E5%AD%97%E7%AC%A6%E4%B8%B2%EF%BC%88%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6%EF%BC%89%2F</url>
    <content type="text"><![CDATA[题目链接洛谷 darkbzoj 题意简述$n$ 个入栈操作，$m$ 个出栈操作，问合法操作序列数。 简要做法借用一下这篇题解（的图）。 选了 $x$ 个数，$1$ 与 $0$ 个数之差为 $y$，如下图： 不考虑限制条件，方案数为从 $(0,0)$ 到 $(n+m,n-m)$ 的折线数，即从 $n+m$ 次操作中选择 $m$ 次向下： $\binom{n+m}m$。考虑某一种不合法的情况，把这条折线第一次碰到 $y=-1$ 前的部分以 $y=-1$ 为轴翻折，这样就建立了 从 $(0,0)$ 到 $(n+m,n-m)$ 且碰到了 $y=-1$ 的折线 与 从 $(0,-2)$ 到 $(n+m,n-m)$ 的折线 的一一对应，所以不合法的情况个数为 $\binom{n+m}{m-1}$，答案为 $\binom{n+m}m-\binom{n+m}{m-1}$。 （上面看懂了这段可以不看，这段是废话证明）为什么这玩意是双射（一一对应）..其实很简单，每条 从 $(0,0)$ 到 $(n+m,n-m)$ 且碰到了 $y=-1$ 的折线 在第一次碰到 $y=-1$ 前的部分以 $y=-1$ 为轴翻折可以得到唯一一条 从 $(0,-2)$ 到 $(n+m,n-m)$ 的折线，而一条 从 $(0,-2)$ 到 $(n+m,n-m)$ 的折线 必然会碰到 $y=-1$，同样可以把它在第一次碰到 $y=-1$ 前的部分以 $y=-1$ 为轴翻折，就会得到唯一一条 从 $(0,0)$ 到 $(n+m,n-m)$ 且碰到了 $y=-1$ 的折线。 最后吐槽一句。你谷完全不接受做法相同的题解，无法对已有做法进行阐述，所以并没有尝试在你谷发题解。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;iostream&gt;#include &lt;cstdio&gt;using namespace std;typedef long long ll;const int N=1000010;const int mod=20100403;int qpow(int x,int y);int c(int x,int y);int jc[N&lt;&lt;1];int main()&#123; int n,m; cin&gt;&gt;n&gt;&gt;m; jc[0]=1; for (int i=1;i&lt;=n+m;++i) jc[i]=(ll)jc[i-1]*i%mod; cout&lt;&lt;(c(n+m,m)-c(n+m,m-1)+mod)%mod; return 0;&#125;int qpow(int x,int y)&#123; int out=1; while (y) &#123; if (y&amp;1) out=(ll)out*x%mod; x=(ll)x*x%mod; y&gt;&gt;=1; &#125; return out;&#125;int c(int x,int y)&#123; return (ll)jc[x]*qpow(jc[y],mod-2)%mod*qpow(jc[x-y],mod-2)%mod;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>组合数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[n方过百万 暴力碾标算——指令集优化的基础使用]]></title>
    <url>%2Fn%E6%96%B9%E8%BF%87%E7%99%BE%E4%B8%87-%E6%9A%B4%E5%8A%9B%E7%A2%BE%E6%A0%87%E7%AE%97%E2%80%94%E2%80%94%E6%8C%87%E4%BB%A4%E9%9B%86%E4%BC%98%E5%8C%96%E7%9A%84%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[感谢 yfz 和 mcfx 在 WC 营员交流上的分享！ 然而只看那个课件来学习指令集好像略有困难..所以我来分享一下我自学一晚上的成果。 希望能帮助大家暴力过题，考场上再也写不出标算。 注：本文省略了无数个 unsigned，请自行把所有 int 视作 unsigned int，把所有 long long 视作 unsigned long long。 适用范围环境不要尝试在正式OI竞赛中使用指令集优化。 只适用于提供资瓷的 OJ，具体列表参照营员交流ppt： sse2，avx 什么的都是指令集的名字。 作用适用于方便对连续内存空间进行批量处理的题目。大约可以视作每 $8$ 个 int 为一个分块，块内进行赋值、修改等操作常数为 $1$，也就实现了常数/=$8$。当然如果是 long long 就只能除以四。 具体使用define &amp; pragma &amp; include12345678910111213141516#define __AVX__ 1#define __AVX2__ 1#define __SSE__ 1#define __SSE2__ 1#define __SSE2_MATH__ 1#define __SSE3__ 1#define __SSE4_1__ 1#define __SSE4_2__ 1#define __SSE_MATH__ 1#define __SSSE3__ 1#pragma GCC optimize("Ofast,no-stack-protector,unroll-loops,fast-math")#pragma GCC target("sse,sse2,sse3,ssse3,sse4.1,sse4.2,avx,avx2,popcnt,tune=native")#include &lt;immintrin.h&gt;#include &lt;emmintrin.h&gt; 第一行是优化，如果你都用指令集了当然是能优化尽量优化。 第二行是告诉编译器你要使用指令集。 后面两个头文件是 C++ 将指令集封装成了函数，这样就不用在代码中内联汇编了。 变量类型大约有 __m256i __m256 __m256d 三种，分别存储 long long，float 和 double，实际上 __m256i 也可以用来存储 int。 指令使用可以在一个神奇的网站查需要的指令，左边选指令集以及指令类型，右边是指令，点开指令可以查看函数原型以及伪代码。 这里列几条常用指令： __m256i _mm256_set_epi32 (int e7, int e6, int e5, int e4, int e3, int e2, int e1, int e0)：参数是八个数，也就是一个“分块”里的数，注意是逆序的。返回值是一个含这八个数的“分块”。 __m256i _mm256_set_epi64x (__int64 e3, __int64 e2, __int64 e1, __int64 e0)：和上面一样，只不过是 $64$ 位整数，也就是 long long。 __m256i _mm256_set1_epi32 (int a)：相当于 _mm256_set_epi32(a,a,a,a,a,a,a,a)。 __m256i _mm256_add_epi32 (__m256i a, __m256i b)：把两个“分块”的对应位置分别相加，返回结果。 __m256i _mm256_cmpeq_epi32 (__m256i a, __m256i b)：判断两个“分块”的对应位置是否相等，若相等则返回的“分块”对应位置是 0xffffffff，否则是 0。 __m256i _mm256_cmpgt_epi32 (__m256i a, __m256i b)：和上面一样，只不过比较符是大于而不是相等。 __m256i _mm256_and_si256 (__m256i a, __m256i b)：返回两个“分块”的按位与，可以配合上面两条比较指令来使用。 访问数据可以直接通过下标访问： 12345678910111213141516#include &lt;cstdio&gt;#pragma GCC optimize("Ofast,no-stack-protector,unroll-loops,fast-math")#pragma GCC target("sse,sse2,sse3,ssse3,sse4.1,sse4.2,avx,avx2,popcnt,tune=native")#include &lt;immintrin.h&gt;#include &lt;emmintrin.h&gt;__m256i a;int main()&#123; a=_mm256_set_epi32(1,2,3,4,5,6,7,8); printf("%d",a[2]); return 0;&#125; 你们可以猜猜这个的结果是什么。 答案是..4。 为什么呢，首先 _mm256_set_epi32 的参数是逆序的，所以实际上存储的数顺序是 8,7,6,5,4,3,2,1。其次，__m256i 类型是存储 long long 的，所以直接通过下标访问实际上是在访问 long long，如果 cout&lt;&lt;a[2]就会返回 12884901892（$3\times2^{32}+4$）。所以，这句话实际上是在 printf("%d",12884901892ll);。 那么如何访问 int（甚至 short，如果题目允许这样就可以常数除以 $16$）呢？ 其实搞个指针就可以了： 123a=_mm256_set_epi32(1,2,3,4,5,6,7,8);int *b=(int *)&amp;a;printf("%d",b[2]); 这样子的输出就是 $6$ 了。 用这种方法就可以方便地处理序列问题了： 123456789101112131415161718192021222324252627#include &lt;cstdio&gt;#pragma GCC optimize("Ofast,no-stack-protector,unroll-loops,fast-math")#pragma GCC target("sse,sse2,sse3,ssse3,sse4.1,sse4.2,avx,avx2,popcnt,tune=native")#include &lt;immintrin.h&gt;#include &lt;emmintrin.h&gt;int* b;__m256i a[10],x;int main()&#123; int i; b=(int *)&amp;a; for (i=0;i&lt;80;++i) scanf("%d",b+i); x=_mm256_set1_epi32(233); for (i=0;i&lt;10;++i) a[i]=_mm256_add_epi32(a[i],x); for (i=0;i&lt;80;++i) printf("%d ",b[i]); return 0;&#125; 上面是一个简单的示例，读入 $80$ 个数，然后输出它们加上 $233$ 的结果。 例题这种东西为什么还会有例题啊。 教主的魔法，这题比较简单（废话暴力当然简单）。 【模板】线段树1，这题其实是最简单的，然而由于 dl 出题人把值域搞到了 long long，常数只能除以四，需要卡卡常，多提交几次才能过。 [Ynoi2018]五彩斑斓的世界，神司怒艹lxl标算的课件例题。 Simple Tree，这个还要树剖，只不过也还好，神司是直接内嵌汇编写的，没有测过用函数能不能过.. 然后以教主的魔法为例讲一下代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;cstdio&gt;#pragma GCC optimize("Ofast,no-stack-protector,unroll-loops,fast-math")#pragma GCC target("sse,sse2,sse3,ssse3,sse4.1,sse4.2,avx,avx2,popcnt,tune=native")#include &lt;immintrin.h&gt;#include &lt;emmintrin.h&gt;const int N=1000010;int n,m,tot,*a;__m256i A[N&gt;&gt;3];char op[10];void modify(int l,int r,int x)&#123; while ((l&amp;7)&amp;&amp;l&lt;r) a[l++]+=x; //处理左边不是整块的部分，和分块的处理方法是一样的 if (l==r) return; while (r&amp;7) a[--r]+=x; //处理右边不是整块的部分 if (l==r) return; __m256i t=_mm256_set1_epi32(x); //剩下的部分整块加上x for (l&gt;&gt;=3,r&gt;&gt;=3;l&lt;r;++l) A[l]=_mm256_add_epi32(A[l],t);&#125;int query(int l,int r,int x)&#123; int out=0; while ((l&amp;7)&amp;&amp;l&lt;r) out+=int(a[l++]&gt;=x); //处理左边不是整块的部分 if (l==r) return out; while (r&amp;7) out+=int(a[--r]&gt;=x); //处理右边不是整块的部分 if (l==r) return out; __m256i t=_mm256_set1_epi32(1); //这个1是每个大于等于x的数的贡献 __m256i ans=_mm256_set1_epi32(0); //这个ans是用来存答案的 __m256i cp=_mm256_set1_epi32(x-1); //这个是用来比较的，题目中是大于等于，所以和x-1比较 for (l&gt;&gt;=3,r&gt;&gt;=3;l&lt;r;++l) ans=_mm256_add_epi32(ans,_mm256_and_si256(t,_mm256_cmpgt_epi32(A[l],cp))); //这个意会一下，作用是数当前块有几个大于x-1的数 for (int i=0;i&lt;4;++i) out+=(ans[i]&amp;0xffffffff)+(ans[i]&gt;&gt;32); //最后统计答案，因为ans[i]是一个long long，所以要前32位和后32位分别统计 return out;&#125;int main()&#123; int i,l,r,x,aa[8]; scanf("%d%d",&amp;n,&amp;m); a=(int*)&amp;A; for (i=0;i&lt;n;++i) scanf("%d",a+i); while (m--) &#123; scanf("%s%d%d%d",op,&amp;l,&amp;r,&amp;x); if (op[0]=='M') modify(l-1,r,x); else printf("%d\n",query(l-1,r,x)); &#125; return 0;&#125;]]></content>
      <categories>
        <category>黑科技</category>
      </categories>
      <tags>
        <tag>常数优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019THUWC/WC冬眠记]]></title>
    <url>%2F2019THUWC-WC%E5%86%AC%E7%9C%A0%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[又到了 Kanon 的季节呢，快乐的冬眠生活开始了_(:з」∠)_ Day 0/-8Day -1 被归到广二避寒记去了.. 上午在水群的时候吐槽 Kanon 结局，然后和 yfz 稍微聊了一下，又看了看萌百，的确あゆ就是和风子、面码差不多的思念体鸭，为什么我会觉得看不懂呢..大约不止是因为あゆ的存在？ 下午只做了一道题…淀粉质竟然能把 solve(rt) 写成 solve(v)…退役吧 然后不知道为什么去试了下自走棋，连续垫底了一下午，算是明示WC垫底了。 RNG居（guo）然连跪两把，继续暗示窝WC的命运。 Day 1/-7上午报到的时候没能和 BlackRedRabbit 面基，只不过试机的时候发现brr就在窝左边的左边的左边，然后就愉快的面基了。 哦对了，晚上跟 jxl 还有 hyf 住。好像是女生宿舍？被子是粉的..然而听说A栋住女生，B栋住男生，感觉不会特意反过来.. 试机题目T1（听别人说）是AC自动机上dp..本来就不会，AC自动机也几年没打过了…T2是THUSC2017提答，于是没做试机题，打了个NTT，还没一遍打对..丢人。 下午果然垫底了..T1一个简单 $12$ 分暴力打了 1h，然后 T2 的第一档 $26$ 分写了 1h 才过大（xiao）样例，交上去没过pt..然后又调了 50min，还是没过..然后花了 0.5h 重构代码，莫名其妙就过了..T3看了看感觉第一档都不会，回去看T2，T2是答对第一问有 $60\%$ 的分那种，发现自己会另一档的 $27\times60\%$，然后又花了 50min 写.. 最后 30min 的时候发现 T2 还有 $43\times 60\%$ 可以用可持久化并查集写，然而时间不够了… T2 第一次写了 6K…（菜死了连 6K 都没写过..）也是第一次用 namespace 写 subtask。 1234if (r&lt;=10&amp;&amp;c&lt;=10)&#123; using namespace subtask1;&#125; 这样写真的爽_(:з」∠)_ T1是道期望，输出格式是最简分数，而且不约分的话数会非常大。当时我就在想为什么不取模..然后出考场听说 T1 的式子有一堆可以约分，剩下的形式特别简单… 我的游记好像经常不写题目就瞎bb..还是简单说一下吧。 T1：给两个数列 $a_{1..n},\,b_{1..n}$，多组询问，每次给 $c,\,d,\,e,\,f$ ，需要从 $a_{c..d}$ 和 $b_{e..f}$ 中各取 $d-c+1$ 个数然后两两配对，问配对的两个数相同的对数的期望，以最简分数形式输出。$n$ 和询问数好像大约是 $10^5$ ，因为只打了第一档暴力不记得了… T2：一个网格图，有两种连边： 一整行/列两两连边。 一些特殊点之间两两连边。 有 $m$ 个被破坏的点，在某个时间点（每个被破坏的点独立）被修好，修好前所在行/列的整行/列连边不会连上。每个特殊点在某个时间点（每个特殊点独立）前不会和其它特殊点连边。多组询问问两个点联通的最早时间点，以及这个时间点的最短路。 网格大小 $10^5$，询问数 $10^6$，被破坏的点数和特殊点数都是 $2\times 10^5$。 T3：求有多少个不同的长度不超过 $m$ 的 区间取min操作序列 使得进行最后一次操作后原序列恰好变成指定序列。值域和序列大小一样都是 $n$。$n$ 好像是一两百的样子，$m$ $10^9$。 数据范围可能记错了，题意可能简述成看不懂了..QAQ就这样吧。 晚上开营仪式，先是清华系主任自吹，然后是广二校长继续吹+拉拢和THU的关系，然后请一个现在在THU的NOI2017Au爷上台念了篇游记…感觉那如果是篇游记还是写的挺好的，然而当众念出来..然后请了广二的一个妹子OIer 讲了一点，就结束了。 Day 2/-6今天是上午考试..T1是给你一棵树，每个点有 $a_i,\,b_i$，每条边有 $c_i,\,d_i$，$u$ 到 $v$ 的费用为 $\sum\limits_{i\text{ on path }(u,v)}\min(a_u+c_i,b_u+d_i)$，求每个点到其它所有点的费用之和。树大小 $5\times 10^5$，值域 $10^5$。开场先打了个暴力，然后感觉可以枚举每条边把树分成两半，然后就可以计算 $\sum\limits_{c-d&lt;b-a} c$ 和 $\sum\limits_{c-d\ge b-a}d$ 来做，然而一开始没想到怎么做。继续去想链的部分分，发现可以主席树，然后花了 $1.5h$ 过 pt。然后发现可以用线段树合并搬到树上，又花了 $1h$ 过掉 pt。在 THUWC 过 pt 还是挺爽的.. T2是道通过询问得到树的形态的交互，没仔细看… T3是给平面上一些点，定义“好的多边形”为取一些点构成的没有三点共线的凸四边形，求所有“好的多边形”的面积的平均值和方差，对 $998244353$ 取模。点数 $400$ ，值域 $10^9$。有个点在坐标轴上的部分分，然而WA了两个小时..至今不知道哪错了.. 中午回寝室发现两边隔壁寝室分别有 nzhtl1984 和 yyb..然而最后和 lk 面基了。 下午推了会儿 Kanon。 去吃晚饭的时候碰见了 pr 和 lk。 晚上是图像处理题： 任务一把 $B\times65536+A$ 看成 $A\times65536+B$，调了 20min… 任务二任务三也写的特别慢，最后任务四没时间了.. 三场加起来没别人一场高，whkwhk 最后离场的时候发现了这个： 那两个红红的桌面壁纸是今天的样例… Day 3/-5今天应该是我来广二之后最有趣的一天了，本来拍了一堆照片，录了一堆视频，还有一堆录音，好多想说的。可是记（gu）忆（gu）是个好东西，它会帮你筛去那些不重要的，留在脑海中的便是那些真正值得写的吧。 讲题Day2+讲题的时候听到最多的一句话就是“然后就可以跳到”….. 讲完之后还讲了一些关于图像的其它内容，比如把图片的某些 bit 异或一下来加密： D1T2的讲题是带动画的，非常有意思，虽然有一些录像，然而还是放几张图片凑合一下吧： 好像 ctr 还觉得 D1T2 可以放 NOIp T2T3 左右… 然后是什么 ”圆梦清华路上有力的援助“什么的… 反正讲题特别有意思。 扯皮下午是扯皮介绍THU的时间。 能发弹幕，所以现场特别欢乐。 先是介绍了算协，然后介绍了科协，然后是一个去年THUWC签约然后进队今年过来当工作人员的介绍自己这一年的经历，然后是一个人介绍了一下科研相关。 反正当时感觉超有意思的..然而不太记得算协具体讲了啥了..科协讲的就记得智能体大赛..那位神仙 lzj 讲的倒记得比较清楚。大约是说他签约后写了个光线追踪的工程，然后写了个“二维屁股守望”还现场演示了，之后还去参加了智能体（注意他现在才高三..）。科研相关的讲的非常科研，可能是比较硬核而且互动/玩梗不够，当时现场也不太活跃，弹幕都没什么人刷… 结营感觉贵系招生主任的演讲水平真的超棒..弹幕都能迅速地扯到相关话题并且立刻扯回原本的主线，衔接自然流畅，感觉可以去当主播。 中途提了个问题，问我们为什么选择OI。 有回答“不想上文化课”“不想高考_(:з」∠)_”的，有回答“因为兴趣（略略略”“好玩”的，有回答“希望在有生之年解决曾经无法解决的问题”的，也有回答“能结识好多厉害的同学！”的。可能大多数人都是如此吧。因为兴趣开始，时而有宏大的理想，时而又为现实所迫，最后才发现不是自己菜，而是结识了越来越多越来越强的同学们。 约咕咕了一个小时才发，窝自然是没有的，pr签了，lk签了，yyb签了，nzhtlshadowice1984签了，joker签了，窝认识的都签了。 一天下来那么多的感想竟然短短几行就写完了呢…遗憾没有拍到的照片也只是和其它拍到了的照片一样没有被放上来。 Day -4今天早上一起来就是愉快的卷铺盖走人，虽然路程比去 THUWC 的时候近（从“苏元”（好像是初中部？）到“二高”），然而要搬被子床单什么的..分了两趟搬QAQ 然后颓推了一天一会儿Kanon，魔芋的翻译真有意思： 报到的时候有个签名墙，中午和晚上各拍了一张，晚上的比较全（废话），然而中午的拍的比较清楚，所以都放上来好了.. 看到窝写的 &lt;font color="grey"&gt;ouuan&lt;/font&gt; 了吗qwq 晚上是开幕式，掌声最热烈的有两个地方。 第一个是广二的一个妹子OIer的演讲：“OI到底在学什么？班主任眼中最会修电脑的一批人，旁人眼中前途一片平坦通向美好未来的道路，同班同学眼中那个经常消失不知道去哪的神秘人”，“OI 已不只是一个竞赛，也不只是一门学科，而是存在于群聊中一句句 Orz 和三个百分号里，存在于看到十的九次方加七时的熟悉感以及看到 998244353 时的心里默默的波动中，抑或是一步步化难为简，最终得出正解的喜悦，也可能是自闭场后一个人独自惆怅的身影”。 第二个有js风险，所以..： 当NOI科学委员会主席念到“WC性价比高”的时候（copy这行） Day -3~0自闭。 放几张图好了。 把汐里线（推了游戏之后更喜欢这个翻译了..和香里也有姐妹的感觉）推完了。算是理解了为什么汐里的“名言”是“起きないから奇跡って言うんですよ”，这句话有好几层意思，光是看动画不会明白的吧..也稍微明白了“梦境”与“第三个愿望”是怎么回事了。虽然还是不完全懂..（都是不合理的，好像也没什么“完全懂”） 第二场营员交流上 yfz 和 mcfx 讲的指令集真好玩。 Day 1打铁。 开场先写了 $T1$ $34$ 分，一出考场就听说自己挂了 $8$ 分。 然后去想 $T3$ 交互，发现不会做，先把强制数据分治的 $13$ 分写了，调了一会儿，继续想 $O(n^2)$。 感觉不会，这时候已经过去 $3.5h$ 了（鬼知道前面那点分为什么写了这么久..），去玩 $T2$ 提答，前面 $60$ 分还是很好写的，然后作死的想了一会儿第四个点，发现不会，已经只剩 $0.5h$ 了。 问题是我这个时候还在想 $T3​$ 的 $n^2​$ 怎么写…最后 $15min​$ 的时候决定写个随机询问打表对照，直接随便打了个表都没有检查结果是否两两不同，本来还把原来的代码复制了一份，最后 $1min​$ 写好的时候竟然把代码复制回去编译的..随手输了个数据，一测，既不是 correct 也不是 incorrect，然后就考试结束了..估计连那 $13​$ 分一起没了，爆零了。 写了的分：$34+60+44=138$，Cu/Ag。 估分 at 考试结束前 $15min$ ：$34+60+13=107$，Cu。 估分 of 考试结束前 $15min$ ：$26+60+13=99$，Fe/Cu。 考试结束后的估分：$26+60+0=86$，Fe。 保底估分：$18+38+0=56$，Fe。 最高可能得分：$26+60+44=130$，Cu/Ag。 Day 1.5虽然只有下午+晚上，然而发生了好多事鸭。 先是 GGF 把选手复读复测鸽到了讲题开始之后.. 然后窝去看成绩，$T3$ 竟然没挂（$13$），然而 $T2$ 的第二个点莫名挂了..仔细看了半天都是对的，问别人也是对的，群里更有趣了，$O(1)$ 的题目 $O(n)$ 做法有 $0,\,6,\,20$ 分的..然后找到了工作人员，咕了一会儿之后帮我重测过了..然后去申诉，还不知道能不能加回来。讲题没去听..听了也是自闭。 OIer真能搞，说搞就搞出来了一个文艺汇演。 LCA nb！Joker nb！大连24 nb！zzt nb！ 感觉这一晚上更加了解 OI 了。要变得更强，和更强的人在一起，去喜欢正确的事情，再用尽全力去喜欢自己喜欢的事情。 完整版文艺汇演录制今晚压制出来，大约要回武汉之后才能传到b站上。 Day 2上午去科学中心冬眠。在车上用 zar 的热点把文艺汇演传了。 下午听说 $T2$ 重测了，然后窝莫名 Ag 了.. 这场 WC 好像是暴力 Au，只要 $127$ 分，然而窝暴力没打满，又疯狂挂分，只好滚粗了.. 另外好像人人都有一枚铁牌。 睡前看了两集《比宇宙更远的地方》。 Day 3上午看了两集《比宇宙更远的地方》，然后去火车站。发现竟然和 PinkRabbit 一辆（去火车站的）车。 中午吃了干拌面（来火车站之前买的），然后有个卖方便面的小哥让我们帮忙把方便面看着，他去上个厕所。$20min$ 后，他从厕所出来，去问 ylh 在玩什么游戏： 本来想对广二说 さようなら 的，想了想应该是 またね 。 感觉 cl 中渚对朋也说的那句“离开的时候一定要是笑着离开的，不然就再也回不来了”莫名可以用在这里。]]></content>
      <categories>
        <category>游记</category>
      </categories>
      <tags>
        <tag>清华营</tag>
        <tag>CCF系列赛事</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UER #8 —— 通信题：打雪仗]]></title>
    <url>%2FUER-8-%E6%B8%B8%E8%AE%B0-%E2%80%94%E2%80%94-%E9%80%9A%E4%BF%A1%E9%A2%98%EF%BC%9A%E6%89%93%E9%9B%AA%E4%BB%97%2F</url>
    <content type="text"><![CDATA[T1题目链接 大意：Alice 有一个长度为 $2n$ 的 $01$ 串 $s_{1..2n}$，Bob 有 $n$ 个下标 $p_{1..n}$，Alice 和 Bob 只能用 $01$ 通信，需要在每人各 $m$ 个 bit 内使 Bob 输出 $s_{p_1..p_n}$ . $n=1000,\ m=1350$ Part 1 通信题 只是说一下我做了这道题后对通信题的理解，可能有误。 赛时：通信题是啥？？？作为一个从未做过通信题的选手，遇到这题自然是百度了一下“通信题”。如果你尝试一下，会搜到《移动通信试题库》。 尝试搜索 “通信题 OI”——OI是什么意思? - 问通信专家；”通信题 CSDN”——通信原理考试题-CSDN下载。 ok，只能自己看样例程序了。 于是我比赛的第一个小时就在对着样例代码懵逼中度过了….. 然后发现我sb了，忘记了一件事：标准输入是会等待输入的！ 可能是我 OI 题做傻了，以为输入一定要一连串不停地输入…导致我一直没有理解为什么两个程序之间可以来回通信… （上面那段话纯属我sb了，请跳过不看） 通信题是……根据我的理解，通信题就是：两个程序，分别从文件读入数据，从标准输入读入另一个程序的标准输出。最后其中一个程序按要求输出到文件。 （好像跟题面描述的差不多…） 那就说说我sb了而卡住的地方好了..一个程序 getchar() 的时候会暂停执行，直到另一个程序输出，就跟手动输入数据时等待回车一样。 关于调试广二机房是 win7，不太方便复制… 于是只好手动输入了，只不过感觉 copy 两个程序的输出看它们相互配合着工作，还是蛮有趣的。 Part 2 解法其实我 $5min$ 就想到怎么做了..（但好像做法比最短解那些神仙做法麻烦的多？）其实也不是很难写，但由于第一次写通信题不太习惯，各种细节写挂，最后写了一个小时才A… 解决问题可以想到这样一个做法（如果想不到也没关系..看懂就好了）：选择一个区间 $[l,r]$ ，Bob 用一个长度为 $r-l+1$ 的 $01$ 串告诉 Alice 这个区间内每个位置是否是一个下标，对于每个下标 Alice 告诉 Bob 对应的值；对于不在 $[l,r]$ 内的其它部分，Alice 把所有值（不管是不是一个下标）都告诉 Bob . 优化通信数考虑一下，这样做需要的 bit 数是多少： Bob 给 Alice 的：首先 Bob 要告诉 Alice $l$ 和 $r$ , 用二进制表示，需要 $22$ 个 bit；其次，Bob 要询问 $[l,r]$ ，需要 $r-l+1$ 个 bit 。 Alice 给 Bob 的：首先 Alice 要回答 Bob 在 $[l,r]$ 内的询问，需要 “ $[l,r]$ 内下标个数” 个 bit；其次，Alice 要告诉 Bob 除了 $[l,r]$ 其它区域的所有值，需要 $n-(r-l+1)$ 个 bit 。 那么，我们需要最小化：$\max(r-l+23,\ [l,r]\text{ 内下标个数}+n-r+l-1)$ 。 用 $[l,l+len)$ 来表示会简洁一些，所以下文都使用这种方式，即需要最小化：$\max(len+22,\ [l,l+len)\text{ 内下标个数}+n-len)$ 。 预处理前缀和即可快速算出 $[l,l+len)$ 内的下标个数，$O(n^2)$ 枚举区间取最小值即可。 参考代码Bob1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495#include &lt;iostream&gt;#include &lt;fstream&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;using namespace std;ifstream fin("bob.in");ofstream fout("bob.out");char rd() //读入一个bit&#123; return getchar();&#125;void wt(int x) //输出一个bit&#123; putchar(x+'0'); fflush(stdout);&#125;int n,m,p[1010],rk[4010],pre[4010],minn=0x7fffffff,l,len;char ans[1010];int main()&#123; int i,j,t; fin&gt;&gt;n&gt;&gt;m; for (i=1;i&lt;=n;++i) //读入并记录是第几个下标（便于存答案），并且复制一份拼在后面，这样如果询问的区间跨过首尾可以方便地处理 &#123; fin&gt;&gt;p[i]; rk[p[i]]=rk[p[i]+2*n]=i; &#125; for (i=1;i&lt;=4*n;++i) //预处理前缀和 &#123; pre[i]=pre[i-1]+(rk[i]&gt;0); &#125; for (i=1;i&lt;=2*n;++i) //枚举找最优方案 &#123; for (j=1;j&lt;=2*n;++j) &#123; t=max(pre[i+j-1]-pre[i-1]+2*n-j,j+22); if (t&lt;minn) &#123; minn=t; l=i; len=j; &#125; &#125; &#125; for (i=10;i&gt;=0;--i) //告诉Alice l和len &#123; wt(bool((1&lt;&lt;i)&amp;l)); &#125; for (i=10;i&gt;=0;--i) &#123; wt(bool((1&lt;&lt;i)&amp;len)); &#125; for (i=l;i&lt;l+len;++i) //询问区间 &#123; if (rk[i]) &#123; wt(1); ans[rk[i]-1]=rd(); //存答案 &#125; else &#123; wt(0); &#125; &#125; for (i=l+len;i&lt;l+2*n;++i) //读取剩余部分 &#123; if (rk[i]) &#123; ans[rk[i]-1]=rd(); &#125; else &#123; rd(); &#125; &#125; fout&lt;&lt;ans; return 0;&#125; Alice12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;iostream&gt;#include &lt;fstream&gt;#include &lt;cstdio&gt;using namespace std;ifstream fin("alice.in");int rd() //为了方便，两个程序中rd()和wt()的char/int是反的&#123; return getchar()-'0';&#125;void wt(char x)&#123; putchar(x); fflush(stdout);&#125;int n,m;char s[4010];int main()&#123; int i,l=0,len=0; fin&gt;&gt;n&gt;&gt;m&gt;&gt;(s+1); for (i=2*n+1;i&lt;=4*n;++i) //复制一遍放在后面 &#123; s[i]=s[i-2*n]; &#125; for (i=0;i&lt;=10;++i) //读入l和len &#123; l=l*2+rd(); &#125; for (i=0;i&lt;=10;++i) &#123; len=len*2+rd(); &#125; for (i=l;i&lt;l+len;++i) //回答询问 &#123; if (rd()) &#123; wt(s[i]); &#125; &#125; for (i=l+len;i&lt;l+2*n;++i) //告诉Bob剩下的部分 &#123; wt(s[i]); &#125; return 0;&#125; Part 3 证明取询问区间为 $[l,l+1318]$ ，这样的话 Bob 发给 Alice 的 bit 数就为 $1319+22=1341$ . 区间 $[l,l+1318]$ 内下标的期望个数为 $\frac{1319}2$ ，所以一定存在某个区间使得下标个数小于等于 $659$ ，再加上剩余部分 $681$ ，Alice 发给 Bob 的 bit 数就为 $1340$ 。 事实上，我提交的评测记录里通信次数最多的就是 $1341+1340$ 。 Part 4 优化只取 $len=1325$ ，少枚举一维，可以优化到时间复杂度 $O(n)$ ；少传 $11$ 个 bit，可以优化到最大通信次数 $1336+1337$ 。证明从略。 提交记录]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>UOJ</tag>
        <tag>通信题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[随机生成图片展示]]></title>
    <url>%2F%E9%9A%8F%E6%9C%BA%E7%94%9F%E6%88%90%E5%9B%BE%E7%89%87%E5%B1%95%E7%A4%BA%2F</url>
    <content type="text"><![CDATA[传送门 源码按F12即可查看（当然也可以在 repo 里面看） 看到一个帖子里提到了一个140字符画图比赛，看到了 Martin Büttner’s code ，然后就随便写了一个. JavaScript 都是要用啥现场百度… 已经更新了（存档？）功能，在地址栏后以 ? 开头 &amp; 分隔即可输入参数。例如：https://ouuan.github.io/randpic/generator/?width=512&amp;height=512&amp;blocksize=75&amp;qwq=2&amp;minred=100&amp;maxred=255&amp;mingreen=100&amp;maxgreen=255&amp;minblue=200&amp;maxblue=255&amp;minalpha=0&amp;maxalpha=255 下面是一些图片（附有参数链接）：]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>HTML/JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Avito Cool Challenge 2018 游记]]></title>
    <url>%2FAvito-Cool-Challenge-2018-%E6%B8%B8%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[这两天比赛是真的多..碰上了场 Chinese Legends Round / HackForces 竟然在紫名涨了点分QAQ 看到 A，$gcd(x,x-1)=1$ ，这不是sb题吗？然后愉快地WA了…互质 $\ne$ 不为倍数鸭QAQ还有 $1$ 呢.开场-50分.. B貌似比C难，但A的人比C多..其实当时交的时候还没想清楚 $p$ 个一样的人数是 $p$ 的倍数这个结论，就感觉好像是对的，就交了。 C 很快就想到了结论，排列组合乘一乘随便做，而且数据范围小到可以用杨辉三角算组合数+不用快速幂。 D 感觉要搞个MST，然后就真的先搞了个MST，然后就没有想到简单的解法..正解是MST搞完所有关键点就不搞了。一开始写挂了，然而pt特别水（好像直接输出MST最大边就可以），A完E之后看到jason的D被叉了，就仔细看了下，发现自己写挂了..然后重交，少了 $400$ 多分。 E 贪心搞一搞就行了，据说ylh没有做出来是忘了积一定差越小和越小.. F 看了看感觉不会，于是锁了 D 开始叉人。看到room rank1的正解感觉自己整个人都sb了..在离比赛结束 $5$ 分钟的时候看到一个感觉写挂了的，然而不敢hack，于是一直盯着看，直到离比赛结束还有 $1$ 分钟的时候才hack，然而一不小心把数据打错了..幸好格式错误不扣分，赶紧点回去重新hack，最后在离比赛结束 $4s$ 的时候提交了hack，然后绿了！喜提 $100$ 分、$50​$ 名。 当时比赛一结束我就跟 ylh 说我感觉如果我不 fst能再涨 $100$ 名，然后最后真的又涨了 $100$ 名.. B和D一堆fst的。 F 用奇偶性判断选择的哪边，感觉很妙。 G 没仔细看。 H： and we didn’t except anyone to pass. 不知道会在紫名待多久QAQ]]></content>
      <categories>
        <category>游记</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CF edu 56 & AT Grand 029 游记]]></title>
    <url>%2FCF-edu-56-AT-Grand-029-%E6%B8%B8%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[今天 AT 和 CF 刚好连上了，于是就都打了一下。 关于模板今天心血来潮把用于在线比赛的模板换了一下，加了点东西，然后发现 rep(1,l,r) 写起来非常不顺手..保留了部分比较好用的。 测试的时候忘记开数组了（都是些什么sb错误），然后以为 ll 不能作下标，于是没有 #define long long，然后 CF 挂惨了.. AtCoder上一场打的 Beginner，这场难度正常多了。 A 是个值域为 $2$ 的逆序对.. B 用 multiset 乱搞了一下，对于每个数枚举组成的数，然后从大到小匹配，不知道是不是正解，反正过了，而且是 $log^2$ 的。 C 感觉挺可做的..可能有细节没调出来，赶着回酒店打 CF 就没有继续调了.. D 一开始还在想博弈论完全不会..然后仔细看了一眼，如果 A 不走，B 就会不走，就结束了；所以 A 一定能走则走。然后就随便做了。 只不过 AT 的 rating 真的涨的好快.. CodeforcesABC 三道 spj ？？？ 都是随便构造就能做的.. 然而 C 一开始忘开 ll 了….. D 黑白染色一下，连通块内两种节点分别有 $a$ 个和 $b$ 个答案就是 $2^a+2^b$ ，把每个连通块的答案加起来就好了。 由于 $O(nq)$ memset 会爆掉，不能 memset 整个数组，于是愉快地在开了 ll 的情况下 memset(…sizeof(int)…)；发现了之后不小心把开 int 的另一个数组也改成 memset(…sizeof(long long)..) 了.. 开场 $40$ 分钟的时候这 $3$ 个关于 ll 的罚时让我排名翻了三倍… 于是，A 了 D 之后我就在板子里加上了 #define int long long。 看了会儿 E 不会做，然后一看 standing，惊奇地发现 G 有一堆（$15$ 个，当时 E $7$ F $1$）人 A 了，然后一看，就是POJ 2926+动态RMQ… 感觉自己几年没有写过普通线段树了（最近写的全是平衡树/动态开点线段树），写了半个多小时还写错了..毕竟是 CF，应该去复制个模板才对的…一交，MLE 了，woc我好不容易#define int long long了就是这个结果？？改成 int，跑了 $5.4s$，巨方，于是手动开了 O3，$4.8s$ ，但重交竟然没有罚时。应该去找个 BIT 动态求 RMQ 的模板的… 看到 halyavin 参赛了，感觉自己要 fst ，赶紧把博客写了睡觉去。 UPDhalyavin 竟然没有 hack…然而 D 有一堆 memset 整个数组的，我也去 hack 了一个（edu hack $\sqrt{}$）。 没有 fst，第一次 A $5$ 题，上 $2k$ 了，感觉海星。 UUPD题解 CF1093D 【Beautiful Graph】 题解 CF1093G 【Multidimensional Queries】]]></content>
      <categories>
        <category>游记</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
        <tag>AtCoder</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[html实现随机图片]]></title>
    <url>%2Fhtml%E5%AE%9E%E7%8E%B0%E9%9A%8F%E6%9C%BA%E5%9B%BE%E7%89%87%2F</url>
    <content type="text"><![CDATA[注：暂时还不知道如何制作能被引用的随机图片，只能查看图片，而不能通过类似于![](图片地址)的方式查看。 demo 欢迎投稿图片：投稿地址 核心代码12345&lt;script type="text/javascript" src="imagelist.json"&gt;&lt;/script&gt;&lt;script type="text/javascript"&gt; var r=Math.floor(Math.random()*images.length) document.write("&lt;img src="+images[r]+"&gt;")&lt;/script&gt; 图片列表保存在 imagelist.json 内。 参考示例https://ouuan.github.io/randpic/people/index.html： 123456789101112131415161718192021&lt;html&gt; &lt;head&gt; &lt;script type="text/javascript" src="imagelist.json"&gt;&lt;/script&gt; &lt;title&gt;随机图片-人物类&lt;/title&gt; &lt;link rel="icon" type="image/png" sizes="32x32" href="/images/favicon32.png"&gt; &lt;link rel="icon" type="image/png" sizes="16x16" href="/images/favicon16.png"&gt; &lt;style&gt; img &#123; width: 100%; height: auto; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;script type="text/javascript"&gt; var r=Math.floor(Math.random()*images.length) document.write("&lt;img src="+images[r]+"&gt;") &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; https://ouuan.github.io/randpic/people/imagelist.json： 123456789101112131415161718192021var images=[ "https://z4a.net/images/2018/12/12/70469686_p0.png", "https://z4a.net/images/2018/12/12/69212051_p0.jpg", "https://z4a.net/images/2018/12/12/64660644_p0.jpg", "https://z4a.net/images/2018/12/12/61438972_p0.jpg", "https://z4a.net/images/2018/12/12/60141148_p0.png", "https://z4a.net/images/2018/12/12/1200296-20170715113653118-1762611401.jpg", "https://z4a.net/images/2018/12/12/71631241_p0.jpg", "https://z4a.net/images/2018/12/12/f0Q5-g62pXkZ5lT3cS1hc-rs.jpg", "https://z4a.net/images/2018/12/12/36224612_p0.jpg", "https://z4a.net/images/2018/12/12/64702477_p0.jpg", "https://z4a.net/images/2018/12/12/64670588_p0.jpg", "https://z4a.net/images/2018/12/12/61815260_p0.jpg", "https://i.loli.net/2018/12/12/5c10a02b0831b.jpg", "https://i.loli.net/2018/12/12/5c1119665c83a.jpg", "https://i.loli.net/2018/12/12/5c111a8bed8e8.jpg", "https://i.loli.net/2018/12/12/5c111ab43f7cf.jpg", "https://i.loli.net/2018/12/12/5c111ade38590.jpg", "https://i.loli.net/2018/12/12/5c111b8240591.png"] UPD研究了一下 js 后写了一下图片缩放：（代码很丑，毕竟是靠百度学了一个小时写出来的）（大括号不换行是因为sublime缩进写着写着就炸了，只好在网上格式化了一下） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107&lt;html&gt; &lt;head&gt; &lt;script type="text/javascript" src="imagelist.json"&gt; &lt;/script&gt; &lt;title&gt; 随机图片-人物类 &lt;/title&gt; &lt;link rel="icon" type="image/png" sizes="32x32" href="/images/favicon32.png"&gt; &lt;link rel="icon" type="image/png" sizes="16x16" href="/images/favicon16.png"&gt; &lt;/head&gt; &lt;body style="margin: 0px; background: #0e0e0e;"&gt; &lt;script type="text/javascript"&gt; var cur = 1; var xx = 0; var yy = 0; var rx = 0; var ry = 0; var nw; var nh; var mw; var mh; var w; var h; function setSize() &#123; if (cur == 1) &#123; var p = document.getElementsByTagName("img")[0]; nw = p.naturalWidth; nh = p.naturalHeight; mw = window.innerWidth; mh = window.innerHeight; if (nw &gt; mw || nh &gt; mh) &#123; p.style = "cursor: zoom-in"; &#125; else &#123; p.style = "cursor: auto"; &#125; if (nw * mh &gt; nh * mw) &#123; h = nh * mw / nw; w = mw; &#125; else &#123; w = nw * mh / nh; h = mh; &#125; p.style.width = w; p.style.height = h; p.style.marginTop = (mh - h) / 2; p.style.marginLeft = (mw - w) / 2; &#125; else &#123; if (nw &gt; mw || nh &gt; mh) &#123; p.style = "cursor: zoom-out"; &#125; else &#123; p.style = "cursor: auto"; &#125; &#125; &#125; function picLoaded() &#123; setSize(); window.onresize = function() &#123; setSize(); &#125; &#125; function BigSmall() &#123; mw = window.innerWidth; mh = window.innerHeight; if (nw &gt; mw || nh &gt; mh) &#123; if (cur == 1) &#123; cur = 2; var p = document.getElementsByTagName("img")[0]; p.style = "cursor: zoom-out"; var e = event || window.event; mw = window.innerWidth; mh = window.innerHeight; if (nw * mh &gt; nh * mw) &#123; h = nh * mw / nw; w = mw; &#125; else &#123; w = nw * mh / nh; h = mh; &#125; if (nw &lt;= mw) &#123; xx = (mw - nw) / 2; rx = 0; &#125; else &#123; xx = 0; rx = (nw - mw) * (e.clientX - (mw - w) / 2) / w; &#125; if (nh &lt;= mh) &#123; yy = (mh - nh) / 2; ry = 0; &#125; else &#123; yy = 0; ry = (nh - mh) * (e.clientY - (mh - h) / 2) / h; &#125; p.style.marginTop = yy; p.style.marginLeft = xx; document.body.scrollLeft = rx; document.body.scrollTop = ry; &#125; else &#123; cur = 1; setSize(); &#125; &#125; &#125; var r = Math.floor(Math.random() * images.length); document.write("&lt;img src=" + images[r] + " onload=\"picLoaded()\" onclick=\"BigSmall()\"&gt;"); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>HTML/JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018~2019冬 广二避寒记]]></title>
    <url>%2F2018-2019%E5%86%AC-%E5%B9%BF%E4%BA%8C%E9%81%BF%E5%AF%92%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[迎风迈出的步伐更艰难，即使走的不远，但踩得更深。一代人只能做一代人的事，完成这个时代赋予的使命就是英雄，大地也会将他的脚印铭记。 ——乒乓帝国（句子迷上说是《孤杂记》..） 突然就得知了要去广二集训。 然后知道了这次出去可能要一直到 WC，差不多有 $50$ 天。这样一算这个学期我在武汉的时间可能和外出的时间一样多了。 毕竟是去广州，会暖和很多，也许看不到武汉的雪了。 Day 0Railway在站台上遇到了 Dew、ylh，感觉自己活尸化严重，都是我妈先看见的… 中午吃了泡面（有汤的那种），之前出去都比较近，在火车上不用吃饭，印象中上次吃方便面还是初三的时候在学校里吃的（桶装的泡面，愣是被我当成干拌面吃的）。 在火车上看看手机、看看《大卫·科波菲尔》，当然我现在在写博客。 途中看到了一幅非常………..ok我承认我词穷了。云很低，好像不比火车高多少，环绕在山的周围，山脚下是一些平房，在远处插入了几栋现代化的高楼大厦，有一种违和却奇妙的美感。 赶紧掏出手机，可毕竟只是手机，拍不出云那种虚无缥缈的立体感，匆忙中也没能选好角度，没拍到那几栋高楼大厦。 已经逝去了，经纬度也没有记下来，不能在回来的火车上再览其景，只能用粗浅的文字将其略微地记录下来罢。 Underground进地铁前忘记上厕所了Orz 和 ylh 一起体验了一次换票出站上厕所。 然后是 huangbei 站： 人特别多，特别热。毕竟是来避寒的 Restaurant和广二的教练谈了谈人生，建议我和 ylh 先系统地学知识点，不着急打套题，结果 dew 想先学知识点，我和 ylh 想在广二做题.. 然后就是住宿的事，貌似准备先住两个星期三人间，等 ylh 回去了就去教练家里住（教练一个星期只回家一天）。今晚是先各自和家长住双人间。房号 1216. Day 1上午教练咕咕了，中午才来接我们。 然后让我们不着急打比赛，给我们三个人安排了个机房做题。 $5$ 道左偏树，派遣、罗马游戏和Joint Stacks比较轻松地做出来了；Sequence看了看题解，感觉还没完全搞懂，但A了；魔法猪学院用A*在广二的OJ和BZOJ上过了，暂时放弃可持久化左偏树，以后再学吧.. 山、河、树（不只是路边那种）（当然也不是可持久化那种），游泳池，令人联想起 Angel Beats! 的食堂，各式各样的社团活动。 Day 2-3把题目列表搞到了洛谷团队里. 搞了搞平衡树、启发式合并之类的，感觉自己啥都不会.. 搞了个随机图片 。 Day 4一天就写了[NOI2004]郁闷的出纳员和LCT模板… 然后搞了个stylus插件：洛谷犇犇、讨论隐藏。 果然整天待机房效率低. Day 5上午听隔壁机房的讲了下回文自动机、后缀数组、后缀自动机，但由于手头上的题还没搞完就没做相关的题目。 [NOI2005]维护数列做了好久..本来操作就多，取的子段还不能为空… 然后学了下LCT。 Day 6-7就做了几道 LCT 的题…学了学虚树，还没做题。 然后这几天比赛挺多的，at+cf 还有洛谷比赛。感觉洛谷比赛都挺dl的… 然后今天看了几篇vfk的博客，感觉都写的挺好的。 里面提到了CFctr的自我修养，感觉以后出题时要牢记（虽然里面有些是只适用于CF的）： 准备一场CF包括：题目、比赛通知、题解。 你的题目必须是独一无二的。你不能从以前用过的题目中抄袭它的想法。PLEASE BE FAIR WITH THE COMMUNITY。（ 空间限制必须是256MB，时间限制至少是出题人的java程序运行时间的两倍。 题面必须清晰好懂，没有语法错误。建议写得短短的…… 题目背景中不要写数据范围，全部都要写在输入格式里。 请参考以前CF的题目描述的格式来写题目描述。如果你不知道怎么清晰地描述输入输出格式，请找与之类似的题目进行仿写。 题目描述中的数组下标最好从1开始。 你必须限制被你提到的所有的变量的范围。如果你提到一个字符串，你必须写明哪些字符可以出现在这个字符串内。 题目的tests中必须包括各种各样的数据，而且应该有各种各样的达到最小数据范围的数据和达到最大数据范围的数据。也就是说如果1 &lt;= n &lt;= 100000，那么数据中既应该有n = 1，也应该有n = 100000。 你应该写个暴力。 你应该拿标程与暴力对拍。 Div.2的题的pretests要很强，能让应该超时的程序在pretests上就TLE掉。但是你可以让这个点毫无意义。比如给n个数排序，你可以用n个1来确保选择排序不能过。 确保读错题的人不能过pretests。 建议添加极端数据，但是不必是所有极端数据。确保数组开小的人不能过pretests。 不要让时间复杂度很高但做了大量常数优化的人AC。 每道题至少2个样例。每道Div.2的题目的前两个样例必须有样例解释。 如果要使用long long，请确保不开long long的人不能过pretests。 哦对了，自定义域名总是炸，以后这个博客就用 ouuan.github.io 作为地址了。（正好避免了一年后域名到期的问题） Day 8今天好像啥都没干..估计是每天都没睡好导致白天效率低下.. 好像看了好几篇淀粉质的教程，但就是不想写题.. 和 memset0 讨论关于保留几位小数与精度限制的问题..感觉其他人总是不能轻松地理解保留几位小数是卡精度的… 翻译了CF的几道题，写了写题解。 继续yy自己口胡的题的优秀做法，依然没什么进展。 跟 Sooke 说了说自己出 CF 的想法，Sooke 表示想一起出，然后在还没想好一道题的情况下大谈怎么出 CF.. 说实话出 div.2 的话会有些不甘，哪怕晚点也想出 div.1+div.2 的.. 第一次用洗衣机，感觉洗衣机真有趣 （好像暴露了我一周没洗衣服…） （hexo 貌似不支持行内图片？） Day 9搞了个 随机生成图片 ，感觉自己自从用了 Hexo 日益由 OIer 变成码农了。 Day 10-11这几天忙着搞比赛，博客可能咕咕咕了..准备比赛记大约会在比赛出来之后发QAQ. Day ?-?咕咕咕咕咕咕咕 Day 14广二先是四楼停电，用了一上午笔记本，准备回酒店的时候门卫告诉我们电来了，然后回去一看发现四楼没电三楼有电。下午突然就又停电了，幸好我和 dew 都没有在写代码.. ylh 走了，然而住教练家被咕咕了，好像是因为又来了几个外省的。 新酒店..发几张图感受一下吧： 没错 p3 是 dew 在吊椅上 然而不敢对着 dew 拍… wifi 特别神仙： 被夹在了一个没有 wifi 的世界里.. 然后貌似明天还是什么时候开始要打比赛了，然后这篇游记就不会继续真的成“游记”了。 Day 15今天是集训队爷 zjt 出的 集训队互测。 T1 一道带权带花树好题的确是带权带花树裸题（求一般图最大权值匹配），然而不需要输出方案。 虽然说 OI 题名无正解，然而我还是百度了一下..然后学了一个半小时带花树，没学会！ 然后再一看，$n\le20$ 不会做？ 只好写了二分图的 $20$ 分滚粗.. 然而发现一个严重的问题，这貌似是我第一次写二分图最大权值匹配..百度了一下，发现全是KM算法，没有一篇费用流？然后仔细想了好多遍，感觉费用流应该没问题，就写了。然而一开始写挂了（连图中的边时没判哪个点是起点），幸好后来发现了。 后来听说这题 std 是一个线代做法，由于不用输出方案码量非常小。具体可以参考2017年集训队论文。然而看不懂鸭… 这题不卡随机化乱搞.（嘤嘤嘤？） T2 一道拉格朗日反演好题看到 T1 真的是一般图最大权值匹配的我真的信了题名的鬼话.. 一个 $01$ 序列，初始为空，有三种操作： 往末尾加个 $0$ . 删掉一个子序列，包含 $x$ 个 $0$ ，$y$ 个 $1$ ，然后往末尾加个 $1$ 。其中 $x\in A$ 。 删掉一个子序列，只包含 $x$ 个 $0$ ，然后往末尾加个 $1$ 。其中 $x\in B$ 。 $A$ 和 $B$ 还有操作总数 $n$ 是给你的，让你求 $n$ 次操作完成后序列长度为 $1$ 的方案数。 一开始还以为只用管 $01$ 分别的个数，后来才发现选的子序列位置不同也算不同的方案… 数据范围：いいよ,こいよ $114514$ 不太会做，好像是转化成一个树上的 dp，然后再算一波式子，分治FFT/牛顿迭代？ 不得不说样例十分lx： 12310 10 100 1 2 3 4 5 6 7 8 90 1 2 3 4 5 6 7 8 9 1362880 愉快地拿到了 $|A|=|B|=n$ 这档部分分。 T3 一道 Top cactus 好题仙人掌上 $q$ 次询问求经过某个点的路径贡献之和。模 $998244353$。“不在简单环上的边数”为 $x$ 的路径贡献为 $v_x$ 。 部分分第一档，树，$n\le2000$ 。 woc我只会 $O(n^3)$ .. 冷静了一下，发现可以枚举路径树上差分.. 愉快地拿到了这 $10$ 分。 正解好像是淀粉质+NTT。然后搬到圆方树上去。 总结队爷出的题就是神仙..之前一直感觉多项式看起来没啥用？请julao们看到这句话别打我..感觉很有必要早点去学多项式全家桶了。 另外题名里的算法真的 $99\%$ 不可信。 另外由于打比赛换了个机房，貌似机房里都是一些外省的？ OIer居然是可以有npy的！ Day 16yww咕咕了，myh出的题。这场题面太赞了！据说题意不清被吐槽的很厉害，但我貌似还是第一次碰见YNOI型题面，背景是自己看过的番，题意瞬间理解。 这场还有个有趣的地方，T1 和 T3 的 subtask 一开始放反了，而且 T3 的变量 T1 都有，于是我比赛开始 $2h$ 才发现..（当然我发现的时候已经改回来了） T1 青春野狼不做理性小魔女的梦题意简述，题目背景太棒了，所以我要题面简述。 在咖啡厅，双叶不说话，只是推给了你一张纸，上面写着一个不定方程： $A_1x_1+A_2x_2+\cdots+A_kx_k\equiv1\mod m$，然而其中的一些 $A_i$ 被咖啡打湿了，需要给被打湿的 $A_i$ 们赋值（$A_i\in[0,m)$），使得不定方程有整数解；同时，双叶也不记得 $m$ 是多少了，所以要求 $m\in[1,n]$ 的方案数之和。$1\le k\le50,1\le n \le10^9$。 大约想到怎么做了，然而感觉无法实现（事实是正解要用杜教筛），会写的特别麻烦复杂度还不对，于是就只打了 $k\le5,\,n\le10$ 的暴力和没有数字被打湿的分。然而后面那档挂了，因为求区间内与某个数互质的数个数时没有容斥，最神奇的是拍半个多小时没拍出来… T2 青春野狼不做姐控偶像的梦和花给麻衣的信很有规律，她写的信是一个 $1$ ~ $n$ 的排列，一段连续的信能给麻衣鼓励，当且仅当它的值也连续（noi.ac的whzzt邀请赛里把这玩意定义为“广义排列”，意思就是一个区间， $max-min=r-l$ 且没有重复的数），麻衣想知道如果只保留一段连续的信，她能收到多少鼓励（就是多组区间询问）。 其实..就是 CF997E Good Subsegments.. 千古神犇wxh log碾标算！lxctr myh n^2 送温暖！嗯，我拿了 $O(n^2)$ 的 $20$ 分… 做法参考 zzq的评论 T3 青春野狼不做小恶魔学妹的梦这道题题面写的最好！（貌似也被吐槽的最惨） 对学长的思念，深埋于心底。 难以表达。 与学长的记忆分为 $n$ 个部分，两个不同的部分间可能会有一种关系，也可能没有。 可是我知道，它们藕断丝连，注定联通。 想忘掉，可是却越来越难忘，$m$ 种关系会带给我 $m^k$ 的思念。 我不知道我有多思念学长，能告诉我如果关系随意出现，思念的和吗？ 我不想看到太大的数，只要告诉我它模 $998244353$ 的结果就好了。 题意简述：$n$ 个点组成联通无向图，求不同的方案边数的 $k$ 次方之和。 斯特林展开+大力推式子+NTT. 再见。 其它myh 问班上的女生：你怎么3.5k写完仙人掌剖分的。 嗯，女生就是昨天的总结里的女生。yqyry Day 17今天没有比赛。 Day 16 ~ Day 17 的这晚貌似是来广二之后睡的最长的一次（$6$ 小时 $40$ 分），然后效率果然略高了一些（一天只搞了FFT/NTT/多项式求逆，高个鬼），比起之前整天几乎啥都不干还是好多了..（有种如果睡8小时能一天搞完多项式全家桶的错觉） 希望这周能把多项式常见的一些东西搞完吧..到时候应该会写一篇博客。 Day 18颓颓颓。 T1题意大约是求 $l_i\le ki+b\le r_i$ 的 $k,b$ 方案数。 最低档暴力在考试结束前 $10min$ 才想出来一个特别麻烦的解法..然后爆零了。 正解半平面交。 T2线性同余找循环节海星。 T3给几个团，团内点连相同权值边，问点之间两两距离之和。 以团内边权为点权求出团之间的最短路，然后 $dist(i,j)=\min\{d(x,y)|x\in S_i,y\in S_j\}$（$S_i$ 表示 $i$ 所在团的集合）。 具体实现要用到 FMT 里的一个小 trick ，然而题解里一笔带过，我看了一下午题解都没看明白… 其它那位女生 $rank1$ 了… 然后今天才发现广二 OJ 外网是能上的..（当然注册不了账号QAQ） Day 19今天搬的 ACM 原题？CF 权限 gym Orz 题解给吉老师视频，太灵性了.. zjt 25（$rank\ 8$），myh 赛后五分钟提交 $15$ 快乐赛。 T1dp，好像没啥不会的知识点，然而没做出来。 T2把排列当成坐标放在平面上，分类讨论求上升块？表示完全没听懂，讲的时候 myh 在不停地提问。 黑科技听不懂，而这道题除了黑科技还要牛顿迭代…每场必有多项式的flag还是没倒. T3没听懂嘤嘤嘤。 Day 20颓颓颓。 今天没比赛，然而只搞了多项式除法和任意模数NTT。 多项式除法一开始 $B(x)$ 模了 $x^m$ ，然而应该模 $x^{n-m+1}$ ，然后挂了半天。 任意模数NTT因为数组开小挂了半天… 看到洛咕有绘板，就把晚上的at咕咕了，搞了个py脚本。一开始妄想手动把图片转成数据，差点一晚没睡，后来main包发了个脚本，转的效果还挺不错的。 Day 21-23基本上都在搞绘板，比赛记应该是永久咕咕了，绘板记这几天会写出来。 有一个小插曲，9102年第一个梗被我骗了点赞。 Day gugugu绘板记咕咕了，这两天的比赛记咕咕了，今晚的CF不咕咕！猝死！！ Day 27今天的T1非常有意思，$8$ 个 int 进行编码，编码长度至少是 $1000$ 个 int，随机打乱之后给你解码。标算是一个不确定性算法，所以这题是达到一定正确率就过，（然后我赛时第一次提交30，第二次提交20，脸黑选手zjt赛时90，赛后AC），然而有神仙想出了多点求值、快速插值的确定算法。 T2一看是几何题我就跳了..然而这题不怎么需要计算几何，而且有 $30$ 分挺好写的….. T3是个树上dp，部分分有个“与一条蛇同构”，然后： xswl 尝试着按myh的提交记录刷题，第一题是个字符串哈希，第一眼还以为是AC自动机..然后一发mapT飞，unordered就过了。第二题是个裸的单点、子树加，单点询问，竟然写错了3遍…..第三题是个数位dp，愉快地卡住了….再不好好学数位dp感觉会出事_(:з」∠)_ Day 28T1是树上在线多组多路径询问颜色种类数和mex，一开始看到部分分还在想为什么没给树上莫队分，然后一想多条路径莫队复杂度肯定不对，看题解才知道正解树分块…bitset能在线搞定的事，为什么要离线排序呢？然后成功在赛后A掉了（广二膜你赛赛后首A_(:з」∠)_）大约就是预处理关键点之间的bitset，块内暴力跳，关键点之间已经预处理了。 T2是道神仙题..好像从某外国比赛搬的，赛时0A，通过分治时判断左右一样来保证复杂度，没太听懂。 T3：“点分治然后建虚树再点分治就好了！”（mdzz）“听说fzy有两个log做法？treap/Splay合并就行了！”（mdzz） 然后用bitset&lt;0&gt;水了点contribution，达成成就：contribution比friends多。 polygon真有意思！试着把一道题搞上去了。 Day 29-30稍微学了下莫比乌斯反演和杜教筛，感觉挺有意思的QAQ。 比赛全场就我不会马拉车，然而三题暴力排名还不错…貌似只要打了点非无脑的暴力就能考的还行。（A题就jxd了 Day 31今天比赛是zzq出的，上场 Chinese round 既视感严重.. T1树上有一些特殊点。 两两匹配特殊点使得距离之和最大。正解没听懂，然而直接扫一遍存为 $rk_{1..k}$ 然后输出 $(rk_i,rk_{i+\frac k 2})$ 就能过… T2“这是一道交互题”。 加了一些限制条件，不同排名的人在某些情况下可能不回答询问，对其排序。 并不是很难然而赛时没想到.. T3QuickSort伪代码。 求 $cnt$ 次操作后排序成啥样了。又是只需要大小时转化为 $0/1$,$0/\pm1$ 的 trick. 然后，今天写了 $5$ 道莫比乌斯反演，100+600，感觉海星。 Day 32改题日→出题日 Day 33比赛的时候OJ挂了海星，最后修好了。 感受一下刚修好时的提交。这次题目时限又大，当时卡了好几页。 T1一开始时限是 $2s$，后来开成 $4s$ 了，然后一排人 $3.9s$… T3一开始时限是 $6s$，myh NTT被卡常，赛后给自己开到 $12s$ 重测，$9s$ 过了…然后他成功 $rank1$。 Day 34 这个是我们刚来时就在画的，最近画好了，趁着迟到没人拍了一下。 上午被告知学校有考试，机房被占用了，让我们下午不要去机房，在打比赛的体育馆待着。于是很多人都提前跑了..我也下午就走了，走的时候看到一堆小学生模样的孩子和家长，听到了“XX考试的第二场和XX时间一样，不让考完第一场就跑”之类的话，听到了“二火”之类曾经熟悉的名词。我是为什么放弃了华一寄来到外初的呢..早就忘得一干二净了，只记得来外高是因为wqs的寥寥几句话： 还听到一个孩子说：“二中环境真好。”我以为他也会感叹二中有山有水，没想到他说的是——“二中有专门的清洁工”。 Day 35改题日颓颓颓 Day 36OrangeRabbit tql!!! 去机房的路上发现这个： 我们刚来的时候就看到有人在画井盖了，然而才发现这个QAQ T2对自己 $20$ 分暴力过于自信，打了一个半小时表找不到规律后写了下 $20$ 分才发现是错的… T1写了一个半小时比暴力跑的还慢的树剖..稍微想想就可以发现复杂度完全不比暴力优的，然而想到就打了.. 最后没时间写T3暴力了，赛后听说T3数据特别水，随便写都能六七十分.. 于是炸的特别惨。 晚上学了下淀粉质（讲题的时候myh认为机房里没人不会动态点分树…），看题解怎么都看不懂，只不过自己yy很快就写出来了，然而第一次交的时候前向星存边数组没开两倍..？ Day 37今天又是zzq出的题，T1T2都是构造，其中T1没有输入..T1 rand跑了一个小时跑出来 $60$ 分（存种子提交），T2最低档爆搜不会..两个特殊性质subtask写了 $30$ 分。 T3 也是道思维好题，写了个 $O(n^3)$ 暴力 $30$ 分。 Day 38好像是最后一个改题日..又颓过去了没什么好说的。 Day 39Sooke跟我说他昨天做了这套题…然后告诉我不要看T3，会很惨。然而.. 这次好像是我拿到 $80$ 分最快的一次，打完T1T2拍了一下就开始玩提答了。看了一会儿大约看懂了一点，然后试着百度了一下“lambda”，啥都没查到，然后继续搜“lambda 邱奇”，发现“邱奇数 百度百科”，然后继续搜“邱奇数”，搜到了这个。于是开始研究..前面 $6$ 个点有的是自己想的，有的是看懂之后写的，78是直接抄的。最后混到个15名..lx特别ba…只不过今天又来了几个人，感觉不抄的话二三十名好像也有，也海星啦… Day 40最后一天了呢..已经在布置THUWC了。 今天的题暴力档特别少..又是1h拿到了 $48$ 然后肝不出了…T3有很多人A，和之前D16T2有点像，是给一个排列问划分成若干个连续段的方案数，做法也比较类似，然而没想起来，也不会做… 这 $40$ 天好多想补的知识点也没补完..题也没怎么改..总体来说挺颓的…最后两天再稍微补一补，调整一下状态吧，考出应有的成绩就好。这篇博客大概就这样完结了，下次就是THUWC/WC游记了。 Day 41本来应该结束了的..今天没去学校，10点的时候dew突然告诉我今天有场比赛？？一看是THUSCH2017原题，然后T1 dl线段树写了2h没调出来…只不过好像并不是膜你赛，广二OJ很早就有这几题了，今天的standing也只有6个人… 然后..窝竟然真的在WC前把kanon补完了..]]></content>
      <categories>
        <category>游记</category>
      </categories>
      <tags>
        <tag>集训</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AtCoder Beginner Contest 115 游记]]></title>
    <url>%2FAtCoder-Beginner-Contest-115%2F</url>
    <content type="text"><![CDATA[之前听教练安利，就来打了场 AtCoder。 -5h比赛地址 一开始看到 “Beginner”的时候我还迟疑了一下，看了下上一场 Beginner 的题目，又在网上搜了一下，想着可以熟悉一下 AtCoder ，就准备打了。 0min咕咕咕 5min咕咕咕咕咕咕 只不过幸好咕咕了，我的模板还没搞好..赶紧新建文件夹 atcoder\AtCoder Beginner Contest 115 ，把 $4$ 个用于 CF 的模板扔进去。 10min开始了！ 用了 $0.1s$ 决定用 switch 而不是 if else 。 用了不知道多久敲完。 没测样例（废话）直接交了。 其实我现在还在想，如果 WJ 的时候我去写 T2 而不是刷新看结果会不会涨个一两名… 12min看了下 $10\times10000&lt;10^9$ 。 用了不知道多久敲完。 测了样例交了。 其实我现在还在想，如果没测样例我会不会再涨个一两名… 14min想了想还是用了快读，毕竟模板里有。 测样例，没写cout&lt;&lt;ans; 。 其实我现在还在想，其实我现在还在想，如果没测样例我会不会掉个十几名。 16min数据范围看起来好小。 等等，$x$ 的范围？ 预处理汉堡的大小。 哦，爆 int 了。 其实我现在还在想，如果模板里有#define int long long我会不会再涨个一两名… 写个函数 work(int a) 处理大小为 $a$ 的汉堡，分类讨论乱搞一下应该就行了。 测样例，#3 看起来好大。 终于可以安心地看 judging 不用担心浪费时间了。 130minBeginner 定级貌似最高 400 点 rating..]]></content>
      <categories>
        <category>游记</category>
      </categories>
      <tags>
        <tag>AtCoder</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WC2019 全国模拟赛第二场 T1 题解]]></title>
    <url>%2FWC2019-%E5%85%A8%E5%9B%BD%E6%A8%A1%E6%8B%9F%E8%B5%9B%E7%AC%AC%E4%BA%8C%E5%9C%BA-T1-%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[又只会写T1… 题目链接 题意简述给你一个排列 $p_{1..n}$，$a_{1..n}$ 为任意的一个排列，定义 $b[a_i]=a[p_i]$，求总共有多少个不同的 $b_{1..n}$ 。 做法首先，对 $(i,p_i)$ 连边，会得到若干个环。 环上旋转一下（$\forall i\text{ on the cycle : }i\rightarrow p_i$）得到的置换是本质相同的。节点个数相同的环互换一下是本质相同的。 先计算把 $n​$ 个节点分成若干个环的方案数：（用 $siz[i]​$ 表示第 $i​$ 个环的大小，$k​$ 表示环的个数，$sum[i]​$ 表示 $\sum\limits_{j=i}^ksiz[j]​$） $$S_1=\prod\limits_{i=1}^kC_{sum[i]}^{siz[i]}$$ 然后去掉节点个数相同的环互相交换：（用 $num[i]$ 表示节点个数为 $i$ 的环的个数） $$S_2=\frac{S_1}{\prod\limits_{i=1}^nnum[i]!}$$ 然后乘上每个环旋转（旋转造成的不同方案数即固定某个数后剩下的数的排列个数）： $$S_3=S_2\times\prod\limits_{i=1}^k(siz[i]-1)!$$ $S_3$ 就是最终的答案了。 参考代码noi.ac 上最短解（其实计算方式和我是一样的..）： 12345678910111213141516#include&lt;bits/stdc++.h&gt;#define mn 1111111using namespace std;long long n,i=1,s=1,j,x,p=998244353,a[mn],f[mn],v[mn],t[mn];int main()&#123; scanf("%lld",&amp;n); f[0]=f[1]=1; for (;i&lt;=n;i++) scanf("%lld",a+i); for (i=2;i&lt;=n;i++) f[i]=f[p%i]*(p-p/i)%p,(s*=i)%=p; for (i=1;i&lt;=n;i++) if (!v[i]) &#123; for (j=i,x=0;!v[j];x++,j=a[j]) v[j]=1; (s*=f[x]*f[++t[x]]%p)%=p; &#125; printf("%lld",s);&#125; 我自己赛时的辣鸡写法： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cctype&gt;using namespace std;int read()&#123; int out=0; char c; while (!isdigit(c=getchar())); for (;isdigit(c);c=getchar()) &#123; out=out*10+c-'0'; &#125; return out;&#125;const int N=1000010;const int M=998244353;void dfs(int u);int c(int a,int b);int n,p[N],dfn[N],low[N],sta[N],dfncnt,top,siz[N],tot,num[N];int x,y,jc[N],inv[N],ans=1,sum;bool ins[N];int main()&#123; int i; n=sum=read(); for (i=1;i&lt;=n;++i) &#123; p[i]=read(); &#125; for (i=1;i&lt;=n;++i) &#123; if (dfn[i]==0) &#123; dfs(i); &#125; &#125; jc[0]=jc[1]=inv[0]=inv[1]=1; for (i=2;i&lt;=n;++i) &#123; inv[i]=(1ll*M*M-1ll*(M/i)*inv[M%i])%M; &#125; for (i=2;i&lt;=n;++i) &#123; jc[i]=(1ll*jc[i-1]*i)%M; inv[i]=(1ll*inv[i-1]*inv[i])%M; &#125; for (i=1;i&lt;=tot;++i) &#123; ans=1ll*ans*c(sum,siz[i])%M; sum-=siz[i]; &#125; for (i=1;i&lt;=n;++i) &#123; ans=1ll*ans*inv[num[i]]%M; &#125; for (i=1;i&lt;=tot;++i) &#123; ans=1ll*ans*jc[siz[i]-1]%M; &#125; cout&lt;&lt;ans; return 0;&#125;int c(int a,int b)&#123; if (a==b||b==0) &#123; return 1; &#125; return 1ll*(1ll*jc[a]*inv[b]%M)*inv[a-b]%M;&#125;void dfs(int u)&#123; dfn[u]=low[u]=++dfncnt; sta[++top]=u; ins[u]=true; if (dfn[p[u]]==0) &#123; dfs(p[u]); low[u]=min(low[u],low[p[u]]); &#125; else if (ins[p[u]]) &#123; low[u]=min(low[u],dfn[p[u]]); &#125; if (low[u]==dfn[u]) &#123; siz[++tot]=1; while (sta[top]!=u) &#123; ++siz[tot]; ins[sta[top--]]=false; &#125; ins[sta[top--]]=false; ++num[siz[tot]]; &#125;&#125; 所以说不要看到环就 tarjan…]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>组合数学</tag>
        <tag>noi.ac</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo博客搭建指北]]></title>
    <url>%2Fhexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E6%8C%87%E5%8C%97%2F</url>
    <content type="text"><![CDATA[折腾了 $3$ 天终于把博客搭建好了…本文会简单介绍一下 hexo 博客的搭建，并选取一些我自己在配置博客的过程中遇到的问题，说明一下我的解决方案。 实际上，hexo 博客的搭建并不难，难搞的是美化，我在这个过程中遇到了很多问题，不可能在这篇博客中全部陈述出来，最重要的还是勤于百度。 本篇博客不完全按照顺序撰写，可以通过页面左边的目录跳转阅读。 博客的搭建先推荐两篇比较好的教程：搭建个人博客-hexo+github详细完整步骤，使用github+Hexo人人都能拥有一个美美的博客。 这部分网上讲的已经比较好了，我在这就简单说一下。 安装软件需要安装的软件有：git，Node.js。 下载安装即可… 本地设置装好之后，在本地创建一个文件夹，下文中称其为“根目录”。 下文中“输入命令”均指在命令行中输入命令（并回车废话），既可以使用 git bash，也可以使用 cmd 或 powershell 。输入命令时若无特别说明都需要 cd 到根目录下。 输入命令 npm install -g hexo 来安装 hexo 。 输入命令 hexo init 来初始化 hexo 。 输入命令 npm install 来安装一些需要的包。 输入命令 hexo s，并在浏览器打开 localhost:4000，在本地预览博客；如果上文步骤进行正确，应该看到一个类似于这样的页面： 注：命令可以缩写，条件是没有开头几个字母相同的其它命令。hexo s 实际上是 hexo server 的缩写；下文中 hexo d 是 hexo deploy 的缩写，hexo g 是 hexo generate 的缩写；hexo clean 不能缩写为 hexo c，因为存在命令 hexo config ，但是可以缩写为 hexo cl 。 按 Ctrl+C 关闭 server 以继续操作。（若出现类似于 终止批处理操作吗(Y/N)? 的提示，输入 y 即可。） 接着安装博客的主题，可以在 hexo 官网 选择主题下载，本篇教程推荐使用 NexT 主题。 在 hexo 官网 点击图片下方蓝色的文字即可打开主题的 GitHub 主页，一般来说，一个主题的 GitHub 主页上是有用于安装的命令以及配置博客的教程的。 如果没有的话（或者即使有也一样），你应该输入命令 git clone 主题的Github主页地址 themes/主题名 。例如：git clone https://github.com/theme-next/hexo-theme-next themes/next 。 当然，你也可以使用默认的 landscape 主题，从而不用额外下载主题。 下载好主题后，用任何一款文本编辑器（记事本也可以），打开根目录下的 _config.yml ，将 theme: landscape 修改为 theme: 你想用的主题名 即可。 配置 GitHub 仓库首先你需要有一个 GitHub 账号。 然后点击右上角你的头像，打开“Your repositories”，点击绿色的按钮“New”。 在”Repository name”一栏填入 yourname.github.io （“yourname”指你的 GitHub ID，比如我就填 ouuan.github.io），”Description”可以随便填也可以不填，然后点绿色的按钮“Create repository”。 将博客上传至 GitHub输入命令 ssh-keygen 来生成 SSH，让你输入东西你就空着，按回车（应该要按三次回车）。 然后用任意的文本编辑器打开 C:\Users\电脑用户名\.ssh\id_rsa.pub（如果装了 vim 可以直接输入命令 vim ~/.ssh/id_rsa.pub），复制里面的内容。 打开 GitHub，点击右上角的头像，打开“Settings”，选择左边的“SSH and GPG keys”，点绿色的按钮“New SSH key”，Title 随便填，下面的 Key 把刚才复制的东西粘贴进去，然后点绿色的按钮“Add SSH key”。过程中可能需要输入密码。 输入命令 ssh -T git@github.com ，若出现 Hi yourname! You've successfully authenticated, but GitHub does not provide shell access. 表示 SSH 配置成功。 输入命令 npm install hexo-deployer-git --save 安装 deployer 。 打开根目录下的 _config.yml ，将最后几行改为： 1234deploy: type: git repository: https://github.com/yourname/yourname.github.io.git branch: master 当然”yourname”要改成你的 GitHub ID 。 依次输入命令： 123hexo cleanhexo ghexo d 这一步可能要输入密码。 等几分钟，再用浏览器打开 yourname.github.io ，应该就可以看到你的博客了。（此时别人也可以通过这个网址看到你的博客。） 博客的配置与美化根目录下的 _config.yml这部分参考官网教程即可。 建议不要像我一样 permalink 设成 title/…博客写多了之后，如果博客全放在根目录，就会非常自闭。（试想一下你哪天写到了 1000 篇博客，然后打开博客 repo，显示 Sorry, we had to truncate this directory to 1,000 files.，整个页面都是乱七八糟的博文名称）。可以设成 blog/title 之类的，总之不要全放根目录。 可以在 highlight.tab_replace 设置将缩进替换为什么，默认是长度为八空格的制表符。例如： 12345highlight: enable: true line_number: true auto_detect: false tab_replace: &apos; &apos; 主题目录下的 _config.yml主题目录下的 _config.yml 指 \themes\主题名\_config.yml。 这里以 NexT 主题（本文基于 NexT 6.6，其它版本可能有些区别）为例，这个主题的 _config.yml 非常完备，修改配置基本上只需删除/添加注释符号 # 以及改变 true/false 即可。 选择 NexT 主题的四种之一12345# Schemesscheme: Muse#scheme: Mist#scheme: Pisces#scheme: Gemini 将想用的主题前的 # 删掉，在 scheme: Muse 前加上 # 即可。 例如： 12345# Schemes#scheme: Muse#scheme: Mist#scheme: Piscesscheme: Gemini 四种主题的预览在 NexT 主题的官网有。 改变网站图标12345favicon: small: /images/favicon-16x16-next.png medium: /images/favicon-32x32-next.png apple_touch_icon: /images/apple-touch-icon-next.png safari_pinned_tab: /images/logo.svg 将你想用的图标放在 \themes\next\source\images 里，然后修改上面的文件名即可。 例如： 123favicon: small: /images/favicon16.png medium: /images/favicon32.png 页脚设置1234567891011121314151617181920212223242526272829303132333435footer: # Specify the date when the site was setup. # If not defined, current year will be used. #since: 2015 # Icon between year and copyright info. icon: # Icon name in fontawesome, see: https://fontawesome.com/v4.7.0/icons # `heart` is recommended with animation in red (#ff0000). name: battery-full # If you want to animate the icon, set it to true. animated: false # Change the color of icon, using Hex Code. color: &quot;#808080&quot; # If not defined, will be used `author` from Hexo main config. copyright: # ------------------------------------------------------------- powered: # Hexo link (Powered by Hexo). enable: false # Version info of Hexo after Hexo link (vX.X.X). version: true theme: # Theme &amp; scheme info link (Theme - NexT.scheme). enable: true # Version info of NexT after scheme info (vX.X.X). version: true # ------------------------------------------------------------- # Beian icp information for Chinese users. In China, every legal website should have a beian icp in website footer. # http://www.miitbeian.gov.cn beian: enable: false icp: icon： © 2019 与用户名之间的图标。（图中 $1$） 图标名称为 Font Awesome 上的图标名称。 powered.enable：为 true 则会显示“由 Hexo 强力驱动”。（图中 $2$） powered.version：为 true 则会显示 Hexo 的版本。（图中 $3$） theme.enable：为 true 则会显示“主题 – NexT.XX”。（图中 $4$） theme.version：为 true 则会显示主题的版本。（图中 $5$） 注：根据 NexT 主题的 LICENSE，footer 中必须开启 theme.enable 选项。 “关于”&amp;”标签”123456789menu: home: / || home about: /about/ || user tags: /tags/ || tags #categories: /categories/ || th archives: /archives/ || archive #schedule: /schedule/ || calendar #sitemap: /sitemap.xml || sitemap #commonweal: /404/ || heartbeat 将需要的项目取消注释即可在侧边栏显示。 如果需要使用“关于”页面，输入命令 hexo new page "about"。 然后在 \source\about\index.md 中就可以编辑“关于”页面了。 可以修改 \source\about\index.md 中的 title 项来显示“关于”而非“about”。 如果需要使用“标签”功能，需要在博文中添加选项 tags ： 如果有多个标签，每行一个，以 - 开头： 1234tags:- 标签1- 标签2- 标签3 如果需要使用“标签”页面，输入命令 hexo new page "tags"。 然后向 source\tags\index.md 中添加一行： 1type: &quot;tags&quot; “分类”与“标签”类似。 站内搜索输入命令 npm install hexo-generator-searchdb --save 安装所需的库。 在根目录下的 _config.yml 的结尾加入： 12345search: path: search.xml field: post format: html limit: 10000 然后在 \themes\next\_config.yml 中，打开 local_search： 12local_search: enable: true 社交网站123456789101112131415# Social Links.# Usage: `Key: permalink || icon`# Key is the link label showing to end users.# Value before `||` delimeter is the target permalink.# Value after `||` delimeter is the name of FontAwesome icon. If icon (with or without delimeter) is not specified, globe icon will be loaded.social: GitHub: https://github.com/ouuan || github 洛谷: https://www.luogu.org/space/show?uid=49742 || code Codeforces: https://www.codeforces.com/profile/ouuan || code b站: https://space.bilibili.com/11067182 || tvsocial_icons: enable: true icons_only: false transition: false 在 social 下每行一个，格式为：名称: 地址 || 图标。 其中，“图标”为 Font Awesome 图标名称，但有些图标是不可用的，而且图标也不全，使用的时候要尝试一下图标是否可用。 12social_icons: enable: false 这样设置可以只显示名称不显示图标。 友情链接（或其它链接）123456789101112# Blog rollslinks_icon: globelinks_title: 友情链接# links_layout: blocklinks_layout: inlinelinks: Dew: https://www.cnblogs.com/ppprseter/ wjyyy: https://www.wjyyy.top/ Sooke: https://www.luogu.org/blog/Sooke/ huyufeifei: https://www.cnblogs.com/huyufeifei/ Rye_Catcher: https://rye-catcher.github.io/ 额冻豆腐: http://www.mayflyyh.com/ links_icon：显示在标题前的图标。 links_title：标题。 links_layout：block 一行一个，inline 一行多个。 links：要显示的链接以及名称。 头像123456789101112# Sidebar Avataravatar: # in theme directory(source/images): /images/avatar.gif # in site directory(source/uploads): /uploads/avatar.gif # You can also use other linking images. url: /images/avatar.jpg # If true, the avatar would be dispalyed in circle. rounded: true # The value of opacity should be choose from 0 to 1 to set the opacity of the avatar. opacity: 1 # If true, the avatar would be rotated with the cursor. rotated: false url：头像地址，留空则不显示头像。 rounded：圆/方头像。 opacity：不透明度。 rotated：随光标旋转。 回到顶部按钮/阅读百分比12345# Back to top in sidebar (only for Pisces | Gemini).b2t: true# Scroll percent label in b2t button.scrollpercent: true 博客首页不显示全文在博文里可以用 &lt;!-- more --&gt; 来标识在首页显示到哪为止。 可以在 \themes\next\_config.yml 里设置到一定字数自动不显示全文： 123456789# Automatically Excerpt. Not recommend.# Please use &lt;!-- more --&gt; in the post to control excerpt accurately.auto_excerpt: enable: true length: 150# Read more button# If true, the read more button would be displayed in excerpt sectionread_more_btn: true length：不显示全文的字数上限。 read_more_btn： 代码块复制按钮123456789codeblock: # Manual define the border radius in codeblock # Leave it empty for the default 1 border_radius: # Add copy button on codeblock copy_button: enable: true # Show text copy result show_result: true enable：启用复制按钮。 show_result： $\LaTeX$1234567891011# Math Equations Render Supportmath: enable: true # Default(true) will load mathjax/katex script on demand # That is it only render those page who has &apos;mathjax: true&apos; in Front Matter. # If you set it to false, it will load mathjax/katex srcipt EVERY PAGE. per_page: false engine: mathjax #engine: katex enable：启用 $\LaTeX$ 。 per_page：为 true 则只有博文中有 mathjax: true 才会启用 $\LaTeX$，否则每篇博客都会启用 $\LaTeX$ 。 engine：推荐使用 mathjax 。 hexo 博客的 mathjax 和 Markdown 有一些冲突，将在后文专门讲解如何解决冲突。 访客统计12busuanzi_count: enable: true 书签书签的功能是关闭页面/手动点击书签按钮时，保存这篇博客看到的位置，下次点进这篇博客时继续从这个位置开始。 安装插件：git clone https://github.com/theme-next/theme-next-bookmark.git source/lib/bookmark 更改 \themes\next\_config.yml： 123456789# Bookmark Support# Dependencies: https://github.com/theme-next/theme-next-bookmarkbookmark: enable: true # if auto # - save the reading position when closing the page # - or clicking the bookmark-icon # if manual, only save it by clicking the bookmark-icon save: manual 其它配置博客背景打开 \themes\next\source\css\_custom\custom.styl，输入： 1234body &#123; background-image:url(/images/background.jpg); background-size: cover;&#125; 把背景图片重命名为 background.jpg，放入 \themes\source\images（当然也可以更改background-image:url()）。 background-size: cover; 表示宽度缩放至页面大小。 123456body &#123; background-image:url(/images/background.jpg); background-repeat: no-repeat; background-attachment:fixed; background-size: cover;&#125; 如果修改成这样的话背景图片就不会滚动。 如果不想让博客内容挡住背景，可以设置博客内容的透明度，在 \themes\next\source\css\_custom\custom.styl 中加入下面的代码即可： 123.main-inner &#123; opacity: 0.9;&#125; 评论功能由于 Gitalk 存在一些安全性的问题（OAuth App 的 client_id 和 client_secret 是可见的、访客需要授予读写自己的 repo 的权限），并且稳定性较差，推荐使用 utterances。 在 https://utteranc.es/ 中进行设置，将配置代码放到 \themes\next\layout\_partials\comments.swig 中即可，如： 12345678910111213141516&#123;% if page.comments %&#125; &lt;div class="comments"&gt; &lt;script src="https://utteranc.es/client.js" repo="ouuan/hexo-blog-utterances" issue-term="title" label="utterances" theme="github-light" crossorigin="anonymous" async&gt; &lt;/script&gt; &lt;/div&gt; &#123;% if theme.facebook_sdk.enable and theme.facebook_comments_plugin.enable %&#125; ... 其实也可以安装 hexo-next-utteranc 插件，但没必要。 另外，用于存放 issue 的 repo 需要安装 utterances app。 博文自定义排序打开 \node_modules\hexo-generator-index\lib\generator.js 。 在末尾添加如下代码： 12345678910111213posts.data = posts.data.sort(function(a, b) &#123; if(a.top &amp;&amp; b.top) &#123; if(a.top == b.top) return b.date - a.date; else return b.top - a.top; &#125; else if(a.top &amp;&amp; !b.top) &#123; return -1; &#125; else if(!a.top &amp;&amp; b.top) &#123; return 1; &#125; else return b.date - a.date;&#125;); 在博文设置中加入 top: x 即可，会以 top 为第一关键字，时间为第二关键字排序。若 top 为空则视作 -INF 。 折叠块怎么搞？ 标题链接的这篇博文写的够清楚了.. 需要注意的是这个折叠块标题的字体被设置了..如果想和博文用同样的字体，需要删去 font-family: "Microsoft Yahei";。 README.md如果想在 https://github.com/yourname/yourname.github.io 让别人看到你的博客的简介，就需要写一个 README.md 放在根目录下的 source 文件夹内。 然而，只是这样的话， README.md 会被渲染成 html，所以需要更改根目录下 _config.yml 的设置： 1skip_render: README.md 自定义404页面首先写一个 \source\404.html 。 至于怎么写html..这里地方太小写不下。 需要注意的是，一个真正的 404 页面应当在访问时返回 404 代码。在 HTML 中，可以使用 &lt;meta http-equiv="Content-Security-Policy" content="connect-src 'self'"&gt; 实现。（似乎不加这个也会返回 404？不是特别清楚。） 可以参考一下我的： 1234567891011121314151617181920&lt;html&gt; &lt;head&gt; &lt;meta http-equiv="Content-type" content="text/html; charset=utf-8"&gt; &lt;meta http-equiv="Content-Security-Policy" content="connect-src 'self'"&gt; &lt;title&gt;404 Error | ouuan的博客&lt;/title&gt; &lt;link rel="icon" type="image/png" sizes="32x32" href="/images/favicon32.ico"&gt; &lt;link rel="icon" type="image/png" sizes="16x16" href="/images/favicon16.ico"&gt; &lt;/head&gt; &lt;body&gt; &lt;div&gt; &lt;p style="text-align: center;"&gt;&lt;strong&gt;您可能访问了错误的网址&lt;/strong&gt;&lt;img src="/images/5bd4705dd844f.jpg"&gt;&lt;/p&gt; &lt;br&gt;&lt;br&gt; &lt;p style="text-align: center;"&gt;&lt;strong&gt;您现在可以：&lt;/strong&gt;&lt;/p&gt; &lt;p style="text-align: center;"&gt;&lt;a href="/"&gt;&lt;strong&gt;回到博客主页&lt;/strong&gt;&lt;/a&gt;&lt;/p&gt; &lt;p style="text-align: center;"&gt;&lt;a href="javascript:history.go(-1);"&gt;&lt;strong&gt;返回上一页&lt;/strong&gt;&lt;/a&gt;&lt;/p&gt; &lt;br&gt;&lt;br&gt; &lt;p style="text-align: center;"&gt;&lt;strong&gt;如果您在登录 Gitalk 时遇到此问题，请尝试&lt;a href="/%E5%A5%BD%E7%94%A8%E7%9A%84%E7%BD%91%E7%AB%99/"&gt;换一篇博客&lt;/a&gt;登录&lt;/strong&gt;&lt;/p&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 然后，如果直接这样发布，html 会被渲染，就跟一个自定义页面（hexo new page）一样了。 所以要修改根目录下的 _config.yml，在 skip_render: 后添加 404.html，如果有多项用 - 隔开： 123skip_render: - README.md - 404.html 发布完成后，访问一个错误的网址，比如 你的域名/qaq 就可以查看效果了。 一言（ヒトコト）大约是这个。 网上没找到教程，自己随便瞎研究了一波，所以方法比较丑陋，仅供参考.. 本来想稍微写一下自己研究的经过，想了想自己也没完全搞清楚，就来一波授人以鱼吧… \themes\next\layout\_macro\sidebar.swig: 1234567891011121314151617181920…… &lt;aside id="sidebar" class="sidebar"&gt; &lt;div class="sidebar-inner"&gt; &lt;div class="hitokoto-block"&gt; &lt;div class="hitokoto-inner hitokoto-comma hitokoto-left-comma"&gt;“&lt;/div&gt; &lt;div class="hitokoto-inner hitokoto-content"&gt;&lt;b&gt;&lt;span&gt;&lt;span id="hitokoto-content"&gt;&lt;/span&gt;&lt;/span&gt;&lt;/b&gt;&lt;/div&gt; &lt;div class="hitokoto-inner hitokoto-comma hitokoto-right-comma"&gt;”&lt;/div&gt; &lt;/div&gt; &lt;div id="hitokoto-from"&gt;&lt;/div&gt; &lt;div class="hitokoto-bottom"&gt; &lt;a id="hitokoto-link" href="https://hitokoto.cn/"&gt;Hitokoto&lt;/a&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;button id="hitokoto-like" title="通过给句子点赞可以增加其出现概率，由于技术原因并不能在博客中显示赞数与点赞是否成功的信息（红心表示成功发送点赞请求，但如果同 IP 重复点赞就会失败），如需查看可以点击左边的“Hitokoto”链接。"&gt;&lt;i class="menu-item-icon fa fa-fw fa-heart"&gt;&lt;/i&gt;&lt;/button&gt; &lt;/div&gt; &lt;/div&gt; &lt;div style="height: 15px"&gt;&lt;/div&gt; &#123;% if theme.sidebar.onmobile %&#125;…… \themes\next\layout\_scripts\commons.swig: 1234567891011121314151617181920212223242526……&lt;script type="text/javascript"&gt; function hitokotoLike(x, y) &#123; $.ajax(&#123; url: "https://hitokoto.cn/Like", type: "GET", data: "ID=" + x, dataType: "jsonp", success: function(data) &#123; alert(data.message); $(y).css('color', 'red'); &#125;, error: function() &#123; console.log('Hitokoto Like Request Error.'); $(y).css('color', 'red'); &#125; &#125;); &#125; $.get('https://v1.hitokoto.cn/?c=a', function(data) &#123; $('#hitokoto-content').css('display', '').text(data.hitokoto); $('#hitokoto-from').css('display', '').text('——' + data.from); $('#hitokoto-from').attr('title', '上传者: ' + data.creator); $('#hitokoto-link').attr('href', 'https://hitokoto.cn/?id=' + data.id); document.getElementById('hitokoto-like').onclick = function() &#123; hitokotoLike(data.id, '#hitokoto-like'); &#125; &#125;);&lt;/script&gt; \themes\next\source\css\_custom\custom.styl: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950…….sidebar &#123; background: rgba(0, 0, 0, 0);&#125;.hitokoto-block &#123; width: 200px; display: table; padding: 0 10px;&#125;.hitokoto-inner &#123; text-align: left; display: table-cell;&#125;.hitokoto-comma &#123; color: #B2B7F2; font-size: 24px; font-weight: bold; font-family: 'Times New Roman', serif;&#125;.hitokoto-left-comma &#123; vertical-align: top;&#125;.hitokoto-right-comma &#123; vertical-align: bottom;&#125;.hitokoto-content &#123; width: 176px; color: burlywood; text-indent: 2em; vertical-align: middle; padding: 0.8em 0.2em 1em 0.2em;&#125;#hitokoto-from &#123; text-align: right; font-size: 0.8em; color: black;&#125;.hitokoto-bottom &#123; margin-top: 15px; font-size: 0.8em; color: black;&#125; 大约就这样，省略号表示文件中本来就有的其它部分。不保证在其他人电脑上可以用。大致思路就是搞个空 div 指定一个 id，用 js 往里面塞东西。所以即使我这个“鱼”不能直接用大约也是可以稍微研究研究来用的。 博文复制提醒在 \themes\next\layout\_scripts\commons.swig 中加入： 12345&lt;script type="text/javascript"&gt; $('.post-body').bind('copy', function() &#123; alert('本博客内容欢迎分享（将本博客的原文地址分享到其它网站），允许部分摘录并在醒目位置附上原文链接，未经许可禁止任何形式的全文转载。'); &#125;);&lt;/script&gt; 更改 CSS大概按照 谢益辉博客 魔改了一下。 CSS Files。 Emoji详见 crimx/hexo-filter-github-emojis 🤔 。 安装的时候遇到了一些问题，具体来说执行 npm install hexo-filter-github-emojis --save 不会安装 peer dependencies，需要手动安装（从警告信息就可以看出需要安装哪些）。而在安装 canvas 时出现错误，更新 node-pre-gyp 后得到了解决。 大约是为了保证用户能够看到，很多显示 emoji 的库（如 emojione）都是使用 cdn 加载图片，然而我还是觉得 Win 10 本身的 emoji 样式比较好看，Linux 的也不错，所以又稍微魔改了一下，改成了显示 Unicode 字符而非图片。具体来说，将 \node_modules\hexo-filter-github-emojis\index.js 中的 renderEmoji 函数中的全部内容替换成了 return emojis[name].codepoints ? emojis[name].codepoints.map(c =&gt; `&amp;#x${c};`).join('') : ' '; 。 博客的写作Markdown 的使用网上有很多 Markdown 的学习资源，我自己是在洛谷剪贴板学会的。 我以前一般都用洛谷剪贴板编辑 Markdown，但 hexo 博客需要在本地编辑 .md 文件，这时普通的文本编辑器就不太方便了。我推荐 Typora 这款软件，还是挺方便的。 撰写博客前的准备打开根目录下的 _config.yml ，将 post_asset_folder 设为 true。 这样就可以把图片放到博客里而不用其它图床了。 然后把 \source\_posts\hello-world.md 删除。 博文的撰写新建一篇博客：hexo new "博文标题"。 然后等几秒钟，在 \source\_posts 文件夹下，就会生成 博客名 这个文件夹（如果你把 post_asset_folder 设为 true 了）以及 博客名.md。 撰写博客就是编辑 博客名.md。 这个文件的开头是博客的一些设置，可以在 \scaffolds\posts.md 中修改默认设置，我的默认设置是： 123456---title: &#123;&#123; title &#125;&#125;date: &#123;&#123; date &#125;&#125;tags: top: --- 然后就可以写 Markdown 格式的文章了。（top 是自定义文章排序，上文中介绍过） 需要注意的是，在洛谷代码块可以不加”cpp”，但在 hexo 上，一定要加上”cpp”： 12345#include &lt;iostream&gt;int main()&#123; cout&lt;&lt;&quot;hello world!&quot;&#125; 12345#include &lt;iostream&gt;int main()&#123; cout&lt;&lt;"hello world!"&#125; 更多博文模板在 \scaffolds 文件夹中可以增加更多的模板，比如我就搞了一个 \scaffolds\tutorial.md，这样的话，新建一篇题解的时候输入命令 hexo new tutorial "博文标题" 就可以使用模板了。 引用本地图片引用链接/网络上的图片格式与普通 Markdown 相同（[链接名称](链接地址) 和 ![图片描述](图片地址)），引用本地图片需要把 post_asset_folder 设为 true ，然后把图片放在与博客同名的文件夹中，然后只用 ![图片描述](图片文件名) 就可以引用了。 在编辑器里显示不出图片是正常的。 还有另一种方式引用图片， 用这种方式引用图片的话，把鼠标放在上面会显示图片描述（上面这张图就是用这种方式引用的）。 只有这种方式引用图片才能在博客首页正常显示图片，否则只能点进博客才能看到图片。 $\LaTeX$ 的使用$\LaTeX$ 概述$\LaTeX$ 主要用于编辑数学公式，十分方便，网上也有很多学习资源，比如：LaTeX数学公式大全。 在支持 $\LaTeX$ 的 Markdown 文档里，使用两个美元符号将 $\LaTeX$ 公式括起来，例如： 1~~QAQ$f_i=\sum\limits_&#123;j=1&#125;^ia_j$f_i=\sum\limits_&#123;j=1&#125;^ia_j~~ QAQ$f_i=\sum\limits_{j=1}^ia_j$f_i=\sum\limits_{j=1}^ia_j 也可以用一对双美元符号使公式居中显示在单行，例如： 123$f_i=1$$$f_i=1$$ $f_i=1$ $$f_i=1$$ 在 Typora 中使用 $\LaTeX$ 需要将设置中的”Markdown 扩展语法”全部勾选。 P.S. $\LaTeX$：\LaTeX 启用 $\LaTeX$在 \themes\next\_config.yml 中将 mathjax 设为 true，然后将 per_page 设为 false 或者在需要启用 \LaTeX 的博文开头加上 mathjax: true 。 解决冲突由于hexo博客中即使是 $$ 内的字符也会被当成 Markdown 渲染，类似于 $f_{f_i}$、$a*b*c$、$[x,y](1&lt;x&lt;y&lt;2)$ 之类的，都会被错误地渲染。 对于下划线，新版本的 marked 已经修复这一 bug（新版本的 hexo 或许已经不需要手动升级了），所以可以通过执行 npm install --save marked 和 npm install --save hexo-renderer-marked 解决。但同时，新版本的 marked 会将 \ 用作转义，所以 \\ 、 \{ 之类的要改成 \\\\ 、 \\{ 。 对于 *，建议使用 $\cdot$ ($a\cdot b$，一般用于表示乘积) 或 $\times$ （$n\times m$ 的矩阵，一般用于表示维度或者笛卡尔积）或 $\ast$ （$\mathbb{N}^\ast$，一般用于上标或表示卷积） 代替。其实也可以使用 $\*$ 来代替 $\ast$ 。 对于 $[x,y](1&lt;x&lt;y&lt;2)$，在它们之间加上空格，即 $[x,y] (1&lt;x&lt;y&lt;2)$ 就好了。 博客的发布其实前文提到过，依次输入以下三条命令即可： 123hexo clhexo ghexo d hexo cl 是可选的。加上不会有坏处..而且有时候必须加上。 发布之前还可以执行 hexo s 并在本地使用浏览器打开 localhost:4000 进行预览。 当然也可以使用 hexo g -d 命令。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>hexo博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WC2019 全国模拟赛第一场 T1 题解]]></title>
    <url>%2FWC2019-%E5%85%A8%E5%9B%BD%E6%A8%A1%E6%8B%9F%E8%B5%9B%E7%AC%AC%E4%B8%80%E5%9C%BA-T1-%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[由于只会T1，没法写游记，只好来写题解了… 题目链接 题目大意给你一个数列，每次可以任取两个不相交的区间，取一次的贡献是这两个区间里所有数的最小值，求所有取法的贡献和，对 $10^9+7$ 取模。 数列长度 $2\times 10^5$ ，值域 $1$ ~ $10^9$ 。 $O(n^4)$ 做法预处理区间最小值，枚举选的两个区间。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;const int M=1000000007;int n,a[60][60],ans;int main()&#123; int i,j,k,l; cin&gt;&gt;n; for (i=1;i&lt;=n;++i) &#123; cin&gt;&gt;a[i][i]; &#125; for (i=1;i&lt;n;++i) &#123; for (j=i+1;j&lt;=n;++j) &#123; a[i][j]=min(a[i][j-1],a[j][j]); &#125; &#125; for (i=1;i&lt;n;++i) &#123; for (j=i;j&lt;n;++j) &#123; for (k=j+1;k&lt;=n;++k) &#123; for (l=k;l&lt;=n;++l) &#123; ans=(ans+min(a[i][j],a[k][l]))%M; &#125; &#125; &#125; &#125; cout&lt;&lt;ans; return 0;&#125; $O(nlogn)$ 做法 warning：接下来的文章里“的”字嵌套情况非常严重，文字叙述比较繁杂，看不懂十分正常，建议看懂一小部分然后自己推。 考虑每个元素作为贡献的区间是哪些，为了把每个区间分给唯一的元素，规定一个区间的贡献是最小值里最靠左的（ e.g. 4 3 2 4 2 2 的贡献是 $3$ 号元素，即最左边的 $2$ ）。所以，可以利用栈在 $O(n)$ 的时间内预处理出每个元素作为贡献的区间的左端点和右端点的范围： 123456789101112131415161718192021222324252627for (i=1;i&lt;=n;++i)&#123; while (top&amp;&amp;a[sta[top]].w&gt;a[i].w) &#123; a[sta[top--]].r=i-1; &#125; sta[++top]=i;&#125;while (top)&#123; a[sta[top--]].r=n;&#125;for (i=n;i&gt;=1;--i)&#123; while (top&amp;&amp;a[sta[top]].w&gt;=a[i].w) &#123; a[sta[top--]].l=i+1; &#125; sta[++top]=i;&#125;while (top)&#123; a[sta[top--]].l=1;&#125; 每个元素作为贡献的区间就是 $[x,y] (l_i\le x\le i\le y\le r_i)$，每个元素作为贡献的区间数就是 $t_i=(i-l_i+1)\times(r_i-i+1)$ 。 然后，将元素按值从大到小排序，就能计算出区间数的后缀和 $suf[i]$，但一个元素的总贡献并不是 $t_i\times suf[i+1]$，因为这些区间可能与当前元素作为贡献的区间相交。 注意到，要想和当前元素作为贡献的区间相交，必须 $[x,y] (l_i\le x\le y\le r_i)$ ，而这样的区间除了当前元素作为贡献的区间，贡献都排在当前元素之后（值比当前元素大或值相等但位置靠后），所以这样的区间除了当前元素作为贡献的区间，都是我们要找的与当前元素作为贡献的区间相交的贡献更靠后的区间。 注：下面这段话中“相交的区间对”指（与当前元素作为贡献的区间相交的贡献更靠后的区间，当前元素作为贡献的区间）这样的一对区间；“相交的区间”指与当前元素作为贡献的区间相交的贡献更靠后的区间。 接下来就要计算相交的区间有多少对。首先，相交的区间不可能跨过当前元素，否则就是当前元素作为贡献的区间；所以，相交的区间要么是 $[x,y] (l_i\le x\le y&lt;i)$ ，要么是 $[x,y] (i&lt;x\le y\le r_i)$。先计算 $[x,y] (l_i\le x\le y&lt;i)$ 与当前元素作为贡献的区间相交的对数，先考虑 $y$ 固定时，个数为 $(r_i-i+1)\times(y-l_i+1)^2$ ，其中：$y-l_i+1$ 既是相交的区间左端点的个数，也是与相交的区间相交的当前元素作为贡献的区间的左端点的个数；$r_i-i+1$ 是与相交的区间相交的当前元素作为贡献的区间的右端点的个数。所以，总数是 $(r_i-i+1)\times\sum\limits_{y=l_i}^{i-1}(y-l_i+1)^2$ ，乘号右边是自然数平方和，可以用公式计算，所以就是 $(r_i-i+1)\times\frac{(i-l_i)\times(i-l_i+1)\times(2i-2l_i+1)}6$ 。$[x,y] (i&lt;x\le y\le r_i)$ 同理，总数为 $(i-l_i+1)\times\frac{(r_i-i)\times(r_i-i+1)\times(2r_i-2i+1)}6$ 。 所以，把相交的总对数减掉就可以了。 参考代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cctype&gt;#include &lt;algorithm&gt;using namespace std;int read()&#123; int out=0; char c; while (!isdigit(c=getchar())); for (;isdigit(c);c=getchar()) &#123; out=out*10+c-'0'; &#125; return out;&#125;const int N=200010;const int M=1000000007;const int SIX=166666668; //6模1e9+7的逆元struct Node&#123; long long id,w,l,r,t; bool operator&lt;(const Node&amp; b) const &#123; return w&lt;b.w; &#125;&#125; a[N];long long n,suf[N],sta[N],top,ans;int main()&#123; int i; n=read(); for (i=1;i&lt;=n;++i) &#123; a[i].w=read(); a[i].id=i; &#125; for (i=1;i&lt;=n;++i) &#123; while (top&amp;&amp;a[sta[top]].w&gt;a[i].w) &#123; a[sta[top--]].r=i-1; &#125; sta[++top]=i; &#125; while (top) &#123; a[sta[top--]].r=n; &#125; for (i=n;i&gt;=1;--i) &#123; while (top&amp;&amp;a[sta[top]].w&gt;=a[i].w) &#123; a[sta[top--]].l=i+1; &#125; sta[++top]=i; &#125; while (top) &#123; a[sta[top--]].l=1; &#125; for (i=1;i&lt;=n;++i) &#123; a[i].t=(i-a[i].l+1)*(a[i].r-i+1)%M; &#125; sort(a+1,a+n+1); for (i=n;i&gt;=1;--i) &#123; suf[i]=(suf[i+1]+a[i].t)%M; &#125; for (i=1;i&lt;=n;++i) &#123; ans=(ans+(a[i].w*suf[i+1]%M)*a[i].t)%M; ans=(ans-(a[i].id-a[i].l)*(a[i].id-a[i].l+1)%M*(2*a[i].id-2*a[i].l+1)%M*SIX%M*(a[i].r-a[i].id+1)%M*a[i].w%M+M)%M; //重复区间在左 ans=(ans-(a[i].r-a[i].id)*(a[i].r-a[i].id+1)%M*(2*a[i].r-2*a[i].id+1)%M*SIX%M*(a[i].id-a[i].l+1)%M*a[i].w%M+M)%M; //重复区间在右 &#125; cout&lt;&lt;ans; return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>noi.ac</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[树上背包的上下界优化]]></title>
    <url>%2F%E6%A0%91%E4%B8%8A%E8%83%8C%E5%8C%85%E7%9A%84%E4%B8%8A%E4%B8%8B%E7%95%8C%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[最近做了几道树上背包的题目，很多题目的数据范围都很小，但实际上树上背包有多种方式可以优化到 $O(nm)$ （$n$ 为节点数，$m$ 为体积的值域），比如先序遍历优化（何森《先序遍历用于优化树形背包问题》），求泛化物品的并（徐持衡《浅谈几类背包题》）……经过一番学习，觉得还是上下界优化理解起来最简单，也比较好写，适用范围广，唯一比其它做法复杂的地方就是复杂度分析。 例题讲解这里以一道经典的树上背包作为例题：【数据加强版】选课 直接把我出的数据加强版放上来了..反正题面里有原题链接QAQ 注：本文中用 $a_i$ 代指题面中的 $s_i$ 。 $O(nm^2)$ 做法用 $f_{u,i}$ 表示以 $u$ 为根的子树中选 $i$ 门课的最大得分，那么 $f_{u,i}=\min\limits_{\forall fa[v_j]=u,\sum k_j=i-1}(\sum f[v_j][k_j])+a_u$，而这个转移可以通过背包实现，依次合并每棵子树，每次合并时枚举 $i$ 和 $k_j$ ，$f_{u,i}=\max(f_{u,i},f_{u,i-k_j}+f_{v_j,k_j})$ 。 需要倒序枚举 $i$ 防止状态在转移前被覆盖。否则的话dp数组要多一维。 由于可能是森林，所有没有直接先修课的节点，父亲视为节点 $0$，实际上就要选 $m+1$ 个节点。 参考代码： 1234567891011121314151617void dfs(int u)&#123; f[u][1]=a[u]; int i,j,k,v; for (i=head[u];i;i=nxt[i]) &#123; v=to[i]; dfs(v); for (j=m+1;j&gt;=1;--j) &#123; for (k=1;k&lt;j;++k) &#123; f[u][j]=max(f[u][j],f[u][j-k]+f[v][k]); &#125; &#125; &#125;&#125; 上下界优化注意背包转移的这部分： 1234567for (j=m+1;j&gt;=1;--j)&#123; for (k=1;k&lt;j;++k) &#123; f[u][j]=max(f[u][j],f[u][k]+f[v][j-k]); &#125;&#125; 实际上，这里面有很多状态都是没有意义的： 转移时已经合并了大小之和为 $s$ 的一些子树，那么 $f_{u,i}(i&gt;s)$ 实际上是没有意义的。 $f_{v,i}(i&gt;siz[v])$ 也是没有意义的。 $f_{u,i}(i&gt;m)$ 是没有作用的。 所以，可以对 $j$ 和 $k$ 的枚举范围进行优化： 12345678910111213141516171819void dfs(int u)&#123; siz[u]=1; f[u][1]=a[u]; int i,j,k,v; for (i=head[u];i;i=nxt[i]) &#123; v=to[i]; dfs(v); for (j=min(m+1,siz[u]+siz[v]);j&gt;=1;--j) &#123; for (k=max(1,j-siz[u]);k&lt;=siz[v]&amp;&amp;k&lt;j;++k) &#123; f[u][j]=max(f[u][j],f[u][j-k]+f[v][k]); &#125; &#125; siz[u]+=siz[v]; &#125;&#125; 复杂度分析可以参考这篇博客。 形象的解释每个点对都只会在 $lca$ 处合并一次，所以总的复杂度是 $O(n^2)$ 的。 这个解释很简洁，需要自己意会一下.. 严格？证明令 $T_u$ 为处理子树 $u$ 的总用时，那么： $\begin{aligned}T_u&amp;=\left(\sum\limits_{\forall fa[v_i]=u}T_{v_i}\right)+t_u\\t_u&amp;=1+(1+siz[v_1])\times siz[v_1]+(1+siz[v_1]+siz[v_2])\times siz[v_2]+\cdots+siz[u]\times siz[v_k]\\&amp;=1+\sum\limits_{\forall fa[v_i]=u}siz[v_i]\times(siz[u]+1)\\&amp;=siz[u]^2\end{aligned}$ 对于叶子节点 $u$ ，$T(u)=1$ ，是 $O(siz[u]^2)$ 的。 对于儿子都是叶子节点的节点 $u$，由于平方和小于和平方，$\sum\limits_{\forall fa[v_i]=u}T_{v_i}$ 也是 $O(siz[u]^2)$ 的。 可以这样递归地说明，对于任意节点 $u$ ，$\sum\limits_{\forall fa[v_i]=u}T_{v_i}$ 都是 $O(siz[u]^2)$ 的。 又因为 $t(u)$ 是 $O(siz[u]^2)$ 的，$T(u)$ 就是 $O(siz[u]^2)$ 的。 所以解决整个问题就是 $O(n^2)$ 的。 严格！证明枚举过程中还要对 $m$ 取 min ，所以应该是这样的： $\begin{aligned}t_u&amp;=1+\min(m,1+siz[v_1])\times \min(m,siz[v_1])+\min(m,1+siz[v_1]+siz[v_2])\times \min(m,siz[v_2])+\cdots+\min(m,siz[u])\times \min(m,siz[v_k])\&amp;\le m\times siz[u]\end{aligned}$ 所以，$t(u)$ 是 $O(\min(siz[u],m)\times siz[u])$ 的。 对于 $siz[u]\le m$，$T(u)$ 是 $O(siz[u]^2)$ 的。 对于 $siz[u]&gt;m$，$\sum\limits_{\forall fa[v_i]=u,siz[v_i]\le m}T_{v_i}$ 是 $O\left(\left(\sum\limits_{\forall fa[v_i]=u,siz[v_i]\le m}siz[v_i]\right)^2\right)$ 的；$\sum\limits_{\forall fa[v_i]=u,siz[v_i]&gt;m}T_{v_i}$ 是 $O\left(m\times\sum\limits_{\forall fa[v_i]=u,siz[v_i]&gt;m}siz[v_i]\right)$ 的；所以，$T(u)$ 是 $O(m\times siz[u])$ 的。 所以，解决整个问题是 $O(nm)$ 的。 其它例题【数据加强版】道路重建 dl代码我出的那两道数据加强版略有些毒瘤..（$n\times m\le 10^8$） 大约需要这样写： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;void dfs(int u);void add(int u,int v);const int N=100010;int head[N],nxt[N],to[N],cnt;int n,m,a[N],f[100000010],siz[N];int main()&#123; int i,k; scanf("%d%d",&amp;n,&amp;m); for (i=1;i&lt;=n;++i) &#123; scanf("%d%d",&amp;k,a+i); add(k,i); &#125; dfs(0); printf("%d",f[m+1]); return 0;&#125;void add(int u,int v)&#123; nxt[++cnt]=head[u]; head[u]=cnt; to[cnt]=v;&#125;void dfs(int u)&#123; siz[u]=1; f[u*(m+2)+1]=a[u]; int i,j,k,v; for (i=head[u];i;i=nxt[i]) &#123; v=to[i]; dfs(v); for (j=min(m+1,siz[u]+siz[v]);j&gt;=1;--j) &#123; for (k=max(1,j-siz[u]);k&lt;=siz[v]&amp;&amp;k&lt;j;++k) &#123; f[u*(m+2)+j]=max(f[u*(m+2)+j],f[u*(m+2)+j-k]+f[v*(m+2)+k]); &#125; &#125; siz[u]+=siz[v]; &#125;&#125; 关于另一种 $O(nm)$ 做法一开始我在洛谷发了篇选课的题解，然后没过… 那篇题解 用的是求泛化物品的并（徐持衡《浅谈几类背包题》） 虽然说洛谷好像还没有上下界优化的题解..但最近好几篇题解没过审，都不太想在洛谷发题解了…]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>树形dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅谈邻项交换排序的应用以及需要注意的问题]]></title>
    <url>%2F%E6%B5%85%E8%B0%88%E9%82%BB%E9%A1%B9%E4%BA%A4%E6%8D%A2%E6%8E%92%E5%BA%8F%E7%9A%84%E5%BA%94%E7%94%A8%E4%BB%A5%E5%8F%8A%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[邻项交换排序是一种常见的贪心算法，通过比较两个相邻元素交换前后的优劣对整个序列进行排序，从而使得这个序列成为题目所求的最优解。然而，邻项交换排序的应用有一些需要注意的地方，稍有不慎便会成为一个错误的算法。 算法简介例题引入题目来源NOIP2012提高组D1T2 国王游戏 题目描述恰逢 $H$ 国国庆，国王邀请 $n$ 位大臣来玩一个有奖游戏。首先，他让每个大臣在左、右手上面分别写下一个整数，国王自己也在左、右手上各写一个整数。然后，让这 $n $位大臣排成一排，国王站在队伍的最前面。排好队后，所有的大臣都会获得国王奖赏的若干金币，每位大臣获得的金币数分别是：排在该大臣前面的所有人的左手上的数的乘积除以他自己右手上的数，然后向下取整得到的结果。 国王不希望某一个大臣获得特别多的奖赏，所以他想请你帮他重新安排一下队伍的顺序，使得获得奖赏最多的大臣，所获奖赏尽可能的少。注意，国王的位置始终在队伍的最前面。 输入格式第一行包含一个整数 $n$ ，表示大臣的人数。 第二行包含两个整数 $a$ 和 $b$ ，之间用一个空格隔开，分别表示国王左手和右手上的整数。 接下来 $n$ 行，每行包含两个整数 $a$ 和 $b$ ，之间用一个空格隔开，分别表示每个大臣左手和右手上的整数。 输出格式一个整数，表示重新排列后的队伍中获奖赏最多的大臣所获得的金币数。 数据范围对于 $20\%$ 的数据，有 $1\le n\le 10,0&lt;a,b&lt;8$； 对于 $40\%$ 的数据，有 $1\le n\le 20,0&lt;a,b&lt;8$； 对于 $60\%$ 的数据，有 $1\le n\le 100$； 对于 $60\%$ 的数据，保证答案不超过 $10^9$； 对于 $100\%$ 的数据，有 $1\le n\le 1000,0&lt;a,b&lt;10000$ 。 使用邻项交换排序解决问题选取相邻的两个大臣 $i$ 和 $j$ （$j$ 此时在 $i$ 后一个），分别用 $a_i,b_i,a_j,b_j$ 表示这两位大臣左手上和右手上的数字，设这两位大臣前面的所有大臣左手上的数乘积为 $k$ 。 此时，若调整这两名大臣的顺序，对前面和后面的大臣都不会造成影响，因此我们只要使得这两位大臣中获得较多奖赏的那位获得的奖赏尽量少即可。 当 $i$ 在前 $j$ 在后时，这个值为 $\max(\frac k{b_i},\frac {k a_i}{b_j})$ 。 当 $j$ 在前 $i$ 在后时，这个值为 $\max(\frac k{b_j},\frac {k a_j}{b_i})$ 。 因此，若 $\max(\frac k{b_i},\frac {k a_i}{b_j})&gt;\max(\frac k{b_j},\frac {k a_j}{b_i})$ ，就需要交换 $i$ 和 $j$ 。 实际上，由于 $\frac {k a_i}{b_j}\ge\frac k{b_j},\frac {k a_j}{b_i}\ge\frac k{b_i}$ ，只需比较 $\frac {k a_i}{b_j}$ 和 $\frac {k a_j}{b_i}$ ，也就只需比较 $\frac {a_i}{b_j}$ 和 $\frac {a_j}{b_i}$ ，即：若 $a_i b_i&gt;a_j b_j$，就要交换 $i$ 和 $j$ 。 1234567891011121314151617181920212223242526272829303132333435#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N=1010;struct Node&#123; int a,b; bool operator&lt;(Node&amp; y) &#123; return a*b&lt;y.a*y.b; &#125;&#125; dc[N];long long n,ans,k;int main()&#123; cin&gt;&gt;n; for (int i=0;i&lt;=n;++i) &#123; cin&gt;&gt;dc[i].a&gt;&gt;dc[i].b; &#125; sort(dc+1,dc+n+1); k=dc[0].a; for (int i=1;i&lt;=n;++i) &#123; ans=max(ans,k/dc[i].b); k*=dc[i].a; &#125; cout&lt;&lt;ans; return 0;&#125; 使用以上代码即可得到60分，而AC此题需要使用高精度乘除法，不在本文讨论范围内。 使用邻项交换排序需要注意的问题另一道例题题目来源洛谷P2123 皇后游戏 题目描述皇后有 $n$ 位大臣，每位大臣的左右手上面分别写上了一个正整数。恰逢国庆节来临，皇后决定为 $n$ 位大臣颁发奖金，其中第 $i$ 位大臣所获得的奖金数目为第 $i－1$ 位大臣所获得奖金数目与前 $i$ 位大臣左手上的数的和的较大值再加上第 $i$ 位大臣右手上的数。 形式化地讲：我们设第 $i$ 位大臣左手上的正整数为 $a_i$ ，右手上的正整数为 $b_i$ ， 则第 $i$ 位大臣获得的奖金数目为 $c_i$ 可以表达为： $$c_i=\begin{cases}a_1+b_1 &amp; i=1\\\max(c_{i-1},\sum\limits_{j=1}^ia_j)+b_i &amp; 2\le i\le n\end{cases}$$ 当然，吝啬的皇后并不希望太多的奖金被发给大臣，所以她想请你来重新安排一下队伍的顺序，使得获得奖金最多的大臣，所获奖金数目尽可能的少。 注意：重新安排队伍并不意味着一定要打乱顺序，我们允许不改变任何一位大臣的位置。 输入格式第一行包含一个正整数 $T$ ，表示测试数据的组数。 接下来 $T$ 个部分，每个部分的第一行包含一个正整数 $n$ ，表示大臣的数目。 每个部分接下来 $n$ 行中，每行两个正整数，分别为 $a_i$ 和 $b_i$ ，含义如上文所述。 输出格式共 $T$ 行，每行包含一个整数，表示获得奖金最多的大臣所获得的奖金数目。 数据范围对于全部测试数据满足：$T\le10,1\le n\le20000,1\le a_i,b_i\le10^9$ 。 尝试用邻项交换排序解决问题还是选取相邻的两个大臣 $i$ 和 $j$ （$j$ 此时在 $i$ 后一个），交换 $i$ 和 $j$ 对前面的大臣无影响，对后面的大臣的影响在于排在后面的那个大臣获得的奖金，需要使之尽量小。 设这两个大臣前面的所有大臣左手上的数之和为 $\rm sum$ ，这两个大臣的再往前一个大臣得到的奖金是 $\rm pre$ 。 当 $i$ 在前 $j$ 在后时，这个值为 $\max(\max(\mathrm{pre},\mathrm{sum}+a_i)+b_i,\mathrm{sum}+a_i+a_j)+b_j$ 。 当 $j$ 在前 $i$ 在后时，这个值为 $\max(\max(\mathrm{pre},\mathrm{sum}+a_j)+b_j,\mathrm{sum}+a_j+a_i)+b_i$ 。 由于 $\max(x,y)+z=\max(x+z,y+z)$ ，需要比较的就是 $\max(\mathrm{pre}+b_i+b_j,\mathrm{sum}+a_i+b_i+b_j,\mathrm{sum}+a_i+a_j+b_j)$ 和 $\max(\mathrm{pre}+b_j+b_i,\mathrm{sum}+a_j+b_j+b_i,\mathrm{sum}+a_j+a_i+b_i)$ ，其中 $\mathrm{pre}+b_i+b_j=\mathrm{pre}+b_j+b_i$ ，需要比较的就是 $\max(\mathrm{sum}+a_i+b_i+b_j,\mathrm{sum}+a_i+a_j+b_j)$ 和 $\max(\mathrm{sum}+a_j+b_j+b_i,\mathrm{sum}+a_j+a_i+b_i)$ ，再用 $\mathrm{sum}+a_i+b_i+a_j+b_j$ 减去两边并变号，即：当 $\min(a_i,b_j)&gt;\min(a_j,b_i)$ 时，需要交换 $i$ 和 $j$。 于是，可以写出以下代码，并在洛谷上AC此题： 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N=20010;struct Node&#123; int a,b; bool operator&lt;(Node&amp; y) &#123; return min(a,y.b)&lt;min(b,y.a); &#125;&#125; dc[N];long long ans,sum,t,n;int main()&#123; cin&gt;&gt;t; while (t--) &#123; cin&gt;&gt;n; for (int i=1;i&lt;=n;++i) &#123; cin&gt;&gt;dc[i].a&gt;&gt;dc[i].b; &#125; sort(dc+1,dc+n+1); ans=sum=0; for (int i=1;i&lt;=n;++i) &#123; sum+=dc[i].a; ans=max(ans,sum)+dc[i].b; &#125; cout&lt;&lt;ans&lt;&lt;endl; &#125; return 0;&#125; hack数据事实上，上面的做法是错误的，无法通过下面这组数据： 1234567891011241 11 13 52 741 13 51 12 7 这两组数据只有大臣给出的顺序不同，但上面的代码输出为： 121617 输出中间结果，可以发现，排列后的最终结果分别为： 12341 11 12 73 5 和 12341 13 51 12 7 这两种排列方式都满足 $\forall i\in [1,n),\min(a_i,b_{i+1})\le\min(a_{i+1},b_i)$，但第二种方式并不是最优解。具体原因将在下文分析。 严格弱序严格弱序简介要知道为什么这种做法是错误的，首先需要了解严格弱序（strict weak ordering）。 对于一个比较运算符（用“$&lt;$”表示此运算符，用“$\not&lt;$”表示不满足此运算符），若满足以下四个条件，则称其是满足严格弱序的： $x\not&lt;x$ （非自反性） 若 $x&lt;y$，则 $y\not&lt;x$ （非对称性） 若 $x&lt;y,y&lt;z$，则 $x&lt;z$ （传递性） 若 $x\not&lt;y,y\not&lt;x,y\not&lt;z,z\not&lt;y$，则 $x\not&lt;z,z\not&lt;x$ （不可比性的传递性） 而 C++ 标准库要求用于排序的运算符必须满足严格弱序： It has to be antisymmetric. This means that for operator $&lt;$: If $x &lt; y$ is true, then $y &lt; x$ is false. This means that for a predicate op(): If op(x,y) is true, then op(y,x) is false. It has to be transitive. This means that for operator $&lt;$: If $x &lt; y$ is true and $y &lt; z$ is true, then $x &lt; z$ is true. This means that for a predicate op(): If op(x,y) is true and op(y,z) is true, then op(x,z) is true. It has to be irreflexive. This means that for operator $&lt;$: $x &lt; x$ is always false. This means that for a predicate op(): op(x,x) is always false. It has to have transitivity of equivalence, which means roughly: If a is equivalent to b and b is equivalent to c, then a is equivalent to c. This means that for operator $&lt;$: If $!(a&lt;b) \&amp;\&amp; !(b&lt;a)$ is true and $!(b&lt;c) \&amp;\&amp; !(c&lt;b)$ is true then $!(a&lt;c) \&amp;\&amp; !(c&lt;a)$ is true. This means that for a predicate op(): If op(a,b), op(b,a), op(b,c), and op(c,b) all yield false, then op(a,c) and op(c,a) yield false. 上述做法的判断条件满足传递性，但不满足不可比性的传递性。 满足传递性的证明命题：$\forall \begin{cases}\min(a_i,b_j)&lt;\min(a_j,b_i)\\\min(a_j,b_k)&lt;\min(a_k,b_j)\end{cases}$，有 $\min(a_i,b_k)&lt;\min(a_k,b_i)$。 将上式拆解成逻辑式，即证： $\forall \begin{cases}\,(a_i&lt;a_j\lor b_j&lt;a_j)\land(a_i&lt;b_i\lor b_j&lt;b_i) \\\,(a_j&lt;a_k\lor b_k&lt;a_k)\land(a_j&lt;b_j\lor b_k&lt;b_j)\end{cases}$，有 $(a_i&lt;a_k\lor b_k&lt;a_k)\land(a_i&lt;b_i\lor b_k&lt;b_i)$。 假设原命题不成立，即 $\exists\begin{cases}\,(a_i&lt;a_j\lor b_j&lt;a_j)\land(a_i&lt;b_i\lor b_j&lt;b_i)&amp;(1) \\\,(a_j&lt;a_k\lor b_k&lt;a_k)\land(a_j&lt;b_j\lor b_k&lt;b_j)&amp;(2) \\\,(a_i\ge a_k\land b_k\ge a_k)\lor(a_i\ge b_i\land b_k\ge b_i)&amp;(3)\end{cases}$ 分别讨论 $(3)$ 式成立的两种情况： 若 $a_i\ge a_k\land b_k\ge a_k$，由 $(2)$ 式得 $a_j&lt;a_k$，进而推出 $a_j&lt;a_i$，再由 $(1)$ 式得 $b_j&lt;a_j$，再由 $(2)$ 式得到 $b_k&lt;b_j$，所以 $b_k&lt;b_j&lt;a_j&lt;a_k$，与 $b_k\ge a_k$ 矛盾，不成立。 若 $a_i\ge b_i\land b_k\ge b_i$，与上面类似，由 $(1)$ 式得 $b_j&lt;b_i$，进而推出 $b_j&lt;b_k$，再由 $(2)$ 式得到 $a_j&lt;b_j$，再由 $(1)$ 式得到 $a_i&lt;a_j$，所以 $a_i&lt;a_j&lt;b_j&lt;b_i$，与 $a_i\ge b_i$ 矛盾，不成立。 综上所述，假设不成立。 所以，$P_{i,j}=\min(a_i,b_j)&lt;\min(a_j,b_i)$ 具有传递性。 不具有不可比性的传递性的证明命题：$\forall \begin{cases}\min(a_i,b_j)=\min(a_j,b_i)\\\min(a_j,b_k)=\min(a_k,b_j)\end{cases}$，有 $\min(a_i,b_k)=\min(a_k,b_i)$。 很明显，当 $a_j=b_j$ 且都很小时存在反例，如： $$\begin{array}{c|c|c}&amp;a&amp;b\\i&amp;3&amp;5\\j&amp;1&amp;1\\k&amp;2&amp;7\end{array}$$ $\begin{cases}\min(3,1)=\min(1,5)\\\min(1,7)=\min(2,1)\end{cases}$，但 $\min(3,7)\ne \min(2,5)$。 这样的反例还有很多，所以，$P_{i,j}=\min(a_i,b_j)&lt;\min(a_j,b_i)$ 不具有不可比性的传递性。 为何会错简单地说，$P_{i,j}=\min(a_i,b_j)&lt;\min(a_j,b_i)$ 不满足严格弱序，不能作为 std::sort 的比较函数。 究其原因，“不具有不可比性的传递性”意味着：将序列中若干个不可比的相邻元素对（在这种比较方式下即 $\min(a_i,b_{i+1})=\min(a_{i+1},b_i)$ 的 $i$ 和 $i+1$）互换后，可能会出现前面的元素“大于”后面的元素（在这种比较方式下即出现 $\min(a_i,b_{i+1})&gt;\min(a_{i+1},b_i)$），从而使得原先的排列方式不是最优的。 正确解法更加完善的贪心解法比较相邻两项时，若 $\min(a_i,b_j)=\min(a_j,b_i)$ ，从全局来看，由于 $a$ 的前缀和对答案有一定的影响，把 $a$ 更小的放前面是更优的。从而可以得到这样一个解法： 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N=20010;struct Node&#123; int a,b; bool operator&lt;(Node&amp; y) &#123; return min(a,y.b)==min(b,y.a)?a&lt;y.a:min(a,y.b)&lt;min(b,y.a); &#125;&#125; dc[N];long long ans,sum,t,n;int main()&#123; cin&gt;&gt;t; while (t--) &#123; cin&gt;&gt;n; for (int i=1;i&lt;=n;++i) &#123; cin&gt;&gt;dc[i].a&gt;&gt;dc[i].b; &#125; sort(dc+1,dc+n+1); ans=sum=0; for (int i=1;i&lt;=n;++i) &#123; sum+=dc[i].a; ans=max(ans,sum)+dc[i].b; &#125; cout&lt;&lt;ans&lt;&lt;endl; &#125; return 0;&#125; 这个解法的正确性将在下文证明。 一个解法是否正确的判断方式由上文的讨论可以得知，一个排序方式 $P_{i,j}$ 要是正解，需要满足两个条件： 满足严格弱序。 $\forall P_{i,j}=true$，$\min(a_i,b_j)\le\min(a_j,b_i)$ 。 即，可以作为比较函数，且排序完成后任意交换相邻元素均不会使答案更优。 从而可以写出下面的正解判断器： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;bool cmp(int i,int j);int a[10],b[10];int main()&#123; for (a[0]=1;a[0]&lt;=6;++a[0]) &#123; for (b[0]=1;b[0]&lt;=6;++b[0]) &#123; if (cmp(0,0)) &#123; printf("No irreflexivity:%d %d\n",a[0],b[0]); &#125; for (a[1]=1;a[1]&lt;=6;++a[1]) &#123; for (b[1]=1;b[1]&lt;=6;++b[1]) &#123; if (cmp(0,1)&amp;&amp;min(a[0],b[1])&gt;min(a[1],b[0])) &#123; printf("Not the best:%d %d %d %d\n",a[0],b[0],a[1],b[1]); &#125; for (a[2]=1;a[2]&lt;=6;++a[2]) &#123; for (b[2]=1;b[2]&lt;=6;++b[2]) &#123; if (cmp(0,1)&amp;&amp;cmp(1,2)&amp;&amp;!cmp(0,2)) &#123; printf("No transitivity:%d %d %d %d %d %d\n",a[0],b[0],a[1],b[1],a[2],b[2]); &#125; if (!cmp(0,1)&amp;&amp;!cmp(1,0)&amp;&amp;!cmp(1,2)&amp;&amp;!cmp(2,1)&amp;&amp;(cmp(0,2)||cmp(2,0))) &#123; printf("No transitivity of incomparability:%d %d %d %d %d %d\n",a[0],b[0],a[1],b[1],a[2],b[2]); &#125; &#125; &#125; &#125; &#125; &#125; &#125; return 0;&#125;bool cmp(int i,int j)&#123; return min(a[i],b[j])==min(a[j],b[i])?a[i]&lt;a[j]:min(a[i],b[j])&lt;min(a[j],b[i]);&#125; 运行程序，没有任何输出，说明上文所述的排序方式是一个正解。 用其它排序方式替换 cmp，若没有任何输出即可作为本题的正确排序方式。 下面是几种排序方式的例子： 1234bool cmp(int i,int j)&#123; return min(a[i],b[j])==min(a[j],b[i])?b[i]&gt;b[j]:min(a[i],b[j])&lt;min(a[j],b[i]);&#125; 输出为空，是正解。 1234bool cmp(int i,int j)&#123; return min(a[i],b[j])&lt;min(a[j],b[i]);&#125; 共输出1694行，前10行如下： 12345678910No transitivity of incomparability:1 2 1 1 2 1No transitivity of incomparability:1 2 1 1 2 2No transitivity of incomparability:1 2 1 1 2 3No transitivity of incomparability:1 2 1 1 2 4No transitivity of incomparability:1 2 1 1 2 5No transitivity of incomparability:1 2 1 1 2 6No transitivity of incomparability:1 2 1 1 3 1No transitivity of incomparability:1 2 1 1 3 2No transitivity of incomparability:1 2 1 1 3 3No transitivity of incomparability:1 2 1 1 3 4 1234bool cmp(int i,int j)&#123; return min(a[i],b[j])==min(a[j],b[i])?a[i]&gt;a[j]:min(a[i],b[j])&lt;min(a[j],b[i]);&#125; 共输出280行，前10行如下： 12345678910No transitivity:1 2 2 1 1 1No transitivity:1 2 2 2 1 1No transitivity:1 2 2 3 1 1No transitivity:1 2 2 4 1 1No transitivity:1 2 2 5 1 1No transitivity:1 2 2 6 1 1No transitivity:1 2 3 1 1 1No transitivity:1 2 3 2 1 1No transitivity:1 2 3 3 1 1No transitivity:1 2 3 4 1 1 1234bool cmp(int i,int j)&#123; return min(a[i],b[j])&lt;=min(a[j],b[i]);&#125; 共输出883行，前10行如下： 12345678910No irreflexivity:1 1No irreflexivity:1 2No irreflexivity:1 3No irreflexivity:1 4No irreflexivity:1 5No irreflexivity:1 6No irreflexivity:2 1No transitivity:2 1 1 1 1 2No transitivity:2 1 1 1 1 3No transitivity:2 1 1 1 1 4 总结在可以通过比较相邻两项得出交换或不交换一定不会更差时，可以通过邻项交换排序的方式来得到最优解。 邻项交换排序的比较函数需要满足严格弱序，并且排序完成后任意交换相邻元素都不会更优。 使用这种算法时，一定要注意以上两点，才能得到真正正确的算法。 最后再把我去雅礼集训的时候水题选讲的 slide 放上来好了..（还附赠一道由乃题）]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>贪心</tag>
        <tag>序理论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NOIp2018提高组游记]]></title>
    <url>%2FNOIp2018%E6%8F%90%E9%AB%98%E7%BB%84%E6%B8%B8%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[Day1T1 积木大赛NOIp2013D2T1…..看到的时候我还以为我记错了，以为原题是一次可以随便加，这题只能加一，出考场后查了下发现一模一样。 12345678910111213141516171819202122232425262728#include &lt;iostream&gt;#include &lt;cstdio&gt;using namespace std;const int N=100010;int n,d[N],ans;int main()&#123; int i; scanf("%d",&amp;n); for (i=1;i&lt;=n;++i) &#123; scanf("%d",d+i); if (d[i]&gt;d[i-1]) &#123; ans+=d[i]-d[i-1]; &#125; &#125; cout&lt;&lt;ans; return 0;&#125; T2 货币系统去掉可以由其它货币拼成的货币，这个结论倒是很快猜到了。但由于xkdyh留下的阴影，一开始我还写了个exgcd…幸好大样例比较良心，有一组数据是三种货币拼成另一种。然后再仔细一看，发现是个完全背包… 简单证明一下： 结论：对于一个没有任何一种货币可以由系统内其它货币拼成的货币系统 $(n,A)$，与其等价的货币系统 $(m,B)$ 只能是 $(n,A)$ 自身或者加上一些能由 $(n,A)$ 表示的数。 若 $A\not\subseteq B$，任取 $t\in (A-B)$，那么在 $B$ 中必然有一些元素能够拼成 $t$，而这些元素在 $A$ 中必然有不能表示的（否则与 $A$ 中没有任何一种货币可以由系统内其它货币拼成矛盾），而存在 $(m,B)$ 能表示而 $(n,A)$ 不能表示的数与 $(n,A),(m,B)$ 等价矛盾，不成立。 若 $B$ 中有 $(n,A)$ 所不能表示的元素，依然与 $(n,A),(m,B)$ 等价矛盾，不成立。 所以命题得证。 排个序然后完全背包去掉能被系统内其它货币表示的货币即可。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;int t,n,a[110],maxx;bool f[25010];int main()&#123; int i,j,ans; scanf("%d",&amp;t); while (t--) &#123; scanf("%d",&amp;n); ans=n; maxx=0; for (i=1;i&lt;=n;++i) &#123; scanf("%d",a+i); maxx=max(maxx,a[i]); &#125; sort(a+1,a+n+1); memset(f,false,sizeof(f)); f[0]=true; for (i=1;i&lt;=n;++i) &#123; if (f[a[i]]) &#123; --ans; continue; &#125; for (j=0;j+a[i]&lt;=maxx;++j) &#123; if (f[j]) &#123; f[j+a[i]]=true; &#125; &#125; &#125; printf("%d\n",ans); &#125; return 0;&#125; T3 赛道修建看到这题就想起了ylh当时跟我一个房间的时候切掉的 CF div.2 E，但赛后发现不一样… 出考场得知dew、ylh都切掉了这题，然而我只写了直径、链和菊花图的 $55$ 分…凉凉凉 Day2T1 旅行一开始看错题了，以为是最小字典序生成树，还在想为什么 $m$ 这么小..然后仔细一看题，发现一条边只能回溯时重复经过，也就是最后得到的序列只能是个dfs序…数据范围很小，所以就枚举断边写了个 $O(n^2)$ 的，预处理边排序。然后出考场听一堆dalao在那说各种 $O(nlogn)$，$O(n)$ 做法…都不会QAQ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;using namespace std;const int N=5010;void dfs(int u);int n,m,cut,a[N][N],tot,e[N][2];bool vis[N],used[N]; //used用于对m个字典序取min，若used[i]=true说明断开第 i 条边时一定不是答案vector&lt;int&gt; g[N];int main()&#123; int i,j,u,v,minn; scanf("%d%d",&amp;n,&amp;m); for (i=0;i&lt;m;++i) &#123; scanf("%d%d",&amp;u,&amp;v); e[i][0]=u; e[i][1]=v; g[u].push_back(v); g[v].push_back(u); &#125; for (i=1;i&lt;=n;++i) &#123; sort(g[i].begin(),g[i].end()); &#125; if (n==m) &#123; for (cut=0;cut&lt;m;++cut) &#123; memset(vis,false,sizeof(vis)); tot=0; dfs(1); if (tot&lt;n) &#123; used[cut]=true; &#125; &#125; for (i=1;i&lt;=n;++i) &#123; minn=n; for (j=0;j&lt;m;++j) &#123; if (!used[j]&amp;&amp;a[j][i]&lt;minn) &#123; minn=a[j][i]; &#125; &#125; for (j=0;j&lt;m;++j) &#123; if (a[j][i]&gt;minn) &#123; used[j]=true; &#125; &#125; printf("%d",minn); if (i&lt;n) &#123; putchar(' '); &#125; &#125; &#125; else &#123; cut=m; dfs(1); for (i=1;i&lt;=n;++i) &#123; printf("%d",a[m][i]); if (i&lt;n) &#123; putchar(' '); &#125; &#125; &#125; return 0;&#125;void dfs(int u)&#123; if (vis[u]) &#123; return; &#125; vis[u]=true; a[cut][++tot]=u; int v,i; for (i=0;i&lt;g[u].size();++i) &#123; v=g[u][i]; if ((u!=e[cut][0]||v!=e[cut][1])&amp;&amp;(u!=e[cut][1]||v!=e[cut][0])) &#123; dfs(v); &#125; &#125;&#125; T2 填数游戏要是数据范围给到 $10^9$ 我就不会在考场上推半天了…一开始想了好久怎么 $O(nm)$ dp，虽然没想出来怎么做，但发现了暴力怎么写：一种方案合法等价于：对于每个点，它右边的点先往下再往右的路径小于它下面的点先往右再往下的路径。因为这两条路径分别是一个点向右走后最大的路径和向下走后最小的路径。然后打了个表，发现 $(n,m)=(n,n+1)\times 3^{m-n-1} (n\ge 2,m\ge n+1)$。于是开始跑 $(8,9)$ ，跑到11:50 还没跑出来…幸好发现了 $(n,n)$ 和 $(n,n+1)$ 之间也有一定的规律，把 $(8,9)$ 算出来了… 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;const long long Ans[9][10]=&#123;&#123;0,0,0,0,0,0,0,0,0,0&#125;, &#123;0,0,0,0,0,0,0,0,0,0&#125;, &#123;0,4,12,36,0,0,0,0,0,0&#125;, &#123;0,8,36,112,336,0,0,0,0,0&#125;, &#123;0,16,108,336,912,2688,0,0,0,0&#125;, &#123;0,32,324,1008,2688,7136,21312,0,0,0&#125;, &#123;0,64,972,3024,8064,21312,56768,170112,0,0&#125;, &#123;0,128,2916,9072,24192,63936,170112,453504,1360128,0&#125;, &#123;0,256,8748,27216,72576,191808,510336,1360128,3626752,10879488&#125;&#125;; //其实有一部分表是不必要（没有意义）的...const long long M=1000000007;long long n,m,ans=1;int main()&#123; int i; cin&gt;&gt;n&gt;&gt;m; if (n&gt;m) &#123; swap(n,m); &#125; if (n==1) &#123; for (i=30;i&gt;=0;--i) &#123; ans=ans*ans%M; if (m&amp;(1&lt;&lt;i)) &#123; ans=ans*2%M; &#125; &#125; cout&lt;&lt;ans; &#125; else &#123; if (m&lt;=n+1) &#123; cout&lt;&lt;Ans[n][m]; return 0; &#125; else &#123; for (i=30;i&gt;=0;--i) &#123; ans=ans*ans%M; if ((m-n-1)&amp;(1&lt;&lt;i)) &#123; ans=ans*3%M; &#125; &#125; cout&lt;&lt;ans*Ans[n][n+1]%M; &#125; &#125; return 0;&#125; T3 保卫王国据说是ddp…考场上先10min写了44分（一开始还以为是55分Orz），然后看了下，觉得B1挺可写的，更新向上的链貌似就可以了，但最后没调出来.. Day7上（tui）了一个星期的whk..个鬼啊，三天在考期中，就上了两天whk。感觉从零开始的whk没有想象中那么恐怖… 一周不让去机房，一到家就在洛谷上测了一下公布的代码.其它题都和预估的一样，D2T1可能会被卡常，洛谷上开了O2最慢点 $0.9s$ ，而且不用vector好像也过不了，不知道是不是洛谷上内存开小了的原因… D1T3大众AC题我爆菊（花图）了… 幸好菊花图的数据分治放在了最后面，还有 $40$ 分。发现自己傻了，不知道为什么会认为只有最短的两条边可以拼在一起，其它边都只能自成一条道……. 听说D2T3不用ddp，还是我太菜了… 估分：$100+100+40+88/100+100+44=472/484$ Day10GGF咕咕咕，然而我把两个T3写了一下.. D1T3真的好简单…二分答案，check的时候dfs处理每棵子树并返回块数最多时最大剩余，具体就是把子树返回值排个序，双指针配对得到最多块数，然后从最后一个配对的左指针开始往前这么多个依次配对，最后看剩下的没配对的里面最大的是多少。（第二天换成CCF数据发现做法挂了）处理子树的时候二分返回值不影响复杂度但能保证正确性。 D2T3做法挺有趣的..倍增题做少了，估计做多了就比较套路了…预处理出 $f[u][1],f[u][0],g[u][1],g[u][0]$，分别代表选/不选 $u$ 时 子树 $u$ 答案，选/不选 $u$ 时 $u$ 往上（整颗树减去子树 $u$）的答案。倍增处理出祖先 $fa[u][i]$ 表示 $u$ 的 $2^i$ 祖先，用 $bz[u][i][0/1][0/1]$ 表示子树 $fa[u][i]$ 除去子树 $u$ ，其中 $u$ 选/不选，$fa[u][i]$ 选/不选的答案，可以在dfs预处理 f 和 g 的同时算出 $bz[u][0][0/1][0/1]$ ，然后 $bz[u][i][a][b]=\min(bz[u][i-1][a][0]+bz[fa[u][i-1]][i-1][0][b],bz[u][i-1][a][1]+bz[fa[u][i-1]][i-1][1][b])$ 。计算答案的时候如果是祖先关系直接倍增计算链上答案，再加上子树的 f 和 祖先上方的 g；否则倍增到 $lca$ 计算路径上的答案，两棵子树以及 $lca$ 上方的答案就是对应的 $f$ 和 $g$ 。然后写到 $22:15$，交上去 $68$ 分，回寝室…ab相邻的 $16$ 分真的好简单，不用倍增，考场上应该写出来的… Day11刚到学校听说自己 $480$ ，还在想8700k这么强，能把我的 travel 卡成 $96$ … 中午一看是 $489$，数据真有趣…D1T3 隔壁原 $95$ 变成 $80$，我昨天A的变成 $90$ 了，考场写的还骗到了 $5$ 分（$45$）…8700k天下第一！ Day25咕咕咕咕咕，$\mathrm{CN}\ 329$。]]></content>
      <categories>
        <category>游记</category>
      </categories>
      <tags>
        <tag>CCF系列赛事</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二维莫队解题报告]]></title>
    <url>%2F%E4%BA%8C%E7%BB%B4%E8%8E%AB%E9%98%9F%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%2F</url>
    <content type="text"><![CDATA[我写的莫队教程 其实这是一道bzoj上的题（bzoj2639，貌似是权限题，反正我看不了），在YALI做模拟赛的时候遇到了. 然后在网上查到了几篇关于这道题的博客，都和我的做法略有不同… 题目大意给你一个 $r*c$ 的矩阵，每个点有一个颜色， $m$ 个询问，每次询问一个子矩阵内，每种颜色出现次数的平方和。 $r,c\le 200,m\le 100000$ 做法简述首先我们要明白，莫队究竟在干什么。 莫队其实就是几个指针在那跳来跳去，每跳一步都需要一定的时间，通过对询问排序使得指针跳的总次数尽量小。 所以，这题中询问为 $(x_1,y_1,x_2,y_2)$ ，也就是四个指针在那跳，分别分块再排序就可以了，即： 123456789//为避免和cmath库中的y0y1重名，下文中代码内的x1,y1,x2,y2都用x,y,xx,yy代替struct Query&#123; int x,y,xx,yy,id; bool operator&lt;(Query&amp; b) &#123; return x/B==b.x/B?(y/B==b.y/B?(xx/B==b.xx/B?yy&lt;b.yy:xx&lt;b.xx):y&lt;b.y):x&lt;b.x; //B为分块大小 &#125;&#125; q[M]; 答案更新一般的莫队都是 $O(1)$ 更新答案的，然而这题是 $O(n)$ （用 $n$ 代表 $r,c$ ） 更新。 移动指针的时候，把一排一起修改。 需要注意的是，8个while的顺序如果排列不当在某些情况下会导致答案出错，所以最好是将所有add都放在del前面（实际上有多种排列顺序都可以在不进行“反操作”的情况下保证答案正确，所有add放在del前面只是其中一种），或者是对“反区间”进行“反操作”。 所谓“反区间”，如：修改 $x_1$ 指针时，本应进行add操作，而此时$y_1&gt;y_2+1$，那么就要将 $(y_2,y_1)$ 这个开区间内的所有点进行del。 while的排列顺序得当可以使“反区间”不可能出现。 “反操作”参考代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697while (x&lt;q[i].x)&#123; for (j=y;j&lt;=yy;++j) &#123; del(a[x][j]); &#125; for (j=yy+1;j&lt;y;++j) &#123; add(a[x][j]); &#125; ++x;&#125;while (y&lt;q[i].y)&#123; for (j=x;j&lt;=xx;++j) &#123; del(a[j][y]); &#125; for (j=xx+1;j&lt;x;++j) &#123; add(a[j][y]); &#125; ++y;&#125;while (xx&gt;q[i].xx)&#123; for (j=y;j&lt;=yy;++j) &#123; del(a[xx][j]); &#125; for (j=yy+1;j&lt;y;++j) &#123; add(a[xx][j]); &#125; --xx;&#125;while (yy&gt;q[i].yy)&#123; for (j=x;j&lt;=xx;++j) &#123; del(a[j][yy]); &#125; for (j=xx+1;j&lt;x;++j) &#123; add(a[j][yy]); &#125; --yy;&#125;while (x&gt;q[i].x)&#123; --x; for (j=y;j&lt;=yy;++j) &#123; add(a[x][j]); &#125; for (j=yy+1;j&lt;y;++j) &#123; del(a[x][j]); &#125;&#125;while (y&gt;q[i].y)&#123; --y; for (j=x;j&lt;=xx;++j) &#123; add(a[j][y]); &#125; for (j=xx+1;j&lt;x;++j) &#123; del(a[j][y]); &#125;&#125;while (xx&lt;q[i].xx)&#123; ++xx; for (j=y;j&lt;=yy;++j) &#123; add(a[xx][j]); &#125; for (j=yy+1;j&lt;y;++j) &#123; del(a[xx][j]); &#125;&#125;while (yy&lt;q[i].yy)&#123; ++yy; for (j=x;j&lt;=xx;++j) &#123; add(a[j][yy]); &#125; for (j=xx+1;j&lt;x;++j) &#123; del(a[j][yy]); &#125;&#125;out[q[i].id]=ans; 分块大小具体计算清楚非常复杂，这里只是估算一下. $x_1$ 指针的移动次数为 $O(mB)$，$y_2$ 指针的移动次数渐进复杂度中含有 $O\left(\frac{n^4}{B^3}\right)$，取 $mB=\frac{n^4}{B^3}$，得到 $B=nm^{-\frac{1}{4}}$ 总时间复杂度为 $O(mlogm+n^2m^{\frac{3}{4}})$ 反正这样的分块大小实测比 $\sqrt{n}$ 优秀…有兴趣的话可以严谨地算一算（如果发现我这个估算有问题可以直接在这篇博客下评论） 初始子矩阵任意一个空矩阵就可以了，如 $x_1=y_1=1,x_2=y_2=0$ 参考代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;const int N=210;const int M=100010;void add(int x);void del(int x);int r,c,m,B,a[N][N],lsh[N*N],tot,cnt[N*N],ans,out[M];struct Query&#123; int x,y,xx,yy,id; bool operator&lt;(Query&amp; b) &#123; return x/B==b.x/B?(y/B==b.y/B?(xx/B==b.xx/B?yy&lt;b.yy:xx&lt;b.xx):y&lt;b.y):x&lt;b.x; &#125;&#125; q[M];int main()&#123; int i,j,x=1,y=1,xx=0,yy=0; cin&gt;&gt;r&gt;&gt;c&gt;&gt;m; B=pow(r*c,0.5)/pow(m,0.25)+1.0; for (i=1;i&lt;=r;++i) &#123; for (j=1;j&lt;=c;++j) &#123; cin&gt;&gt;a[i][j]; lsh[tot++]=a[i][j]; //这题要离散化 &#125; &#125; sort(lsh,lsh+tot); tot=unique(lsh,lsh+tot)-lsh; for (i=1;i&lt;=r;++i) &#123; for (j=1;j&lt;=c;++j) &#123; a[i][j]=lower_bound(lsh,lsh+tot,a[i][j])-lsh; &#125; &#125; for (i=0;i&lt;m;++i) &#123; cin&gt;&gt;q[i].x&gt;&gt;q[i].y&gt;&gt;q[i].xx&gt;&gt;q[i].yy; q[i].id=i; &#125; sort(q,q+m); for (i=0;i&lt;m;++i) &#123; while (x&gt;q[i].x) &#123; --x; for (j=y;j&lt;=yy;++j) &#123; add(a[x][j]); &#125; &#125; while (xx&lt;q[i].xx) &#123; ++xx; for (j=y;j&lt;=yy;++j) &#123; add(a[xx][j]); &#125; &#125; while (y&gt;q[i].y) &#123; --y; for (j=x;j&lt;=xx;++j) &#123; add(a[j][y]); &#125; &#125; while (yy&lt;q[i].yy) &#123; ++yy; for (j=x;j&lt;=xx;++j) &#123; add(a[j][yy]); &#125; &#125; while (x&lt;q[i].x) &#123; for (j=y;j&lt;=yy;++j) &#123; del(a[x][j]); &#125; ++x; &#125; while (xx&gt;q[i].xx) &#123; for (j=y;j&lt;=yy;++j) &#123; del(a[xx][j]); &#125; --xx; &#125; while (y&lt;q[i].y) &#123; for (j=x;j&lt;=xx;++j) &#123; del(a[j][y]); &#125; ++y; &#125; while (yy&gt;q[i].yy) &#123; for (j=x;j&lt;=xx;++j) &#123; del(a[j][yy]); &#125; --yy; &#125; out[q[i].id]=ans; &#125; for (i=0;i&lt;m;++i) &#123; cout&lt;&lt;out[i]&lt;&lt;endl; &#125; return 0;&#125;void add(int x)&#123; ans=ans+2*cnt[x]+1; ++cnt[x];&#125;void del(int x)&#123; ans=ans-2*cnt[x]+1; --cnt[x];&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>莫队</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018国庆YALI集训游记]]></title>
    <url>%2F2018%E5%9B%BD%E5%BA%86YALI%E9%9B%86%E8%AE%AD%E6%B8%B8%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[想了想，像之前那样简略地叙述题意和做法，根本没讲清楚，没有任何意义，还不如写写自己的感受。 感觉YALI真的是一所挺不错的学校吧。总是能有一机房的julao轮番吊打你，总是能有集训队的奆佬来给你出dltm、给你讲题。每天放学回酒店的路上还能看到操场上一群目测是田径队之类的同学在努力地训练着。到处都洋溢着「青春」的氛围，反倒是老师见得很少（或许是国庆的缘故吧..）。YALI在我心中已经不止是那个在OIerDb的“全国信息学竞赛学校排名2018”上排名第一的学校了。 这几天去掉失误基本上都能排在前 $20$，但其他julao也会失误，所以是不存在“如果没有失误”的… 既然生在了弱省，就更要把眼光放在省外。OIerDb学校排行榜$rank1\sqrt{}$，OIerDb学校排行榜$rank5\sqrt{}​$。 虽然写的很短，还是比之前几乎什么都没写好吧. ———————————————以上于7号上午——————————————— 到了YALI的学生们返校的下午，YALI变得和外高没什么两样了…或许是那些国庆还在学校的人们让我看到了YALI不同的一面吧.]]></content>
      <categories>
        <category>游记</category>
      </categories>
      <tags>
        <tag>集训</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[莫队、带修莫队、树上莫队详解]]></title>
    <url>%2F%E8%8E%AB%E9%98%9F%E3%80%81%E5%B8%A6%E4%BF%AE%E8%8E%AB%E9%98%9F%E3%80%81%E6%A0%91%E4%B8%8A%E8%8E%AB%E9%98%9F%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[这几天学习了莫队算法，试着写一篇比较详细的莫队教程吧… 普通莫队简介莫队是一种基于分块思想的离线算法，用于解决区间问题，适用范围如下： 只有询问没有修改。 允许离线。 在已知询问 $[l,r]$ 答案的情况下可以 $O(1)$ 得到 $[l,r-1],[l,r+1],[l-1,r],[l+1,r]$ 的答案。 满足以上三个条件就可以在 $O(n\sqrt{m}+m\log m)​$ 的时间复杂度下得到每个询问的解。 算法思想莫队的精髓就在于通过对询问进行排序，并把询问的结果作为下一个询问求解的基础，使得暴力求解的复杂度得到保证。 上文中“适用范围”的第三点“在已知询问 $[l,r]$ 答案的情况下可以 $O(1)$ 得到 $[l,r-1],[l,r+1],[l-1,r],[l+1,r]$ 的答案”即是“把询问的结果作为下一个询问求解的基础”的方法。 例题解析例：[国家集训队]小Z的袜子 在这题中，用 $cnt_i$ 表示当前处理的区间内颜色为i的袜子出现的次数，用 $\mathrm{len}$ 表示当前处理的区间的长度，用 $x$ 表示新增的那只袜子的颜色。 以已知区间 $[l,r]$ 的答案求解区间 $[l,r+1]$ 为例。分别处理分子和分母： 分母为任选两只袜子的组合总数，原先是 $\frac{\mathrm{len}(\mathrm{len}-1)}{2}$，现在是 $\frac{\mathrm{len}(\mathrm{len}+1)}{2}$，增加了 $\mathrm{len}$ 。 分子为两只袜子颜色相同的组合总数，比原来增加了 $cnt_x$，即新增的这只袜子和原本就在当前区间内的相同颜色的袜子的组合。 因此，将一只颜色为x的袜子计入答案的函数就可以写出来了： 12345678//fz代表分子，fm代表分母void add(int x)&#123; fz+=cnt[x]; ++cnt[x]; fm+=len; ++len;&#125; 同理可以写出将一只颜色为x的袜子移出答案的函数： 1234567void del(int x)&#123; --cnt[x]; fz-=cnt[x]; --len; fm-=len;&#125; 于是，我们就可以得到一个暴力的算法：用 $l$ 和 $r$ 分别记录当前区间的两个端点，然后用下面这段代码来更新答案（q[i].l,q[i].r代表正在处理的询问的两个端点，col[p]代表第 $p$ 只袜子的颜色）： 12345678910111213141516while (l&gt;q[i].l)&#123; add(col[--l]);&#125;while (r&lt;q[i].r)&#123; add(col[++r]);&#125;while (l&lt;q[i].l) &#123; del(col[l++]);&#125;while (r&gt;q[i].r)&#123; del(col[r--]);&#125; 然而，这个算法的时间复杂度是 $O(nm)$ 的（因为最坏情况下每次 $l$ 和 $r$ 两个指针都要走 $O(n)$ 的距离，而一共有 $m$ 次询问），和暴力完全一样甚至跑的更慢。 优化复杂度别忘了，之前我说过，莫队的精髓就在于通过对询问进行排序，使得暴力求解的复杂度得到保证。 我们的目的是使 $l$ 和 $r$ 两个指针走过的总距离尽量的小，这时候就要用到分块的思想了。 把整个区间 $[1,n]$ 分成若干块，以询问的左端点所在块为第一关键字，以询问的右端点大小为第二关键字，对询问进行排序，那么： 对于同一块的询问，$l$ 指针每次最多移动块的大小，$r$ 指针的移动则是单调的，总共移动最多 $n$ 。 对于不同块的询问，$l$ 每次换块时最多移动两倍块的大小， $r$ 每次换块时最多移动 $n$ 。 总结：（用 $B$ 表示块的大小）$l$ 指针每次移动 $O(B)$，$r$ 指针每块移动 $O(n)​$ 。 所以： $l$ 的移动次数最多为询问数 $\times$ 块的大小，即 $O(mB)$ 。 $r$ 的移动次数最多为块的个数 $\times$ 总区间大小，即 $O(n^2/B)$ 。 因此，总移动次数为 $O(mB+n^2/B)$ 。 实际上，“换块”这一事件发生的次数并不多，因此即便换块复杂度达到 $\mathcal O(n)$ 也是不会影响复杂度的。只不过一般情况下块是相邻的，换块复杂度就比较小。 —— update on 2019.7.27 没错，这就是个双勾函数，所以当 $B=\sqrt{\frac{n^2}{m}}$ 即 $\frac{n}{\sqrt{m}}$ 时复杂度最小，为 $O(n\sqrt{m})$ 。 剩下的最后一个问题：初始的当前区间是什么？ 只要任意指定一个空区间就好了，如 $l=1,r=0$ 。 所以，整个莫队算法就可以概括为： 将询问记录下来。 以 $\frac{n}{\sqrt{m}}$ 为块的大小，以询问的左端点所在块为第一关键字，以询问的右端点大小为第二关键字，对询问进行排序。 暴力处理每个询问。 输出答案。 总的复杂度为 $O(n\sqrt{m}+m\log m)$ 。 P.S. 网上很多教程说分块大小取 $\sqrt{n}$ 最优，复杂度为 $O(n\sqrt{n})$，这是不严谨的，当n、m差别较大时使用 $\sqrt{n}$ 作为分块大小效率会明显偏低。 例题代码[国家集训队]小Z的袜子 AC代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;const int N=50010;void add(int x);void del(int x);int gcd(int a,int b);int n,m,B,fz,fm,len,col[N],cnt[N],ans[N][2];struct Query&#123; int l,r,id; bool operator&lt;(Query&amp; b) &#123; return l/B==b.l/B?r&lt;b.r:l&lt;b.l; &#125;&#125; q[N];int main()&#123; int i,l=1,r=0,g; cin&gt;&gt;n&gt;&gt;m; B=n/sqrt(m); for (i=1;i&lt;=n;++i) &#123; cin&gt;&gt;col[i]; &#125; for (i=0;i&lt;m;++i) &#123; cin&gt;&gt;q[i].l&gt;&gt;q[i].r; q[i].id=i; &#125; sort(q,q+m); for (i=0;i&lt;m;++i) &#123; if (q[i].l==q[i].r) &#123; ans[q[i].id][0]=0; ans[q[i].id][1]=1; continue; &#125; while (l&gt;q[i].l) &#123; add(col[--l]); &#125; while (r&lt;q[i].r) &#123; add(col[++r]); &#125; while (l&lt;q[i].l) &#123; del(col[l++]); &#125; while (r&gt;q[i].r) &#123; del(col[r--]); &#125; g=gcd(fz,fm); ans[q[i].id][0]=fz/g; ans[q[i].id][1]=fm/g; &#125; for (i=0;i&lt;m;++i) &#123; printf("%d/%d\n",ans[i][0],ans[i][1]); &#125; return 0;&#125;void add(int x)&#123; fz+=cnt[x]; ++cnt[x]; fm+=len; ++len;&#125;void del(int x)&#123; --cnt[x]; fz-=cnt[x]; --len; fm-=len;&#125;int gcd(int a,int b)&#123; return b==0?a:gcd(b,a%b);&#125; 其它例题小B的询问 带修莫队前面说过，普通的莫队只能解决没有修改的问题，那么带修改的问题怎么解决呢？带修莫队就是一种支持单点修改的莫队算法。 算法简介还是对询问进行排序，每个询问除了左端点和右端点还要记录这次询问是在第几次修改之后（时间），以左端点所在块为第一关键字，以右端点所在块为第二关键字，以时间为第三关键字进行排序。 暴力查询时，如果当前修改数比询问的修改数少就把没修改的进行修改，反之回退。 需要注意的是，修改分为两部分： 若修改的位置在当前区间内，需要更新答案（del原颜色，add修改后的颜色）。 无论修改的位置是否在当前区间内，都要进行修改（以供add和del函数在以后更新答案）。 分块大小的选择以及复杂度证明（用 $B$ 表示分块大小，$c$ 表示修改个数，$q$ 表示询问个数，l块表示以 $l/B$ 分的块，r块表示以 $r/B$ 分的块，每个l块包含 $n/B$ 个r块） 对于时间指针 $now$：对于每个r块，最坏情况下会移动 $c$，共有 $\left(\frac{n}{B}\right)^2$ 个r块，所以总移动次数为 $\frac{cn^2}{B^2}$ 。 对于左端点指针 $l$ ：l块内移动每次最多 $B$，换l块每次最多 $2B$，所以总移动次数为 $O(qB)$ 。 对于右端点指针 $r​$：r块内移动每次最多 $B​$，换r块每次最多 $2B​$，所有l块内移动次数之和为 $O(qB)​$；换l块时最多移动 $n​$，总的换l块时移动次数为 $O\left(\frac{n^2}{B}\right)​$；所以总的移动次数为 $O\left(qB+\frac{n^2}{B}\right)​$ 。 所以：总移动次数为 $O\left(\frac{cn^2}{B^2}+qB+\frac{n^2}{B}\right)$ 。 实际上，“换块”这一事件发生的次数并不多，因此即便换块复杂度达到 $\mathcal O(n)​$ 也是不会影响复杂度的。只不过一般情况下块是相邻的，换块复杂度就比较小。 —— update on 2019.7.27 由于一般的题目都不会告诉你修改和询问分别的个数，所以统一用 $m​$ 表示，即 $O\left(\frac{mn^2}{B^2}+mB+\frac{n^2}{B}\right)​$ 。 那么 $B$ 取多少呢…Mathematica告诉我大约是这个： 所以还是不要纠结带修莫队的最佳分块大小好了…视作 $n=m​$ 的话，就可以得到总移动次数为 $O\left(\frac{n^3}{B^2}+nB+\frac{n^2}{B}\right)​$，那么 $B=n^{\frac{2}{3}}​$ 时取最小值 $O\left(n^{\frac{5}{3}}\right)​$ 。 所以：带修莫队的渐进时间复杂度为 $O\left(n\log n+n^{\frac{5}{3}}\right)$ （视作 $n=m$）。 例题代码这次就不详细分析例题了，直接上代码。 [国家集训队]数颜色 AC代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;void add(int x);void del(int x);void modify(int x,int ti); //这个函数会执行或回退修改ti（执行还是回退取决于是否执行过，具体通过swap实现），x表明当前的询问是x，即若修改了区间[q[x].l,q[x].r]便要更新答案int n,m,B,cnt[1000010],a[50010],ans,ccnt,qcnt,now,out[50010];struct Change&#123; int p,col;&#125; c[50010];struct Query&#123; int l,r,t,id; bool operator&lt;(Query&amp; b) &#123; return l/B==b.l/B?(r/B==b.r/B?t&lt;b.t:r&lt;b.r):l&lt;b.l; &#125;&#125; q[50010];int main()&#123; int i,l=2,r=1; char type[10]; cin&gt;&gt;n&gt;&gt;m; B=pow(n,0.66666); for (i=1;i&lt;=n;++i) &#123; cin&gt;&gt;a[i]; &#125; for (i=1;i&lt;=m;++i) &#123; scanf("%s",type); if (type[0]=='Q') &#123; ++qcnt; cin&gt;&gt;q[qcnt].l&gt;&gt;q[qcnt].r; q[qcnt].t=ccnt; q[qcnt].id=qcnt; &#125; else &#123; ++ccnt; cin&gt;&gt;c[ccnt].p&gt;&gt;c[ccnt].col; &#125; &#125; sort(q+1,q+qcnt+1); for (i=1;i&lt;=qcnt;++i) &#123; while (l&gt;q[i].l) &#123; add(a[--l]); &#125; while (r&lt;q[i].r) &#123; add(a[++r]); &#125; while (l&lt;q[i].l) &#123; del(a[l++]); &#125; while (r&gt;q[i].r) &#123; del(a[r--]); &#125; while (now&lt;q[i].t) &#123; modify(i,++now); &#125; while (now&gt;q[i].t) &#123; modify(i,now--); &#125; out[q[i].id]=ans; &#125; for (i=1;i&lt;=qcnt;++i) &#123; cout&lt;&lt;out[i]&lt;&lt;endl; &#125; return 0;&#125;void add(int x)&#123; if (cnt[x]++==0) &#123; ++ans; &#125;&#125;void del(int x)&#123; if (--cnt[x]==0) &#123; --ans; &#125;&#125;void modify(int x,int ti)&#123; if (c[ti].p&gt;=q[x].l&amp;&amp;c[ti].p&lt;=q[x].r) &#123; del(a[c[ti].p]); add(c[ti].col); &#125; swap(a[c[ti].p],c[ti].col); //下次执行时必定是回退这次操作，直接互换就可以了 &#125; 其它例题CF940F Machine Learning 树上莫队其实，莫队算法除了序列还可以用于树。复杂度同序列上的莫队（不带修 $O(n\sqrt{m}+m\log m)​$，带修 $O\left(n\log n+n^{\frac{5}{3}}\right)$）。 例题：[WC2013]糖果公园 分块方式这里需要看一道专门为树上莫队设计的题目 [SCOI2005]王室联邦。 用这道题所要求的方式进行分块，并用后文的方式更新答案，就能保证复杂度（复杂度分析见后文）。 那么如何满足每块大小在 $[B,3B]$，块内每个点到核心点路径上的所有点都在块内呢？ 这里先提供一种构造方式，再予以证明： dfs，并创建一个栈，dfs一个点时先记录初始栈顶高度，每dfs完当前节点的一棵子树就判断栈内（相对于刚开始dfs时）新增节点的数量是否≥B，是则将栈内所有新增点分为同一块，核心点为当前dfs的点，当前节点结束dfs时将当前节点入栈，整个dfs结束后将栈内所有剩余节点归入已经分好的最后一个块。 参考代码： 1234567891011121314151617181920212223242526272829void dfs(int u,int fa)&#123; int t=top; for (int i=head[u];i;i=nxt[i]) &#123; int v=to[i]; if (v!=fa) &#123; dfs(v,u); if (top-t&gt;=B) &#123; key[++tot]=u; while (top&gt;t) bl[stk[top--]]=tot; &#125; &#125; &#125; stk[++top]=u;&#125;int main()&#123; //....... dfs(1,0); if (!tot) ++tot; key[tot]=1; while (top) bl[stk[top--]]=tot;&#125; 如果你看懂了这个方法的话，每块大小≥B是显然的，下面证明为何每块大小≤3B： 对于当前节点的每一棵子树： 若未被分块的节点数&gt;B，那么在dfs这棵子树的根节点时就一定会把这棵子树的一部分分为一块直至这棵子树的剩余节点数≤B，所以这种情况不存在。 若未被分块的节点数=B，这些节点一定会和栈中所有节点分为一块，栈中之前还剩 $[0,B-1]$ 个节点，那么这一块的大小为 $[B,2B-1]$ 。 若未被分块的节点数&lt;B，当未被分块的节点数+栈中剩余节点数≥B时，这一块的大小为 $[B,2B-1)$，否则继续进行下一棵子树。 对于dfs结束后栈内剩余节点，数量一定在 $[1,B]​$ 内，而已经分好的每一块的大小为 $[B,2B-1]​$，所以每块的大小都在 $[B,3B)​$ 内。 修改方式所谓“修改”，就是由询问 $(cu,cv)$ 更新至询问 $(tu,tv)$ 。 如果把两条路径上的点全部修改复杂度是和暴力一样的，所以需要做一些处理。 （下文中 $T(u,v)​$ 表示 $u​$ 到 $v​$ 的路径上除 $lca(u,v)​$ 外的所有点构成的集合，$S(u,v)​$ 代表u到v的路径，$xor​$ 表示集合对称差（就跟异或差不多）） 两个指针 $cu,cv​$ （相当于序列莫队的 $l,r​$ 两个指针）， $ans​$记录$T(cu,cv)​$ 的答案，$vis​$ 数组记录每个节点是否在 $T(cu,cv)​$ 内； 由 $T(cu,cv)​$ 更新至 $T(tu,tv)​$ 时，将 $T(cu,tu)​$ 和 $T(cv,tv)​$ 的 $vis​$ 分别取反，并相应地更新答案； 将答案记录到 $out​$ 数组（离线后用于输出那个）时对 $lca(cu,cv)​$ （此时的 $cu,cv​$ 已更新为上一步中的 $tu,tv​$） 的 $vis​$ 取反并更新答案，记录完再改回来（因为 $lca​$ 处理比较麻烦，这样搞比较方便）。 第二步证明如下： $\quad\,T(cu,cv)\ xor\ T(tu,tv)$ $=[S(cu,root)\ xor\ S(cv,root)]\ xor\ [S(tu,root)\ xor\ S(tv,root)]$ （lca及以上相消） $=[S(cu,root)\ xor\ S(tu,root)]\ xor\ [S(cv,root)\ xor\ S(tv,root)]$ （交换律、结合律） $=T(cu,tu)\ xor\ T(cv,tv)$ 之所以要把 $T(cu,cv)\ xor\ T(tu,tv)$ 转化成 $T(cu,tu)\ xor\ T(cv,tv)$，是因为这样的话就能通过对询问排序来保证复杂度。排序方式就是以 $u$ 所在块编号为第一关键字，$v​$ 的编号为第二关键字排序。如果是带修莫队，就还要以时间为第三关键字。 关于单点修改树上莫队的单点修改和序列莫队类似，唯一不同就是，修改后是否更新答案通过 $vis$ 数组判断。 复杂度分析每块大小在 $[B,3B)​$，所以两点间路径长度也在 $[B,3B)​$，块内移动就是 $\mathcal O(B)​$ 的，然后就和序列莫队的复杂度分析类似了… 例题代码[WC2013]糖果公园 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;const int N=100010;void pathmodify(int u,int v); //将T(u,v)取反并更新答案void opp(int x); //将节点x取反并更新答案void modify(int ti); //进行或回退修改tiint lca(int u,int v);void dfs(int u); //进行分块并记录dep数组、f数组（用于求lca、两点间路径）void add(int u,int v);int head[N],nxt[N&lt;&lt;1],to[N&lt;&lt;1],cnt;int n,m,Q,B,bl[N],tot,V[N],W[N],a[N],stk[N],top,qcnt,ccnt,dep[N],f[20][N],num[N],now;long long ans,out[N];bool vis[N];struct Query&#123; int u,v,t,id; bool operator&lt;(Query&amp; y) &#123; return bl[u]==bl[y.u]?(bl[v]==bl[y.v]?t&lt;y.t:bl[v]&lt;bl[y.v]):bl[u]&lt;bl[y.u]; &#125;&#125; q[N];struct Change&#123; int p,x;&#125; c[N];int main()&#123; int i,j,u,v,lc,type; cin&gt;&gt;n&gt;&gt;m&gt;&gt;Q; B=pow(n,0.666); for (i=1;i&lt;=m;++i) cin&gt;&gt;V[i]; for (i=1;i&lt;=n;++i) cin&gt;&gt;W[i]; for (i=1;i&lt;n;++i) &#123; cin&gt;&gt;u&gt;&gt;v; add(u,v); add(v,u); &#125; dfs(1); for (i=1;i&lt;=16;++i) &#123; for (j=1;j&lt;=n;++j) &#123; f[i][j]=f[i-1][f[i-1][j]]; &#125; &#125; while (top) bl[stk[top--]]=tot; for (i=1;i&lt;=n;++i) cin&gt;&gt;a[i]; for (i=0;i&lt;Q;++i) &#123; cin&gt;&gt;type; if (type==0) &#123; ++ccnt; cin&gt;&gt;c[ccnt].p&gt;&gt;c[ccnt].x; &#125; else &#123; cin&gt;&gt;q[qcnt].u&gt;&gt;q[qcnt].v; q[qcnt].t=ccnt; q[qcnt].id=qcnt; ++qcnt; &#125; &#125; sort(q,q+qcnt); u=v=1; for (i=0;i&lt;qcnt;++i) &#123; pathmodify(u,q[i].u); pathmodify(v,q[i].v); u=q[i].u; v=q[i].v; while (now&lt;q[i].t) modify(++now); while (now&gt;q[i].t) modify(now--); lc=lca(u,v); opp(lc); out[q[i].id]=ans; opp(lc); &#125; for (i=0;i&lt;qcnt;++i) cout&lt;&lt;out[i]&lt;&lt;endl; return 0;&#125;void pathmodify(int u,int v)&#123; if (dep[u]&lt;dep[v]) swap(u,v); while (dep[u]&gt;dep[v]) &#123; opp(u); u=f[0][u]; &#125; while (u!=v) &#123; opp(u); opp(v); u=f[0][u]; v=f[0][v]; &#125;&#125;void opp(int x)&#123; if (vis[x]) ans-=1ll*V[a[x]]*W[num[a[x]]--]; else ans+=1ll*V[a[x]]*W[++num[a[x]]]; vis[x]^=1;&#125;void modify(int ti)&#123; if (vis[c[ti].p]) &#123; opp(c[ti].p); swap(a[c[ti].p],c[ti].x); opp(c[ti].p); &#125; else swap(a[c[ti].p],c[ti].x);&#125;int lca(int u,int v)&#123; if (dep[u]&lt;dep[v]) &#123; swap(u,v); &#125; int i; for (i=0;i&lt;=16;++i) &#123; if ((dep[u]-dep[v])&amp;(1&lt;&lt;i)) &#123; u=f[i][u]; &#125; &#125; if (u==v) return u; for (i=16;i&gt;=0;--i) &#123; if (f[i][u]!=f[i][v]) &#123; u=f[i][u]; v=f[i][v]; &#125; &#125; return f[0][u];&#125;void dfs(int u)&#123; int t=top; for (int i=head[u];i;i=nxt[i]) &#123; int v=to[i]; if (v!=f[0][u]) &#123; f[0][v]=u; dep[v]=dep[u]+1; dfs(v); if (top-t&gt;=B) &#123; ++tot; while (top&gt;t) bl[stk[top--]]=tot; &#125; &#125; &#125; stk[++top]=u;&#125;void add(int u,int v)&#123; nxt[++cnt]=head[u]; head[u]=cnt; to[cnt]=v;&#125; 回滚莫队（只增莫队）适用范围 删除时不方便统计答案。 可以方便地回滚单次操作，即修改造成的影响要么能够在 $\mathcal O(\sqrt n)$ 内保存下来，要么可以 $\mathcal O(1)​$ 地回滚单次增加。 算法流程 对于左右端点在同一块的暴力计算。 跟普通莫队一样排序，左端点换块时清空答案，把左指针设为左端点所在块的下一块的开头，把右指针设为左端点所在块的最后一位。这样右指针是单调递增的，每处理一个询问时，先记录一些信息（比如答案），再左移左指针并更新答案，然后把左指针移回左端点所在块的下一块的开头，过程中回滚除记录下的信息以外的其它影响，最后把记录下的信息恢复。如：先右移右指针，再记录 ans，然后左移左指针时增加 cnt 并更新 ans，回滚时把增加的 cnt 减掉，最后把 ans 回滚为记录的值。 例题 &amp; 代码BZOJ4241 历史研究 参考代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cctype&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;typedef long long ll;const int N = 100010;const int B = 333;int read()&#123; int out = 0; char c; while (!isdigit(c = getchar())); for (; isdigit(c); c = getchar()) out = out * 10 + c - '0'; return out;&#125;struct Query&#123; int l, r, id; bool operator&lt;(const Query &amp; y) const &#123; return l / B == y.l / B ? r &lt; y.r : l &lt; y.l; &#125;&#125; q[N];void add(int x);int n, m, a[N], lsh[N], tot, cnt[N];ll ans, bk, out[N];int main()&#123; int i, j, l, r, bl = -1; n = read(); m = read(); for (i = 1; i &lt;= n; ++i) a[i] = lsh[++tot] = read(); sort(lsh + 1, lsh + tot + 1); tot = unique(lsh + 1, lsh + tot + 1) - lsh; for (i = 1; i &lt;= n; ++i) a[i] = lower_bound(lsh + 1, lsh + tot, a[i]) - lsh; for (i = 1; i &lt;= m; ++i) &#123; q[i].l = read(); q[i].r = read(); q[i].id = i; if (q[i].l / B == q[i].r / B) // 暴力处理左右端点在同一块的询问 &#123; for (j = q[i].l; j &lt;= q[i].r; ++j) &#123; ++cnt[a[j]]; out[i] = max(out[i], (ll) cnt[a[j]] * lsh[a[j]]); &#125; for (j = q[i].l; j &lt;= q[i].r; ++j) --cnt[a[j]]; &#125; &#125; sort(q + 1, q + m + 1); for (i = 1; i &lt;= m; ++i) &#123; if (q[i].l / B == q[i].r / B) continue; if (i == 1 || q[i].l / B != bl) // 左端点换块 &#123; ans = 0; bl = q[i].l / B; memset(cnt, 0, sizeof(cnt)); l = (bl + 1) * B; r = (bl + 1) * B - 1; &#125; while (r &lt; q[i].r) add(a[++r]); // 右移右指针 bk = ans; // 记录 ans while (l &gt; q[i].l) add(a[--l]); // 左移左指针并更新答案 out[q[i].id] = ans; while (l &lt; (bl + 1) * B) --cnt[a[l++]]; // 回滚 ans = bk; // 把 ans 修改回来 &#125; for (i = 1; i &lt;= m; ++i) printf("%lld\n", out[i]); return 0;&#125;void add(int x)&#123; ++cnt[x]; ans = max(ans, (ll) cnt[x] * lsh[x]);&#125; 莫队的扩展其实莫队可以扩展到高维，参见二维莫队解题报告。 更一般地，若 $Q(x_1,x_2,\cdots,x_k)​$ 为一个询问，$\forall i\in[1,k]​$，$x_i​$ 的规模都为 $n​$，可以在时间 $\mathrm{T}​$ 内求解 $Q(x_1,x_2,\cdots,x_i\pm 1,\cdots,x_n)​$，共有 $m​$ 个询问，那么就可以在 $O\left(km\log m+nTm^\frac{k-1}{k}\right)​$ 的时间复杂度下离线求解。 （蒟蒻的大胆猜想而已..并没有严格证明）]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>离线算法</tag>
        <tag>莫队</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[好用的网站]]></title>
    <url>%2F%E5%A5%BD%E7%94%A8%E7%9A%84%E7%BD%91%E7%AB%99%2F</url>
    <content type="text"><![CDATA[一些好用的网站。 图床 几何 图论 函数 找规律 矩阵运算 在线汇编编译器 C++ LaTeX 公式大全 LaTeX 公式奆全 .tex 教程 OI Wiki Wolfram Alpha OIerDb OI 中转站 线稿上色]]></content>
      <categories>
        <category>其它</category>
      </categories>
      <tags>
        <tag>网站</tag>
      </tags>
  </entry>
</search>
